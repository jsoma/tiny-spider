{"version":3,"sources":["webpack:///static/js/vendor.007b22d751ae62bc81e6.js","webpack:///./~/core-js/library/modules/_core.js","webpack:///./~/babel-runtime/helpers/classCallCheck.js","webpack:///./~/babel-runtime/helpers/createClass.js","webpack:///./~/core-js/library/modules/_export.js","webpack:///./~/core-js/library/modules/_global.js","webpack:///./~/core-js/library/modules/_to-iobject.js","webpack:///./~/core-js/library/modules/_wks.js","webpack:///./~/core-js/library/modules/_descriptors.js","webpack:///./~/core-js/library/modules/_has.js","webpack:///./~/core-js/library/modules/_object-dp.js","webpack:///./~/core-js/library/modules/_object-keys.js","webpack:///./~/stream-browserify/~/readable-stream/lib/_stream_duplex.js","webpack:///./~/core-js/library/modules/_an-object.js","webpack:///./~/core-js/library/modules/_fails.js","webpack:///./~/core-js/library/modules/_hide.js","webpack:///./~/inherits/inherits_browser.js","webpack:///./~/buffer/index.js","webpack:///./~/core-js/library/modules/_is-object.js","webpack:///./~/core-js/library/modules/_object-pie.js","webpack:///./~/core-util-is/lib/util.js","webpack:///./~/process/browser.js","webpack:///./~/stream-browserify/index.js","webpack:///./~/core-js/library/modules/_iterators.js","webpack:///./~/core-js/library/modules/_property-desc.js","webpack:///./~/core-js/library/modules/_to-object.js","webpack:///./~/core-js/library/modules/_uid.js","webpack:///./~/babel-runtime/core-js/get-iterator.js","webpack:///./~/core-js/library/modules/_cof.js","webpack:///./~/core-js/library/modules/_defined.js","webpack:///./~/core-js/library/modules/_enum-bug-keys.js","webpack:///./~/core-js/library/modules/_library.js","webpack:///./~/core-js/library/modules/_object-create.js","webpack:///./~/core-js/library/modules/_object-gops.js","webpack:///./~/core-js/library/modules/_set-to-string-tag.js","webpack:///./~/core-js/library/modules/_shared-key.js","webpack:///./~/core-js/library/modules/_shared.js","webpack:///./~/core-js/library/modules/_to-integer.js","webpack:///./~/core-js/library/modules/_to-primitive.js","webpack:///./~/core-js/library/modules/_wks-define.js","webpack:///./~/core-js/library/modules/_wks-ext.js","webpack:///./~/stream-browserify/~/readable-stream/lib/_stream_transform.js","webpack:///./~/stream-browserify/~/readable-stream/lib/_stream_writable.js","webpack:///./~/babel-runtime/core-js/object/get-prototype-of.js","webpack:///./~/babel-runtime/core-js/object/keys.js","webpack:///./~/babel-runtime/core-js/object/values.js","webpack:///./~/babel-runtime/helpers/inherits.js","webpack:///./~/babel-runtime/helpers/possibleConstructorReturn.js","webpack:///./~/babel-runtime/helpers/typeof.js","webpack:///./~/core-js/library/modules/_ctx.js","webpack:///./~/core-js/library/modules/_dom-create.js","webpack:///./~/core-js/library/modules/_ie8-dom-define.js","webpack:///./~/core-js/library/modules/_iobject.js","webpack:///./~/core-js/library/modules/_iter-define.js","webpack:///./~/core-js/library/modules/_object-gopd.js","webpack:///./~/core-js/library/modules/_object-gopn.js","webpack:///./~/core-js/library/modules/_object-gpo.js","webpack:///./~/core-js/library/modules/_object-keys-internal.js","webpack:///./~/core-js/library/modules/_object-sap.js","webpack:///./~/core-js/library/modules/_redefine.js","webpack:///./~/core-js/library/modules/es6.string.iterator.js","webpack:///./~/core-js/library/modules/web.dom.iterable.js","webpack:///./~/d3-collection/build/d3-collection.js","webpack:///./~/events/events.js","webpack:///./~/stream-browserify/~/readable-stream/lib/_stream_passthrough.js","webpack:///./~/stream-browserify/~/readable-stream/lib/_stream_readable.js","webpack:///./~/string_decoder/index.js","webpack:///./~/PapaParse/papaparse.js","webpack:///./~/babel-runtime/core-js/json/stringify.js","webpack:///./~/babel-runtime/core-js/object/assign.js","webpack:///./~/babel-runtime/core-js/object/create.js","webpack:///./~/babel-runtime/core-js/object/define-property.js","webpack:///./~/babel-runtime/core-js/object/set-prototype-of.js","webpack:///./~/babel-runtime/core-js/symbol.js","webpack:///./~/babel-runtime/core-js/symbol/iterator.js","webpack:///./~/base64-js/index.js","webpack:///./~/core-js/library/fn/get-iterator.js","webpack:///./~/core-js/library/fn/json/stringify.js","webpack:///./~/core-js/library/fn/object/assign.js","webpack:///./~/core-js/library/fn/object/create.js","webpack:///./~/core-js/library/fn/object/define-property.js","webpack:///./~/core-js/library/fn/object/get-prototype-of.js","webpack:///./~/core-js/library/fn/object/keys.js","webpack:///./~/core-js/library/fn/object/set-prototype-of.js","webpack:///./~/core-js/library/fn/object/values.js","webpack:///./~/core-js/library/fn/symbol/index.js","webpack:///./~/core-js/library/fn/symbol/iterator.js","webpack:///./~/core-js/library/modules/_a-function.js","webpack:///./~/core-js/library/modules/_add-to-unscopables.js","webpack:///./~/core-js/library/modules/_array-includes.js","webpack:///./~/core-js/library/modules/_classof.js","webpack:///./~/core-js/library/modules/_enum-keys.js","webpack:///./~/core-js/library/modules/_html.js","webpack:///./~/core-js/library/modules/_is-array.js","webpack:///./~/core-js/library/modules/_iter-create.js","webpack:///./~/core-js/library/modules/_iter-step.js","webpack:///./~/core-js/library/modules/_keyof.js","webpack:///./~/core-js/library/modules/_meta.js","webpack:///./~/core-js/library/modules/_object-assign.js","webpack:///./~/core-js/library/modules/_object-dps.js","webpack:///./~/core-js/library/modules/_object-gopn-ext.js","webpack:///./~/core-js/library/modules/_object-to-array.js","webpack:///./~/core-js/library/modules/_set-proto.js","webpack:///./~/core-js/library/modules/_string-at.js","webpack:///./~/core-js/library/modules/_to-index.js","webpack:///./~/core-js/library/modules/_to-length.js","webpack:///./~/core-js/library/modules/core.get-iterator-method.js","webpack:///./~/core-js/library/modules/core.get-iterator.js","webpack:///./~/core-js/library/modules/es6.array.iterator.js","webpack:///./~/core-js/library/modules/es6.object.assign.js","webpack:///./~/core-js/library/modules/es6.object.create.js","webpack:///./~/core-js/library/modules/es6.object.define-property.js","webpack:///./~/core-js/library/modules/es6.object.get-prototype-of.js","webpack:///./~/core-js/library/modules/es6.object.keys.js","webpack:///./~/core-js/library/modules/es6.object.set-prototype-of.js","webpack:///./~/core-js/library/modules/es6.symbol.js","webpack:///./~/core-js/library/modules/es7.object.values.js","webpack:///./~/core-js/library/modules/es7.symbol.async-iterator.js","webpack:///./~/core-js/library/modules/es7.symbol.observable.js","webpack:///./~/d3/build/d3.js","webpack:///./~/ieee754/index.js","webpack:///./~/isarray/index.js","webpack:///./~/stream-browserify/~/isarray/index.js","webpack:///./~/stream-browserify/~/readable-stream/duplex.js","webpack:///./~/stream-browserify/~/readable-stream/passthrough.js","webpack:///./~/stream-browserify/~/readable-stream/readable.js","webpack:///./~/stream-browserify/~/readable-stream/transform.js","webpack:///./~/stream-browserify/~/readable-stream/writable.js","webpack:///./~/vue/dist/vue.js","webpack:///./~/xml/lib/escapeForXML.js","webpack:///./~/xml/lib/xml.js","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/vue-style-loader/addStyles.js"],"names":["webpackJsonp","module","exports","core","version","__e","__esModule","default","instance","Constructor","TypeError","__webpack_require__","_interopRequireDefault","obj","_defineProperty","_defineProperty2","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","global","ctx","hide","PROTOTYPE","$export","type","name","source","own","out","IS_FORCED","F","IS_GLOBAL","G","IS_STATIC","S","IS_PROTO","P","IS_BIND","B","IS_WRAP","W","expProto","undefined","C","a","b","c","this","arguments","apply","Function","call","virtual","R","U","window","Math","self","__g","IObject","defined","it","store","uid","Symbol","USE_SYMBOL","$exports","Object","defineProperty","get","hasOwnProperty","anObject","IE8_DOM_DEFINE","toPrimitive","dP","f","O","Attributes","e","value","$keys","enumBugKeys","keys","process","Duplex","options","Readable","Writable","readable","allowHalfOpen","once","onend","_writableState","ended","nextTick","end","bind","forEach","xs","l","objectKeys","push","util","inherits","method","isObject","exec","createDesc","object","create","ctor","superCtor","super_","constructor","TempCtor","Buffer","typedArraySupport","arr","Uint8Array","__proto__","foo","subarray","byteLength","kMaxLength","TYPED_ARRAY_SUPPORT","createBuffer","that","RangeError","arg","encodingOrOffset","Error","allocUnsafe","from","ArrayBuffer","fromArrayBuffer","fromString","fromObject","assertSize","size","alloc","fill","encoding","checked","string","isEncoding","actual","write","slice","fromArrayLike","array","byteOffset","isBuffer","len","copy","buffer","isnan","isArray","data","toString","SlowBuffer","isView","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","start","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","n","m","bidirectionalIndexOf","val","dir","isNaN","arrayIndexOf","indexOf","lastIndexOf","read","buf","indexSize","readUInt16BE","arrLength","valLength","String","foundIndex","found","j","hexWrite","offset","Number","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","asciiToBytes","latin1Write","base64Write","ucs2Write","utf16leToBytes","base64","fromByteArray","min","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","ret","toHex","bytes","checkOffset","ext","checkInt","max","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","ieee754","writeDouble","base64clean","str","stringtrim","replace","INVALID_BASE64_RE","trim","units","Infinity","leadSurrogate","charCodeAt","byteArray","hi","lo","toByteArray","src","dst","INSPECT_MAX_BYTES","poolSize","_augment","species","allocUnsafeSlow","_isBuffer","compare","x","y","concat","list","pos","swap16","swap32","swap64","equals","inspect","match","join","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","Array","_arr","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","maxBytes","writeUIntBE","writeUInt8","floor","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","set","code","propertyIsEnumerable","objectToString","isBoolean","isNull","isNullOrUndefined","isNumber","isString","isSymbol","isUndefined","isRegExp","re","isDate","d","isError","isFunction","isPrimitive","o","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","setTimeout","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","run","Item","noop","args","title","browser","env","argv","versions","on","addListener","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","umask","Stream","EE","EventEmitter","Transform","PassThrough","pipe","dest","ondata","chunk","pause","ondrain","resume","didOnEnd","onclose","destroy","onerror","er","cleanup","listenerCount","_isStdio","bitmap","id","px","random","split","dPs","IE_PROTO","Empty","createDict","iframeDocument","iframe","lt","gt","style","display","appendChild","contentWindow","document","open","close","Properties","result","getOwnPropertySymbols","def","has","TAG","tag","stat","shared","SHARED","ceil","fn","valueOf","LIBRARY","wksExt","$Symbol","charAt","TransformState","stream","afterTransform","needTransform","transforming","writecb","writechunk","ts","_transformState","cb","rs","_readableState","reading","needReadable","highWaterMark","_read","sync","_flush","done","ws","_transform","_write","writeencoding","WriteReq","callback","WritableState","hwm","defaultHwm","objectMode","writableObjectMode","needDrain","ending","finished","noDecode","decodeStrings","defaultEncoding","writing","corked","bufferProcessing","onwrite","writelen","pendingcb","prefinished","errorEmitted","writeAfterEnd","state","validChunk","valid","decodeChunk","writeOrBuffer","doWrite","writev","_writev","onwriteError","onwriteStateUpdate","needFinish","clearBuffer","afterWrite","onwriteDrain","finishMaybe","cbs","err","entry","prefinish","need","endWritable","cork","uncork","_setPrototypeOf","_setPrototypeOf2","_create","_create2","_typeof2","_typeof3","subClass","superClass","ReferenceError","_iterator","_iterator2","_symbol","_symbol2","_typeof","aFunction","is","createElement","cof","redefine","Iterators","$iterCreate","setToStringTag","getPrototypeOf","ITERATOR","BUGGY","FF_ITERATOR","KEYS","VALUES","returnThis","Base","NAME","next","DEFAULT","IS_SET","FORCED","methods","IteratorPrototype","getMethod","kind","proto","DEF_VALUES","VALUES_BUG","$native","$default","$entries","$anyNative","entries","values","pIE","toIObject","gOPD","getOwnPropertyDescriptor","hiddenKeys","getOwnPropertyNames","toObject","ObjectProto","names","fails","KEY","exp","$at","iterated","_t","_i","point","index","TO_STRING_TAG","collections","Collection","factory","Map","map","each","nest","depth","createResult","setResult","rollup","sortValues","sort","keyValue","valuesByKey","sortKey","sortKeys","v","k","createObject","setObject","createMap","setMap","order","Set","add","prefix","remove","property","clear","empty","_events","_maxListeners","defaultMaxListeners","setMaxListeners","handler","listeners","error","context","listener","newListener","warned","console","trace","g","fired","position","splice","evlistener","emitter","ReadableState","pipes","pipesCount","flowing","endEmitted","emittedReadable","readableListening","readableObjectMode","ranOut","awaitDrain","readingMore","decoder","StringDecoder","readableAddChunk","addToFront","chunkInvalid","onEofChunk","unshift","emitReadable","maybeReadMore","needMoreData","roundUpToNextPowerOf2","MAX_HWM","p","howMuchToRead","debug","emitReadable_","flow","maybeReadMore_","pipeOnDrain","resumeScheduled","resume_","fromList","stringMode","shift","cpy","endReadable","debuglog","setEncoding","enc","nOrig","doRead","pipeOpts","onunpipe","onfinish","unpipe","doEnd","stdout","stderr","endFn","dests","ev","wrap","paused","events","_fromList","assertEncoding","isBufferEncoding","passThroughWrite","utf16DetectIncompleteChar","charReceived","charLength","base64DetectIncompleteChar","surrogateSize","detectIncompleteChar","charBuffer","charStr","available","charCode","substring","cr","__WEBPACK_AMD_DEFINE_RESULT__","CsvToJson","_input","_config","worker","Papa","WORKERS_SUPPORTED","w","newWorker","userStep","step","userChunk","userComplete","complete","userError","postMessage","input","config","workerId","streamer","download","NetworkStreamer","StringStreamer","File","FileStreamer","JsonToCsv","unpackConfig","delimiter","BAD_DELIMITERS","_delimiter","quotes","_quotes","newline","_newline","serialize","fields","csv","JSON","parse","hasHeader","dataKeyedByField","safe","row","maxCol","col","colIdx","needsQuotes","hasAny","substrings","ChunkStreamer","replaceConfig","configCopy","chunkSize","_handle","ParserHandle","_paused","_finished","_baseIndex","_partialLine","_rowCount","_start","_nextChunk","isFirstChunk","_completeResults","errors","meta","parseChunk","beforeFirstChunk","modifiedChunk","aggregate","results","aborted","lastIndex","cursor","finishedIncludingPreview","preview","IS_PAPA_WORKER","WORKER_ID","_sendError","getFileSize","xhr","contentRange","getResponseHeader","RemoteChunkSize","IS_WORKER","_readChunk","_chunkLoaded","url","XMLHttpRequest","onload","bindFunction","_chunkError","setRequestHeader","send","message","status","readyState","responseText","errorMessage","errorText","statusText","LocalChunkSize","reader","usingAsyncReader","FileReader","file","webkitSlice","mozSlice","FileReaderSync","txt","readAsText","event","s","processResults","_results","_delimiterError","addError","DefaultDelimiter","skipEmptyLines","needsHeaderRow","fillHeaderFields","applyHeaderAndDynamicTyping","header","_fields","dynamicTyping","tryParseFloat","guessDelimiter","bestDelim","bestDelta","fieldCountPrevRow","delimChoices","RECORD_SEP","UNIT_SEP","delim","delta","avgFieldCount","Parser","fieldCount","abs","successful","bestDelimiter","guessLineEndings","r","numWithN","FLOAT","test","parseFloat","msg","_parser","_stepCounter","_aborted","abort","baseIndex","ignoreLastRow","delimGuess","parserConfig","getCharIndex","comments","fastMode","pushRow","lastCursor","finish","returnable","inputLen","stepIsFunction","doStep","saveRow","newCursor","nextNewline","stopped","linebreak","truncated","delimLen","newlineLen","commentsLen","rows","nextDelim","quoteSearch","getScriptPath","scripts","getElementsByTagName","LOADED_SYNC","SCRIPT_PATH","workerUrl","AUTO_SCRIPT_PATH","Worker","onmessage","mainThreadReceivedMessage","workerIdCounter","workers","completeWorker","handle","notImplemented","terminate","workerThreadReceivedMessage","func","location","search","unparse","BYTE_ORDER_MARK","define","amd","jQuery","$","parseNextFile","before","returned","inputElem","action","reason","fileComplete","instanceConfig","extend","userCompleteFunc","elem","idx","supported","prop","toUpperCase","attr","files","body","addEventListener","placeHoldersCount","b64","tmp","placeHolders","Arr","L","revLookup","tripletToBase64","num","lookup","encodeChunk","uint8","output","extraBytes","parts","maxChunkLength","len2","$JSON","stringify","assign","$Object","D","desc","setPrototypeOf","toLength","toIndex","IS_INCLUDES","$this","el","fromIndex","ARG","tryGet","T","callee","getKeys","gOPS","getSymbols","symbols","isEnum","documentElement","META","setDesc","isExtensible","FREEZE","preventExtensions","setMeta","fastKey","getWeak","onFreeze","NEED","$assign","A","K","aLen","gOPN","windowNames","getWindowNames","isEntries","check","buggy","toInteger","TO_STRING","classof","getIteratorMethod","getIterator","iterFn","addToUnscopables","_k","Arguments","$getPrototypeOf","DESCRIPTORS","$fails","wks","wksDefine","keyOf","enumKeys","gOPNExt","$GOPD","$DP","_stringify","HIDDEN","TO_PRIMITIVE","SymbolRegistry","AllSymbols","OPSymbols","USE_NATIVE","QObject","setter","findChild","setSymbolDesc","protoDesc","sym","iterator","$defineProperty","$defineProperties","$create","$propertyIsEnumerable","E","$getOwnPropertyDescriptor","$getOwnPropertyNames","$getOwnPropertySymbols","IS_OP","$set","for","keyFor","useSetter","useSimple","replacer","$replacer","$values","ascendingComparator","ascending","tickStep","stop","count","step0","step1","log","LN10","e10","e5","e2","map$1","linear","t","quadIn","quadOut","quadInOut","cubicIn","cubicOut","cubicInOut","sinIn","cos","halfPi","sinOut","sin","sinInOut","pi","expIn","expOut","expInOut","circleIn","sqrt","circleOut","circleInOut","bounceIn","bounceOut","b1","b0","b3","b2","b4","b6","b5","b7","b8","b9","bounceInOut","lexicographicOrder","computeUpperHullIndexes","points","indexes","cross","Path","_x0","_y0","_x1","_y1","_","path","tree","parent","xm","ym","xp","yp","right","bottom","node","_root","leaf","x0","y0","x1","y1","_x","_y","addAll","xz","yz","cover","removeAll","defaultX","defaultY","quadtree","nodes","Quadtree","NaN","leaf_copy","Queue","_size","_call","_error","_tasks","_data","_waiting","_active","_ended","poke","q","noabort","maybeNotify","concurrency","arcInnerRadius","innerRadius","arcOuterRadius","outerRadius","arcStartAngle","startAngle","arcEndAngle","endAngle","arcPadAngle","padAngle","asin","halfPi$1","intersect","x2","y2","x3","y3","x10","y10","x32","y32","cornerTangents","r1","rc","cw","x01","y01","ox","oy","x11","y11","x00","y00","dx","dy","d2","cx0","cy0","cx1","cy1","dx0","dy0","dx1","dy1","cx","cy","Linear","_context","Radial","curve","_curve","curveRadial","radial","radialLine","angle","radius","bezierCurveTo","Basis","BasisClosed","BasisOpen","Bundle","beta","_basis","_beta","point$1","_x2","_y2","Cardinal","tension","CardinalClosed","CardinalOpen","point$2","_l01_a","epsilon$1","_l01_2a","_l12_a","_l12_2a","_l23_a","_l23_2a","CatmullRom","alpha","_alpha","CatmullRomClosed","CatmullRomOpen","LinearClosed","sign","slope3","h0","h1","s0","s1","slope2","h","point$3","t0","t1","MonotoneX","MonotoneY","ReflectContext","monotoneX","monotoneY","Natural","controlPoints","Step","stepBefore","stepAfter","stackValue","sum$1","series","definition","Color","color","format","reHex3","Rgb","reHex6","rgbn","reRgbInteger","reRgbPercent","reRgbaInteger","rgba","reRgbaPercent","reHslPercent","hsla","reHslaPercent","named","rgbConvert","rgb","opacity","Hsl","hslConvert","hsl","hsl2rgb","m1","m2","labConvert","Lab","Hcl","deg2rad","rgb2xyz","xyz2lab","Xn","Yn","z","Zn","lab","t3","t2","lab2xyz","xyz2rgb","hclConvert","atan2","rad2deg","hcl","cubehelixConvert","Cubehelix","BC_DA","ED","EB","bl","cubehelix","basis$1","v0","v1","v2","v3","linear$1","exponential$1","hue","round","constant$3","gamma","nogamma","rgbSpline","spline","colors","color$$1","zero","one","parseCss","identity$2","cssNode","cssRoot","cssView","defaultView","transform","getComputedStyle","getPropertyValue","removeChild","decompose","parseSvg","svgNode","createElementNS","setAttribute","baseVal","consolidate","matrix","interpolateTransform","pxComma","pxParen","degParen","pop","translate","xa","ya","xb","yb","interpolateNumber","rotate","skewX","scale","translateX","translateY","scaleX","scaleY","cosh","sinh","tanh","hsl$1","hue$$1","lab$1","hcl$1","cubehelix$1","cubehelixGamma","cubehelix$$1","dispatch","Dispatch","parseTypenames","typenames","types","set$2","noop$1","objectConverter","columns","customConverter","inferColumns","columnSet","column","fixCallback","hasResponse","responseType","response","responseOf","request$$1","now","clockNow","setFrame","clearNow","clock","clockSkew","Timer","_time","_next","timer","delay","time","restart","timerFlush","frame","taskHead","wake","clockLast","nap","poke$1","pokeDelay","taskTail","sleep","interval","clearInterval","setInterval","newInterval","floori","offseti","field","date","Date","d0","d1","range","filter","setTime","t0$1","t1$1","every","weekday","setDate","getDate","getDay","setHours","getTimezoneOffset","durationMinute","durationWeek","utcWeekday","setUTCDate","getUTCDate","getUTCDay","setUTCHours","FormatSpecifier","specifier","align","symbol","width","comma","precision","formatTypes","identity$3","defaultLocale","locale$1","formatLocale","formatPrefix","localDate","H","M","setFullYear","utcDate","UTC","setUTCFullYear","newYear","formatLocale$1","locale","newFormat","formats","pad","pads","newParse","newDate","parseSpecifier","day$$1","Z","parses","parsePeriod","periodRe","periodLookup","parseShortWeekday","shortWeekdayRe","shortWeekdayLookup","parseWeekday","weekdayRe","weekdayLookup","parseShortMonth","shortMonthRe","shortMonthLookup","parseMonth","monthRe","monthLookup","parseLocaleDateTime","locale_dateTime","parseLocaleDate","locale_date","parseLocaleTime","locale_time","formatShortWeekday","locale_shortWeekdays","formatWeekday","locale_weekdays","formatShortMonth","locale_shortMonths","getMonth","formatMonth","locale_months","formatPeriod","locale_periods","getHours","formatUTCShortWeekday","formatUTCWeekday","formatUTCShortMonth","getUTCMonth","formatUTCMonth","formatUTCPeriod","getUTCHours","dateTime","periods","days","shortDays","months","shortMonths","formatRe","formatLookup","formatDayOfMonth","formatHour24","I","formatHour12","formatDayOfYear","formatMilliseconds","formatMonthNumber","formatMinutes","formatSeconds","formatWeekNumberSunday","formatWeekdayNumber","formatWeekNumberMonday","X","formatYear","Y","formatFullYear","formatZone","%","formatLiteralPercent","utcFormats","formatUTCDayOfMonth","formatUTCHour24","formatUTCHour12","formatUTCDayOfYear","formatUTCMilliseconds","formatUTCMonthNumber","formatUTCMinutes","formatUTCSeconds","formatUTCWeekNumberSunday","formatUTCWeekdayNumber","formatUTCWeekNumberMonday","formatUTCYear","formatUTCFullYear","formatUTCZone","parseDayOfMonth","parseHour24","parseDayOfYear","parseMilliseconds","parseMonthNumber","parseMinutes","parseSeconds","parseWeekNumberSunday","parseWeekdayNumber","parseWeekNumberMonday","parseYear","parseFullYear","parseZone","parseLiteralPercent","utcFormat","utcParse","requote","requoteRe","RegExp","numberRe","percentRe","day","year","getMilliseconds","getMinutes","getSeconds","sunday","monday","getFullYear","utcDay","utcYear","getUTCMilliseconds","getUTCMinutes","getUTCSeconds","utcSunday","utcMonday","getUTCFullYear","defaultLocale$1","locale$2","timeFormat","timeParse","formatIsoNative","toISOString","parseIsoNative","ordinal","unknown","implicit","domain","slice$3","band","rescale","reverse","range$$1","paddingInner","paddingOuter","bandwidth","ordinalRange","rangeRound","padding","pointish","point$4","deinterpolateLinear","constant$4","deinterpolateClamp","deinterpolate","reinterpolateClamp","reinterpolate","bimap","r0","polymap","bisectRight","interpolate","clamp","continuous","piecewise","interpolate$$1","unit","invert","map$3","number$1","interpolateRound","linearish","ticks","tickFormat","nice","linear$2","identity$4","pow10","powp","base","logp","log10","log2","reflect","logs","pows","u","raise","exponent","quantile$$1","thresholds","threshold","invertExtent","quantiles","quantize$1","threshold$1","date$1","number$2","calendar","year$$1","month$$1","week","hour$$1","minute$$1","second$$1","millisecond$$1","formatMillisecond","formatSecond","formatMinute","formatHour","formatDay","formatWeek","tickInterval","bisector","tickIntervals","durationYear","durationSecond$1","durationMinute$1","durationHour$1","durationDay$1","durationWeek$1","durationMonth","ramp","sequential","interpolator","creatorInherit","ownerDocument","uri","namespaceURI","xhtml","creatorFixed","fullname","space","local","Local","nextId","filterContextListener","group","contextListener","related","relatedTarget","compareDocumentPosition","event1","event0","__data__","parseTypenames$1","onRemove","typename","__on","removeEventListener","capture","onAdd","filterEvents","customEvent","sourceEvent","none$2","EnterNode","datum","_parent","bindIndex","enter","update","exit","groupLength","dataLength","bindKey","nodeByKeyValue","keyValues","keyPrefix","ascending$2","attrRemove","removeAttribute","attrRemoveNS","removeAttributeNS","attrConstant","attrConstantNS","setAttributeNS","attrFunction","attrFunctionNS","styleRemove","removeProperty","styleConstant","priority","setProperty","styleFunction","propertyRemove","propertyConstant","propertyFunction","classArray","classList","ClassList","_node","_names","getAttribute","classedAdd","classedRemove","classedTrue","classedFalse","classedFunction","textRemove","textContent","textConstant","textFunction","htmlRemove","innerHTML","htmlConstant","htmlFunction","raise$1","nextSibling","parentNode","lower","previousSibling","insertBefore","firstChild","constantNull","dispatchEvent","params","window$$1","CustomEvent","createEvent","initEvent","bubbles","cancelable","detail","dispatchConstant","dispatchFunction","Selection","groups","parents","_groups","_parents","selection","root","init","schedule","__transition","CREATED","set$3","STARTING","get$1","elapsed","SCHEDULED","schedules","STARTED","timeout$1","RUNNING","ENDED","tick","tween","duration","ease","ENDING","tweenRemove","tween0","tween1","tweenFunction","tweenValue","transition","_id","attrRemove$1","attrRemoveNS$1","attrConstant$1","value1","value00","interpolate0","value0","attrConstantNS$1","getAttributeNS","attrFunction$1","value10","attrFunctionNS$1","attrTweenNS","_value","attrTween","delayFunction","delayConstant","durationFunction","durationConstant","easeConstant","start$1","onFunction","on0","on1","sit","removeFunction","styleRemove$1","styleRemoveEnd","styleConstant$1","styleFunction$1","styleTween","textConstant$1","textFunction$1","Transition","_name","newId","inherit","timing","defaultTiming","scale0","scale1","center","entering","__axis","axis","orient","tickValues","tickArguments","identity$5","spacing","tickSizeInner","tickPadding","top","range0","range1","selectAll","tickExit","tickEnter","append","line","select","text","left","merge","insert","epsilon$2","tickSizeOuter","slice$4","tickSize","axisTop","axisRight","axisBottom","axisLeft","defaultSeparation","meanX","children","reduce","meanXReduce","maxY","maxYReduce","leafLeft","leafRight","leastCommonAncestor","aNodes","ancestors","bNodes","hierarchy","child","childs","Node","valued","defaultChildren","eachBefore","computeHeight","node_copy","copyData","height","Node$2","encloses","dr","encloseN","circle","l2","p1","l0","l1","head","enclose1","enclose2","enclose3","tail","r2","x21","y21","r21","r3","a2","c2","a3","c3","d3","ab","place","ax","ay","da","db","dc","intersects","distance2","Node$1","previous","packEnclose","circles","sj","sk","aa","ba","ca","oa","pack","enclose","optional","required","constantZero","defaultRadius","radiusLeaf","packChildren","translateChild","defaultId","defaultParentId","parentId","defaultSeparation$1","nextLeft","nextRight","moveSubtree","wm","wp","change","executeShifts","nextAncestor","vim","ancestor","TreeNode","treeRoot","squarifyRatio","ratio","nodeValue","i1","sumValue","minValue","maxValue","newRatio","minRatio","i0","dice","treemapDice","treemapSlice","x$1","vx","y$1","vy","index$2","find","nodeById","nodeId","x$2","y$2","nopropagation","stopImmediatePropagation","yesdrag","view","noclick","selection$$1","noevent","MozUserSelect","__noselect","DragEvent","subject","active","identifier","defaultFilter","button","defaultContainer","defaultSubject","x$4","y$4","RedBlackTree","RedBlackNode","N","RedBlackRotateLeft","RedBlackRotateRight","RedBlackFirst","createEdge","edge","edges","setEdgeEnd","cells","halfedges","createBorderEdge","vertex","clipEdge","bx","by","connectEdge","fm","fb","lx","ly","rx","ry","fx","fy","clipEdges","epsilon$3","createCell","site","cellHalfedgeAngle","cell","va","vb","cellHalfedgeStart","cellHalfedgeEnd","sortCellHalfedges","clipCells","iCell","iHalfedge","nHalfedges","startX","startY","endX","endY","nCells","v00","v01","v11","v10","Circle","arc","attachCircle","lArc","rArc","lSite","cSite","rSite","epsilon2$1","ha","hc","circlePool","firstCircle","detachCircle","Beach","createBeach","beach","beachPool","detachBeach","beaches","removeBeach","disappearing","iArc","nArcs","addBeach","dxl","dxr","directrix","leftBreakPoint","rightBreakPoint","newArc","hb","rfocx","rfocy","pby2","lfocx","lfocy","plby2","hl","aby2","triangleArea","lexicographic","Diagram","sites","extent","ZoomEvent","__zoom","identity$6","nopropagation$1","defaultFilter$1","defaultExtent","SVGElement","ownerSVGElement","clientWidth","clientHeight","defaultTransform","nopropagation$2","type$1","defaultFilter$2","defaultExtent$1","svg","local$1","__brush","empty$1","brushSelection","dim","brushX","brush$1","brushY","brush","overlay","initialize","cursors","handles","redraw","started","handleSize","Emitter","moved","point1","mouse","shifting","lockX","lockY","moving","noevent$2","move","point0","mode","MODE_SPACE","MODE_DRAG","signX","w0","e0","w1","e1","signY","n0","n1","MODE_HANDLE","MODE_CENTER","flipX","flipY","touches","touchending","keydowned","keyCode","keyupped","altKey","changedTouches","metaKey","signsX","signsY","shiftKey","beforestart","dragDisable","interrupt","selection1","selection0","starting","BrushEvent","constant$11","compareValue","defaultSource","defaultTarget","defaultRadius$1","defaultStartAngle","defaultEndAngle","Adder","reset","add$1","adder","bv","av","acos","pi$4","asin$1","halfPi$3","haversin","sin$1","noop$2","streamGeometry","geometry","streamGeometryType","streamLine","coordinates","closed","coordinate","lineStart","lineEnd","streamPolygon","polygonStart","polygonEnd","areaRingStart","areaStream","areaPointFirst","areaRingEnd","areaPoint","lambda00","phi00","lambda","phi","radians","lambda0","cosPhi0","cos$1","quarterPi","sinPhi0","dLambda","sdLambda","adLambda","cosPhi","sinPhi","areaRingSum","spherical","cartesian","cartesianDot","cartesianCross","cartesianAddInPlace","cartesianScale","vector","cartesianNormalizeInPlace","sqrt$1","boundsPoint","ranges","range$1","lambda0$1","lambda1","phi0","phi1","linePoint","p0","normal","equatorial","inflection","phii","lambda2","sign$$1","lambdai","degrees$1","antimeridian","boundsLineStart","boundsStream","boundsLineEnd","boundsRingPoint","deltaSum","lambda00$1","phi00$1","boundsRingStart","boundsRingEnd","epsilon$4","rangeCompare","rangeContains","centroidPoint","centroidPointCartesian","W0","X0","Y0","Z0","centroidLineStart","centroidStream","centroidLinePointFirst","z0","centroidLinePoint","W1","X1","Y1","Z1","centroidLineEnd","centroidRingStart","centroidRingPointFirst","centroidRingEnd","centroidRingPoint","lambda00$2","phi00$2","cz","X2","Y2","Z2","rotationIdentity","tau$4","rotateRadians","deltaLambda","deltaPhi","deltaGamma","compose","rotationLambda","rotationPhiGamma","forwardRotationLambda","rotation","cosDeltaPhi","sinDeltaPhi","cosDeltaGamma","sinDeltaGamma","circleStream","direction","cosRadius","sinRadius","circleRadius","Intersection","other","link$1","clipExtent","visible","to","a1","corner","comparePoint","compareIntersection","activeStream","polygonInside","winding","polygon","a0","ring","bufferStream","segments","clean","startInside","cleanInside","clipPolygon","clipStream","first","v_","x_","y_","x__","y__","v__","rejoin","clipMin","clipMax","clipLine","clipBuffer","lengthLineStart","lengthStream","lengthPointFirst","lengthLineEnd","lambda0$2","sinPhi0$1","cosPhi0$1","lengthPoint","cosDelta","sinDelta","lengthSum","graticuleX","graticuleY","graticule","lines","DX","DY","outline","extentMajor","extentMinor","stepMajor","stepMinor","graticule10","areaRingStart$1","areaStream$1","areaPointFirst$1","areaPoint$1","x0$1","y0$1","areaRingSum$1","areaRingEnd$1","boundsPoint$1","x0$2","y0$2","centroidPoint$1","X0$1","Y0$1","Z0$1","centroidLineStart$1","centroidStream$1","centroidPointFirstLine","centroidPointLine","x0$3","y0$3","X1$1","Y1$1","Z1$1","centroidLineEnd$1","centroidRingStart$1","centroidPointFirstRing","centroidRingEnd$1","centroidPointRing","x00$1","y00$1","X2$1","Y2$1","Z2$1","PathContext","PathString","_string","circle$2","validSegment","segment","clipAntimeridianLine","sign0","sign1","clipAntimeridianIntersect","cosPhi1","sinLambda0Lambda1","atan","clipAntimeridianInterpolate","transformer","TransformStream","fitExtent","projection","clip","geoStream","boundsStream$1","fitSize","resampleNone","project","resample$1","delta2","resampleLineTo","c0","c1","phi2","dx2","dy2","dz","cosMinDistance","resampleStream","maxDepth","ringStart","ringPoint","ringEnd","a00","b00","c00","projectionMutator","projectAt","projectRotate","projectTransform","recenter","cache","cacheStream","theta","preclip","clipAntimeridian","postclip","identity$7","projectResample","resample","transformRadians","clipAngle","clipCircle","conicProjection","parallels","cylindricalEqualAreaRaw","forward","conicEqualAreaRaw","sy0","r0y","sign$1","multiplex","streams","sphere","azimuthalRaw","azimuthalInvert","sc","cc","mercatorRaw","log$1","tan","mercatorProjection","clipAuto","tany","conicConformalRaw","pow$1","equirectangularRaw","conicEquidistantRaw","gy","nx","gnomonicRaw","scaleTranslate","tx","ty","orthographicRaw","stereographicRaw","transverseMercatorRaw","mid","ascendingBisect","bisectLeft","descending","number","variance","deviation","constant$1","identity","sturges","LN2","histogram","tz","bin","bins","freedmanDiaconis","scott","mean","median","numbers","arrays","merged","pairs","permute","permutes","scan","xi","xj","shuffle","sum","transpose","zip","uniform","mu","sigma","logNormal","randomNormal","irwinHall","bates","randomIrwinHall","exponential","polyIn","custom","polyOut","polyInOut","PI","overshoot","backIn","backOut","backInOut","tau","amplitude","period","elasticIn","elasticOut","elasticInOut","area","centroid","hull","sortedPoints","flippedPoints","upperIndexes","lowerIndexes","skipLeft","skipRight","contains","inside","length$1","perimeter","pi$1","tau$1","epsilon","tauEpsilon","moveTo","closePath","lineTo","quadraticCurveTo","arcTo","l01_2","x20","y20","l21_2","l20_2","l21","l01","t01","t21","ccw","rect","tree_add","tree_cover","tree_data","visit","tree_extent","Quad","tree_find","quads","tree_remove","retainer","tree_root","tree_size","tree_visit","tree_visitAfter","tree_x","tree_y","treeProto","visitAfter","slice$1","defer","await","awaitAll","constant$2","pi$2","tau$2","a01","a11","a10","da0","da1","ap","rp","padRadius","cornerRadius","rc0","rc1","oc","kc","lc","areaStart","_line","areaEnd","_point","curveLinear","defined0","x$$1","y$$1","area$1","x0z","y0z","arealine","lineX0","lineY0","lineY1","lineX1","descending$1","identity$1","pie","arcs","pa","curveRadialLinear","radialLine$1","radialArea","lineStartAngle","lineEndAngle","lineInnerRadius","lineOuterRadius","draw","cross$1","tan30","tan30_2","diamond","ka","kr","kx","ky","star","square","sqrt3","triangle","wye","basis","_x3","_x4","_y3","_y4","basisClosed","basisOpen","bundle","cardinal","_x5","_y5","cardinalClosed","cardinalOpen","x23","y23","catmullRom","catmullRomClosed","catmullRomOpen","linearClosed","_t0","py","natural","slice$2","none","none$1","stack","oz","kz","sz","sij","ki","si","expand","silhouette","wiggle","s2","sij0","sij1","s3","skj0","skj1","ascending$1","sums","descending$2","insideOut","tops","bottoms","darker","brighter","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","displayable","Kn","basis$2","basisClosed$1","interpolateRgb","rgbGamma","rgb$$1","rgbBasis","rgbBasisClosed","array$1","nb","na","reA","reB","interpolateString","am","bm","bs","bi","degrees","interpolateTransformCss","interpolateTransformSvg","rho","SQRT2","rho2","rho4","epsilon2","interpolateZoom","ux0","uy0","ux1","uy1","coshr0","hsl$2","hslLong","hcl$2","hclLong","cubehelix$2","cubehelixLong","quantize","samples","dsv","convert","parseRows","token","EOF","eol","EOL","delimiterCode","formatValue","formatRows","formatRow","reFormat","csvParse","csvParseRows","csvFormat","csvFormatRows","tsv","tsvParse","tsvParseRows","tsvFormat","tsvFormatRows","request","respond","mimeType","headers","user","password","XDomainRequest","ontimeout","onreadystatechange","onprogress","post","overrideMimeType","defaultMimeType","html","createRange","createContextualFragment","json","xml","responseXML","dsv$1","csv$1","tsv$1","performance","requestAnimationFrame","interval$1","total","millisecond","milliseconds","durationSecond","durationHour","durationDay","second","seconds","minute","minutes","hour","hours","tuesday","wednesday","thursday","friday","saturday","sundays","mondays","tuesdays","wednesdays","thursdays","fridays","saturdays","month","setMonth","years","utcMinute","setUTCSeconds","utcMinutes","utcHour","setUTCMinutes","utcHours","utcDays","utcTuesday","utcWednesday","utcThursday","utcFriday","utcSaturday","utcSundays","utcMondays","utcTuesdays","utcWednesdays","utcThursdays","utcFridays","utcSaturdays","utcMonth","setUTCMonth","utcMonths","prefixExponent","utcYears","formatDecimal","toExponential","coefficient","exponent$1","formatGroup","grouping","thousands","formatDefault","toPrecision","formatPrefixAuto","formatRounded","","toFixed","formatSpecifier","prefixes","valuePrefix","valueSuffix","suffix","formatType","valueNegative","maybeSuffix","decimal","currency","precisionFixed","precisionPrefix","precisionRound","-","0","isoSpecifier","formatIso","parseIso","array$2","utcTime","category10","category20b","category20c","category20","cubehelix$3","warm","cool","rainbow","rainbow$1","viridis","magma","inferno","plasma","namespaces","xlink","xmlns","namespace","creator","matcher","selector","matches","element","vendorMatches","webkitMatchesSelector","msMatchesSelector","mozMatchesSelector","oMatchesSelector","matcher$1","element$1","mouseenter","mouseleave","selection_on","current","point$5","createSVGPoint","clientX","clientY","matrixTransform","getScreenCTM","inverse","getBoundingClientRect","clientLeft","clientTop","querySelector","selection_select","subgroups","subnode","subgroup","selectorAll","querySelectorAll","selection_selectAll","selection_filter","sparse","selection_enter","_enter","constant$5","selection_data","enterGroup","updateGroup","exitGroup","_exit","selection_exit","selection_merge","groups0","groups1","m0","merges","group0","group1","selection_order","selection_sort","compareNode","sortgroups","sortgroup","selection_call","selection_nodes","selection_node","selection_size","selection_empty","selection_each","selection_attr","selection_style","selection_property","selection_classed","selection_text","selection_html","selection_raise","selection_lower","selection_append","selection_insert","selection_remove","selection_datum","selection_dispatch","classed","touch","emptyOn","emptyTween","selection_interrupt","transition_tween","interpolate$1","transition_attr","transition_attrTween","transition_delay","transition_duration","transition_ease","transition_filter","transition_merge","transition_on","transition_remove","transition_select","select$$1","transition_selectAll","Selection$1","transition_selection","transition_style","transition_styleTween","transition_text","transition_transition","id0","id1","selection_prototype","selection_transition","root$1","cluster","previousNode","eachAfter","separation","nodeSize","node_each","node_eachBefore","node_eachAfter","node_sum","node_sort","node_path","node_ancestors","node_descendants","node_leaves","leaves","node_links","links","descendants","shuffle$1","siblings","constant$6","roundNode","partition","positionNode","keyPrefix$1","preroot","ambiguous","stratify","nodeKey","nodeByKey","firstWalk","secondWalk","sizeNode","midpoint","apportion","vip","vop","vom","sip","sop","sim","som","squarify","index$1","treemap","paddingStack","paddingLeft","paddingTop","paddingRight","paddingBottom","tile","binary","valueOffset","valueTarget","valueLeft","valueRight","yk","xk","sliceDice","resquarify","_squarify","center$1","force","sx","sy","constant$7","jiggle","collide","quad","rj","ri","yi","strength","ri2","iterations","prepare","radii","link","defaultStrength","distances","strengths","bias","initializeStrength","initializeDistance","distance","initialRadius","initialAngle","simulation","alphaMin","stepper","alphaTarget","alphaDecay","forces","velocityDecay","initializeNodes","initializeForce","closest","manyBody","accumulate","theta2","distanceMax2","distanceMin2","distanceMin","distanceMax","x$3","y$3","preventDefault","constant$8","drag","mousedowned","touchstarted","touchmoved","touchended","gesture","container","mousemoved","mouseupped","mousemoving","gestures","touches$$1","sublisteners","constant$9","after","grandpa","uncle","sibling","polygons","triangles","_found","voronoi","constant$10","applyX","applyY","invertX","invertY","rescaleX","rescaleY","noevent$1","zoom","wheeled","dblclicked","k0","k1","constrain","transition$$1","Gesture","wheelidled","wheel","deltaY","deltaMode","wheelDelay","touch0","touch1","touchstarting","touchDelay","dp","dl","collection","scaleBy","scaleTo","translateBy","scaleExtent","translateExtent","xy","XY","nw","ne","se","sw","pi$3","halfPi$2","tau$3","max$1","chord","groupSums","groupIndex","subgroupIndex","chords","sortGroups","sortSubgroups","di","dj","subindex","sortChords","slice$5","constant$12","ribbon","sr","sa0","sa1","sx0","tr","ta0","ta1","temp","epsilon2$2","streamObjectType","Feature","feature","FeatureCollection","features","Sphere","Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon","GeometryCollection","geometries","areaSum","areaRing","area$2","bounds","deltaMax","centroid$1","constant$13","circle$1","pointEqual","isSubject","extent$1","length$2","object$1","interpolate$2","sy1","kx0","ky0","kx1","ky1","areaSum$1","_radius","pointRadius","_circle","index$3","contextStream","projectionStream","sum$2","polygonContains","sinPhi1","absDelta","intersection","phiArc","pointVisible","sink","pointLine","pointRing","ringSink","ringSegments","ringBuffer","polygonStarted","rotatedStart","point2","smallRadius","notHemisphere","two","pb","n2","n2n2","n1n2","determinant","n1xn2","uu","polar","meridian","q1","transform$1","conicEqualArea","albers","albersUsa","lower48Point","alaskaPoint","hawaiiPoint","lower48","alaska","hawaii","pointStream","azimuthalEqualAreaRaw","cxcy","azimuthalEqualArea","azimuthalEquidistantRaw","azimuthalEquidistant","mercator","conicConformal","equirectangular","conicEquidistant","gnomonic","identity$8","orthographic","stereographic","transverseMercator","bisect","thresholdFreedmanDiaconis","thresholdScott","thresholdSturges","quantile","randomUniform","randomLogNormal","randomBates","randomExponential","easeLinear","easeQuad","easeQuadIn","easeQuadOut","easeQuadInOut","easeCubic","easeCubicIn","easeCubicOut","easeCubicInOut","easePoly","easePolyIn","easePolyOut","easePolyInOut","easeSin","easeSinIn","easeSinOut","easeSinInOut","easeExp","easeExpIn","easeExpOut","easeExpInOut","easeCircle","easeCircleIn","easeCircleOut","easeCircleInOut","easeBounce","easeBounceIn","easeBounceOut","easeBounceInOut","easeBack","easeBackIn","easeBackOut","easeBackInOut","easeElastic","easeElasticIn","easeElasticOut","easeElasticInOut","polygonArea","polygonCentroid","polygonHull","polygonLength","symbolCircle","symbolCross","symbolDiamond","symbolSquare","symbolStar","symbolTriangle","symbolWye","curveBasisClosed","curveBasisOpen","curveBasis","curveBundle","curveCardinalClosed","curveCardinalOpen","curveCardinal","curveCatmullRomClosed","curveCatmullRomOpen","curveCatmullRom","curveLinearClosed","curveMonotoneX","curveMonotoneY","curveNatural","curveStep","curveStepAfter","curveStepBefore","stackOffsetExpand","stackOffsetNone","stackOffsetSilhouette","stackOffsetWiggle","stackOrderAscending","stackOrderDescending","stackOrderInsideOut","stackOrderNone","stackOrderReverse","interpolateArray","interpolateDate","interpolateObject","interpolateRgbBasis","interpolateRgbBasisClosed","interpolateHsl","interpolateHslLong","interpolateLab","interpolateHcl","interpolateHclLong","interpolateCubehelix","interpolateCubehelixLong","interpolateBasis","interpolateBasisClosed","dsvFormat","timeInterval","timeMillisecond","timeMilliseconds","timeSecond","timeSeconds","timeMinute","timeMinutes","timeHour","timeHours","timeDay","timeDays","timeWeek","timeWeeks","timeSunday","timeSundays","timeMonday","timeMondays","timeTuesday","timeTuesdays","timeWednesday","timeWednesdays","timeThursday","timeThursdays","timeFriday","timeFridays","timeSaturday","timeSaturdays","timeMonth","timeMonths","timeYear","timeYears","utcMillisecond","utcMilliseconds","utcSecond","utcSeconds","utcWeek","utcWeeks","formatDefaultLocale","isoFormat","isoParse","timeFormatLocale","timeFormatDefaultLocale","scaleBand","scalePoint","scaleIdentity","scaleLinear","scaleLog","scaleOrdinal","scaleImplicit","scalePow","scaleSqrt","scaleQuantile","scaleQuantize","scaleThreshold","scaleTime","scaleUtc","schemeCategory10","schemeCategory20b","schemeCategory20c","schemeCategory20","scaleSequential","interpolateCubehelixDefault","interpolateRainbow","interpolateWarm","interpolateCool","interpolateViridis","interpolateMagma","interpolateInferno","interpolatePlasma","packSiblings","treemapBinary","treemapSliceDice","treemapSquarify","treemapResquarify","forceCenter","forceCollide","forceLink","forceManyBody","forceSimulation","forceX","forceY","dragEnable","zoomIdentity","zoomTransform","geoAlbers","geoAlbersUsa","geoArea","geoAzimuthalEqualArea","geoAzimuthalEqualAreaRaw","geoAzimuthalEquidistant","geoAzimuthalEquidistantRaw","geoBounds","geoCentroid","geoCircle","geoClipExtent","geoConicConformal","geoConicConformalRaw","geoConicEqualArea","geoConicEqualAreaRaw","geoConicEquidistant","geoConicEquidistantRaw","geoDistance","geoEquirectangular","geoEquirectangularRaw","geoGnomonic","geoGnomonicRaw","geoGraticule","geoGraticule10","geoIdentity","geoInterpolate","geoLength","geoMercator","geoMercatorRaw","geoOrthographic","geoOrthographicRaw","geoPath","geoProjection","geoProjectionMutator","geoRotation","geoStereographic","geoStereographicRaw","geoTransform","geoTransverseMercator","geoTransverseMercatorRaw","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","rt","NODE_ENV","READABLE_STREAM","_toString","toNumber","makeMap","expectsLowerCase","remove$1","item","hasOwn","cached","hit","bind$1","boundFn","_length","toArray","_from","isPlainObject","OBJECT_STRING","genStaticKeys","modules","staticKeys","looseEqual","looseIndexOf","isReserved","parsePath","bailRE","isNative","Ctor","pushTarget","_target","Dep","targetStack","popTarget","resetSchedulerState","has$1","circular","waiting","flushing","flushSchedulerQueue","watcher","_maxUpdateCount","warn","vm","devtools","queueWatcher","traverse","seen","seenObjects","isA","isO","__ob__","depId","dep","protoAugment","copyAugment","observe","ob","Observer","observerState","shouldConvert","_isServer","_isVue","defineReactive$$1","customSetter","getter","childOb","depend","dependArray","newVal","notify","vmCount","del","initState","_watchers","initProps","initData","initComputed","initMethods","initWatch","$options","propsData","_propKeys","isRoot","$parent","loop","validateProp","isSettingProps","proxy","computed","userDef","computedSharedDefinition","makeComputedGetter","owner","Watcher","lazy","dirty","evaluate","watch","createWatcher","$watch","stateMixin","Vue","dataDef","newData","$delete","expOrFn","immediate","teardown","cloneVNode","vnode","cloned","VNode","elm","ns","componentOptions","isStatic","isCloned","cloneVNodes","vnodes","mergeVNodeHook","hookKey","hook","injectedHash","__injected","oldHook","updateListeners","oldOn","remove$$1","cur","old","invoker","arrInvoker","fnInvoker","arguments$1","single","normalizeChildren","nestedIndex","createTextVNode","last","applyNS","getFirstComponentChild","initLifecycle","abstract","$children","$root","$refs","_watcher","_inactive","_isMounted","_isDestroyed","_isBeingDestroyed","lifecycleMixin","_mount","hydrating","$el","render","emptyVNode","template","callHook","_update","_render","$vnode","prevEl","prevActiveInstance","activeInstance","prevVnode","_vnode","__patch__","__vue__","_updateFromParent","parentVnode","renderChildren","hasChildren","_renderChildren","_parentVnode","propKeys","oldListeners","_parentListeners","_updateListeners","$slots","resolveSlots","_renderContext","$forceUpdate","$destroy","$off","handlers","$emit","createComponent","Vue$3","cid","resolved","resolveAsyncComponent","extractProps","functional","createFunctionalComponent","nativeOn","mergeHooks","propOptions","_self","slots","functionalContext","slot","createComponentInstanceForVnode","vnodeComponentOptions","_isComponent","_componentTag","inlineTemplate","staticRenderFns","$mount","prepatch","oldVnode","keepAlive","destroy$1","requested","pendingCallbacks","resolve","reject","then","attrs","domProps","hyphenate","checkProp","hash","preserve","hooksToMerge","fromParent","ours","hooks","mergeHook$1","__","_createElement","getTagNamespace","isReservedTag","resolveAsset","initRender","_staticTrees","$createElement","renderMixin","$nextTick","ref","_renderProxy","formatComponentName","errorHandler","_h","_s","_n","_e","_q","_m","isInFor","_f","_l","fallback","slotNodes","_rendered","_b","asProp","mustUseProp","keyCodes","defaultSlot","isComment","initEvents","$on","eventsMixin","$once","initMixin","initInternalComponent","opts","resolveConstructorOptions","super","superOptions","cachedSuperOptions","mergeOptions","extendOptions","components","_init","_uid","initProxy","mergeData","toVal","fromVal","mergeHook","parentVal","childVal","mergeAssets","normalizeComponents","isBuiltInTag","normalizeProps","camelize","normalizeDirectives","dirs","directives","mergeField","strat","strats","defaultStrat","extendsFrom","extends","mixins","mixin","warnMissing","assets","capitalize","absent","isBooleanType","getPropDefaultValue","prevShouldConvert","assertProp","expectedTypes","assertedType","assertType","expectedType","validator","getType","initUse","use","plugin","installed","install","initMixin$1","initExtend","Super","isFirstExtend","_Ctor","Sub","_assetTypes","initAssetRegisters","initGlobalAPI","configDef","delete","builtInComponents","genClassForVnode","childNode","mergeClassData","genClassFromData","staticClass","class","dynamicClass","stringifyClass","stringified","isSVG","isUnknownElement","inBrowser","unknownElementCache","HTMLUnknownElement","HTMLElement","query","createElement$1","tagName","namespaceMap","createTextNode","createComment","newNode","referenceNode","setTextContent","childNodes","registerRef","isRemoval","refs","refInFor","isUndef","isDef","sameVnode","vnode1","vnode2","createKeyToOldIdx","beginIdx","endIdx","createPatchFunction","backend","emptyNodeAt","nodeOps","createRmCb","childElm","removeElement","createElm","insertedVnodeQueue","nested","isRootInsert","initComponent","ignoredElements","setScope","createChildren","invokeCreateHooks","isPatchable","i$1","emptyNode","pendingInsert","_scopeId","addVnodes","parentElm","startIdx","invokeDestroyHook","removeVnodes","ch","removeAndInvokeRemoveHook","rm","updateChildren","oldCh","newCh","removeOnly","oldKeyToIdx","idxInOld","elmToMove","oldStartIdx","newStartIdx","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","canMove","patchVnode","hasData","postpatch","invokeInsertHook","initial","hydrate","assertNodeMatch","childrenMatch","bailed","hooks$1","isInitialPatch","isRealElement","nodeType","hasAttribute","updateDirectives","oldDir","isCreate","oldDirs","normalizeDirectives$1","newDirs","dirsWithInsert","dirsWithPostpatch","oldValue","callHook$1","componentUpdated","inserted","callInsert","modifiers","emptyModifiers","getRawDirName","rawName","updateAttrs","oldAttrs","setAttr","isXlink","xlinkNS","getXlinkProp","isEnumeratedAttr","isBooleanAttr","isFalsyAttrValue","updateClass","oldData","cls","transitionClass","_transitionClasses","_prevClass","updateDOMListeners","_v_add","_v_remove","updateDOMProps","oldProps","strCur","composing","updateStyle","oldStyle","cssText","needClone","normalize","addClass","removeClass","tar","nextFrame","raf","addTransitionClass","removeTransitionClass","whenTransitionEnds","getTransitionInfo","propCount","TRANSITION","transitionEndEvent","animationEndEvent","onEnd","styles","transitioneDelays","transitionProp","transitionDurations","transitionTimeout","getTimeout","animationDelays","animationProp","animationDurations","animationTimeout","ANIMATION","hasTransform","transformRE","delays","durations","toMs","_leaveCb","cancelled","resolveTransition","_enterCb","css","enterClass","enterActiveClass","appearClass","appearActiveClass","beforeEnter","afterEnter","enterCancelled","beforeAppear","appear","afterAppear","appearCancelled","transitionNode","isAppear","startClass","activeClass","beforeEnterHook","enterHook","afterEnterHook","enterCancelledHook","expectsCSS","isIE9","userWantsControl","show","pendingNode","_pending","leave","performLeave","beforeLeave","leaveClass","leaveActiveClass","afterLeave","leaveCancelled","delayLeave","def$$1","autoCssTransition","called","setSelected","isMultiple","multiple","selected","option","getValue","selectedIndex","hasNoMatchingOption","onCompositionStart","onCompositionEnd","trigger","locateNode","getRealChild","compOptions","extractTransitionData","comp","key$1","placeholder","rawChild","hasParentTransition","callPendingCbs","_moveCb","recordPosition","newPos","applyTranslation","oldPos","WebkitTransform","transitionDuration","shouldDecode","content","encoded","div","decode","decodeAttr","shouldDecodeNewlines","nlRE","ltRE","gtRE","ampRE","quoteRE","parseHTML","advance","parseStartTag","startTagOpen","startTagClose","attribute","unarySlash","handleStartTag","expectHTML","lastTag","isNonPhrasingTag","parseEndTag","canBeLeftOpenTag","unary","isUnaryTag$$1","IS_REGEX_CAPTURING_BROKEN","needle","isUnaryTag","no","isSpecialTag","stackedTag","reStackedTag","reCache","endTagLength","rest","all","endTag","chars","textEnd","commentEnd","conditionalEnd","doctypeMatch","doctype","endTagMatch","curIndex","startTagMatch","parseFilters","pushFilter","filters","lastFilterIndex","prev","expression","inSingle","inDouble","curly","paren","wrapFilter","parseText","delimiters","tagRE","buildRegex","defaultTagRE","tokens","baseWarn","pluckModuleFunction","addProp","addAttr","addDirective","addHandler","important","native","nativeEvents","newHandler","getBindingAttr","getStatic","dynamicValue","getAndRemoveAttr","staticValue","attrsMap","attrsList","warn$1","platformGetTagNamespace","platformMustUseProp","platformIsPreTag","isPreTag","preTransforms","transforms","postTransforms","currentParent","preserveWhitespace","inVPre","inPre","checkRootConstraints","isIE","guardIESVGBug","makeAttrsMap","isForbiddenTag","forbidden","processPre","pre","processRawAttrs","processFor","processIf","processOnce","processKey","plain","processRef","processSlot","processComponent","processAttrs","if","else","elseBlock","processElse","i$2","lastNode","decodeHTMLCached","specialNewlineRE","checkInFor","inMatch","forAliasRE","alias","iteratorMatch","forIteratorRE","iterator1","iterator2","findPrevElement","slotName","slotTarget","component","isProp","dirRE","hasBindings","parseModifiers","modifierRE","bindRE","onRE","argMatch","argRE","checkForAliasModel","ieNSBug","ieNSPrefix","_el","optimize","isStaticKey","genStaticKeysCached","isPlatformReservedTag","markStatic","markStaticRoots","genStaticKeys$1","static","staticRoot","staticInFor","isDirectChildOfTemplateFor","genHandlers","genHandler","modifierCode","genKeyFilter","handlerCode","simplePathRE","normalizeKeyCode","bind$2","wrapData","generate","ast","prevStaticRenderFns","currentStaticRenderFns","currentOptions","warn$2","transforms$1","dataGenFns","platformDirectives$1","genElement","staticProcessed","forProcessed","genFor","ifProcessed","genIf","genSlot","genComponent","genData","genChildren","genElse","genDirectives","genProps","inlineRenderFns","needRuntime","hasRuntime","gen","baseDirectives","genNode","genText","compile$1","detectErrors","checkNode","checkFor","checkExpression","checkIdentifier","ident","identRE","keywordMatch","stripStringRE","prohibitedKeywordRE","transformNode","classBinding","genData$1","transformNode$1","styleBinding","genData$2","model$1","_warn","warn$3","dynamicType","genSelect","genCheckboxModel","genRadioModel","genDefaultModel","valueBinding","trueValueBinding","falseValueBinding","needCompositionGuard","valueExpression","some","checkOptionWarning","compile$$1","baseOptions","compileToFunctions","compiled","makeFunction","getOuterHTML","outerHTML","cloneNode","_Set","camelizeRE","hyphenateRE","optionMergeStrategies","silent","_lifecycleHooks","hasProto","UA","navigator","userAgent","isEdge","isAndroid","isIOS","__VUE_DEVTOOLS_GLOBAL_HOOK__","nextTickHandler","pending","copies","callbacks","timerFunc","Promise","MutationObserver","counter","observer","textNode","characterData","hasProxy","proxyHandlers","allowedGlobals","Proxy","isAllowed","uid$2","subs","addSub","removeSub","addDep","uid$1","deep","deps","newDeps","depIds","newDepIds","cleanupDeps","this$1","_vForRemoving","arrayProto","arrayMethods","original","observeArray","arrayKeys","augment","walk","items","raw","hasConsole","formatLocation","__file","instanceData","defaultData","freeze","defineReactive","KeepAlive","created","destroyed","testEl","math","isHTMLTag","baseModules","klass","upper","prefixed","hasTransition","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","platformModules","patch$1","modelableTagRE","activeElement","vmodel","model","needReset","originalDisplay","__vOriginalDisplay","platformDirectives","transitionProps","Boolean","_leaving","oldRawChild","oldChild","delayedLeave","moveClass","TransitionGroup","prevChildren","rawChildren","transitionData","kept","removed","c$1","beforeUpdate","updated","hasMove","offsetHeight","propertyName","_hasMove","info","platformComponents","singleAttrIdentifier","singleAttrAssign","singleAttrValues","ncname","qnameCapture","regexEscapeRE","esc","tab","up","down","prevent","cloak","klass$1","style$1","modules$1","directives$1","idToTemplate","mount","compile","escapeForXML","XML_CHARACTER_MAP","&","\"","'","<",">","instant","interrupted","indent","addXmlDeclaration","declaration","standalone","?xml","_attr","DEFAULT_INDENT","_elem","icount","create_indent","character","indent_count","get_attributes","attributes","indent_spaces","indents","isStringContent","_cdata","proceed","Element","mediaQuery","alreadyImportedModules","addStylesToDom","domStyle","stylesInDom","addStyle","listToStyles","newStyles","media","sourceMap","part","insertStyleElement","styleElement","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","removeStyleElement","createStyleElement","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","applyToTag","newObj","styleSheet","replaceText","sources","btoa","unescape","encodeURIComponent","memoize","memo","isOldIE","newList","mayRemove","textStore","replacement"],"mappings":"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","file":"static/js/vendor.007b22d751ae62bc81e6.js","sourcesContent":["webpackJsonp([1,0],[\n/* 0 */,\n/* 1 */\n/***/ function(module, exports) {\n\n\tvar core = module.exports = {version: '2.4.0'};\n\tif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\texports.default = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _defineProperty = __webpack_require__(86);\n\t\n\tvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = function () {\n\t  function defineProperties(target, props) {\n\t    for (var i = 0; i < props.length; i++) {\n\t      var descriptor = props[i];\n\t      descriptor.enumerable = descriptor.enumerable || false;\n\t      descriptor.configurable = true;\n\t      if (\"value\" in descriptor) descriptor.writable = true;\n\t      (0, _defineProperty2.default)(target, descriptor.key, descriptor);\n\t    }\n\t  }\n\t\n\t  return function (Constructor, protoProps, staticProps) {\n\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t    return Constructor;\n\t  };\n\t}();\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global    = __webpack_require__(5)\n\t  , core      = __webpack_require__(1)\n\t  , ctx       = __webpack_require__(50)\n\t  , hide      = __webpack_require__(15)\n\t  , PROTOTYPE = 'prototype';\n\t\n\tvar $export = function(type, name, source){\n\t  var IS_FORCED = type & $export.F\n\t    , IS_GLOBAL = type & $export.G\n\t    , IS_STATIC = type & $export.S\n\t    , IS_PROTO  = type & $export.P\n\t    , IS_BIND   = type & $export.B\n\t    , IS_WRAP   = type & $export.W\n\t    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n\t    , expProto  = exports[PROTOTYPE]\n\t    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n\t    , key, own, out;\n\t  if(IS_GLOBAL)source = name;\n\t  for(key in source){\n\t    // contains in native\n\t    own = !IS_FORCED && target && target[key] !== undefined;\n\t    if(own && key in exports)continue;\n\t    // export native or passed\n\t    out = own ? target[key] : source[key];\n\t    // prevent global pollution for namespaces\n\t    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n\t    // bind timers to global for call from export context\n\t    : IS_BIND && own ? ctx(out, global)\n\t    // wrap global constructors for prevent change them in library\n\t    : IS_WRAP && target[key] == out ? (function(C){\n\t      var F = function(a, b, c){\n\t        if(this instanceof C){\n\t          switch(arguments.length){\n\t            case 0: return new C;\n\t            case 1: return new C(a);\n\t            case 2: return new C(a, b);\n\t          } return new C(a, b, c);\n\t        } return C.apply(this, arguments);\n\t      };\n\t      F[PROTOTYPE] = C[PROTOTYPE];\n\t      return F;\n\t    // make static versions for prototype methods\n\t    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n\t    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n\t    if(IS_PROTO){\n\t      (exports.virtual || (exports.virtual = {}))[key] = out;\n\t      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n\t      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n\t    }\n\t  }\n\t};\n\t// type bitmap\n\t$export.F = 1;   // forced\n\t$export.G = 2;   // global\n\t$export.S = 4;   // static\n\t$export.P = 8;   // proto\n\t$export.B = 16;  // bind\n\t$export.W = 32;  // wrap\n\t$export.U = 64;  // safe\n\t$export.R = 128; // real proto method for `library` \n\tmodule.exports = $export;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n\t  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\n\tif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// to indexed object, toObject with fallback for non-array-like ES3 strings\n\tvar IObject = __webpack_require__(53)\n\t  , defined = __webpack_require__(29);\n\tmodule.exports = function(it){\n\t  return IObject(defined(it));\n\t};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar store      = __webpack_require__(36)('wks')\n\t  , uid        = __webpack_require__(26)\n\t  , Symbol     = __webpack_require__(5).Symbol\n\t  , USE_SYMBOL = typeof Symbol == 'function';\n\t\n\tvar $exports = module.exports = function(name){\n\t  return store[name] || (store[name] =\n\t    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n\t};\n\t\n\t$exports.store = store;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Thank's IE8 for his funny defineProperty\n\tmodule.exports = !__webpack_require__(14)(function(){\n\t  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\tmodule.exports = function(it, key){\n\t  return hasOwnProperty.call(it, key);\n\t};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar anObject       = __webpack_require__(13)\n\t  , IE8_DOM_DEFINE = __webpack_require__(52)\n\t  , toPrimitive    = __webpack_require__(38)\n\t  , dP             = Object.defineProperty;\n\t\n\texports.f = __webpack_require__(8) ? Object.defineProperty : function defineProperty(O, P, Attributes){\n\t  anObject(O);\n\t  P = toPrimitive(P, true);\n\t  anObject(Attributes);\n\t  if(IE8_DOM_DEFINE)try {\n\t    return dP(O, P, Attributes);\n\t  } catch(e){ /* empty */ }\n\t  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n\t  if('value' in Attributes)O[P] = Attributes.value;\n\t  return O;\n\t};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.14 / 15.2.3.14 Object.keys(O)\n\tvar $keys       = __webpack_require__(58)\n\t  , enumBugKeys = __webpack_require__(30);\n\t\n\tmodule.exports = Object.keys || function keys(O){\n\t  return $keys(O, enumBugKeys);\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t// a duplex stream is just a stream that is both readable and writable.\n\t// Since JS doesn't have multiple prototypal inheritance, this class\n\t// prototypally inherits from Readable, and then parasitically from\n\t// Writable.\n\t\n\tmodule.exports = Duplex;\n\t\n\t/*<replacement>*/\n\tvar objectKeys = Object.keys || function (obj) {\n\t  var keys = [];\n\t  for (var key in obj) keys.push(key);\n\t  return keys;\n\t}\n\t/*</replacement>*/\n\t\n\t\n\t/*<replacement>*/\n\tvar util = __webpack_require__(20);\n\tutil.inherits = __webpack_require__(16);\n\t/*</replacement>*/\n\t\n\tvar Readable = __webpack_require__(66);\n\tvar Writable = __webpack_require__(42);\n\t\n\tutil.inherits(Duplex, Readable);\n\t\n\tforEach(objectKeys(Writable.prototype), function(method) {\n\t  if (!Duplex.prototype[method])\n\t    Duplex.prototype[method] = Writable.prototype[method];\n\t});\n\t\n\tfunction Duplex(options) {\n\t  if (!(this instanceof Duplex))\n\t    return new Duplex(options);\n\t\n\t  Readable.call(this, options);\n\t  Writable.call(this, options);\n\t\n\t  if (options && options.readable === false)\n\t    this.readable = false;\n\t\n\t  if (options && options.writable === false)\n\t    this.writable = false;\n\t\n\t  this.allowHalfOpen = true;\n\t  if (options && options.allowHalfOpen === false)\n\t    this.allowHalfOpen = false;\n\t\n\t  this.once('end', onend);\n\t}\n\t\n\t// the no-half-open enforcer\n\tfunction onend() {\n\t  // if we allow half-open state, or if the writable side ended,\n\t  // then we're ok.\n\t  if (this.allowHalfOpen || this._writableState.ended)\n\t    return;\n\t\n\t  // no more data can be written.\n\t  // But allow more writes to happen in this tick.\n\t  process.nextTick(this.end.bind(this));\n\t}\n\t\n\tfunction forEach (xs, f) {\n\t  for (var i = 0, l = xs.length; i < l; i++) {\n\t    f(xs[i], i);\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(18);\n\tmodule.exports = function(it){\n\t  if(!isObject(it))throw TypeError(it + ' is not an object!');\n\t  return it;\n\t};\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(exec){\n\t  try {\n\t    return !!exec();\n\t  } catch(e){\n\t    return true;\n\t  }\n\t};\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar dP         = __webpack_require__(10)\n\t  , createDesc = __webpack_require__(24);\n\tmodule.exports = __webpack_require__(8) ? function(object, key, value){\n\t  return dP.f(object, key, createDesc(1, value));\n\t} : function(object, key, value){\n\t  object[key] = value;\n\t  return object;\n\t};\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\tif (typeof Object.create === 'function') {\n\t  // implementation from standard node.js 'util' module\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t      constructor: {\n\t        value: ctor,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t  };\n\t} else {\n\t  // old school shim for old browsers\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    var TempCtor = function () {}\n\t    TempCtor.prototype = superCtor.prototype\n\t    ctor.prototype = new TempCtor()\n\t    ctor.prototype.constructor = ctor\n\t  }\n\t}\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!\n\t * The buffer module from node.js, for the browser.\n\t *\n\t * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n\t * @license  MIT\n\t */\n\t/* eslint-disable no-proto */\n\t\n\t'use strict'\n\t\n\tvar base64 = __webpack_require__(90)\n\tvar ieee754 = __webpack_require__(141)\n\tvar isArray = __webpack_require__(142)\n\t\n\texports.Buffer = Buffer\n\texports.SlowBuffer = SlowBuffer\n\texports.INSPECT_MAX_BYTES = 50\n\t\n\t/**\n\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t *   === true    Use Uint8Array implementation (fastest)\n\t *   === false   Use Object implementation (most compatible, even IE6)\n\t *\n\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t * Opera 11.6+, iOS 4.2+.\n\t *\n\t * Due to various browser bugs, sometimes the Object implementation will be used even\n\t * when the browser supports typed arrays.\n\t *\n\t * Note:\n\t *\n\t *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n\t *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n\t *\n\t *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n\t *\n\t *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n\t *     incorrect length in some situations.\n\t\n\t * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n\t * get the Object implementation, which is slower but behaves correctly.\n\t */\n\tBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n\t  ? global.TYPED_ARRAY_SUPPORT\n\t  : typedArraySupport()\n\t\n\t/*\n\t * Export kMaxLength after typed array support is determined.\n\t */\n\texports.kMaxLength = kMaxLength()\n\t\n\tfunction typedArraySupport () {\n\t  try {\n\t    var arr = new Uint8Array(1)\n\t    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n\t    return arr.foo() === 42 && // typed array instances can be augmented\n\t        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n\t        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n\t  } catch (e) {\n\t    return false\n\t  }\n\t}\n\t\n\tfunction kMaxLength () {\n\t  return Buffer.TYPED_ARRAY_SUPPORT\n\t    ? 0x7fffffff\n\t    : 0x3fffffff\n\t}\n\t\n\tfunction createBuffer (that, length) {\n\t  if (kMaxLength() < length) {\n\t    throw new RangeError('Invalid typed array length')\n\t  }\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = new Uint8Array(length)\n\t    that.__proto__ = Buffer.prototype\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    if (that === null) {\n\t      that = new Buffer(length)\n\t    }\n\t    that.length = length\n\t  }\n\t\n\t  return that\n\t}\n\t\n\t/**\n\t * The Buffer constructor returns instances of `Uint8Array` that have their\n\t * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n\t * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n\t * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n\t * returns a single octet.\n\t *\n\t * The `Uint8Array` prototype remains unmodified.\n\t */\n\t\n\tfunction Buffer (arg, encodingOrOffset, length) {\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n\t    return new Buffer(arg, encodingOrOffset, length)\n\t  }\n\t\n\t  // Common case.\n\t  if (typeof arg === 'number') {\n\t    if (typeof encodingOrOffset === 'string') {\n\t      throw new Error(\n\t        'If encoding is specified then the first argument must be a string'\n\t      )\n\t    }\n\t    return allocUnsafe(this, arg)\n\t  }\n\t  return from(this, arg, encodingOrOffset, length)\n\t}\n\t\n\tBuffer.poolSize = 8192 // not used by this implementation\n\t\n\t// TODO: Legacy, not needed anymore. Remove in next major version.\n\tBuffer._augment = function (arr) {\n\t  arr.__proto__ = Buffer.prototype\n\t  return arr\n\t}\n\t\n\tfunction from (that, value, encodingOrOffset, length) {\n\t  if (typeof value === 'number') {\n\t    throw new TypeError('\"value\" argument must not be a number')\n\t  }\n\t\n\t  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n\t    return fromArrayBuffer(that, value, encodingOrOffset, length)\n\t  }\n\t\n\t  if (typeof value === 'string') {\n\t    return fromString(that, value, encodingOrOffset)\n\t  }\n\t\n\t  return fromObject(that, value)\n\t}\n\t\n\t/**\n\t * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n\t * if value is a number.\n\t * Buffer.from(str[, encoding])\n\t * Buffer.from(array)\n\t * Buffer.from(buffer)\n\t * Buffer.from(arrayBuffer[, byteOffset[, length]])\n\t **/\n\tBuffer.from = function (value, encodingOrOffset, length) {\n\t  return from(null, value, encodingOrOffset, length)\n\t}\n\t\n\tif (Buffer.TYPED_ARRAY_SUPPORT) {\n\t  Buffer.prototype.__proto__ = Uint8Array.prototype\n\t  Buffer.__proto__ = Uint8Array\n\t  if (typeof Symbol !== 'undefined' && Symbol.species &&\n\t      Buffer[Symbol.species] === Buffer) {\n\t    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n\t    Object.defineProperty(Buffer, Symbol.species, {\n\t      value: null,\n\t      configurable: true\n\t    })\n\t  }\n\t}\n\t\n\tfunction assertSize (size) {\n\t  if (typeof size !== 'number') {\n\t    throw new TypeError('\"size\" argument must be a number')\n\t  } else if (size < 0) {\n\t    throw new RangeError('\"size\" argument must not be negative')\n\t  }\n\t}\n\t\n\tfunction alloc (that, size, fill, encoding) {\n\t  assertSize(size)\n\t  if (size <= 0) {\n\t    return createBuffer(that, size)\n\t  }\n\t  if (fill !== undefined) {\n\t    // Only pay attention to encoding if it's a string. This\n\t    // prevents accidentally sending in a number that would\n\t    // be interpretted as a start offset.\n\t    return typeof encoding === 'string'\n\t      ? createBuffer(that, size).fill(fill, encoding)\n\t      : createBuffer(that, size).fill(fill)\n\t  }\n\t  return createBuffer(that, size)\n\t}\n\t\n\t/**\n\t * Creates a new filled Buffer instance.\n\t * alloc(size[, fill[, encoding]])\n\t **/\n\tBuffer.alloc = function (size, fill, encoding) {\n\t  return alloc(null, size, fill, encoding)\n\t}\n\t\n\tfunction allocUnsafe (that, size) {\n\t  assertSize(size)\n\t  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n\t    for (var i = 0; i < size; ++i) {\n\t      that[i] = 0\n\t    }\n\t  }\n\t  return that\n\t}\n\t\n\t/**\n\t * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n\t * */\n\tBuffer.allocUnsafe = function (size) {\n\t  return allocUnsafe(null, size)\n\t}\n\t/**\n\t * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n\t */\n\tBuffer.allocUnsafeSlow = function (size) {\n\t  return allocUnsafe(null, size)\n\t}\n\t\n\tfunction fromString (that, string, encoding) {\n\t  if (typeof encoding !== 'string' || encoding === '') {\n\t    encoding = 'utf8'\n\t  }\n\t\n\t  if (!Buffer.isEncoding(encoding)) {\n\t    throw new TypeError('\"encoding\" must be a valid string encoding')\n\t  }\n\t\n\t  var length = byteLength(string, encoding) | 0\n\t  that = createBuffer(that, length)\n\t\n\t  var actual = that.write(string, encoding)\n\t\n\t  if (actual !== length) {\n\t    // Writing a hex string, for example, that contains invalid characters will\n\t    // cause everything after the first invalid character to be ignored. (e.g.\n\t    // 'abxxcd' will be treated as 'ab')\n\t    that = that.slice(0, actual)\n\t  }\n\t\n\t  return that\n\t}\n\t\n\tfunction fromArrayLike (that, array) {\n\t  var length = array.length < 0 ? 0 : checked(array.length) | 0\n\t  that = createBuffer(that, length)\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromArrayBuffer (that, array, byteOffset, length) {\n\t  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\t\n\t  if (byteOffset < 0 || array.byteLength < byteOffset) {\n\t    throw new RangeError('\\'offset\\' is out of bounds')\n\t  }\n\t\n\t  if (array.byteLength < byteOffset + (length || 0)) {\n\t    throw new RangeError('\\'length\\' is out of bounds')\n\t  }\n\t\n\t  if (byteOffset === undefined && length === undefined) {\n\t    array = new Uint8Array(array)\n\t  } else if (length === undefined) {\n\t    array = new Uint8Array(array, byteOffset)\n\t  } else {\n\t    array = new Uint8Array(array, byteOffset, length)\n\t  }\n\t\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = array\n\t    that.__proto__ = Buffer.prototype\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    that = fromArrayLike(that, array)\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromObject (that, obj) {\n\t  if (Buffer.isBuffer(obj)) {\n\t    var len = checked(obj.length) | 0\n\t    that = createBuffer(that, len)\n\t\n\t    if (that.length === 0) {\n\t      return that\n\t    }\n\t\n\t    obj.copy(that, 0, 0, len)\n\t    return that\n\t  }\n\t\n\t  if (obj) {\n\t    if ((typeof ArrayBuffer !== 'undefined' &&\n\t        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n\t      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n\t        return createBuffer(that, 0)\n\t      }\n\t      return fromArrayLike(that, obj)\n\t    }\n\t\n\t    if (obj.type === 'Buffer' && isArray(obj.data)) {\n\t      return fromArrayLike(that, obj.data)\n\t    }\n\t  }\n\t\n\t  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n\t}\n\t\n\tfunction checked (length) {\n\t  // Note: cannot use `length < kMaxLength()` here because that fails when\n\t  // length is NaN (which is otherwise coerced to zero.)\n\t  if (length >= kMaxLength()) {\n\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n\t  }\n\t  return length | 0\n\t}\n\t\n\tfunction SlowBuffer (length) {\n\t  if (+length != length) { // eslint-disable-line eqeqeq\n\t    length = 0\n\t  }\n\t  return Buffer.alloc(+length)\n\t}\n\t\n\tBuffer.isBuffer = function isBuffer (b) {\n\t  return !!(b != null && b._isBuffer)\n\t}\n\t\n\tBuffer.compare = function compare (a, b) {\n\t  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n\t    throw new TypeError('Arguments must be Buffers')\n\t  }\n\t\n\t  if (a === b) return 0\n\t\n\t  var x = a.length\n\t  var y = b.length\n\t\n\t  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n\t    if (a[i] !== b[i]) {\n\t      x = a[i]\n\t      y = b[i]\n\t      break\n\t    }\n\t  }\n\t\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t}\n\t\n\tBuffer.isEncoding = function isEncoding (encoding) {\n\t  switch (String(encoding).toLowerCase()) {\n\t    case 'hex':\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case 'ascii':\n\t    case 'latin1':\n\t    case 'binary':\n\t    case 'base64':\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return true\n\t    default:\n\t      return false\n\t  }\n\t}\n\t\n\tBuffer.concat = function concat (list, length) {\n\t  if (!isArray(list)) {\n\t    throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t  }\n\t\n\t  if (list.length === 0) {\n\t    return Buffer.alloc(0)\n\t  }\n\t\n\t  var i\n\t  if (length === undefined) {\n\t    length = 0\n\t    for (i = 0; i < list.length; ++i) {\n\t      length += list[i].length\n\t    }\n\t  }\n\t\n\t  var buffer = Buffer.allocUnsafe(length)\n\t  var pos = 0\n\t  for (i = 0; i < list.length; ++i) {\n\t    var buf = list[i]\n\t    if (!Buffer.isBuffer(buf)) {\n\t      throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t    }\n\t    buf.copy(buffer, pos)\n\t    pos += buf.length\n\t  }\n\t  return buffer\n\t}\n\t\n\tfunction byteLength (string, encoding) {\n\t  if (Buffer.isBuffer(string)) {\n\t    return string.length\n\t  }\n\t  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n\t      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n\t    return string.byteLength\n\t  }\n\t  if (typeof string !== 'string') {\n\t    string = '' + string\n\t  }\n\t\n\t  var len = string.length\n\t  if (len === 0) return 0\n\t\n\t  // Use a for loop to avoid recursion\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'ascii':\n\t      case 'latin1':\n\t      case 'binary':\n\t        return len\n\t      case 'utf8':\n\t      case 'utf-8':\n\t      case undefined:\n\t        return utf8ToBytes(string).length\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return len * 2\n\t      case 'hex':\n\t        return len >>> 1\n\t      case 'base64':\n\t        return base64ToBytes(string).length\n\t      default:\n\t        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\tBuffer.byteLength = byteLength\n\t\n\tfunction slowToString (encoding, start, end) {\n\t  var loweredCase = false\n\t\n\t  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n\t  // property of a typed array.\n\t\n\t  // This behaves neither like String nor Uint8Array in that we set start/end\n\t  // to their upper/lower bounds if the value passed is out of range.\n\t  // undefined is handled specially as per ECMA-262 6th Edition,\n\t  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\t  if (start === undefined || start < 0) {\n\t    start = 0\n\t  }\n\t  // Return early if start > this.length. Done here to prevent potential uint32\n\t  // coercion fail below.\n\t  if (start > this.length) {\n\t    return ''\n\t  }\n\t\n\t  if (end === undefined || end > this.length) {\n\t    end = this.length\n\t  }\n\t\n\t  if (end <= 0) {\n\t    return ''\n\t  }\n\t\n\t  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n\t  end >>>= 0\n\t  start >>>= 0\n\t\n\t  if (end <= start) {\n\t    return ''\n\t  }\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t\n\t  while (true) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexSlice(this, start, end)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Slice(this, start, end)\n\t\n\t      case 'ascii':\n\t        return asciiSlice(this, start, end)\n\t\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Slice(this, start, end)\n\t\n\t      case 'base64':\n\t        return base64Slice(this, start, end)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return utf16leSlice(this, start, end)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '').toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\t// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n\t// Buffer instances.\n\tBuffer.prototype._isBuffer = true\n\t\n\tfunction swap (b, n, m) {\n\t  var i = b[n]\n\t  b[n] = b[m]\n\t  b[m] = i\n\t}\n\t\n\tBuffer.prototype.swap16 = function swap16 () {\n\t  var len = this.length\n\t  if (len % 2 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 16-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 2) {\n\t    swap(this, i, i + 1)\n\t  }\n\t  return this\n\t}\n\t\n\tBuffer.prototype.swap32 = function swap32 () {\n\t  var len = this.length\n\t  if (len % 4 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 32-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 4) {\n\t    swap(this, i, i + 3)\n\t    swap(this, i + 1, i + 2)\n\t  }\n\t  return this\n\t}\n\t\n\tBuffer.prototype.swap64 = function swap64 () {\n\t  var len = this.length\n\t  if (len % 8 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 64-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 8) {\n\t    swap(this, i, i + 7)\n\t    swap(this, i + 1, i + 6)\n\t    swap(this, i + 2, i + 5)\n\t    swap(this, i + 3, i + 4)\n\t  }\n\t  return this\n\t}\n\t\n\tBuffer.prototype.toString = function toString () {\n\t  var length = this.length | 0\n\t  if (length === 0) return ''\n\t  if (arguments.length === 0) return utf8Slice(this, 0, length)\n\t  return slowToString.apply(this, arguments)\n\t}\n\t\n\tBuffer.prototype.equals = function equals (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return true\n\t  return Buffer.compare(this, b) === 0\n\t}\n\t\n\tBuffer.prototype.inspect = function inspect () {\n\t  var str = ''\n\t  var max = exports.INSPECT_MAX_BYTES\n\t  if (this.length > 0) {\n\t    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n\t    if (this.length > max) str += ' ... '\n\t  }\n\t  return '<Buffer ' + str + '>'\n\t}\n\t\n\tBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n\t  if (!Buffer.isBuffer(target)) {\n\t    throw new TypeError('Argument must be a Buffer')\n\t  }\n\t\n\t  if (start === undefined) {\n\t    start = 0\n\t  }\n\t  if (end === undefined) {\n\t    end = target ? target.length : 0\n\t  }\n\t  if (thisStart === undefined) {\n\t    thisStart = 0\n\t  }\n\t  if (thisEnd === undefined) {\n\t    thisEnd = this.length\n\t  }\n\t\n\t  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n\t    throw new RangeError('out of range index')\n\t  }\n\t\n\t  if (thisStart >= thisEnd && start >= end) {\n\t    return 0\n\t  }\n\t  if (thisStart >= thisEnd) {\n\t    return -1\n\t  }\n\t  if (start >= end) {\n\t    return 1\n\t  }\n\t\n\t  start >>>= 0\n\t  end >>>= 0\n\t  thisStart >>>= 0\n\t  thisEnd >>>= 0\n\t\n\t  if (this === target) return 0\n\t\n\t  var x = thisEnd - thisStart\n\t  var y = end - start\n\t  var len = Math.min(x, y)\n\t\n\t  var thisCopy = this.slice(thisStart, thisEnd)\n\t  var targetCopy = target.slice(start, end)\n\t\n\t  for (var i = 0; i < len; ++i) {\n\t    if (thisCopy[i] !== targetCopy[i]) {\n\t      x = thisCopy[i]\n\t      y = targetCopy[i]\n\t      break\n\t    }\n\t  }\n\t\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t}\n\t\n\t// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n\t// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n\t//\n\t// Arguments:\n\t// - buffer - a Buffer to search\n\t// - val - a string, Buffer, or number\n\t// - byteOffset - an index into `buffer`; will be clamped to an int32\n\t// - encoding - an optional encoding, relevant is val is a string\n\t// - dir - true for indexOf, false for lastIndexOf\n\tfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n\t  // Empty buffer means no match\n\t  if (buffer.length === 0) return -1\n\t\n\t  // Normalize byteOffset\n\t  if (typeof byteOffset === 'string') {\n\t    encoding = byteOffset\n\t    byteOffset = 0\n\t  } else if (byteOffset > 0x7fffffff) {\n\t    byteOffset = 0x7fffffff\n\t  } else if (byteOffset < -0x80000000) {\n\t    byteOffset = -0x80000000\n\t  }\n\t  byteOffset = +byteOffset  // Coerce to Number.\n\t  if (isNaN(byteOffset)) {\n\t    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n\t    byteOffset = dir ? 0 : (buffer.length - 1)\n\t  }\n\t\n\t  // Normalize byteOffset: negative offsets start from the end of the buffer\n\t  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n\t  if (byteOffset >= buffer.length) {\n\t    if (dir) return -1\n\t    else byteOffset = buffer.length - 1\n\t  } else if (byteOffset < 0) {\n\t    if (dir) byteOffset = 0\n\t    else return -1\n\t  }\n\t\n\t  // Normalize val\n\t  if (typeof val === 'string') {\n\t    val = Buffer.from(val, encoding)\n\t  }\n\t\n\t  // Finally, search either indexOf (if dir is true) or lastIndexOf\n\t  if (Buffer.isBuffer(val)) {\n\t    // Special case: looking for empty string/buffer always fails\n\t    if (val.length === 0) {\n\t      return -1\n\t    }\n\t    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n\t  } else if (typeof val === 'number') {\n\t    val = val & 0xFF // Search for a byte value [0-255]\n\t    if (Buffer.TYPED_ARRAY_SUPPORT &&\n\t        typeof Uint8Array.prototype.indexOf === 'function') {\n\t      if (dir) {\n\t        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n\t      } else {\n\t        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n\t      }\n\t    }\n\t    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n\t  }\n\t\n\t  throw new TypeError('val must be string, number or Buffer')\n\t}\n\t\n\tfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n\t  var indexSize = 1\n\t  var arrLength = arr.length\n\t  var valLength = val.length\n\t\n\t  if (encoding !== undefined) {\n\t    encoding = String(encoding).toLowerCase()\n\t    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n\t        encoding === 'utf16le' || encoding === 'utf-16le') {\n\t      if (arr.length < 2 || val.length < 2) {\n\t        return -1\n\t      }\n\t      indexSize = 2\n\t      arrLength /= 2\n\t      valLength /= 2\n\t      byteOffset /= 2\n\t    }\n\t  }\n\t\n\t  function read (buf, i) {\n\t    if (indexSize === 1) {\n\t      return buf[i]\n\t    } else {\n\t      return buf.readUInt16BE(i * indexSize)\n\t    }\n\t  }\n\t\n\t  var i\n\t  if (dir) {\n\t    var foundIndex = -1\n\t    for (i = byteOffset; i < arrLength; i++) {\n\t      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n\t        if (foundIndex === -1) foundIndex = i\n\t        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n\t      } else {\n\t        if (foundIndex !== -1) i -= i - foundIndex\n\t        foundIndex = -1\n\t      }\n\t    }\n\t  } else {\n\t    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n\t    for (i = byteOffset; i >= 0; i--) {\n\t      var found = true\n\t      for (var j = 0; j < valLength; j++) {\n\t        if (read(arr, i + j) !== read(val, j)) {\n\t          found = false\n\t          break\n\t        }\n\t      }\n\t      if (found) return i\n\t    }\n\t  }\n\t\n\t  return -1\n\t}\n\t\n\tBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n\t  return this.indexOf(val, byteOffset, encoding) !== -1\n\t}\n\t\n\tBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n\t}\n\t\n\tBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n\t}\n\t\n\tfunction hexWrite (buf, string, offset, length) {\n\t  offset = Number(offset) || 0\n\t  var remaining = buf.length - offset\n\t  if (!length) {\n\t    length = remaining\n\t  } else {\n\t    length = Number(length)\n\t    if (length > remaining) {\n\t      length = remaining\n\t    }\n\t  }\n\t\n\t  // must be an even number of digits\n\t  var strLen = string.length\n\t  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\t\n\t  if (length > strLen / 2) {\n\t    length = strLen / 2\n\t  }\n\t  for (var i = 0; i < length; ++i) {\n\t    var parsed = parseInt(string.substr(i * 2, 2), 16)\n\t    if (isNaN(parsed)) return i\n\t    buf[offset + i] = parsed\n\t  }\n\t  return i\n\t}\n\t\n\tfunction utf8Write (buf, string, offset, length) {\n\t  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tfunction asciiWrite (buf, string, offset, length) {\n\t  return blitBuffer(asciiToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction latin1Write (buf, string, offset, length) {\n\t  return asciiWrite(buf, string, offset, length)\n\t}\n\t\n\tfunction base64Write (buf, string, offset, length) {\n\t  return blitBuffer(base64ToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction ucs2Write (buf, string, offset, length) {\n\t  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tBuffer.prototype.write = function write (string, offset, length, encoding) {\n\t  // Buffer#write(string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8'\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, offset[, length][, encoding])\n\t  } else if (isFinite(offset)) {\n\t    offset = offset | 0\n\t    if (isFinite(length)) {\n\t      length = length | 0\n\t      if (encoding === undefined) encoding = 'utf8'\n\t    } else {\n\t      encoding = length\n\t      length = undefined\n\t    }\n\t  // legacy write(string, encoding, offset, length) - remove in v0.13\n\t  } else {\n\t    throw new Error(\n\t      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n\t    )\n\t  }\n\t\n\t  var remaining = this.length - offset\n\t  if (length === undefined || length > remaining) length = remaining\n\t\n\t  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n\t    throw new RangeError('Attempt to write outside buffer bounds')\n\t  }\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexWrite(this, string, offset, length)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Write(this, string, offset, length)\n\t\n\t      case 'ascii':\n\t        return asciiWrite(this, string, offset, length)\n\t\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Write(this, string, offset, length)\n\t\n\t      case 'base64':\n\t        // Warning: maxLength not taken into account in base64Write\n\t        return base64Write(this, string, offset, length)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return ucs2Write(this, string, offset, length)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\tBuffer.prototype.toJSON = function toJSON () {\n\t  return {\n\t    type: 'Buffer',\n\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t  }\n\t}\n\t\n\tfunction base64Slice (buf, start, end) {\n\t  if (start === 0 && end === buf.length) {\n\t    return base64.fromByteArray(buf)\n\t  } else {\n\t    return base64.fromByteArray(buf.slice(start, end))\n\t  }\n\t}\n\t\n\tfunction utf8Slice (buf, start, end) {\n\t  end = Math.min(buf.length, end)\n\t  var res = []\n\t\n\t  var i = start\n\t  while (i < end) {\n\t    var firstByte = buf[i]\n\t    var codePoint = null\n\t    var bytesPerSequence = (firstByte > 0xEF) ? 4\n\t      : (firstByte > 0xDF) ? 3\n\t      : (firstByte > 0xBF) ? 2\n\t      : 1\n\t\n\t    if (i + bytesPerSequence <= end) {\n\t      var secondByte, thirdByte, fourthByte, tempCodePoint\n\t\n\t      switch (bytesPerSequence) {\n\t        case 1:\n\t          if (firstByte < 0x80) {\n\t            codePoint = firstByte\n\t          }\n\t          break\n\t        case 2:\n\t          secondByte = buf[i + 1]\n\t          if ((secondByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n\t            if (tempCodePoint > 0x7F) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 3:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n\t            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 4:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          fourthByte = buf[i + 3]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n\t            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t      }\n\t    }\n\t\n\t    if (codePoint === null) {\n\t      // we did not generate a valid codePoint so insert a\n\t      // replacement char (U+FFFD) and advance only 1 byte\n\t      codePoint = 0xFFFD\n\t      bytesPerSequence = 1\n\t    } else if (codePoint > 0xFFFF) {\n\t      // encode to utf16 (surrogate pair dance)\n\t      codePoint -= 0x10000\n\t      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n\t      codePoint = 0xDC00 | codePoint & 0x3FF\n\t    }\n\t\n\t    res.push(codePoint)\n\t    i += bytesPerSequence\n\t  }\n\t\n\t  return decodeCodePointsArray(res)\n\t}\n\t\n\t// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n\t// the lowest limit is Chrome, with 0x10000 args.\n\t// We go 1 magnitude less, for safety\n\tvar MAX_ARGUMENTS_LENGTH = 0x1000\n\t\n\tfunction decodeCodePointsArray (codePoints) {\n\t  var len = codePoints.length\n\t  if (len <= MAX_ARGUMENTS_LENGTH) {\n\t    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n\t  }\n\t\n\t  // Decode in chunks to avoid \"call stack size exceeded\".\n\t  var res = ''\n\t  var i = 0\n\t  while (i < len) {\n\t    res += String.fromCharCode.apply(\n\t      String,\n\t      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n\t    )\n\t  }\n\t  return res\n\t}\n\t\n\tfunction asciiSlice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i] & 0x7F)\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction latin1Slice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i])\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction hexSlice (buf, start, end) {\n\t  var len = buf.length\n\t\n\t  if (!start || start < 0) start = 0\n\t  if (!end || end < 0 || end > len) end = len\n\t\n\t  var out = ''\n\t  for (var i = start; i < end; ++i) {\n\t    out += toHex(buf[i])\n\t  }\n\t  return out\n\t}\n\t\n\tfunction utf16leSlice (buf, start, end) {\n\t  var bytes = buf.slice(start, end)\n\t  var res = ''\n\t  for (var i = 0; i < bytes.length; i += 2) {\n\t    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n\t  }\n\t  return res\n\t}\n\t\n\tBuffer.prototype.slice = function slice (start, end) {\n\t  var len = this.length\n\t  start = ~~start\n\t  end = end === undefined ? len : ~~end\n\t\n\t  if (start < 0) {\n\t    start += len\n\t    if (start < 0) start = 0\n\t  } else if (start > len) {\n\t    start = len\n\t  }\n\t\n\t  if (end < 0) {\n\t    end += len\n\t    if (end < 0) end = 0\n\t  } else if (end > len) {\n\t    end = len\n\t  }\n\t\n\t  if (end < start) end = start\n\t\n\t  var newBuf\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    newBuf = this.subarray(start, end)\n\t    newBuf.__proto__ = Buffer.prototype\n\t  } else {\n\t    var sliceLen = end - start\n\t    newBuf = new Buffer(sliceLen, undefined)\n\t    for (var i = 0; i < sliceLen; ++i) {\n\t      newBuf[i] = this[i + start]\n\t    }\n\t  }\n\t\n\t  return newBuf\n\t}\n\t\n\t/*\n\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t */\n\tfunction checkOffset (offset, ext, length) {\n\t  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n\t  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n\t}\n\t\n\tBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    checkOffset(offset, byteLength, this.length)\n\t  }\n\t\n\t  var val = this[offset + --byteLength]\n\t  var mul = 1\n\t  while (byteLength > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --byteLength] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  return this[offset]\n\t}\n\t\n\tBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return this[offset] | (this[offset + 1] << 8)\n\t}\n\t\n\tBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return (this[offset] << 8) | this[offset + 1]\n\t}\n\t\n\tBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return ((this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16)) +\n\t      (this[offset + 3] * 0x1000000)\n\t}\n\t\n\tBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] * 0x1000000) +\n\t    ((this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var i = byteLength\n\t  var mul = 1\n\t  var val = this[offset + --i]\n\t  while (i > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  if (!(this[offset] & 0x80)) return (this[offset])\n\t  return ((0xff - this[offset] + 1) * -1)\n\t}\n\t\n\tBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset] | (this[offset + 1] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset + 1] | (this[offset] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset]) |\n\t    (this[offset + 1] << 8) |\n\t    (this[offset + 2] << 16) |\n\t    (this[offset + 3] << 24)\n\t}\n\t\n\tBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] << 24) |\n\t    (this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    (this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, true, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, false, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, true, 52, 8)\n\t}\n\t\n\tBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, false, 52, 8)\n\t}\n\t\n\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n\t  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t}\n\t\n\tBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0)\n\t  }\n\t\n\t  var mul = 1\n\t  var i = 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0)\n\t  }\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n\t    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n\t      (littleEndian ? i : 1 - i) * 8\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n\t    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset + 3] = (value >>> 24)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = 0\n\t  var mul = 1\n\t  var sub = 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n\t      sub = 1\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  var sub = 0\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n\t      sub = 1\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  if (value < 0) value = 0xff + value + 1\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 3] = (value >>> 24)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t  if (offset < 0) throw new RangeError('Index out of range')\n\t}\n\t\n\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, false, noAssert)\n\t}\n\t\n\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n\t  return offset + 8\n\t}\n\t\n\tBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, false, noAssert)\n\t}\n\t\n\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\tBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n\t  if (!start) start = 0\n\t  if (!end && end !== 0) end = this.length\n\t  if (targetStart >= target.length) targetStart = target.length\n\t  if (!targetStart) targetStart = 0\n\t  if (end > 0 && end < start) end = start\n\t\n\t  // Copy 0 bytes; we're done\n\t  if (end === start) return 0\n\t  if (target.length === 0 || this.length === 0) return 0\n\t\n\t  // Fatal error conditions\n\t  if (targetStart < 0) {\n\t    throw new RangeError('targetStart out of bounds')\n\t  }\n\t  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n\t  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\t\n\t  // Are we oob?\n\t  if (end > this.length) end = this.length\n\t  if (target.length - targetStart < end - start) {\n\t    end = target.length - targetStart + start\n\t  }\n\t\n\t  var len = end - start\n\t  var i\n\t\n\t  if (this === target && start < targetStart && targetStart < end) {\n\t    // descending copy from end\n\t    for (i = len - 1; i >= 0; --i) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // ascending copy from start\n\t    for (i = 0; i < len; ++i) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else {\n\t    Uint8Array.prototype.set.call(\n\t      target,\n\t      this.subarray(start, start + len),\n\t      targetStart\n\t    )\n\t  }\n\t\n\t  return len\n\t}\n\t\n\t// Usage:\n\t//    buffer.fill(number[, offset[, end]])\n\t//    buffer.fill(buffer[, offset[, end]])\n\t//    buffer.fill(string[, offset[, end]][, encoding])\n\tBuffer.prototype.fill = function fill (val, start, end, encoding) {\n\t  // Handle string cases:\n\t  if (typeof val === 'string') {\n\t    if (typeof start === 'string') {\n\t      encoding = start\n\t      start = 0\n\t      end = this.length\n\t    } else if (typeof end === 'string') {\n\t      encoding = end\n\t      end = this.length\n\t    }\n\t    if (val.length === 1) {\n\t      var code = val.charCodeAt(0)\n\t      if (code < 256) {\n\t        val = code\n\t      }\n\t    }\n\t    if (encoding !== undefined && typeof encoding !== 'string') {\n\t      throw new TypeError('encoding must be a string')\n\t    }\n\t    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n\t      throw new TypeError('Unknown encoding: ' + encoding)\n\t    }\n\t  } else if (typeof val === 'number') {\n\t    val = val & 255\n\t  }\n\t\n\t  // Invalid ranges are not set to a default, so can range check early.\n\t  if (start < 0 || this.length < start || this.length < end) {\n\t    throw new RangeError('Out of range index')\n\t  }\n\t\n\t  if (end <= start) {\n\t    return this\n\t  }\n\t\n\t  start = start >>> 0\n\t  end = end === undefined ? this.length : end >>> 0\n\t\n\t  if (!val) val = 0\n\t\n\t  var i\n\t  if (typeof val === 'number') {\n\t    for (i = start; i < end; ++i) {\n\t      this[i] = val\n\t    }\n\t  } else {\n\t    var bytes = Buffer.isBuffer(val)\n\t      ? val\n\t      : utf8ToBytes(new Buffer(val, encoding).toString())\n\t    var len = bytes.length\n\t    for (i = 0; i < end - start; ++i) {\n\t      this[i + start] = bytes[i % len]\n\t    }\n\t  }\n\t\n\t  return this\n\t}\n\t\n\t// HELPER FUNCTIONS\n\t// ================\n\t\n\tvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\t\n\tfunction base64clean (str) {\n\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n\t  // Node converts strings with length < 2 to ''\n\t  if (str.length < 2) return ''\n\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t  while (str.length % 4 !== 0) {\n\t    str = str + '='\n\t  }\n\t  return str\n\t}\n\t\n\tfunction stringtrim (str) {\n\t  if (str.trim) return str.trim()\n\t  return str.replace(/^\\s+|\\s+$/g, '')\n\t}\n\t\n\tfunction toHex (n) {\n\t  if (n < 16) return '0' + n.toString(16)\n\t  return n.toString(16)\n\t}\n\t\n\tfunction utf8ToBytes (string, units) {\n\t  units = units || Infinity\n\t  var codePoint\n\t  var length = string.length\n\t  var leadSurrogate = null\n\t  var bytes = []\n\t\n\t  for (var i = 0; i < length; ++i) {\n\t    codePoint = string.charCodeAt(i)\n\t\n\t    // is surrogate component\n\t    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n\t      // last char was a lead\n\t      if (!leadSurrogate) {\n\t        // no lead yet\n\t        if (codePoint > 0xDBFF) {\n\t          // unexpected trail\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        } else if (i + 1 === length) {\n\t          // unpaired lead\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        }\n\t\n\t        // valid lead\n\t        leadSurrogate = codePoint\n\t\n\t        continue\n\t      }\n\t\n\t      // 2 leads in a row\n\t      if (codePoint < 0xDC00) {\n\t        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t        leadSurrogate = codePoint\n\t        continue\n\t      }\n\t\n\t      // valid surrogate pair\n\t      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n\t    } else if (leadSurrogate) {\n\t      // valid bmp char, but last char was a lead\n\t      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t    }\n\t\n\t    leadSurrogate = null\n\t\n\t    // encode utf8\n\t    if (codePoint < 0x80) {\n\t      if ((units -= 1) < 0) break\n\t      bytes.push(codePoint)\n\t    } else if (codePoint < 0x800) {\n\t      if ((units -= 2) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x6 | 0xC0,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x10000) {\n\t      if ((units -= 3) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0xC | 0xE0,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x110000) {\n\t      if ((units -= 4) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x12 | 0xF0,\n\t        codePoint >> 0xC & 0x3F | 0x80,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else {\n\t      throw new Error('Invalid code point')\n\t    }\n\t  }\n\t\n\t  return bytes\n\t}\n\t\n\tfunction asciiToBytes (str) {\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; ++i) {\n\t    // Node's code seems to be doing this and not & 0x7F..\n\t    byteArray.push(str.charCodeAt(i) & 0xFF)\n\t  }\n\t  return byteArray\n\t}\n\t\n\tfunction utf16leToBytes (str, units) {\n\t  var c, hi, lo\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; ++i) {\n\t    if ((units -= 2) < 0) break\n\t\n\t    c = str.charCodeAt(i)\n\t    hi = c >> 8\n\t    lo = c % 256\n\t    byteArray.push(lo)\n\t    byteArray.push(hi)\n\t  }\n\t\n\t  return byteArray\n\t}\n\t\n\tfunction base64ToBytes (str) {\n\t  return base64.toByteArray(base64clean(str))\n\t}\n\t\n\tfunction blitBuffer (src, dst, offset, length) {\n\t  for (var i = 0; i < length; ++i) {\n\t    if ((i + offset >= dst.length) || (i >= src.length)) break\n\t    dst[i + offset] = src[i]\n\t  }\n\t  return i\n\t}\n\t\n\tfunction isnan (val) {\n\t  return val !== val // eslint-disable-line no-self-compare\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(17).Buffer, (function() { return this; }())))\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\texports.f = {}.propertyIsEnumerable;\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t// NOTE: These type checking functions intentionally don't use `instanceof`\n\t// because it is fragile and can be easily faked with `Object.create()`.\n\t\n\tfunction isArray(arg) {\n\t  if (Array.isArray) {\n\t    return Array.isArray(arg);\n\t  }\n\t  return objectToString(arg) === '[object Array]';\n\t}\n\texports.isArray = isArray;\n\t\n\tfunction isBoolean(arg) {\n\t  return typeof arg === 'boolean';\n\t}\n\texports.isBoolean = isBoolean;\n\t\n\tfunction isNull(arg) {\n\t  return arg === null;\n\t}\n\texports.isNull = isNull;\n\t\n\tfunction isNullOrUndefined(arg) {\n\t  return arg == null;\n\t}\n\texports.isNullOrUndefined = isNullOrUndefined;\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\texports.isNumber = isNumber;\n\t\n\tfunction isString(arg) {\n\t  return typeof arg === 'string';\n\t}\n\texports.isString = isString;\n\t\n\tfunction isSymbol(arg) {\n\t  return typeof arg === 'symbol';\n\t}\n\texports.isSymbol = isSymbol;\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\texports.isUndefined = isUndefined;\n\t\n\tfunction isRegExp(re) {\n\t  return objectToString(re) === '[object RegExp]';\n\t}\n\texports.isRegExp = isRegExp;\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\texports.isObject = isObject;\n\t\n\tfunction isDate(d) {\n\t  return objectToString(d) === '[object Date]';\n\t}\n\texports.isDate = isDate;\n\t\n\tfunction isError(e) {\n\t  return (objectToString(e) === '[object Error]' || e instanceof Error);\n\t}\n\texports.isError = isError;\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\texports.isFunction = isFunction;\n\t\n\tfunction isPrimitive(arg) {\n\t  return arg === null ||\n\t         typeof arg === 'boolean' ||\n\t         typeof arg === 'number' ||\n\t         typeof arg === 'string' ||\n\t         typeof arg === 'symbol' ||  // ES6 symbol\n\t         typeof arg === 'undefined';\n\t}\n\texports.isPrimitive = isPrimitive;\n\t\n\texports.isBuffer = Buffer.isBuffer;\n\t\n\tfunction objectToString(o) {\n\t  return Object.prototype.toString.call(o);\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(17).Buffer))\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tmodule.exports = Stream;\n\t\n\tvar EE = __webpack_require__(64).EventEmitter;\n\tvar inherits = __webpack_require__(16);\n\t\n\tinherits(Stream, EE);\n\tStream.Readable = __webpack_require__(146);\n\tStream.Writable = __webpack_require__(148);\n\tStream.Duplex = __webpack_require__(144);\n\tStream.Transform = __webpack_require__(147);\n\tStream.PassThrough = __webpack_require__(145);\n\t\n\t// Backwards-compat with node 0.4.x\n\tStream.Stream = Stream;\n\t\n\t\n\t\n\t// old-style streams.  Note that the pipe method (the only relevant\n\t// part of this class) is overridden in the Readable class.\n\t\n\tfunction Stream() {\n\t  EE.call(this);\n\t}\n\t\n\tStream.prototype.pipe = function(dest, options) {\n\t  var source = this;\n\t\n\t  function ondata(chunk) {\n\t    if (dest.writable) {\n\t      if (false === dest.write(chunk) && source.pause) {\n\t        source.pause();\n\t      }\n\t    }\n\t  }\n\t\n\t  source.on('data', ondata);\n\t\n\t  function ondrain() {\n\t    if (source.readable && source.resume) {\n\t      source.resume();\n\t    }\n\t  }\n\t\n\t  dest.on('drain', ondrain);\n\t\n\t  // If the 'end' option is not supplied, dest.end() will be called when\n\t  // source gets the 'end' or 'close' events.  Only dest.end() once.\n\t  if (!dest._isStdio && (!options || options.end !== false)) {\n\t    source.on('end', onend);\n\t    source.on('close', onclose);\n\t  }\n\t\n\t  var didOnEnd = false;\n\t  function onend() {\n\t    if (didOnEnd) return;\n\t    didOnEnd = true;\n\t\n\t    dest.end();\n\t  }\n\t\n\t\n\t  function onclose() {\n\t    if (didOnEnd) return;\n\t    didOnEnd = true;\n\t\n\t    if (typeof dest.destroy === 'function') dest.destroy();\n\t  }\n\t\n\t  // don't leave dangling pipes when there are errors.\n\t  function onerror(er) {\n\t    cleanup();\n\t    if (EE.listenerCount(this, 'error') === 0) {\n\t      throw er; // Unhandled stream error in pipe.\n\t    }\n\t  }\n\t\n\t  source.on('error', onerror);\n\t  dest.on('error', onerror);\n\t\n\t  // remove all the event listeners that were added.\n\t  function cleanup() {\n\t    source.removeListener('data', ondata);\n\t    dest.removeListener('drain', ondrain);\n\t\n\t    source.removeListener('end', onend);\n\t    source.removeListener('close', onclose);\n\t\n\t    source.removeListener('error', onerror);\n\t    dest.removeListener('error', onerror);\n\t\n\t    source.removeListener('end', cleanup);\n\t    source.removeListener('close', cleanup);\n\t\n\t    dest.removeListener('close', cleanup);\n\t  }\n\t\n\t  source.on('end', cleanup);\n\t  source.on('close', cleanup);\n\t\n\t  dest.on('close', cleanup);\n\t\n\t  dest.emit('pipe', source);\n\t\n\t  // Allow for unix-like usage: A.pipe(B).pipe(C)\n\t  return dest;\n\t};\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {};\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(bitmap, value){\n\t  return {\n\t    enumerable  : !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable    : !(bitmap & 4),\n\t    value       : value\n\t  };\n\t};\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.13 ToObject(argument)\n\tvar defined = __webpack_require__(29);\n\tmodule.exports = function(it){\n\t  return Object(defined(it));\n\t};\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\n\tvar id = 0\n\t  , px = Math.random();\n\tmodule.exports = function(key){\n\t  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n\t};\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(91), __esModule: true };\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = function(it){\n\t  return toString.call(it).slice(8, -1);\n\t};\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\t// 7.2.1 RequireObjectCoercible(argument)\n\tmodule.exports = function(it){\n\t  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n\t  return it;\n\t};\n\n/***/ },\n/* 30 */\n/***/ function(module, exports) {\n\n\t// IE 8- don't enum bug keys\n\tmodule.exports = (\n\t  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n\t).split(',');\n\n/***/ },\n/* 31 */\n/***/ function(module, exports) {\n\n\tmodule.exports = true;\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n\tvar anObject    = __webpack_require__(13)\n\t  , dPs         = __webpack_require__(114)\n\t  , enumBugKeys = __webpack_require__(30)\n\t  , IE_PROTO    = __webpack_require__(35)('IE_PROTO')\n\t  , Empty       = function(){ /* empty */ }\n\t  , PROTOTYPE   = 'prototype';\n\t\n\t// Create object with fake `null` prototype: use iframe Object with cleared prototype\n\tvar createDict = function(){\n\t  // Thrash, waste and sodomy: IE GC bug\n\t  var iframe = __webpack_require__(51)('iframe')\n\t    , i      = enumBugKeys.length\n\t    , lt     = '<'\n\t    , gt     = '>'\n\t    , iframeDocument;\n\t  iframe.style.display = 'none';\n\t  __webpack_require__(107).appendChild(iframe);\n\t  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n\t  // createDict = iframe.contentWindow.Object;\n\t  // html.removeChild(iframe);\n\t  iframeDocument = iframe.contentWindow.document;\n\t  iframeDocument.open();\n\t  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n\t  iframeDocument.close();\n\t  createDict = iframeDocument.F;\n\t  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\n\t  return createDict();\n\t};\n\t\n\tmodule.exports = Object.create || function create(O, Properties){\n\t  var result;\n\t  if(O !== null){\n\t    Empty[PROTOTYPE] = anObject(O);\n\t    result = new Empty;\n\t    Empty[PROTOTYPE] = null;\n\t    // add \"__proto__\" for Object.getPrototypeOf polyfill\n\t    result[IE_PROTO] = O;\n\t  } else result = createDict();\n\t  return Properties === undefined ? result : dPs(result, Properties);\n\t};\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n\texports.f = Object.getOwnPropertySymbols;\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar def = __webpack_require__(10).f\n\t  , has = __webpack_require__(9)\n\t  , TAG = __webpack_require__(7)('toStringTag');\n\t\n\tmodule.exports = function(it, tag, stat){\n\t  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n\t};\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar shared = __webpack_require__(36)('keys')\n\t  , uid    = __webpack_require__(26);\n\tmodule.exports = function(key){\n\t  return shared[key] || (shared[key] = uid(key));\n\t};\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global = __webpack_require__(5)\n\t  , SHARED = '__core-js_shared__'\n\t  , store  = global[SHARED] || (global[SHARED] = {});\n\tmodule.exports = function(key){\n\t  return store[key] || (store[key] = {});\n\t};\n\n/***/ },\n/* 37 */\n/***/ function(module, exports) {\n\n\t// 7.1.4 ToInteger\n\tvar ceil  = Math.ceil\n\t  , floor = Math.floor;\n\tmodule.exports = function(it){\n\t  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n\t};\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.1 ToPrimitive(input [, PreferredType])\n\tvar isObject = __webpack_require__(18);\n\t// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n\t// and the second argument - flag - preferred type is a string\n\tmodule.exports = function(it, S){\n\t  if(!isObject(it))return it;\n\t  var fn, val;\n\t  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  throw TypeError(\"Can't convert object to primitive value\");\n\t};\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global         = __webpack_require__(5)\n\t  , core           = __webpack_require__(1)\n\t  , LIBRARY        = __webpack_require__(31)\n\t  , wksExt         = __webpack_require__(40)\n\t  , defineProperty = __webpack_require__(10).f;\n\tmodule.exports = function(name){\n\t  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n\t  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});\n\t};\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports.f = __webpack_require__(7);\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t\n\t// a transform stream is a readable/writable stream where you do\n\t// something with the data.  Sometimes it's called a \"filter\",\n\t// but that's not a great name for it, since that implies a thing where\n\t// some bits pass through, and others are simply ignored.  (That would\n\t// be a valid example of a transform, of course.)\n\t//\n\t// While the output is causally related to the input, it's not a\n\t// necessarily symmetric or synchronous transformation.  For example,\n\t// a zlib stream might take multiple plain-text writes(), and then\n\t// emit a single compressed chunk some time in the future.\n\t//\n\t// Here's how this works:\n\t//\n\t// The Transform stream has all the aspects of the readable and writable\n\t// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n\t// internally, and returns false if there's a lot of pending writes\n\t// buffered up.  When you call read(), that calls _read(n) until\n\t// there's enough pending readable data buffered up.\n\t//\n\t// In a transform stream, the written data is placed in a buffer.  When\n\t// _read(n) is called, it transforms the queued up data, calling the\n\t// buffered _write cb's as it consumes chunks.  If consuming a single\n\t// written chunk would result in multiple output chunks, then the first\n\t// outputted bit calls the readcb, and subsequent chunks just go into\n\t// the read buffer, and will cause it to emit 'readable' if necessary.\n\t//\n\t// This way, back-pressure is actually determined by the reading side,\n\t// since _read has to be called to start processing a new chunk.  However,\n\t// a pathological inflate type of transform can cause excessive buffering\n\t// here.  For example, imagine a stream where every byte of input is\n\t// interpreted as an integer from 0-255, and then results in that many\n\t// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n\t// 1kb of data being output.  In this case, you could write a very small\n\t// amount of input, and end up with a very large amount of output.  In\n\t// such a pathological inflating mechanism, there'd be no way to tell\n\t// the system to stop doing the transform.  A single 4MB write could\n\t// cause the system to run out of memory.\n\t//\n\t// However, even in such a pathological case, only a single written chunk\n\t// would be consumed, and then the rest would wait (un-transformed) until\n\t// the results of the previous transformed chunk were consumed.\n\t\n\tmodule.exports = Transform;\n\t\n\tvar Duplex = __webpack_require__(12);\n\t\n\t/*<replacement>*/\n\tvar util = __webpack_require__(20);\n\tutil.inherits = __webpack_require__(16);\n\t/*</replacement>*/\n\t\n\tutil.inherits(Transform, Duplex);\n\t\n\t\n\tfunction TransformState(options, stream) {\n\t  this.afterTransform = function(er, data) {\n\t    return afterTransform(stream, er, data);\n\t  };\n\t\n\t  this.needTransform = false;\n\t  this.transforming = false;\n\t  this.writecb = null;\n\t  this.writechunk = null;\n\t}\n\t\n\tfunction afterTransform(stream, er, data) {\n\t  var ts = stream._transformState;\n\t  ts.transforming = false;\n\t\n\t  var cb = ts.writecb;\n\t\n\t  if (!cb)\n\t    return stream.emit('error', new Error('no writecb in Transform class'));\n\t\n\t  ts.writechunk = null;\n\t  ts.writecb = null;\n\t\n\t  if (!util.isNullOrUndefined(data))\n\t    stream.push(data);\n\t\n\t  if (cb)\n\t    cb(er);\n\t\n\t  var rs = stream._readableState;\n\t  rs.reading = false;\n\t  if (rs.needReadable || rs.length < rs.highWaterMark) {\n\t    stream._read(rs.highWaterMark);\n\t  }\n\t}\n\t\n\t\n\tfunction Transform(options) {\n\t  if (!(this instanceof Transform))\n\t    return new Transform(options);\n\t\n\t  Duplex.call(this, options);\n\t\n\t  this._transformState = new TransformState(options, this);\n\t\n\t  // when the writable side finishes, then flush out anything remaining.\n\t  var stream = this;\n\t\n\t  // start out asking for a readable event once data is transformed.\n\t  this._readableState.needReadable = true;\n\t\n\t  // we have implemented the _read method, and done the other things\n\t  // that Readable wants before the first _read call, so unset the\n\t  // sync guard flag.\n\t  this._readableState.sync = false;\n\t\n\t  this.once('prefinish', function() {\n\t    if (util.isFunction(this._flush))\n\t      this._flush(function(er) {\n\t        done(stream, er);\n\t      });\n\t    else\n\t      done(stream);\n\t  });\n\t}\n\t\n\tTransform.prototype.push = function(chunk, encoding) {\n\t  this._transformState.needTransform = false;\n\t  return Duplex.prototype.push.call(this, chunk, encoding);\n\t};\n\t\n\t// This is the part where you do stuff!\n\t// override this function in implementation classes.\n\t// 'chunk' is an input chunk.\n\t//\n\t// Call `push(newChunk)` to pass along transformed output\n\t// to the readable side.  You may call 'push' zero or more times.\n\t//\n\t// Call `cb(err)` when you are done with this chunk.  If you pass\n\t// an error, then that'll put the hurt on the whole operation.  If you\n\t// never call cb(), then you'll never get another chunk.\n\tTransform.prototype._transform = function(chunk, encoding, cb) {\n\t  throw new Error('not implemented');\n\t};\n\t\n\tTransform.prototype._write = function(chunk, encoding, cb) {\n\t  var ts = this._transformState;\n\t  ts.writecb = cb;\n\t  ts.writechunk = chunk;\n\t  ts.writeencoding = encoding;\n\t  if (!ts.transforming) {\n\t    var rs = this._readableState;\n\t    if (ts.needTransform ||\n\t        rs.needReadable ||\n\t        rs.length < rs.highWaterMark)\n\t      this._read(rs.highWaterMark);\n\t  }\n\t};\n\t\n\t// Doesn't matter what the args are here.\n\t// _transform does all the work.\n\t// That we got here means that the readable side wants more data.\n\tTransform.prototype._read = function(n) {\n\t  var ts = this._transformState;\n\t\n\t  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {\n\t    ts.transforming = true;\n\t    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n\t  } else {\n\t    // mark that we need a transform, so that any data that comes in\n\t    // will get processed, now that we've asked for it.\n\t    ts.needTransform = true;\n\t  }\n\t};\n\t\n\t\n\tfunction done(stream, er) {\n\t  if (er)\n\t    return stream.emit('error', er);\n\t\n\t  // if there's nothing in the write buffer, then that means\n\t  // that nothing more will ever be provided\n\t  var ws = stream._writableState;\n\t  var ts = stream._transformState;\n\t\n\t  if (ws.length)\n\t    throw new Error('calling transform done when ws.length != 0');\n\t\n\t  if (ts.transforming)\n\t    throw new Error('calling transform done when still transforming');\n\t\n\t  return stream.push(null);\n\t}\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t// A bit simpler than readable streams.\n\t// Implement an async ._write(chunk, cb), and it'll handle all\n\t// the drain event emission and buffering.\n\t\n\tmodule.exports = Writable;\n\t\n\t/*<replacement>*/\n\tvar Buffer = __webpack_require__(17).Buffer;\n\t/*</replacement>*/\n\t\n\tWritable.WritableState = WritableState;\n\t\n\t\n\t/*<replacement>*/\n\tvar util = __webpack_require__(20);\n\tutil.inherits = __webpack_require__(16);\n\t/*</replacement>*/\n\t\n\tvar Stream = __webpack_require__(22);\n\t\n\tutil.inherits(Writable, Stream);\n\t\n\tfunction WriteReq(chunk, encoding, cb) {\n\t  this.chunk = chunk;\n\t  this.encoding = encoding;\n\t  this.callback = cb;\n\t}\n\t\n\tfunction WritableState(options, stream) {\n\t  var Duplex = __webpack_require__(12);\n\t\n\t  options = options || {};\n\t\n\t  // the point at which write() starts returning false\n\t  // Note: 0 is a valid value, means that we always return false if\n\t  // the entire buffer is not flushed immediately on write()\n\t  var hwm = options.highWaterMark;\n\t  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n\t  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\t\n\t  // object stream flag to indicate whether or not this stream\n\t  // contains buffers or objects.\n\t  this.objectMode = !!options.objectMode;\n\t\n\t  if (stream instanceof Duplex)\n\t    this.objectMode = this.objectMode || !!options.writableObjectMode;\n\t\n\t  // cast to ints.\n\t  this.highWaterMark = ~~this.highWaterMark;\n\t\n\t  this.needDrain = false;\n\t  // at the start of calling end()\n\t  this.ending = false;\n\t  // when end() has been called, and returned\n\t  this.ended = false;\n\t  // when 'finish' is emitted\n\t  this.finished = false;\n\t\n\t  // should we decode strings into buffers before passing to _write?\n\t  // this is here so that some node-core streams can optimize string\n\t  // handling at a lower level.\n\t  var noDecode = options.decodeStrings === false;\n\t  this.decodeStrings = !noDecode;\n\t\n\t  // Crypto is kind of old and crusty.  Historically, its default string\n\t  // encoding is 'binary' so we have to make this configurable.\n\t  // Everything else in the universe uses 'utf8', though.\n\t  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\t\n\t  // not an actual buffer we keep track of, but a measurement\n\t  // of how much we're waiting to get pushed to some underlying\n\t  // socket or file.\n\t  this.length = 0;\n\t\n\t  // a flag to see when we're in the middle of a write.\n\t  this.writing = false;\n\t\n\t  // when true all writes will be buffered until .uncork() call\n\t  this.corked = 0;\n\t\n\t  // a flag to be able to tell if the onwrite cb is called immediately,\n\t  // or on a later tick.  We set this to true at first, because any\n\t  // actions that shouldn't happen until \"later\" should generally also\n\t  // not happen before the first write call.\n\t  this.sync = true;\n\t\n\t  // a flag to know if we're processing previously buffered items, which\n\t  // may call the _write() callback in the same tick, so that we don't\n\t  // end up in an overlapped onwrite situation.\n\t  this.bufferProcessing = false;\n\t\n\t  // the callback that's passed to _write(chunk,cb)\n\t  this.onwrite = function(er) {\n\t    onwrite(stream, er);\n\t  };\n\t\n\t  // the callback that the user supplies to write(chunk,encoding,cb)\n\t  this.writecb = null;\n\t\n\t  // the amount that is being written when _write is called.\n\t  this.writelen = 0;\n\t\n\t  this.buffer = [];\n\t\n\t  // number of pending user-supplied write callbacks\n\t  // this must be 0 before 'finish' can be emitted\n\t  this.pendingcb = 0;\n\t\n\t  // emit prefinish if the only thing we're waiting for is _write cbs\n\t  // This is relevant for synchronous Transform streams\n\t  this.prefinished = false;\n\t\n\t  // True if the error was already emitted and should not be thrown again\n\t  this.errorEmitted = false;\n\t}\n\t\n\tfunction Writable(options) {\n\t  var Duplex = __webpack_require__(12);\n\t\n\t  // Writable ctor is applied to Duplexes, though they're not\n\t  // instanceof Writable, they're instanceof Readable.\n\t  if (!(this instanceof Writable) && !(this instanceof Duplex))\n\t    return new Writable(options);\n\t\n\t  this._writableState = new WritableState(options, this);\n\t\n\t  // legacy.\n\t  this.writable = true;\n\t\n\t  Stream.call(this);\n\t}\n\t\n\t// Otherwise people can pipe Writable streams, which is just wrong.\n\tWritable.prototype.pipe = function() {\n\t  this.emit('error', new Error('Cannot pipe. Not readable.'));\n\t};\n\t\n\t\n\tfunction writeAfterEnd(stream, state, cb) {\n\t  var er = new Error('write after end');\n\t  // TODO: defer error events consistently everywhere, not just the cb\n\t  stream.emit('error', er);\n\t  process.nextTick(function() {\n\t    cb(er);\n\t  });\n\t}\n\t\n\t// If we get something that is not a buffer, string, null, or undefined,\n\t// and we're not in objectMode, then that's an error.\n\t// Otherwise stream chunks are all considered to be of length=1, and the\n\t// watermarks determine how many objects to keep in the buffer, rather than\n\t// how many bytes or characters.\n\tfunction validChunk(stream, state, chunk, cb) {\n\t  var valid = true;\n\t  if (!util.isBuffer(chunk) &&\n\t      !util.isString(chunk) &&\n\t      !util.isNullOrUndefined(chunk) &&\n\t      !state.objectMode) {\n\t    var er = new TypeError('Invalid non-string/buffer chunk');\n\t    stream.emit('error', er);\n\t    process.nextTick(function() {\n\t      cb(er);\n\t    });\n\t    valid = false;\n\t  }\n\t  return valid;\n\t}\n\t\n\tWritable.prototype.write = function(chunk, encoding, cb) {\n\t  var state = this._writableState;\n\t  var ret = false;\n\t\n\t  if (util.isFunction(encoding)) {\n\t    cb = encoding;\n\t    encoding = null;\n\t  }\n\t\n\t  if (util.isBuffer(chunk))\n\t    encoding = 'buffer';\n\t  else if (!encoding)\n\t    encoding = state.defaultEncoding;\n\t\n\t  if (!util.isFunction(cb))\n\t    cb = function() {};\n\t\n\t  if (state.ended)\n\t    writeAfterEnd(this, state, cb);\n\t  else if (validChunk(this, state, chunk, cb)) {\n\t    state.pendingcb++;\n\t    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n\t  }\n\t\n\t  return ret;\n\t};\n\t\n\tWritable.prototype.cork = function() {\n\t  var state = this._writableState;\n\t\n\t  state.corked++;\n\t};\n\t\n\tWritable.prototype.uncork = function() {\n\t  var state = this._writableState;\n\t\n\t  if (state.corked) {\n\t    state.corked--;\n\t\n\t    if (!state.writing &&\n\t        !state.corked &&\n\t        !state.finished &&\n\t        !state.bufferProcessing &&\n\t        state.buffer.length)\n\t      clearBuffer(this, state);\n\t  }\n\t};\n\t\n\tfunction decodeChunk(state, chunk, encoding) {\n\t  if (!state.objectMode &&\n\t      state.decodeStrings !== false &&\n\t      util.isString(chunk)) {\n\t    chunk = new Buffer(chunk, encoding);\n\t  }\n\t  return chunk;\n\t}\n\t\n\t// if we're already writing something, then just put this\n\t// in the queue, and wait our turn.  Otherwise, call _write\n\t// If we return false, then we need a drain event, so set that flag.\n\tfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n\t  chunk = decodeChunk(state, chunk, encoding);\n\t  if (util.isBuffer(chunk))\n\t    encoding = 'buffer';\n\t  var len = state.objectMode ? 1 : chunk.length;\n\t\n\t  state.length += len;\n\t\n\t  var ret = state.length < state.highWaterMark;\n\t  // we must ensure that previous needDrain will not be reset to false.\n\t  if (!ret)\n\t    state.needDrain = true;\n\t\n\t  if (state.writing || state.corked)\n\t    state.buffer.push(new WriteReq(chunk, encoding, cb));\n\t  else\n\t    doWrite(stream, state, false, len, chunk, encoding, cb);\n\t\n\t  return ret;\n\t}\n\t\n\tfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n\t  state.writelen = len;\n\t  state.writecb = cb;\n\t  state.writing = true;\n\t  state.sync = true;\n\t  if (writev)\n\t    stream._writev(chunk, state.onwrite);\n\t  else\n\t    stream._write(chunk, encoding, state.onwrite);\n\t  state.sync = false;\n\t}\n\t\n\tfunction onwriteError(stream, state, sync, er, cb) {\n\t  if (sync)\n\t    process.nextTick(function() {\n\t      state.pendingcb--;\n\t      cb(er);\n\t    });\n\t  else {\n\t    state.pendingcb--;\n\t    cb(er);\n\t  }\n\t\n\t  stream._writableState.errorEmitted = true;\n\t  stream.emit('error', er);\n\t}\n\t\n\tfunction onwriteStateUpdate(state) {\n\t  state.writing = false;\n\t  state.writecb = null;\n\t  state.length -= state.writelen;\n\t  state.writelen = 0;\n\t}\n\t\n\tfunction onwrite(stream, er) {\n\t  var state = stream._writableState;\n\t  var sync = state.sync;\n\t  var cb = state.writecb;\n\t\n\t  onwriteStateUpdate(state);\n\t\n\t  if (er)\n\t    onwriteError(stream, state, sync, er, cb);\n\t  else {\n\t    // Check if we're actually ready to finish, but don't emit yet\n\t    var finished = needFinish(stream, state);\n\t\n\t    if (!finished &&\n\t        !state.corked &&\n\t        !state.bufferProcessing &&\n\t        state.buffer.length) {\n\t      clearBuffer(stream, state);\n\t    }\n\t\n\t    if (sync) {\n\t      process.nextTick(function() {\n\t        afterWrite(stream, state, finished, cb);\n\t      });\n\t    } else {\n\t      afterWrite(stream, state, finished, cb);\n\t    }\n\t  }\n\t}\n\t\n\tfunction afterWrite(stream, state, finished, cb) {\n\t  if (!finished)\n\t    onwriteDrain(stream, state);\n\t  state.pendingcb--;\n\t  cb();\n\t  finishMaybe(stream, state);\n\t}\n\t\n\t// Must force callback to be called on nextTick, so that we don't\n\t// emit 'drain' before the write() consumer gets the 'false' return\n\t// value, and has a chance to attach a 'drain' listener.\n\tfunction onwriteDrain(stream, state) {\n\t  if (state.length === 0 && state.needDrain) {\n\t    state.needDrain = false;\n\t    stream.emit('drain');\n\t  }\n\t}\n\t\n\t\n\t// if there's something in the buffer waiting, then process it\n\tfunction clearBuffer(stream, state) {\n\t  state.bufferProcessing = true;\n\t\n\t  if (stream._writev && state.buffer.length > 1) {\n\t    // Fast case, write everything using _writev()\n\t    var cbs = [];\n\t    for (var c = 0; c < state.buffer.length; c++)\n\t      cbs.push(state.buffer[c].callback);\n\t\n\t    // count the one we are adding, as well.\n\t    // TODO(isaacs) clean this up\n\t    state.pendingcb++;\n\t    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {\n\t      for (var i = 0; i < cbs.length; i++) {\n\t        state.pendingcb--;\n\t        cbs[i](err);\n\t      }\n\t    });\n\t\n\t    // Clear buffer\n\t    state.buffer = [];\n\t  } else {\n\t    // Slow case, write chunks one-by-one\n\t    for (var c = 0; c < state.buffer.length; c++) {\n\t      var entry = state.buffer[c];\n\t      var chunk = entry.chunk;\n\t      var encoding = entry.encoding;\n\t      var cb = entry.callback;\n\t      var len = state.objectMode ? 1 : chunk.length;\n\t\n\t      doWrite(stream, state, false, len, chunk, encoding, cb);\n\t\n\t      // if we didn't call the onwrite immediately, then\n\t      // it means that we need to wait until it does.\n\t      // also, that means that the chunk and cb are currently\n\t      // being processed, so move the buffer counter past them.\n\t      if (state.writing) {\n\t        c++;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (c < state.buffer.length)\n\t      state.buffer = state.buffer.slice(c);\n\t    else\n\t      state.buffer.length = 0;\n\t  }\n\t\n\t  state.bufferProcessing = false;\n\t}\n\t\n\tWritable.prototype._write = function(chunk, encoding, cb) {\n\t  cb(new Error('not implemented'));\n\t\n\t};\n\t\n\tWritable.prototype._writev = null;\n\t\n\tWritable.prototype.end = function(chunk, encoding, cb) {\n\t  var state = this._writableState;\n\t\n\t  if (util.isFunction(chunk)) {\n\t    cb = chunk;\n\t    chunk = null;\n\t    encoding = null;\n\t  } else if (util.isFunction(encoding)) {\n\t    cb = encoding;\n\t    encoding = null;\n\t  }\n\t\n\t  if (!util.isNullOrUndefined(chunk))\n\t    this.write(chunk, encoding);\n\t\n\t  // .end() fully uncorks\n\t  if (state.corked) {\n\t    state.corked = 1;\n\t    this.uncork();\n\t  }\n\t\n\t  // ignore unnecessary end() calls.\n\t  if (!state.ending && !state.finished)\n\t    endWritable(this, state, cb);\n\t};\n\t\n\t\n\tfunction needFinish(stream, state) {\n\t  return (state.ending &&\n\t          state.length === 0 &&\n\t          !state.finished &&\n\t          !state.writing);\n\t}\n\t\n\tfunction prefinish(stream, state) {\n\t  if (!state.prefinished) {\n\t    state.prefinished = true;\n\t    stream.emit('prefinish');\n\t  }\n\t}\n\t\n\tfunction finishMaybe(stream, state) {\n\t  var need = needFinish(stream, state);\n\t  if (need) {\n\t    if (state.pendingcb === 0) {\n\t      prefinish(stream, state);\n\t      state.finished = true;\n\t      stream.emit('finish');\n\t    } else\n\t      prefinish(stream, state);\n\t  }\n\t  return need;\n\t}\n\t\n\tfunction endWritable(stream, state, cb) {\n\t  state.ending = true;\n\t  finishMaybe(stream, state);\n\t  if (cb) {\n\t    if (state.finished)\n\t      process.nextTick(cb);\n\t    else\n\t      stream.once('finish', cb);\n\t  }\n\t  state.ended = true;\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))\n\n/***/ },\n/* 43 */,\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(96), __esModule: true };\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(97), __esModule: true };\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(99), __esModule: true };\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _setPrototypeOf = __webpack_require__(87);\n\t\n\tvar _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);\n\t\n\tvar _create = __webpack_require__(85);\n\t\n\tvar _create2 = _interopRequireDefault(_create);\n\t\n\tvar _typeof2 = __webpack_require__(49);\n\t\n\tvar _typeof3 = _interopRequireDefault(_typeof2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = function (subClass, superClass) {\n\t  if (typeof superClass !== \"function\" && superClass !== null) {\n\t    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(superClass)));\n\t  }\n\t\n\t  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {\n\t    constructor: {\n\t      value: subClass,\n\t      enumerable: false,\n\t      writable: true,\n\t      configurable: true\n\t    }\n\t  });\n\t  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;\n\t};\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _typeof2 = __webpack_require__(49);\n\t\n\tvar _typeof3 = _interopRequireDefault(_typeof2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = function (self, call) {\n\t  if (!self) {\n\t    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n\t  }\n\t\n\t  return call && ((typeof call === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(call)) === \"object\" || typeof call === \"function\") ? call : self;\n\t};\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _iterator = __webpack_require__(89);\n\t\n\tvar _iterator2 = _interopRequireDefault(_iterator);\n\t\n\tvar _symbol = __webpack_require__(88);\n\t\n\tvar _symbol2 = _interopRequireDefault(_symbol);\n\t\n\tvar _typeof = typeof _symbol2.default === \"function\" && typeof _iterator2.default === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj; };\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = typeof _symbol2.default === \"function\" && _typeof(_iterator2.default) === \"symbol\" ? function (obj) {\n\t  return typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n\t} : function (obj) {\n\t  return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n\t};\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// optional / simple context binding\n\tvar aFunction = __webpack_require__(102);\n\tmodule.exports = function(fn, that, length){\n\t  aFunction(fn);\n\t  if(that === undefined)return fn;\n\t  switch(length){\n\t    case 1: return function(a){\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function(a, b){\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function(a, b, c){\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function(/* ...args */){\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(18)\n\t  , document = __webpack_require__(5).document\n\t  // in old IE typeof document.createElement is 'object'\n\t  , is = isObject(document) && isObject(document.createElement);\n\tmodule.exports = function(it){\n\t  return is ? document.createElement(it) : {};\n\t};\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = !__webpack_require__(8) && !__webpack_require__(14)(function(){\n\t  return Object.defineProperty(__webpack_require__(51)('div'), 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar cof = __webpack_require__(28);\n\tmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n\t  return cof(it) == 'String' ? it.split('') : Object(it);\n\t};\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar LIBRARY        = __webpack_require__(31)\n\t  , $export        = __webpack_require__(4)\n\t  , redefine       = __webpack_require__(60)\n\t  , hide           = __webpack_require__(15)\n\t  , has            = __webpack_require__(9)\n\t  , Iterators      = __webpack_require__(23)\n\t  , $iterCreate    = __webpack_require__(109)\n\t  , setToStringTag = __webpack_require__(34)\n\t  , getPrototypeOf = __webpack_require__(57)\n\t  , ITERATOR       = __webpack_require__(7)('iterator')\n\t  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n\t  , FF_ITERATOR    = '@@iterator'\n\t  , KEYS           = 'keys'\n\t  , VALUES         = 'values';\n\t\n\tvar returnThis = function(){ return this; };\n\t\n\tmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n\t  $iterCreate(Constructor, NAME, next);\n\t  var getMethod = function(kind){\n\t    if(!BUGGY && kind in proto)return proto[kind];\n\t    switch(kind){\n\t      case KEYS: return function keys(){ return new Constructor(this, kind); };\n\t      case VALUES: return function values(){ return new Constructor(this, kind); };\n\t    } return function entries(){ return new Constructor(this, kind); };\n\t  };\n\t  var TAG        = NAME + ' Iterator'\n\t    , DEF_VALUES = DEFAULT == VALUES\n\t    , VALUES_BUG = false\n\t    , proto      = Base.prototype\n\t    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n\t    , $default   = $native || getMethod(DEFAULT)\n\t    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n\t    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n\t    , methods, key, IteratorPrototype;\n\t  // Fix native\n\t  if($anyNative){\n\t    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n\t    if(IteratorPrototype !== Object.prototype){\n\t      // Set @@toStringTag to native iterators\n\t      setToStringTag(IteratorPrototype, TAG, true);\n\t      // fix for some old engines\n\t      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n\t    }\n\t  }\n\t  // fix Array#{values, @@iterator}.name in V8 / FF\n\t  if(DEF_VALUES && $native && $native.name !== VALUES){\n\t    VALUES_BUG = true;\n\t    $default = function values(){ return $native.call(this); };\n\t  }\n\t  // Define iterator\n\t  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n\t    hide(proto, ITERATOR, $default);\n\t  }\n\t  // Plug for library\n\t  Iterators[NAME] = $default;\n\t  Iterators[TAG]  = returnThis;\n\t  if(DEFAULT){\n\t    methods = {\n\t      values:  DEF_VALUES ? $default : getMethod(VALUES),\n\t      keys:    IS_SET     ? $default : getMethod(KEYS),\n\t      entries: $entries\n\t    };\n\t    if(FORCED)for(key in methods){\n\t      if(!(key in proto))redefine(proto, key, methods[key]);\n\t    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n\t  }\n\t  return methods;\n\t};\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar pIE            = __webpack_require__(19)\n\t  , createDesc     = __webpack_require__(24)\n\t  , toIObject      = __webpack_require__(6)\n\t  , toPrimitive    = __webpack_require__(38)\n\t  , has            = __webpack_require__(9)\n\t  , IE8_DOM_DEFINE = __webpack_require__(52)\n\t  , gOPD           = Object.getOwnPropertyDescriptor;\n\t\n\texports.f = __webpack_require__(8) ? gOPD : function getOwnPropertyDescriptor(O, P){\n\t  O = toIObject(O);\n\t  P = toPrimitive(P, true);\n\t  if(IE8_DOM_DEFINE)try {\n\t    return gOPD(O, P);\n\t  } catch(e){ /* empty */ }\n\t  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);\n\t};\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\n\tvar $keys      = __webpack_require__(58)\n\t  , hiddenKeys = __webpack_require__(30).concat('length', 'prototype');\n\t\n\texports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){\n\t  return $keys(O, hiddenKeys);\n\t};\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\n\tvar has         = __webpack_require__(9)\n\t  , toObject    = __webpack_require__(25)\n\t  , IE_PROTO    = __webpack_require__(35)('IE_PROTO')\n\t  , ObjectProto = Object.prototype;\n\t\n\tmodule.exports = Object.getPrototypeOf || function(O){\n\t  O = toObject(O);\n\t  if(has(O, IE_PROTO))return O[IE_PROTO];\n\t  if(typeof O.constructor == 'function' && O instanceof O.constructor){\n\t    return O.constructor.prototype;\n\t  } return O instanceof Object ? ObjectProto : null;\n\t};\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar has          = __webpack_require__(9)\n\t  , toIObject    = __webpack_require__(6)\n\t  , arrayIndexOf = __webpack_require__(104)(false)\n\t  , IE_PROTO     = __webpack_require__(35)('IE_PROTO');\n\t\n\tmodule.exports = function(object, names){\n\t  var O      = toIObject(object)\n\t    , i      = 0\n\t    , result = []\n\t    , key;\n\t  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\n\t  // Don't enum bug & hidden keys\n\t  while(names.length > i)if(has(O, key = names[i++])){\n\t    ~arrayIndexOf(result, key) || result.push(key);\n\t  }\n\t  return result;\n\t};\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// most Object methods by ES6 should accept primitives\n\tvar $export = __webpack_require__(4)\n\t  , core    = __webpack_require__(1)\n\t  , fails   = __webpack_require__(14);\n\tmodule.exports = function(KEY, exec){\n\t  var fn  = (core.Object || {})[KEY] || Object[KEY]\n\t    , exp = {};\n\t  exp[KEY] = exec(fn);\n\t  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);\n\t};\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(15);\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $at  = __webpack_require__(118)(true);\n\t\n\t// 21.1.3.27 String.prototype[@@iterator]()\n\t__webpack_require__(54)(String, 'String', function(iterated){\n\t  this._t = String(iterated); // target\n\t  this._i = 0;                // next index\n\t// 21.1.5.2.1 %StringIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , index = this._i\n\t    , point;\n\t  if(index >= O.length)return {value: undefined, done: true};\n\t  point = $at(O, index);\n\t  this._i += point.length;\n\t  return {value: point, done: false};\n\t});\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(123);\n\tvar global        = __webpack_require__(5)\n\t  , hide          = __webpack_require__(15)\n\t  , Iterators     = __webpack_require__(23)\n\t  , TO_STRING_TAG = __webpack_require__(7)('toStringTag');\n\t\n\tfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n\t  var NAME       = collections[i]\n\t    , Collection = global[NAME]\n\t    , proto      = Collection && Collection.prototype;\n\t  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);\n\t  Iterators[NAME] = Iterators.Array;\n\t}\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// https://d3js.org/d3-collection/ Version 1.0.1. Copyright 2016 Mike Bostock.\n\t(function (global, factory) {\n\t   true ? factory(exports) :\n\t  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t  (factory((global.d3 = global.d3 || {})));\n\t}(this, function (exports) { 'use strict';\n\t\n\t  var prefix = \"$\";\n\t\n\t  function Map() {}\n\t\n\t  Map.prototype = map.prototype = {\n\t    constructor: Map,\n\t    has: function(key) {\n\t      return (prefix + key) in this;\n\t    },\n\t    get: function(key) {\n\t      return this[prefix + key];\n\t    },\n\t    set: function(key, value) {\n\t      this[prefix + key] = value;\n\t      return this;\n\t    },\n\t    remove: function(key) {\n\t      var property = prefix + key;\n\t      return property in this && delete this[property];\n\t    },\n\t    clear: function() {\n\t      for (var property in this) if (property[0] === prefix) delete this[property];\n\t    },\n\t    keys: function() {\n\t      var keys = [];\n\t      for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));\n\t      return keys;\n\t    },\n\t    values: function() {\n\t      var values = [];\n\t      for (var property in this) if (property[0] === prefix) values.push(this[property]);\n\t      return values;\n\t    },\n\t    entries: function() {\n\t      var entries = [];\n\t      for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});\n\t      return entries;\n\t    },\n\t    size: function() {\n\t      var size = 0;\n\t      for (var property in this) if (property[0] === prefix) ++size;\n\t      return size;\n\t    },\n\t    empty: function() {\n\t      for (var property in this) if (property[0] === prefix) return false;\n\t      return true;\n\t    },\n\t    each: function(f) {\n\t      for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);\n\t    }\n\t  };\n\t\n\t  function map(object, f) {\n\t    var map = new Map;\n\t\n\t    // Copy constructor.\n\t    if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });\n\t\n\t    // Index array by numeric index or specified key function.\n\t    else if (Array.isArray(object)) {\n\t      var i = -1,\n\t          n = object.length,\n\t          o;\n\t\n\t      if (f == null) while (++i < n) map.set(i, object[i]);\n\t      else while (++i < n) map.set(f(o = object[i], i, object), o);\n\t    }\n\t\n\t    // Convert object to map.\n\t    else if (object) for (var key in object) map.set(key, object[key]);\n\t\n\t    return map;\n\t  }\n\t\n\t  function nest() {\n\t    var keys = [],\n\t        sortKeys = [],\n\t        sortValues,\n\t        rollup,\n\t        nest;\n\t\n\t    function apply(array, depth, createResult, setResult) {\n\t      if (depth >= keys.length) return rollup != null\n\t          ? rollup(array) : (sortValues != null\n\t          ? array.sort(sortValues)\n\t          : array);\n\t\n\t      var i = -1,\n\t          n = array.length,\n\t          key = keys[depth++],\n\t          keyValue,\n\t          value,\n\t          valuesByKey = map(),\n\t          values,\n\t          result = createResult();\n\t\n\t      while (++i < n) {\n\t        if (values = valuesByKey.get(keyValue = key(value = array[i]) + \"\")) {\n\t          values.push(value);\n\t        } else {\n\t          valuesByKey.set(keyValue, [value]);\n\t        }\n\t      }\n\t\n\t      valuesByKey.each(function(values, key) {\n\t        setResult(result, key, apply(values, depth, createResult, setResult));\n\t      });\n\t\n\t      return result;\n\t    }\n\t\n\t    function entries(map, depth) {\n\t      if (++depth > keys.length) return map;\n\t      var array, sortKey = sortKeys[depth - 1];\n\t      if (rollup != null && depth >= keys.length) array = map.entries();\n\t      else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });\n\t      return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;\n\t    }\n\t\n\t    return nest = {\n\t      object: function(array) { return apply(array, 0, createObject, setObject); },\n\t      map: function(array) { return apply(array, 0, createMap, setMap); },\n\t      entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },\n\t      key: function(d) { keys.push(d); return nest; },\n\t      sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },\n\t      sortValues: function(order) { sortValues = order; return nest; },\n\t      rollup: function(f) { rollup = f; return nest; }\n\t    };\n\t  }\n\t\n\t  function createObject() {\n\t    return {};\n\t  }\n\t\n\t  function setObject(object, key, value) {\n\t    object[key] = value;\n\t  }\n\t\n\t  function createMap() {\n\t    return map();\n\t  }\n\t\n\t  function setMap(map, key, value) {\n\t    map.set(key, value);\n\t  }\n\t\n\t  function Set() {}\n\t\n\t  var proto = map.prototype;\n\t\n\t  Set.prototype = set.prototype = {\n\t    constructor: Set,\n\t    has: proto.has,\n\t    add: function(value) {\n\t      value += \"\";\n\t      this[prefix + value] = value;\n\t      return this;\n\t    },\n\t    remove: proto.remove,\n\t    clear: proto.clear,\n\t    values: proto.keys,\n\t    size: proto.size,\n\t    empty: proto.empty,\n\t    each: proto.each\n\t  };\n\t\n\t  function set(object, f) {\n\t    var set = new Set;\n\t\n\t    // Copy constructor.\n\t    if (object instanceof Set) object.each(function(value) { set.add(value); });\n\t\n\t    // Otherwise, assume it’s an array.\n\t    else if (object) {\n\t      var i = -1, n = object.length;\n\t      if (f == null) while (++i < n) set.add(object[i]);\n\t      else while (++i < n) set.add(f(object[i], i, object));\n\t    }\n\t\n\t    return set;\n\t  }\n\t\n\t  function keys(map) {\n\t    var keys = [];\n\t    for (var key in map) keys.push(key);\n\t    return keys;\n\t  }\n\t\n\t  function values(map) {\n\t    var values = [];\n\t    for (var key in map) values.push(map[key]);\n\t    return values;\n\t  }\n\t\n\t  function entries(map) {\n\t    var entries = [];\n\t    for (var key in map) entries.push({key: key, value: map[key]});\n\t    return entries;\n\t  }\n\t\n\t  exports.nest = nest;\n\t  exports.set = set;\n\t  exports.map = map;\n\t  exports.keys = keys;\n\t  exports.values = values;\n\t  exports.entries = entries;\n\t\n\t  Object.defineProperty(exports, '__esModule', { value: true });\n\t\n\t}));\n\n/***/ },\n/* 64 */\n/***/ function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events.error ||\n\t        (isObject(this._events.error) && !this._events.error.length)) {\n\t      er = arguments[1];\n\t      if (er instanceof Error) {\n\t        throw er; // Unhandled 'error' event\n\t      } else {\n\t        // At least give some kind of context to the user\n\t        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n\t        err.context = er;\n\t        throw err;\n\t      }\n\t    }\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (isUndefined(handler))\n\t    return false;\n\t\n\t  if (isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        args = Array.prototype.slice.call(arguments, 1);\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (isObject(handler)) {\n\t    args = Array.prototype.slice.call(arguments, 1);\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (isObject(this._events[type]) && !this._events[type].warned) {\n\t    if (!isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(node) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      if (typeof console.trace === 'function') {\n\t        // not supported in IE 10\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else if (listeners) {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.prototype.listenerCount = function(type) {\n\t  if (this._events) {\n\t    var evlistener = this._events[type];\n\t\n\t    if (isFunction(evlistener))\n\t      return 1;\n\t    else if (evlistener)\n\t      return evlistener.length;\n\t  }\n\t  return 0;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  return emitter.listenerCount(type);\n\t};\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t// a passthrough stream.\n\t// basically just the most minimal sort of Transform stream.\n\t// Every written chunk gets output as-is.\n\t\n\tmodule.exports = PassThrough;\n\t\n\tvar Transform = __webpack_require__(41);\n\t\n\t/*<replacement>*/\n\tvar util = __webpack_require__(20);\n\tutil.inherits = __webpack_require__(16);\n\t/*</replacement>*/\n\t\n\tutil.inherits(PassThrough, Transform);\n\t\n\tfunction PassThrough(options) {\n\t  if (!(this instanceof PassThrough))\n\t    return new PassThrough(options);\n\t\n\t  Transform.call(this, options);\n\t}\n\t\n\tPassThrough.prototype._transform = function(chunk, encoding, cb) {\n\t  cb(null, chunk);\n\t};\n\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tmodule.exports = Readable;\n\t\n\t/*<replacement>*/\n\tvar isArray = __webpack_require__(143);\n\t/*</replacement>*/\n\t\n\t\n\t/*<replacement>*/\n\tvar Buffer = __webpack_require__(17).Buffer;\n\t/*</replacement>*/\n\t\n\tReadable.ReadableState = ReadableState;\n\t\n\tvar EE = __webpack_require__(64).EventEmitter;\n\t\n\t/*<replacement>*/\n\tif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n\t  return emitter.listeners(type).length;\n\t};\n\t/*</replacement>*/\n\t\n\tvar Stream = __webpack_require__(22);\n\t\n\t/*<replacement>*/\n\tvar util = __webpack_require__(20);\n\tutil.inherits = __webpack_require__(16);\n\t/*</replacement>*/\n\t\n\tvar StringDecoder;\n\t\n\t\n\t/*<replacement>*/\n\tvar debug = __webpack_require__(162);\n\tif (debug && debug.debuglog) {\n\t  debug = debug.debuglog('stream');\n\t} else {\n\t  debug = function () {};\n\t}\n\t/*</replacement>*/\n\t\n\t\n\tutil.inherits(Readable, Stream);\n\t\n\tfunction ReadableState(options, stream) {\n\t  var Duplex = __webpack_require__(12);\n\t\n\t  options = options || {};\n\t\n\t  // the point at which it stops calling _read() to fill the buffer\n\t  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\t  var hwm = options.highWaterMark;\n\t  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n\t  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\t\n\t  // cast to ints.\n\t  this.highWaterMark = ~~this.highWaterMark;\n\t\n\t  this.buffer = [];\n\t  this.length = 0;\n\t  this.pipes = null;\n\t  this.pipesCount = 0;\n\t  this.flowing = null;\n\t  this.ended = false;\n\t  this.endEmitted = false;\n\t  this.reading = false;\n\t\n\t  // a flag to be able to tell if the onwrite cb is called immediately,\n\t  // or on a later tick.  We set this to true at first, because any\n\t  // actions that shouldn't happen until \"later\" should generally also\n\t  // not happen before the first write call.\n\t  this.sync = true;\n\t\n\t  // whenever we return null, then we set a flag to say\n\t  // that we're awaiting a 'readable' event emission.\n\t  this.needReadable = false;\n\t  this.emittedReadable = false;\n\t  this.readableListening = false;\n\t\n\t\n\t  // object stream flag. Used to make read(n) ignore n and to\n\t  // make all the buffer merging and length checks go away\n\t  this.objectMode = !!options.objectMode;\n\t\n\t  if (stream instanceof Duplex)\n\t    this.objectMode = this.objectMode || !!options.readableObjectMode;\n\t\n\t  // Crypto is kind of old and crusty.  Historically, its default string\n\t  // encoding is 'binary' so we have to make this configurable.\n\t  // Everything else in the universe uses 'utf8', though.\n\t  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\t\n\t  // when piping, we only care about 'readable' events that happen\n\t  // after read()ing all the bytes and not getting any pushback.\n\t  this.ranOut = false;\n\t\n\t  // the number of writers that are awaiting a drain event in .pipe()s\n\t  this.awaitDrain = 0;\n\t\n\t  // if true, a maybeReadMore has been scheduled\n\t  this.readingMore = false;\n\t\n\t  this.decoder = null;\n\t  this.encoding = null;\n\t  if (options.encoding) {\n\t    if (!StringDecoder)\n\t      StringDecoder = __webpack_require__(67).StringDecoder;\n\t    this.decoder = new StringDecoder(options.encoding);\n\t    this.encoding = options.encoding;\n\t  }\n\t}\n\t\n\tfunction Readable(options) {\n\t  var Duplex = __webpack_require__(12);\n\t\n\t  if (!(this instanceof Readable))\n\t    return new Readable(options);\n\t\n\t  this._readableState = new ReadableState(options, this);\n\t\n\t  // legacy\n\t  this.readable = true;\n\t\n\t  Stream.call(this);\n\t}\n\t\n\t// Manually shove something into the read() buffer.\n\t// This returns true if the highWaterMark has not been hit yet,\n\t// similar to how Writable.write() returns true if you should\n\t// write() some more.\n\tReadable.prototype.push = function(chunk, encoding) {\n\t  var state = this._readableState;\n\t\n\t  if (util.isString(chunk) && !state.objectMode) {\n\t    encoding = encoding || state.defaultEncoding;\n\t    if (encoding !== state.encoding) {\n\t      chunk = new Buffer(chunk, encoding);\n\t      encoding = '';\n\t    }\n\t  }\n\t\n\t  return readableAddChunk(this, state, chunk, encoding, false);\n\t};\n\t\n\t// Unshift should *always* be something directly out of read()\n\tReadable.prototype.unshift = function(chunk) {\n\t  var state = this._readableState;\n\t  return readableAddChunk(this, state, chunk, '', true);\n\t};\n\t\n\tfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n\t  var er = chunkInvalid(state, chunk);\n\t  if (er) {\n\t    stream.emit('error', er);\n\t  } else if (util.isNullOrUndefined(chunk)) {\n\t    state.reading = false;\n\t    if (!state.ended)\n\t      onEofChunk(stream, state);\n\t  } else if (state.objectMode || chunk && chunk.length > 0) {\n\t    if (state.ended && !addToFront) {\n\t      var e = new Error('stream.push() after EOF');\n\t      stream.emit('error', e);\n\t    } else if (state.endEmitted && addToFront) {\n\t      var e = new Error('stream.unshift() after end event');\n\t      stream.emit('error', e);\n\t    } else {\n\t      if (state.decoder && !addToFront && !encoding)\n\t        chunk = state.decoder.write(chunk);\n\t\n\t      if (!addToFront)\n\t        state.reading = false;\n\t\n\t      // if we want the data now, just emit it.\n\t      if (state.flowing && state.length === 0 && !state.sync) {\n\t        stream.emit('data', chunk);\n\t        stream.read(0);\n\t      } else {\n\t        // update the buffer info.\n\t        state.length += state.objectMode ? 1 : chunk.length;\n\t        if (addToFront)\n\t          state.buffer.unshift(chunk);\n\t        else\n\t          state.buffer.push(chunk);\n\t\n\t        if (state.needReadable)\n\t          emitReadable(stream);\n\t      }\n\t\n\t      maybeReadMore(stream, state);\n\t    }\n\t  } else if (!addToFront) {\n\t    state.reading = false;\n\t  }\n\t\n\t  return needMoreData(state);\n\t}\n\t\n\t\n\t\n\t// if it's past the high water mark, we can push in some more.\n\t// Also, if we have no data yet, we can stand some\n\t// more bytes.  This is to work around cases where hwm=0,\n\t// such as the repl.  Also, if the push() triggered a\n\t// readable event, and the user called read(largeNumber) such that\n\t// needReadable was set, then we ought to push more, so that another\n\t// 'readable' event will be triggered.\n\tfunction needMoreData(state) {\n\t  return !state.ended &&\n\t         (state.needReadable ||\n\t          state.length < state.highWaterMark ||\n\t          state.length === 0);\n\t}\n\t\n\t// backwards compatibility.\n\tReadable.prototype.setEncoding = function(enc) {\n\t  if (!StringDecoder)\n\t    StringDecoder = __webpack_require__(67).StringDecoder;\n\t  this._readableState.decoder = new StringDecoder(enc);\n\t  this._readableState.encoding = enc;\n\t  return this;\n\t};\n\t\n\t// Don't raise the hwm > 128MB\n\tvar MAX_HWM = 0x800000;\n\tfunction roundUpToNextPowerOf2(n) {\n\t  if (n >= MAX_HWM) {\n\t    n = MAX_HWM;\n\t  } else {\n\t    // Get the next highest power of 2\n\t    n--;\n\t    for (var p = 1; p < 32; p <<= 1) n |= n >> p;\n\t    n++;\n\t  }\n\t  return n;\n\t}\n\t\n\tfunction howMuchToRead(n, state) {\n\t  if (state.length === 0 && state.ended)\n\t    return 0;\n\t\n\t  if (state.objectMode)\n\t    return n === 0 ? 0 : 1;\n\t\n\t  if (isNaN(n) || util.isNull(n)) {\n\t    // only flow one buffer at a time\n\t    if (state.flowing && state.buffer.length)\n\t      return state.buffer[0].length;\n\t    else\n\t      return state.length;\n\t  }\n\t\n\t  if (n <= 0)\n\t    return 0;\n\t\n\t  // If we're asking for more than the target buffer level,\n\t  // then raise the water mark.  Bump up to the next highest\n\t  // power of 2, to prevent increasing it excessively in tiny\n\t  // amounts.\n\t  if (n > state.highWaterMark)\n\t    state.highWaterMark = roundUpToNextPowerOf2(n);\n\t\n\t  // don't have that much.  return null, unless we've ended.\n\t  if (n > state.length) {\n\t    if (!state.ended) {\n\t      state.needReadable = true;\n\t      return 0;\n\t    } else\n\t      return state.length;\n\t  }\n\t\n\t  return n;\n\t}\n\t\n\t// you can override either this method, or the async _read(n) below.\n\tReadable.prototype.read = function(n) {\n\t  debug('read', n);\n\t  var state = this._readableState;\n\t  var nOrig = n;\n\t\n\t  if (!util.isNumber(n) || n > 0)\n\t    state.emittedReadable = false;\n\t\n\t  // if we're doing read(0) to trigger a readable event, but we\n\t  // already have a bunch of data in the buffer, then just trigger\n\t  // the 'readable' event and move on.\n\t  if (n === 0 &&\n\t      state.needReadable &&\n\t      (state.length >= state.highWaterMark || state.ended)) {\n\t    debug('read: emitReadable', state.length, state.ended);\n\t    if (state.length === 0 && state.ended)\n\t      endReadable(this);\n\t    else\n\t      emitReadable(this);\n\t    return null;\n\t  }\n\t\n\t  n = howMuchToRead(n, state);\n\t\n\t  // if we've ended, and we're now clear, then finish it up.\n\t  if (n === 0 && state.ended) {\n\t    if (state.length === 0)\n\t      endReadable(this);\n\t    return null;\n\t  }\n\t\n\t  // All the actual chunk generation logic needs to be\n\t  // *below* the call to _read.  The reason is that in certain\n\t  // synthetic stream cases, such as passthrough streams, _read\n\t  // may be a completely synchronous operation which may change\n\t  // the state of the read buffer, providing enough data when\n\t  // before there was *not* enough.\n\t  //\n\t  // So, the steps are:\n\t  // 1. Figure out what the state of things will be after we do\n\t  // a read from the buffer.\n\t  //\n\t  // 2. If that resulting state will trigger a _read, then call _read.\n\t  // Note that this may be asynchronous, or synchronous.  Yes, it is\n\t  // deeply ugly to write APIs this way, but that still doesn't mean\n\t  // that the Readable class should behave improperly, as streams are\n\t  // designed to be sync/async agnostic.\n\t  // Take note if the _read call is sync or async (ie, if the read call\n\t  // has returned yet), so that we know whether or not it's safe to emit\n\t  // 'readable' etc.\n\t  //\n\t  // 3. Actually pull the requested chunks out of the buffer and return.\n\t\n\t  // if we need a readable event, then we need to do some reading.\n\t  var doRead = state.needReadable;\n\t  debug('need readable', doRead);\n\t\n\t  // if we currently have less than the highWaterMark, then also read some\n\t  if (state.length === 0 || state.length - n < state.highWaterMark) {\n\t    doRead = true;\n\t    debug('length less than watermark', doRead);\n\t  }\n\t\n\t  // however, if we've ended, then there's no point, and if we're already\n\t  // reading, then it's unnecessary.\n\t  if (state.ended || state.reading) {\n\t    doRead = false;\n\t    debug('reading or ended', doRead);\n\t  }\n\t\n\t  if (doRead) {\n\t    debug('do read');\n\t    state.reading = true;\n\t    state.sync = true;\n\t    // if the length is currently zero, then we *need* a readable event.\n\t    if (state.length === 0)\n\t      state.needReadable = true;\n\t    // call internal read method\n\t    this._read(state.highWaterMark);\n\t    state.sync = false;\n\t  }\n\t\n\t  // If _read pushed data synchronously, then `reading` will be false,\n\t  // and we need to re-evaluate how much data we can return to the user.\n\t  if (doRead && !state.reading)\n\t    n = howMuchToRead(nOrig, state);\n\t\n\t  var ret;\n\t  if (n > 0)\n\t    ret = fromList(n, state);\n\t  else\n\t    ret = null;\n\t\n\t  if (util.isNull(ret)) {\n\t    state.needReadable = true;\n\t    n = 0;\n\t  }\n\t\n\t  state.length -= n;\n\t\n\t  // If we have nothing in the buffer, then we want to know\n\t  // as soon as we *do* get something into the buffer.\n\t  if (state.length === 0 && !state.ended)\n\t    state.needReadable = true;\n\t\n\t  // If we tried to read() past the EOF, then emit end on the next tick.\n\t  if (nOrig !== n && state.ended && state.length === 0)\n\t    endReadable(this);\n\t\n\t  if (!util.isNull(ret))\n\t    this.emit('data', ret);\n\t\n\t  return ret;\n\t};\n\t\n\tfunction chunkInvalid(state, chunk) {\n\t  var er = null;\n\t  if (!util.isBuffer(chunk) &&\n\t      !util.isString(chunk) &&\n\t      !util.isNullOrUndefined(chunk) &&\n\t      !state.objectMode) {\n\t    er = new TypeError('Invalid non-string/buffer chunk');\n\t  }\n\t  return er;\n\t}\n\t\n\t\n\tfunction onEofChunk(stream, state) {\n\t  if (state.decoder && !state.ended) {\n\t    var chunk = state.decoder.end();\n\t    if (chunk && chunk.length) {\n\t      state.buffer.push(chunk);\n\t      state.length += state.objectMode ? 1 : chunk.length;\n\t    }\n\t  }\n\t  state.ended = true;\n\t\n\t  // emit 'readable' now to make sure it gets picked up.\n\t  emitReadable(stream);\n\t}\n\t\n\t// Don't emit readable right away in sync mode, because this can trigger\n\t// another read() call => stack overflow.  This way, it might trigger\n\t// a nextTick recursion warning, but that's not so bad.\n\tfunction emitReadable(stream) {\n\t  var state = stream._readableState;\n\t  state.needReadable = false;\n\t  if (!state.emittedReadable) {\n\t    debug('emitReadable', state.flowing);\n\t    state.emittedReadable = true;\n\t    if (state.sync)\n\t      process.nextTick(function() {\n\t        emitReadable_(stream);\n\t      });\n\t    else\n\t      emitReadable_(stream);\n\t  }\n\t}\n\t\n\tfunction emitReadable_(stream) {\n\t  debug('emit readable');\n\t  stream.emit('readable');\n\t  flow(stream);\n\t}\n\t\n\t\n\t// at this point, the user has presumably seen the 'readable' event,\n\t// and called read() to consume some data.  that may have triggered\n\t// in turn another _read(n) call, in which case reading = true if\n\t// it's in progress.\n\t// However, if we're not ended, or reading, and the length < hwm,\n\t// then go ahead and try to read some more preemptively.\n\tfunction maybeReadMore(stream, state) {\n\t  if (!state.readingMore) {\n\t    state.readingMore = true;\n\t    process.nextTick(function() {\n\t      maybeReadMore_(stream, state);\n\t    });\n\t  }\n\t}\n\t\n\tfunction maybeReadMore_(stream, state) {\n\t  var len = state.length;\n\t  while (!state.reading && !state.flowing && !state.ended &&\n\t         state.length < state.highWaterMark) {\n\t    debug('maybeReadMore read 0');\n\t    stream.read(0);\n\t    if (len === state.length)\n\t      // didn't get any data, stop spinning.\n\t      break;\n\t    else\n\t      len = state.length;\n\t  }\n\t  state.readingMore = false;\n\t}\n\t\n\t// abstract method.  to be overridden in specific implementation classes.\n\t// call cb(er, data) where data is <= n in length.\n\t// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n\t// arbitrary, and perhaps not very meaningful.\n\tReadable.prototype._read = function(n) {\n\t  this.emit('error', new Error('not implemented'));\n\t};\n\t\n\tReadable.prototype.pipe = function(dest, pipeOpts) {\n\t  var src = this;\n\t  var state = this._readableState;\n\t\n\t  switch (state.pipesCount) {\n\t    case 0:\n\t      state.pipes = dest;\n\t      break;\n\t    case 1:\n\t      state.pipes = [state.pipes, dest];\n\t      break;\n\t    default:\n\t      state.pipes.push(dest);\n\t      break;\n\t  }\n\t  state.pipesCount += 1;\n\t  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\t\n\t  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n\t              dest !== process.stdout &&\n\t              dest !== process.stderr;\n\t\n\t  var endFn = doEnd ? onend : cleanup;\n\t  if (state.endEmitted)\n\t    process.nextTick(endFn);\n\t  else\n\t    src.once('end', endFn);\n\t\n\t  dest.on('unpipe', onunpipe);\n\t  function onunpipe(readable) {\n\t    debug('onunpipe');\n\t    if (readable === src) {\n\t      cleanup();\n\t    }\n\t  }\n\t\n\t  function onend() {\n\t    debug('onend');\n\t    dest.end();\n\t  }\n\t\n\t  // when the dest drains, it reduces the awaitDrain counter\n\t  // on the source.  This would be more elegant with a .once()\n\t  // handler in flow(), but adding and removing repeatedly is\n\t  // too slow.\n\t  var ondrain = pipeOnDrain(src);\n\t  dest.on('drain', ondrain);\n\t\n\t  function cleanup() {\n\t    debug('cleanup');\n\t    // cleanup event handlers once the pipe is broken\n\t    dest.removeListener('close', onclose);\n\t    dest.removeListener('finish', onfinish);\n\t    dest.removeListener('drain', ondrain);\n\t    dest.removeListener('error', onerror);\n\t    dest.removeListener('unpipe', onunpipe);\n\t    src.removeListener('end', onend);\n\t    src.removeListener('end', cleanup);\n\t    src.removeListener('data', ondata);\n\t\n\t    // if the reader is waiting for a drain event from this\n\t    // specific writer, then it would cause it to never start\n\t    // flowing again.\n\t    // So, if this is awaiting a drain, then we just call it now.\n\t    // If we don't know, then assume that we are waiting for one.\n\t    if (state.awaitDrain &&\n\t        (!dest._writableState || dest._writableState.needDrain))\n\t      ondrain();\n\t  }\n\t\n\t  src.on('data', ondata);\n\t  function ondata(chunk) {\n\t    debug('ondata');\n\t    var ret = dest.write(chunk);\n\t    if (false === ret) {\n\t      debug('false write response, pause',\n\t            src._readableState.awaitDrain);\n\t      src._readableState.awaitDrain++;\n\t      src.pause();\n\t    }\n\t  }\n\t\n\t  // if the dest has an error, then stop piping into it.\n\t  // however, don't suppress the throwing behavior for this.\n\t  function onerror(er) {\n\t    debug('onerror', er);\n\t    unpipe();\n\t    dest.removeListener('error', onerror);\n\t    if (EE.listenerCount(dest, 'error') === 0)\n\t      dest.emit('error', er);\n\t  }\n\t  // This is a brutally ugly hack to make sure that our error handler\n\t  // is attached before any userland ones.  NEVER DO THIS.\n\t  if (!dest._events || !dest._events.error)\n\t    dest.on('error', onerror);\n\t  else if (isArray(dest._events.error))\n\t    dest._events.error.unshift(onerror);\n\t  else\n\t    dest._events.error = [onerror, dest._events.error];\n\t\n\t\n\t\n\t  // Both close and finish should trigger unpipe, but only once.\n\t  function onclose() {\n\t    dest.removeListener('finish', onfinish);\n\t    unpipe();\n\t  }\n\t  dest.once('close', onclose);\n\t  function onfinish() {\n\t    debug('onfinish');\n\t    dest.removeListener('close', onclose);\n\t    unpipe();\n\t  }\n\t  dest.once('finish', onfinish);\n\t\n\t  function unpipe() {\n\t    debug('unpipe');\n\t    src.unpipe(dest);\n\t  }\n\t\n\t  // tell the dest that it's being piped to\n\t  dest.emit('pipe', src);\n\t\n\t  // start the flow if it hasn't been started already.\n\t  if (!state.flowing) {\n\t    debug('pipe resume');\n\t    src.resume();\n\t  }\n\t\n\t  return dest;\n\t};\n\t\n\tfunction pipeOnDrain(src) {\n\t  return function() {\n\t    var state = src._readableState;\n\t    debug('pipeOnDrain', state.awaitDrain);\n\t    if (state.awaitDrain)\n\t      state.awaitDrain--;\n\t    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {\n\t      state.flowing = true;\n\t      flow(src);\n\t    }\n\t  };\n\t}\n\t\n\t\n\tReadable.prototype.unpipe = function(dest) {\n\t  var state = this._readableState;\n\t\n\t  // if we're not piping anywhere, then do nothing.\n\t  if (state.pipesCount === 0)\n\t    return this;\n\t\n\t  // just one destination.  most common case.\n\t  if (state.pipesCount === 1) {\n\t    // passed in one, but it's not the right one.\n\t    if (dest && dest !== state.pipes)\n\t      return this;\n\t\n\t    if (!dest)\n\t      dest = state.pipes;\n\t\n\t    // got a match.\n\t    state.pipes = null;\n\t    state.pipesCount = 0;\n\t    state.flowing = false;\n\t    if (dest)\n\t      dest.emit('unpipe', this);\n\t    return this;\n\t  }\n\t\n\t  // slow case. multiple pipe destinations.\n\t\n\t  if (!dest) {\n\t    // remove all.\n\t    var dests = state.pipes;\n\t    var len = state.pipesCount;\n\t    state.pipes = null;\n\t    state.pipesCount = 0;\n\t    state.flowing = false;\n\t\n\t    for (var i = 0; i < len; i++)\n\t      dests[i].emit('unpipe', this);\n\t    return this;\n\t  }\n\t\n\t  // try to find the right one.\n\t  var i = indexOf(state.pipes, dest);\n\t  if (i === -1)\n\t    return this;\n\t\n\t  state.pipes.splice(i, 1);\n\t  state.pipesCount -= 1;\n\t  if (state.pipesCount === 1)\n\t    state.pipes = state.pipes[0];\n\t\n\t  dest.emit('unpipe', this);\n\t\n\t  return this;\n\t};\n\t\n\t// set up data events if they are asked for\n\t// Ensure readable listeners eventually get something\n\tReadable.prototype.on = function(ev, fn) {\n\t  var res = Stream.prototype.on.call(this, ev, fn);\n\t\n\t  // If listening to data, and it has not explicitly been paused,\n\t  // then call resume to start the flow of data on the next tick.\n\t  if (ev === 'data' && false !== this._readableState.flowing) {\n\t    this.resume();\n\t  }\n\t\n\t  if (ev === 'readable' && this.readable) {\n\t    var state = this._readableState;\n\t    if (!state.readableListening) {\n\t      state.readableListening = true;\n\t      state.emittedReadable = false;\n\t      state.needReadable = true;\n\t      if (!state.reading) {\n\t        var self = this;\n\t        process.nextTick(function() {\n\t          debug('readable nexttick read 0');\n\t          self.read(0);\n\t        });\n\t      } else if (state.length) {\n\t        emitReadable(this, state);\n\t      }\n\t    }\n\t  }\n\t\n\t  return res;\n\t};\n\tReadable.prototype.addListener = Readable.prototype.on;\n\t\n\t// pause() and resume() are remnants of the legacy readable stream API\n\t// If the user uses them, then switch into old mode.\n\tReadable.prototype.resume = function() {\n\t  var state = this._readableState;\n\t  if (!state.flowing) {\n\t    debug('resume');\n\t    state.flowing = true;\n\t    if (!state.reading) {\n\t      debug('resume read 0');\n\t      this.read(0);\n\t    }\n\t    resume(this, state);\n\t  }\n\t  return this;\n\t};\n\t\n\tfunction resume(stream, state) {\n\t  if (!state.resumeScheduled) {\n\t    state.resumeScheduled = true;\n\t    process.nextTick(function() {\n\t      resume_(stream, state);\n\t    });\n\t  }\n\t}\n\t\n\tfunction resume_(stream, state) {\n\t  state.resumeScheduled = false;\n\t  stream.emit('resume');\n\t  flow(stream);\n\t  if (state.flowing && !state.reading)\n\t    stream.read(0);\n\t}\n\t\n\tReadable.prototype.pause = function() {\n\t  debug('call pause flowing=%j', this._readableState.flowing);\n\t  if (false !== this._readableState.flowing) {\n\t    debug('pause');\n\t    this._readableState.flowing = false;\n\t    this.emit('pause');\n\t  }\n\t  return this;\n\t};\n\t\n\tfunction flow(stream) {\n\t  var state = stream._readableState;\n\t  debug('flow', state.flowing);\n\t  if (state.flowing) {\n\t    do {\n\t      var chunk = stream.read();\n\t    } while (null !== chunk && state.flowing);\n\t  }\n\t}\n\t\n\t// wrap an old-style stream as the async data source.\n\t// This is *not* part of the readable stream interface.\n\t// It is an ugly unfortunate mess of history.\n\tReadable.prototype.wrap = function(stream) {\n\t  var state = this._readableState;\n\t  var paused = false;\n\t\n\t  var self = this;\n\t  stream.on('end', function() {\n\t    debug('wrapped end');\n\t    if (state.decoder && !state.ended) {\n\t      var chunk = state.decoder.end();\n\t      if (chunk && chunk.length)\n\t        self.push(chunk);\n\t    }\n\t\n\t    self.push(null);\n\t  });\n\t\n\t  stream.on('data', function(chunk) {\n\t    debug('wrapped data');\n\t    if (state.decoder)\n\t      chunk = state.decoder.write(chunk);\n\t    if (!chunk || !state.objectMode && !chunk.length)\n\t      return;\n\t\n\t    var ret = self.push(chunk);\n\t    if (!ret) {\n\t      paused = true;\n\t      stream.pause();\n\t    }\n\t  });\n\t\n\t  // proxy all the other methods.\n\t  // important when wrapping filters and duplexes.\n\t  for (var i in stream) {\n\t    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {\n\t      this[i] = function(method) { return function() {\n\t        return stream[method].apply(stream, arguments);\n\t      }}(i);\n\t    }\n\t  }\n\t\n\t  // proxy certain important events.\n\t  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n\t  forEach(events, function(ev) {\n\t    stream.on(ev, self.emit.bind(self, ev));\n\t  });\n\t\n\t  // when we try to consume some more bytes, simply unpause the\n\t  // underlying stream.\n\t  self._read = function(n) {\n\t    debug('wrapped _read', n);\n\t    if (paused) {\n\t      paused = false;\n\t      stream.resume();\n\t    }\n\t  };\n\t\n\t  return self;\n\t};\n\t\n\t\n\t\n\t// exposed for testing purposes only.\n\tReadable._fromList = fromList;\n\t\n\t// Pluck off n bytes from an array of buffers.\n\t// Length is the combined lengths of all the buffers in the list.\n\tfunction fromList(n, state) {\n\t  var list = state.buffer;\n\t  var length = state.length;\n\t  var stringMode = !!state.decoder;\n\t  var objectMode = !!state.objectMode;\n\t  var ret;\n\t\n\t  // nothing in the list, definitely empty.\n\t  if (list.length === 0)\n\t    return null;\n\t\n\t  if (length === 0)\n\t    ret = null;\n\t  else if (objectMode)\n\t    ret = list.shift();\n\t  else if (!n || n >= length) {\n\t    // read it all, truncate the array.\n\t    if (stringMode)\n\t      ret = list.join('');\n\t    else\n\t      ret = Buffer.concat(list, length);\n\t    list.length = 0;\n\t  } else {\n\t    // read just some of it.\n\t    if (n < list[0].length) {\n\t      // just take a part of the first list item.\n\t      // slice is the same for buffers and strings.\n\t      var buf = list[0];\n\t      ret = buf.slice(0, n);\n\t      list[0] = buf.slice(n);\n\t    } else if (n === list[0].length) {\n\t      // first list is a perfect match\n\t      ret = list.shift();\n\t    } else {\n\t      // complex case.\n\t      // we have enough to cover it, but it spans past the first buffer.\n\t      if (stringMode)\n\t        ret = '';\n\t      else\n\t        ret = new Buffer(n);\n\t\n\t      var c = 0;\n\t      for (var i = 0, l = list.length; i < l && c < n; i++) {\n\t        var buf = list[0];\n\t        var cpy = Math.min(n - c, buf.length);\n\t\n\t        if (stringMode)\n\t          ret += buf.slice(0, cpy);\n\t        else\n\t          buf.copy(ret, c, 0, cpy);\n\t\n\t        if (cpy < buf.length)\n\t          list[0] = buf.slice(cpy);\n\t        else\n\t          list.shift();\n\t\n\t        c += cpy;\n\t      }\n\t    }\n\t  }\n\t\n\t  return ret;\n\t}\n\t\n\tfunction endReadable(stream) {\n\t  var state = stream._readableState;\n\t\n\t  // If we get here before consuming all the bytes, then that is a\n\t  // bug in node.  Should never happen.\n\t  if (state.length > 0)\n\t    throw new Error('endReadable called on non-empty stream');\n\t\n\t  if (!state.endEmitted) {\n\t    state.ended = true;\n\t    process.nextTick(function() {\n\t      // Check that we didn't get one last unshift.\n\t      if (!state.endEmitted && state.length === 0) {\n\t        state.endEmitted = true;\n\t        stream.readable = false;\n\t        stream.emit('end');\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\tfunction forEach (xs, f) {\n\t  for (var i = 0, l = xs.length; i < l; i++) {\n\t    f(xs[i], i);\n\t  }\n\t}\n\t\n\tfunction indexOf (xs, x) {\n\t  for (var i = 0, l = xs.length; i < l; i++) {\n\t    if (xs[i] === x) return i;\n\t  }\n\t  return -1;\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tvar Buffer = __webpack_require__(17).Buffer;\n\t\n\tvar isBufferEncoding = Buffer.isEncoding\n\t  || function(encoding) {\n\t       switch (encoding && encoding.toLowerCase()) {\n\t         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n\t         default: return false;\n\t       }\n\t     }\n\t\n\t\n\tfunction assertEncoding(encoding) {\n\t  if (encoding && !isBufferEncoding(encoding)) {\n\t    throw new Error('Unknown encoding: ' + encoding);\n\t  }\n\t}\n\t\n\t// StringDecoder provides an interface for efficiently splitting a series of\n\t// buffers into a series of JS strings without breaking apart multi-byte\n\t// characters. CESU-8 is handled as part of the UTF-8 encoding.\n\t//\n\t// @TODO Handling all encodings inside a single object makes it very difficult\n\t// to reason about this code, so it should be split up in the future.\n\t// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n\t// points as used by CESU-8.\n\tvar StringDecoder = exports.StringDecoder = function(encoding) {\n\t  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n\t  assertEncoding(encoding);\n\t  switch (this.encoding) {\n\t    case 'utf8':\n\t      // CESU-8 represents each of Surrogate Pair by 3-bytes\n\t      this.surrogateSize = 3;\n\t      break;\n\t    case 'ucs2':\n\t    case 'utf16le':\n\t      // UTF-16 represents each of Surrogate Pair by 2-bytes\n\t      this.surrogateSize = 2;\n\t      this.detectIncompleteChar = utf16DetectIncompleteChar;\n\t      break;\n\t    case 'base64':\n\t      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n\t      this.surrogateSize = 3;\n\t      this.detectIncompleteChar = base64DetectIncompleteChar;\n\t      break;\n\t    default:\n\t      this.write = passThroughWrite;\n\t      return;\n\t  }\n\t\n\t  // Enough space to store all bytes of a single character. UTF-8 needs 4\n\t  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n\t  this.charBuffer = new Buffer(6);\n\t  // Number of bytes received for the current incomplete multi-byte character.\n\t  this.charReceived = 0;\n\t  // Number of bytes expected for the current incomplete multi-byte character.\n\t  this.charLength = 0;\n\t};\n\t\n\t\n\t// write decodes the given buffer and returns it as JS string that is\n\t// guaranteed to not contain any partial multi-byte characters. Any partial\n\t// character found at the end of the buffer is buffered up, and will be\n\t// returned when calling write again with the remaining bytes.\n\t//\n\t// Note: Converting a Buffer containing an orphan surrogate to a String\n\t// currently works, but converting a String to a Buffer (via `new Buffer`, or\n\t// Buffer#write) will replace incomplete surrogates with the unicode\n\t// replacement character. See https://codereview.chromium.org/121173009/ .\n\tStringDecoder.prototype.write = function(buffer) {\n\t  var charStr = '';\n\t  // if our last write ended with an incomplete multibyte character\n\t  while (this.charLength) {\n\t    // determine how many remaining bytes this buffer has to offer for this char\n\t    var available = (buffer.length >= this.charLength - this.charReceived) ?\n\t        this.charLength - this.charReceived :\n\t        buffer.length;\n\t\n\t    // add the new bytes to the char buffer\n\t    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n\t    this.charReceived += available;\n\t\n\t    if (this.charReceived < this.charLength) {\n\t      // still not enough chars in this buffer? wait for more ...\n\t      return '';\n\t    }\n\t\n\t    // remove bytes belonging to the current character from the buffer\n\t    buffer = buffer.slice(available, buffer.length);\n\t\n\t    // get the character that was split\n\t    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\t\n\t    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n\t    var charCode = charStr.charCodeAt(charStr.length - 1);\n\t    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n\t      this.charLength += this.surrogateSize;\n\t      charStr = '';\n\t      continue;\n\t    }\n\t    this.charReceived = this.charLength = 0;\n\t\n\t    // if there are no more bytes in this buffer, just emit our char\n\t    if (buffer.length === 0) {\n\t      return charStr;\n\t    }\n\t    break;\n\t  }\n\t\n\t  // determine and set charLength / charReceived\n\t  this.detectIncompleteChar(buffer);\n\t\n\t  var end = buffer.length;\n\t  if (this.charLength) {\n\t    // buffer the incomplete character bytes we got\n\t    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n\t    end -= this.charReceived;\n\t  }\n\t\n\t  charStr += buffer.toString(this.encoding, 0, end);\n\t\n\t  var end = charStr.length - 1;\n\t  var charCode = charStr.charCodeAt(end);\n\t  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n\t  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n\t    var size = this.surrogateSize;\n\t    this.charLength += size;\n\t    this.charReceived += size;\n\t    this.charBuffer.copy(this.charBuffer, size, 0, size);\n\t    buffer.copy(this.charBuffer, 0, 0, size);\n\t    return charStr.substring(0, end);\n\t  }\n\t\n\t  // or just emit the charStr\n\t  return charStr;\n\t};\n\t\n\t// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n\t// the end of the given buffer. If so, it sets this.charLength to the byte\n\t// length that character, and sets this.charReceived to the number of bytes\n\t// that are available for this character.\n\tStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n\t  // determine how many bytes we have to check at the end of this buffer\n\t  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\t\n\t  // Figure out if one of the last i bytes of our buffer announces an\n\t  // incomplete char.\n\t  for (; i > 0; i--) {\n\t    var c = buffer[buffer.length - i];\n\t\n\t    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\t\n\t    // 110XXXXX\n\t    if (i == 1 && c >> 5 == 0x06) {\n\t      this.charLength = 2;\n\t      break;\n\t    }\n\t\n\t    // 1110XXXX\n\t    if (i <= 2 && c >> 4 == 0x0E) {\n\t      this.charLength = 3;\n\t      break;\n\t    }\n\t\n\t    // 11110XXX\n\t    if (i <= 3 && c >> 3 == 0x1E) {\n\t      this.charLength = 4;\n\t      break;\n\t    }\n\t  }\n\t  this.charReceived = i;\n\t};\n\t\n\tStringDecoder.prototype.end = function(buffer) {\n\t  var res = '';\n\t  if (buffer && buffer.length)\n\t    res = this.write(buffer);\n\t\n\t  if (this.charReceived) {\n\t    var cr = this.charReceived;\n\t    var buf = this.charBuffer;\n\t    var enc = this.encoding;\n\t    res += buf.slice(0, cr).toString(enc);\n\t  }\n\t\n\t  return res;\n\t};\n\t\n\tfunction passThroughWrite(buffer) {\n\t  return buffer.toString(this.encoding);\n\t}\n\t\n\tfunction utf16DetectIncompleteChar(buffer) {\n\t  this.charReceived = buffer.length % 2;\n\t  this.charLength = this.charReceived ? 2 : 0;\n\t}\n\t\n\tfunction base64DetectIncompleteChar(buffer) {\n\t  this.charReceived = buffer.length % 3;\n\t  this.charLength = this.charReceived ? 3 : 0;\n\t}\n\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\t\tPapa Parse\n\t\tv4.1.2\n\t\thttps://github.com/mholt/PapaParse\n\t*/\n\t(function(global)\n\t{\n\t\t\"use strict\";\n\t\n\t\tvar IS_WORKER = !global.document && !!global.postMessage,\n\t\t\tIS_PAPA_WORKER = IS_WORKER && /(\\?|&)papaworker(=|&|$)/.test(global.location.search),\n\t\t\tLOADED_SYNC = false, AUTO_SCRIPT_PATH;\n\t\tvar workers = {}, workerIdCounter = 0;\n\t\n\t\tvar Papa = {};\n\t\n\t\tPapa.parse = CsvToJson;\n\t\tPapa.unparse = JsonToCsv;\n\t\n\t\tPapa.RECORD_SEP = String.fromCharCode(30);\n\t\tPapa.UNIT_SEP = String.fromCharCode(31);\n\t\tPapa.BYTE_ORDER_MARK = \"\\ufeff\";\n\t\tPapa.BAD_DELIMITERS = [\"\\r\", \"\\n\", \"\\\"\", Papa.BYTE_ORDER_MARK];\n\t\tPapa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker;\n\t\tPapa.SCRIPT_PATH = null;\t// Must be set by your code if you use workers and this lib is loaded asynchronously\n\t\n\t\t// Configurable chunk sizes for local and remote files, respectively\n\t\tPapa.LocalChunkSize = 1024 * 1024 * 10;\t// 10 MB\n\t\tPapa.RemoteChunkSize = 1024 * 1024 * 5;\t// 5 MB\n\t\tPapa.DefaultDelimiter = \",\";\t\t\t// Used if not specified and detection fails\n\t\n\t\t// Exposed for testing and development only\n\t\tPapa.Parser = Parser;\n\t\tPapa.ParserHandle = ParserHandle;\n\t\tPapa.NetworkStreamer = NetworkStreamer;\n\t\tPapa.FileStreamer = FileStreamer;\n\t\tPapa.StringStreamer = StringStreamer;\n\t\n\t\tif (typeof module !== 'undefined' && module.exports)\n\t\t{\n\t\t\t// Export to Node...\n\t\t\tmodule.exports = Papa;\n\t\t}\n\t\telse if (isFunction(global.define) && global.define.amd)\n\t\t{\n\t\t\t// Wireup with RequireJS\n\t\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return Papa; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// ...or as browser global\n\t\t\tglobal.Papa = Papa;\n\t\t}\n\t\n\t\tif (global.jQuery)\n\t\t{\n\t\t\tvar $ = global.jQuery;\n\t\t\t$.fn.parse = function(options)\n\t\t\t{\n\t\t\t\tvar config = options.config || {};\n\t\t\t\tvar queue = [];\n\t\n\t\t\t\tthis.each(function(idx)\n\t\t\t\t{\n\t\t\t\t\tvar supported = $(this).prop('tagName').toUpperCase() == \"INPUT\"\n\t\t\t\t\t\t\t\t\t&& $(this).attr('type').toLowerCase() == \"file\"\n\t\t\t\t\t\t\t\t\t&& global.FileReader;\n\t\n\t\t\t\t\tif (!supported || !this.files || this.files.length == 0)\n\t\t\t\t\t\treturn true;\t// continue to next input element\n\t\n\t\t\t\t\tfor (var i = 0; i < this.files.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tqueue.push({\n\t\t\t\t\t\t\tfile: this.files[i],\n\t\t\t\t\t\t\tinputElem: this,\n\t\t\t\t\t\t\tinstanceConfig: $.extend({}, config)\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\tparseNextFile();\t// begin parsing\n\t\t\t\treturn this;\t\t// maintains chainability\n\t\n\t\n\t\t\t\tfunction parseNextFile()\n\t\t\t\t{\n\t\t\t\t\tif (queue.length == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (isFunction(options.complete))\n\t\t\t\t\t\t\toptions.complete();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar f = queue[0];\n\t\n\t\t\t\t\tif (isFunction(options.before))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar returned = options.before(f.file, f.inputElem);\n\t\n\t\t\t\t\t\tif (typeof returned === 'object')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (returned.action == \"abort\")\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror(\"AbortError\", f.file, f.inputElem, returned.reason);\n\t\t\t\t\t\t\t\treturn;\t// Aborts all queued files immediately\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (returned.action == \"skip\")\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfileComplete();\t// parse the next file in the queue, if any\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (typeof returned.config === 'object')\n\t\t\t\t\t\t\t\tf.instanceConfig = $.extend(f.instanceConfig, returned.config);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (returned == \"skip\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfileComplete();\t// parse the next file in the queue, if any\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Wrap up the user's complete callback, if any, so that ours also gets executed\n\t\t\t\t\tvar userCompleteFunc = f.instanceConfig.complete;\n\t\t\t\t\tf.instanceConfig.complete = function(results)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (isFunction(userCompleteFunc))\n\t\t\t\t\t\t\tuserCompleteFunc(results, f.file, f.inputElem);\n\t\t\t\t\t\tfileComplete();\n\t\t\t\t\t};\n\t\n\t\t\t\t\tPapa.parse(f.file, f.instanceConfig);\n\t\t\t\t}\n\t\n\t\t\t\tfunction error(name, file, elem, reason)\n\t\t\t\t{\n\t\t\t\t\tif (isFunction(options.error))\n\t\t\t\t\t\toptions.error({name: name}, file, elem, reason);\n\t\t\t\t}\n\t\n\t\t\t\tfunction fileComplete()\n\t\t\t\t{\n\t\t\t\t\tqueue.splice(0, 1);\n\t\t\t\t\tparseNextFile();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\n\t\tif (IS_PAPA_WORKER)\n\t\t{\n\t\t\tglobal.onmessage = workerThreadReceivedMessage;\n\t\t}\n\t\telse if (Papa.WORKERS_SUPPORTED)\n\t\t{\n\t\t\tAUTO_SCRIPT_PATH = getScriptPath();\n\t\n\t\t\t// Check if the script was loaded synchronously\n\t\t\tif (!document.body)\n\t\t\t{\n\t\t\t\t// Body doesn't exist yet, must be synchronous\n\t\t\t\tLOADED_SYNC = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdocument.addEventListener('DOMContentLoaded', function () {\n\t\t\t\t\tLOADED_SYNC = true;\n\t\t\t\t}, true);\n\t\t\t}\n\t\t}\n\t\n\t\n\t\n\t\n\t\tfunction CsvToJson(_input, _config)\n\t\t{\n\t\t\t_config = _config || {};\n\t\n\t\t\tif (_config.worker && Papa.WORKERS_SUPPORTED)\n\t\t\t{\n\t\t\t\tvar w = newWorker();\n\t\n\t\t\t\tw.userStep = _config.step;\n\t\t\t\tw.userChunk = _config.chunk;\n\t\t\t\tw.userComplete = _config.complete;\n\t\t\t\tw.userError = _config.error;\n\t\n\t\t\t\t_config.step = isFunction(_config.step);\n\t\t\t\t_config.chunk = isFunction(_config.chunk);\n\t\t\t\t_config.complete = isFunction(_config.complete);\n\t\t\t\t_config.error = isFunction(_config.error);\n\t\t\t\tdelete _config.worker;\t// prevent infinite loop\n\t\n\t\t\t\tw.postMessage({\n\t\t\t\t\tinput: _input,\n\t\t\t\t\tconfig: _config,\n\t\t\t\t\tworkerId: w.id\n\t\t\t\t});\n\t\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar streamer = null;\n\t\t\tif (typeof _input === 'string')\n\t\t\t{\n\t\t\t\tif (_config.download)\n\t\t\t\t\tstreamer = new NetworkStreamer(_config);\n\t\t\t\telse\n\t\t\t\t\tstreamer = new StringStreamer(_config);\n\t\t\t}\n\t\t\telse if ((global.File && _input instanceof File) || _input instanceof Object)\t// ...Safari. (see issue #106)\n\t\t\t\tstreamer = new FileStreamer(_config);\n\t\n\t\t\treturn streamer.stream(_input);\n\t\t}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\tfunction JsonToCsv(_input, _config)\n\t\t{\n\t\t\tvar _output = \"\";\n\t\t\tvar _fields = [];\n\t\n\t\t\t// Default configuration\n\t\n\t\t\t/** whether to surround every datum with quotes */\n\t\t\tvar _quotes = false;\n\t\n\t\t\t/** delimiting character */\n\t\t\tvar _delimiter = \",\";\n\t\n\t\t\t/** newline character(s) */\n\t\t\tvar _newline = \"\\r\\n\";\n\t\n\t\t\tunpackConfig();\n\t\n\t\t\tif (typeof _input === 'string')\n\t\t\t\t_input = JSON.parse(_input);\n\t\n\t\t\tif (_input instanceof Array)\n\t\t\t{\n\t\t\t\tif (!_input.length || _input[0] instanceof Array)\n\t\t\t\t\treturn serialize(null, _input);\n\t\t\t\telse if (typeof _input[0] === 'object')\n\t\t\t\t\treturn serialize(objectKeys(_input[0]), _input);\n\t\t\t}\n\t\t\telse if (typeof _input === 'object')\n\t\t\t{\n\t\t\t\tif (typeof _input.data === 'string')\n\t\t\t\t\t_input.data = JSON.parse(_input.data);\n\t\n\t\t\t\tif (_input.data instanceof Array)\n\t\t\t\t{\n\t\t\t\t\tif (!_input.fields)\n\t\t\t\t\t\t_input.fields = _input.data[0] instanceof Array\n\t\t\t\t\t\t\t\t\t\t? _input.fields\n\t\t\t\t\t\t\t\t\t\t: objectKeys(_input.data[0]);\n\t\n\t\t\t\t\tif (!(_input.data[0] instanceof Array) && typeof _input.data[0] !== 'object')\n\t\t\t\t\t\t_input.data = [_input.data];\t// handles input like [1,2,3] or [\"asdf\"]\n\t\t\t\t}\n\t\n\t\t\t\treturn serialize(_input.fields || [], _input.data || []);\n\t\t\t}\n\t\n\t\t\t// Default (any valid paths should return before this)\n\t\t\tthrow \"exception: Unable to serialize unrecognized input\";\n\t\n\t\n\t\t\tfunction unpackConfig()\n\t\t\t{\n\t\t\t\tif (typeof _config !== 'object')\n\t\t\t\t\treturn;\n\t\n\t\t\t\tif (typeof _config.delimiter === 'string'\n\t\t\t\t\t&& _config.delimiter.length == 1\n\t\t\t\t\t&& Papa.BAD_DELIMITERS.indexOf(_config.delimiter) == -1)\n\t\t\t\t{\n\t\t\t\t\t_delimiter = _config.delimiter;\n\t\t\t\t}\n\t\n\t\t\t\tif (typeof _config.quotes === 'boolean'\n\t\t\t\t\t|| _config.quotes instanceof Array)\n\t\t\t\t\t_quotes = _config.quotes;\n\t\n\t\t\t\tif (typeof _config.newline === 'string')\n\t\t\t\t\t_newline = _config.newline;\n\t\t\t}\n\t\n\t\n\t\t\t/** Turns an object's keys into an array */\n\t\t\tfunction objectKeys(obj)\n\t\t\t{\n\t\t\t\tif (typeof obj !== 'object')\n\t\t\t\t\treturn [];\n\t\t\t\tvar keys = [];\n\t\t\t\tfor (var key in obj)\n\t\t\t\t\tkeys.push(key);\n\t\t\t\treturn keys;\n\t\t\t}\n\t\n\t\t\t/** The double for loop that iterates the data and writes out a CSV string including header row */\n\t\t\tfunction serialize(fields, data)\n\t\t\t{\n\t\t\t\tvar csv = \"\";\n\t\n\t\t\t\tif (typeof fields === 'string')\n\t\t\t\t\tfields = JSON.parse(fields);\n\t\t\t\tif (typeof data === 'string')\n\t\t\t\t\tdata = JSON.parse(data);\n\t\n\t\t\t\tvar hasHeader = fields instanceof Array && fields.length > 0;\n\t\t\t\tvar dataKeyedByField = !(data[0] instanceof Array);\n\t\n\t\t\t\t// If there a header row, write it first\n\t\t\t\tif (hasHeader)\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < fields.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (i > 0)\n\t\t\t\t\t\t\tcsv += _delimiter;\n\t\t\t\t\t\tcsv += safe(fields[i], i);\n\t\t\t\t\t}\n\t\t\t\t\tif (data.length > 0)\n\t\t\t\t\t\tcsv += _newline;\n\t\t\t\t}\n\t\n\t\t\t\t// Then write out the data\n\t\t\t\tfor (var row = 0; row < data.length; row++)\n\t\t\t\t{\n\t\t\t\t\tvar maxCol = hasHeader ? fields.length : data[row].length;\n\t\n\t\t\t\t\tfor (var col = 0; col < maxCol; col++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (col > 0)\n\t\t\t\t\t\t\tcsv += _delimiter;\n\t\t\t\t\t\tvar colIdx = hasHeader && dataKeyedByField ? fields[col] : col;\n\t\t\t\t\t\tcsv += safe(data[row][colIdx], col);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (row < data.length - 1)\n\t\t\t\t\t\tcsv += _newline;\n\t\t\t\t}\n\t\n\t\t\t\treturn csv;\n\t\t\t}\n\t\n\t\t\t/** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */\n\t\t\tfunction safe(str, col)\n\t\t\t{\n\t\t\t\tif (typeof str === \"undefined\" || str === null)\n\t\t\t\t\treturn \"\";\n\t\n\t\t\t\tstr = str.toString().replace(/\"/g, '\"\"');\n\t\n\t\t\t\tvar needsQuotes = (typeof _quotes === 'boolean' && _quotes)\n\t\t\t\t\t\t\t\t|| (_quotes instanceof Array && _quotes[col])\n\t\t\t\t\t\t\t\t|| hasAny(str, Papa.BAD_DELIMITERS)\n\t\t\t\t\t\t\t\t|| str.indexOf(_delimiter) > -1\n\t\t\t\t\t\t\t\t|| str.charAt(0) == ' '\n\t\t\t\t\t\t\t\t|| str.charAt(str.length - 1) == ' ';\n\t\n\t\t\t\treturn needsQuotes ? '\"' + str + '\"' : str;\n\t\t\t}\n\t\n\t\t\tfunction hasAny(str, substrings)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < substrings.length; i++)\n\t\t\t\t\tif (str.indexOf(substrings[i]) > -1)\n\t\t\t\t\t\treturn true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\n\t\t/** ChunkStreamer is the base prototype for various streamer implementations. */\n\t\tfunction ChunkStreamer(config)\n\t\t{\n\t\t\tthis._handle = null;\n\t\t\tthis._paused = false;\n\t\t\tthis._finished = false;\n\t\t\tthis._input = null;\n\t\t\tthis._baseIndex = 0;\n\t\t\tthis._partialLine = \"\";\n\t\t\tthis._rowCount = 0;\n\t\t\tthis._start = 0;\n\t\t\tthis._nextChunk = null;\n\t\t\tthis.isFirstChunk = true;\n\t\t\tthis._completeResults = {\n\t\t\t\tdata: [],\n\t\t\t\terrors: [],\n\t\t\t\tmeta: {}\n\t\t\t};\n\t\t\treplaceConfig.call(this, config);\n\t\n\t\t\tthis.parseChunk = function(chunk)\n\t\t\t{\n\t\t\t\t// First chunk pre-processing\n\t\t\t\tif (this.isFirstChunk && isFunction(this._config.beforeFirstChunk))\n\t\t\t\t{\n\t\t\t\t\tvar modifiedChunk = this._config.beforeFirstChunk(chunk);\n\t\t\t\t\tif (modifiedChunk !== undefined)\n\t\t\t\t\t\tchunk = modifiedChunk;\n\t\t\t\t}\n\t\t\t\tthis.isFirstChunk = false;\n\t\n\t\t\t\t// Rejoin the line we likely just split in two by chunking the file\n\t\t\t\tvar aggregate = this._partialLine + chunk;\n\t\t\t\tthis._partialLine = \"\";\n\t\n\t\t\t\tvar results = this._handle.parse(aggregate, this._baseIndex, !this._finished);\n\t\t\t\t\n\t\t\t\tif (this._handle.paused() || this._handle.aborted())\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tvar lastIndex = results.meta.cursor;\n\t\t\t\t\n\t\t\t\tif (!this._finished)\n\t\t\t\t{\n\t\t\t\t\tthis._partialLine = aggregate.substring(lastIndex - this._baseIndex);\n\t\t\t\t\tthis._baseIndex = lastIndex;\n\t\t\t\t}\n\t\n\t\t\t\tif (results && results.data)\n\t\t\t\t\tthis._rowCount += results.data.length;\n\t\n\t\t\t\tvar finishedIncludingPreview = this._finished || (this._config.preview && this._rowCount >= this._config.preview);\n\t\n\t\t\t\tif (IS_PAPA_WORKER)\n\t\t\t\t{\n\t\t\t\t\tglobal.postMessage({\n\t\t\t\t\t\tresults: results,\n\t\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\t\tfinished: finishedIncludingPreview\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse if (isFunction(this._config.chunk))\n\t\t\t\t{\n\t\t\t\t\tthis._config.chunk(results, this._handle);\n\t\t\t\t\tif (this._paused)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tresults = undefined;\n\t\t\t\t\tthis._completeResults = undefined;\n\t\t\t\t}\n\t\n\t\t\t\tif (!this._config.step && !this._config.chunk) {\n\t\t\t\t\tthis._completeResults.data = this._completeResults.data.concat(results.data);\n\t\t\t\t\tthis._completeResults.errors = this._completeResults.errors.concat(results.errors);\n\t\t\t\t\tthis._completeResults.meta = results.meta;\n\t\t\t\t}\n\t\n\t\t\t\tif (finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted))\n\t\t\t\t\tthis._config.complete(this._completeResults);\n\t\n\t\t\t\tif (!finishedIncludingPreview && (!results || !results.meta.paused))\n\t\t\t\t\tthis._nextChunk();\n\t\n\t\t\t\treturn results;\n\t\t\t};\n\t\n\t\t\tthis._sendError = function(error)\n\t\t\t{\n\t\t\t\tif (isFunction(this._config.error))\n\t\t\t\t\tthis._config.error(error);\n\t\t\t\telse if (IS_PAPA_WORKER && this._config.error)\n\t\t\t\t{\n\t\t\t\t\tglobal.postMessage({\n\t\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tfinished: false\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction replaceConfig(config)\n\t\t\t{\n\t\t\t\t// Deep-copy the config so we can edit it\n\t\t\t\tvar configCopy = copy(config);\n\t\t\t\tconfigCopy.chunkSize = parseInt(configCopy.chunkSize);\t// parseInt VERY important so we don't concatenate strings!\n\t\t\t\tif (!config.step && !config.chunk)\n\t\t\t\t\tconfigCopy.chunkSize = null;  // disable Range header if not streaming; bad values break IIS - see issue #196\n\t\t\t\tthis._handle = new ParserHandle(configCopy);\n\t\t\t\tthis._handle.streamer = this;\n\t\t\t\tthis._config = configCopy;\t// persist the copy to the caller\n\t\t\t}\n\t\t}\n\t\n\t\n\t\tfunction NetworkStreamer(config)\n\t\t{\n\t\t\tconfig = config || {};\n\t\t\tif (!config.chunkSize)\n\t\t\t\tconfig.chunkSize = Papa.RemoteChunkSize;\n\t\t\tChunkStreamer.call(this, config);\n\t\n\t\t\tvar xhr;\n\t\n\t\t\tif (IS_WORKER)\n\t\t\t{\n\t\t\t\tthis._nextChunk = function()\n\t\t\t\t{\n\t\t\t\t\tthis._readChunk();\n\t\t\t\t\tthis._chunkLoaded();\n\t\t\t\t};\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis._nextChunk = function()\n\t\t\t\t{\n\t\t\t\t\tthis._readChunk();\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\tthis.stream = function(url)\n\t\t\t{\n\t\t\t\tthis._input = url;\n\t\t\t\tthis._nextChunk();\t// Starts streaming\n\t\t\t};\n\t\n\t\t\tthis._readChunk = function()\n\t\t\t{\n\t\t\t\tif (this._finished)\n\t\t\t\t{\n\t\t\t\t\tthis._chunkLoaded();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\txhr = new XMLHttpRequest();\n\t\t\t\t\n\t\t\t\tif (!IS_WORKER)\n\t\t\t\t{\n\t\t\t\t\txhr.onload = bindFunction(this._chunkLoaded, this);\n\t\t\t\t\txhr.onerror = bindFunction(this._chunkError, this);\n\t\t\t\t}\n\t\n\t\t\t\txhr.open(\"GET\", this._input, !IS_WORKER);\n\t\t\t\t\n\t\t\t\tif (this._config.chunkSize)\n\t\t\t\t{\n\t\t\t\t\tvar end = this._start + this._config.chunkSize - 1;\t// minus one because byte range is inclusive\n\t\t\t\t\txhr.setRequestHeader(\"Range\", \"bytes=\"+this._start+\"-\"+end);\n\t\t\t\t\txhr.setRequestHeader(\"If-None-Match\", \"webkit-no-cache\"); // https://bugs.webkit.org/show_bug.cgi?id=82672\n\t\t\t\t}\n\t\n\t\t\t\ttry {\n\t\t\t\t\txhr.send();\n\t\t\t\t}\n\t\t\t\tcatch (err) {\n\t\t\t\t\tthis._chunkError(err.message);\n\t\t\t\t}\n\t\n\t\t\t\tif (IS_WORKER && xhr.status == 0)\n\t\t\t\t\tthis._chunkError();\n\t\t\t\telse\n\t\t\t\t\tthis._start += this._config.chunkSize;\n\t\t\t}\n\t\n\t\t\tthis._chunkLoaded = function()\n\t\t\t{\n\t\t\t\tif (xhr.readyState != 4)\n\t\t\t\t\treturn;\n\t\n\t\t\t\tif (xhr.status < 200 || xhr.status >= 400)\n\t\t\t\t{\n\t\t\t\t\tthis._chunkError();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tthis._finished = !this._config.chunkSize || this._start > getFileSize(xhr);\n\t\t\t\tthis.parseChunk(xhr.responseText);\n\t\t\t}\n\t\n\t\t\tthis._chunkError = function(errorMessage)\n\t\t\t{\n\t\t\t\tvar errorText = xhr.statusText || errorMessage;\n\t\t\t\tthis._sendError(errorText);\n\t\t\t}\n\t\n\t\t\tfunction getFileSize(xhr)\n\t\t\t{\n\t\t\t\tvar contentRange = xhr.getResponseHeader(\"Content-Range\");\n\t\t\t\treturn parseInt(contentRange.substr(contentRange.lastIndexOf(\"/\") + 1));\n\t\t\t}\n\t\t}\n\t\tNetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\t\tNetworkStreamer.prototype.constructor = NetworkStreamer;\n\t\n\t\n\t\tfunction FileStreamer(config)\n\t\t{\n\t\t\tconfig = config || {};\n\t\t\tif (!config.chunkSize)\n\t\t\t\tconfig.chunkSize = Papa.LocalChunkSize;\n\t\t\tChunkStreamer.call(this, config);\n\t\n\t\t\tvar reader, slice;\n\t\n\t\t\t// FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862\n\t\t\t// But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76\n\t\t\tvar usingAsyncReader = typeof FileReader !== 'undefined';\t// Safari doesn't consider it a function - see issue #105\n\t\n\t\t\tthis.stream = function(file)\n\t\t\t{\n\t\t\t\tthis._input = file;\n\t\t\t\tslice = file.slice || file.webkitSlice || file.mozSlice;\n\t\n\t\t\t\tif (usingAsyncReader)\n\t\t\t\t{\n\t\t\t\t\treader = new FileReader();\t\t// Preferred method of reading files, even in workers\n\t\t\t\t\treader.onload = bindFunction(this._chunkLoaded, this);\n\t\t\t\t\treader.onerror = bindFunction(this._chunkError, this);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treader = new FileReaderSync();\t// Hack for running in a web worker in Firefox\n\t\n\t\t\t\tthis._nextChunk();\t// Starts streaming\n\t\t\t};\n\t\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tif (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))\n\t\t\t\t\tthis._readChunk();\n\t\t\t}\n\t\n\t\t\tthis._readChunk = function()\n\t\t\t{\n\t\t\t\tvar input = this._input;\n\t\t\t\tif (this._config.chunkSize)\n\t\t\t\t{\n\t\t\t\t\tvar end = Math.min(this._start + this._config.chunkSize, this._input.size);\n\t\t\t\t\tinput = slice.call(input, this._start, end);\n\t\t\t\t}\n\t\t\t\tvar txt = reader.readAsText(input, this._config.encoding);\n\t\t\t\tif (!usingAsyncReader)\n\t\t\t\t\tthis._chunkLoaded({ target: { result: txt } });\t// mimic the async signature\n\t\t\t}\n\t\n\t\t\tthis._chunkLoaded = function(event)\n\t\t\t{\n\t\t\t\t// Very important to increment start each time before handling results\n\t\t\t\tthis._start += this._config.chunkSize;\n\t\t\t\tthis._finished = !this._config.chunkSize || this._start >= this._input.size;\n\t\t\t\tthis.parseChunk(event.target.result);\n\t\t\t}\n\t\n\t\t\tthis._chunkError = function()\n\t\t\t{\n\t\t\t\tthis._sendError(reader.error);\n\t\t\t}\n\t\n\t\t}\n\t\tFileStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\t\tFileStreamer.prototype.constructor = FileStreamer;\n\t\n\t\n\t\tfunction StringStreamer(config)\n\t\t{\n\t\t\tconfig = config || {};\n\t\t\tChunkStreamer.call(this, config);\n\t\n\t\t\tvar string;\n\t\t\tvar remaining;\n\t\t\tthis.stream = function(s)\n\t\t\t{\n\t\t\t\tstring = s;\n\t\t\t\tremaining = s;\n\t\t\t\treturn this._nextChunk();\n\t\t\t}\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tif (this._finished) return;\n\t\t\t\tvar size = this._config.chunkSize;\n\t\t\t\tvar chunk = size ? remaining.substr(0, size) : remaining;\n\t\t\t\tremaining = size ? remaining.substr(size) : '';\n\t\t\t\tthis._finished = !remaining;\n\t\t\t\treturn this.parseChunk(chunk);\n\t\t\t}\n\t\t}\n\t\tStringStreamer.prototype = Object.create(StringStreamer.prototype);\n\t\tStringStreamer.prototype.constructor = StringStreamer;\n\t\n\t\n\t\n\t\t// Use one ParserHandle per entire CSV file or string\n\t\tfunction ParserHandle(_config)\n\t\t{\n\t\t\t// One goal is to minimize the use of regular expressions...\n\t\t\tvar FLOAT = /^\\s*-?(\\d*\\.?\\d+|\\d+\\.?\\d*)(e[-+]?\\d+)?\\s*$/i;\n\t\n\t\t\tvar self = this;\n\t\t\tvar _stepCounter = 0;\t// Number of times step was called (number of rows parsed)\n\t\t\tvar _input;\t\t\t\t// The input being parsed\n\t\t\tvar _parser;\t\t\t// The core parser being used\n\t\t\tvar _paused = false;\t// Whether we are paused or not\n\t\t\tvar _aborted = false;   // Whether the parser has aborted or not\n\t\t\tvar _delimiterError;\t// Temporary state between delimiter detection and processing results\n\t\t\tvar _fields = [];\t\t// Fields are from the header row of the input, if there is one\n\t\t\tvar _results = {\t\t// The last results returned from the parser\n\t\t\t\tdata: [],\n\t\t\t\terrors: [],\n\t\t\t\tmeta: {}\n\t\t\t};\n\t\n\t\t\tif (isFunction(_config.step))\n\t\t\t{\n\t\t\t\tvar userStep = _config.step;\n\t\t\t\t_config.step = function(results)\n\t\t\t\t{\n\t\t\t\t\t_results = results;\n\t\n\t\t\t\t\tif (needsHeaderRow())\n\t\t\t\t\t\tprocessResults();\n\t\t\t\t\telse\t// only call user's step function after header row\n\t\t\t\t\t{\n\t\t\t\t\t\tprocessResults();\n\t\n\t\t\t\t\t\t// It's possbile that this line was empty and there's no row here after all\n\t\t\t\t\t\tif (_results.data.length == 0)\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t_stepCounter += results.data.length;\n\t\t\t\t\t\tif (_config.preview && _stepCounter > _config.preview)\n\t\t\t\t\t\t\t_parser.abort();\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tuserStep(_results, self);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t/**\n\t\t\t * Parses input. Most users won't need, and shouldn't mess with, the baseIndex\n\t\t\t * and ignoreLastRow parameters. They are used by streamers (wrapper functions)\n\t\t\t * when an input comes in multiple chunks, like from a file.\n\t\t\t */\n\t\t\tthis.parse = function(input, baseIndex, ignoreLastRow)\n\t\t\t{\n\t\t\t\tif (!_config.newline)\n\t\t\t\t\t_config.newline = guessLineEndings(input);\n\t\n\t\t\t\t_delimiterError = false;\n\t\t\t\tif (!_config.delimiter)\n\t\t\t\t{\n\t\t\t\t\tvar delimGuess = guessDelimiter(input);\n\t\t\t\t\tif (delimGuess.successful)\n\t\t\t\t\t\t_config.delimiter = delimGuess.bestDelimiter;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t_delimiterError = true;\t// add error after parsing (otherwise it would be overwritten)\n\t\t\t\t\t\t_config.delimiter = Papa.DefaultDelimiter;\n\t\t\t\t\t}\n\t\t\t\t\t_results.meta.delimiter = _config.delimiter;\n\t\t\t\t}\n\t\n\t\t\t\tvar parserConfig = copy(_config);\n\t\t\t\tif (_config.preview && _config.header)\n\t\t\t\t\tparserConfig.preview++;\t// to compensate for header row\n\t\n\t\t\t\t_input = input;\n\t\t\t\t_parser = new Parser(parserConfig);\n\t\t\t\t_results = _parser.parse(_input, baseIndex, ignoreLastRow);\n\t\t\t\tprocessResults();\n\t\t\t\treturn _paused ? { meta: { paused: true } } : (_results || { meta: { paused: false } });\n\t\t\t};\n\t\n\t\t\tthis.paused = function()\n\t\t\t{\n\t\t\t\treturn _paused;\n\t\t\t};\n\t\n\t\t\tthis.pause = function()\n\t\t\t{\n\t\t\t\t_paused = true;\n\t\t\t\t_parser.abort();\n\t\t\t\t_input = _input.substr(_parser.getCharIndex());\n\t\t\t};\n\t\n\t\t\tthis.resume = function()\n\t\t\t{\n\t\t\t\t_paused = false;\n\t\t\t\tself.streamer.parseChunk(_input);\n\t\t\t};\n\t\n\t\t\tthis.aborted = function () {\n\t\t\t\treturn _aborted;\n\t\t\t}\n\t\n\t\t\tthis.abort = function()\n\t\t\t{\n\t\t\t\t_aborted = true;\n\t\t\t\t_parser.abort();\n\t\t\t\t_results.meta.aborted = true;\n\t\t\t\tif (isFunction(_config.complete))\n\t\t\t\t\t_config.complete(_results);\n\t\t\t\t_input = \"\";\n\t\t\t};\n\t\n\t\t\tfunction processResults()\n\t\t\t{\n\t\t\t\tif (_results && _delimiterError)\n\t\t\t\t{\n\t\t\t\t\taddError(\"Delimiter\", \"UndetectableDelimiter\", \"Unable to auto-detect delimiting character; defaulted to '\"+Papa.DefaultDelimiter+\"'\");\n\t\t\t\t\t_delimiterError = false;\n\t\t\t\t}\n\t\n\t\t\t\tif (_config.skipEmptyLines)\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < _results.data.length; i++)\n\t\t\t\t\t\tif (_results.data[i].length == 1 && _results.data[i][0] == \"\")\n\t\t\t\t\t\t\t_results.data.splice(i--, 1);\n\t\t\t\t}\n\t\n\t\t\t\tif (needsHeaderRow())\n\t\t\t\t\tfillHeaderFields();\n\t\n\t\t\t\treturn applyHeaderAndDynamicTyping();\n\t\t\t}\n\t\n\t\t\tfunction needsHeaderRow()\n\t\t\t{\n\t\t\t\treturn _config.header && _fields.length == 0;\n\t\t\t}\n\t\n\t\t\tfunction fillHeaderFields()\n\t\t\t{\n\t\t\t\tif (!_results)\n\t\t\t\t\treturn;\n\t\t\t\tfor (var i = 0; needsHeaderRow() && i < _results.data.length; i++)\n\t\t\t\t\tfor (var j = 0; j < _results.data[i].length; j++)\n\t\t\t\t\t\t_fields.push(_results.data[i][j]);\n\t\t\t\t_results.data.splice(0, 1);\n\t\t\t}\n\t\n\t\t\tfunction applyHeaderAndDynamicTyping()\n\t\t\t{\n\t\t\t\tif (!_results || (!_config.header && !_config.dynamicTyping))\n\t\t\t\t\treturn _results;\n\t\n\t\t\t\tfor (var i = 0; i < _results.data.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar row = {};\n\t\n\t\t\t\t\tfor (var j = 0; j < _results.data[i].length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (_config.dynamicTyping)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar value = _results.data[i][j];\n\t\t\t\t\t\t\tif (value == \"true\" || value == \"TRUE\")\n\t\t\t\t\t\t\t\t_results.data[i][j] = true;\n\t\t\t\t\t\t\telse if (value == \"false\" || value == \"FALSE\")\n\t\t\t\t\t\t\t\t_results.data[i][j] = false;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t_results.data[i][j] = tryParseFloat(value);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif (_config.header)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (j >= _fields.length)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (!row[\"__parsed_extra\"])\n\t\t\t\t\t\t\t\t\trow[\"__parsed_extra\"] = [];\n\t\t\t\t\t\t\t\trow[\"__parsed_extra\"].push(_results.data[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\trow[_fields[j]] = _results.data[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (_config.header)\n\t\t\t\t\t{\n\t\t\t\t\t\t_results.data[i] = row;\n\t\t\t\t\t\tif (j > _fields.length)\n\t\t\t\t\t\t\taddError(\"FieldMismatch\", \"TooManyFields\", \"Too many fields: expected \" + _fields.length + \" fields but parsed \" + j, i);\n\t\t\t\t\t\telse if (j < _fields.length)\n\t\t\t\t\t\t\taddError(\"FieldMismatch\", \"TooFewFields\", \"Too few fields: expected \" + _fields.length + \" fields but parsed \" + j, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (_config.header && _results.meta)\n\t\t\t\t\t_results.meta.fields = _fields;\n\t\t\t\treturn _results;\n\t\t\t}\n\t\n\t\t\tfunction guessDelimiter(input)\n\t\t\t{\n\t\t\t\tvar delimChoices = [\",\", \"\\t\", \"|\", \";\", Papa.RECORD_SEP, Papa.UNIT_SEP];\n\t\t\t\tvar bestDelim, bestDelta, fieldCountPrevRow;\n\t\n\t\t\t\tfor (var i = 0; i < delimChoices.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar delim = delimChoices[i];\n\t\t\t\t\tvar delta = 0, avgFieldCount = 0;\n\t\t\t\t\tfieldCountPrevRow = undefined;\n\t\n\t\t\t\t\tvar preview = new Parser({\n\t\t\t\t\t\tdelimiter: delim,\n\t\t\t\t\t\tpreview: 10\n\t\t\t\t\t}).parse(input);\n\t\n\t\t\t\t\tfor (var j = 0; j < preview.data.length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar fieldCount = preview.data[j].length;\n\t\t\t\t\t\tavgFieldCount += fieldCount;\n\t\n\t\t\t\t\t\tif (typeof fieldCountPrevRow === 'undefined')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfieldCountPrevRow = fieldCount;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (fieldCount > 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdelta += Math.abs(fieldCount - fieldCountPrevRow);\n\t\t\t\t\t\t\tfieldCountPrevRow = fieldCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (preview.data.length > 0)\n\t\t\t\t\t\tavgFieldCount /= preview.data.length;\n\t\n\t\t\t\t\tif ((typeof bestDelta === 'undefined' || delta < bestDelta)\n\t\t\t\t\t\t&& avgFieldCount > 1.99)\n\t\t\t\t\t{\n\t\t\t\t\t\tbestDelta = delta;\n\t\t\t\t\t\tbestDelim = delim;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t_config.delimiter = bestDelim;\n\t\n\t\t\t\treturn {\n\t\t\t\t\tsuccessful: !!bestDelim,\n\t\t\t\t\tbestDelimiter: bestDelim\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction guessLineEndings(input)\n\t\t\t{\n\t\t\t\tinput = input.substr(0, 1024*1024);\t// max length 1 MB\n\t\n\t\t\t\tvar r = input.split('\\r');\n\t\n\t\t\t\tif (r.length == 1)\n\t\t\t\t\treturn '\\n';\n\t\n\t\t\t\tvar numWithN = 0;\n\t\t\t\tfor (var i = 0; i < r.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (r[i][0] == '\\n')\n\t\t\t\t\t\tnumWithN++;\n\t\t\t\t}\n\t\n\t\t\t\treturn numWithN >= r.length / 2 ? '\\r\\n' : '\\r';\n\t\t\t}\n\t\n\t\t\tfunction tryParseFloat(val)\n\t\t\t{\n\t\t\t\tvar isNumber = FLOAT.test(val);\n\t\t\t\treturn isNumber ? parseFloat(val) : val;\n\t\t\t}\n\t\n\t\t\tfunction addError(type, code, msg, row)\n\t\t\t{\n\t\t\t\t_results.errors.push({\n\t\t\t\t\ttype: type,\n\t\t\t\t\tcode: code,\n\t\t\t\t\tmessage: msg,\n\t\t\t\t\trow: row\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\n\t\n\t\n\t\n\t\n\t\t/** The core parser implements speedy and correct CSV parsing */\n\t\tfunction Parser(config)\n\t\t{\n\t\t\t// Unpack the config object\n\t\t\tconfig = config || {};\n\t\t\tvar delim = config.delimiter;\n\t\t\tvar newline = config.newline;\n\t\t\tvar comments = config.comments;\n\t\t\tvar step = config.step;\n\t\t\tvar preview = config.preview;\n\t\t\tvar fastMode = config.fastMode;\n\t\n\t\t\t// Delimiter must be valid\n\t\t\tif (typeof delim !== 'string'\n\t\t\t\t|| Papa.BAD_DELIMITERS.indexOf(delim) > -1)\n\t\t\t\tdelim = \",\";\n\t\n\t\t\t// Comment character must be valid\n\t\t\tif (comments === delim)\n\t\t\t\tthrow \"Comment character same as delimiter\";\n\t\t\telse if (comments === true)\n\t\t\t\tcomments = \"#\";\n\t\t\telse if (typeof comments !== 'string'\n\t\t\t\t|| Papa.BAD_DELIMITERS.indexOf(comments) > -1)\n\t\t\t\tcomments = false;\n\t\n\t\t\t// Newline must be valid: \\r, \\n, or \\r\\n\n\t\t\tif (newline != '\\n' && newline != '\\r' && newline != '\\r\\n')\n\t\t\t\tnewline = '\\n';\n\t\n\t\t\t// We're gonna need these at the Parser scope\n\t\t\tvar cursor = 0;\n\t\t\tvar aborted = false;\n\t\n\t\t\tthis.parse = function(input, baseIndex, ignoreLastRow)\n\t\t\t{\n\t\t\t\t// For some reason, in Chrome, this speeds things up (!?)\n\t\t\t\tif (typeof input !== 'string')\n\t\t\t\t\tthrow \"Input must be a string\";\n\t\n\t\t\t\t// We don't need to compute some of these every time parse() is called,\n\t\t\t\t// but having them in a more local scope seems to perform better\n\t\t\t\tvar inputLen = input.length,\n\t\t\t\t\tdelimLen = delim.length,\n\t\t\t\t\tnewlineLen = newline.length,\n\t\t\t\t\tcommentsLen = comments.length;\n\t\t\t\tvar stepIsFunction = typeof step === 'function';\n\t\n\t\t\t\t// Establish starting state\n\t\t\t\tcursor = 0;\n\t\t\t\tvar data = [], errors = [], row = [], lastCursor = 0;\n\t\n\t\t\t\tif (!input)\n\t\t\t\t\treturn returnable();\n\t\n\t\t\t\tif (fastMode || (fastMode !== false && input.indexOf('\"') === -1))\n\t\t\t\t{\n\t\t\t\t\tvar rows = input.split(newline);\n\t\t\t\t\tfor (var i = 0; i < rows.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar row = rows[i];\n\t\t\t\t\t\tcursor += row.length;\n\t\t\t\t\t\tif (i !== rows.length - 1)\n\t\t\t\t\t\t\tcursor += newline.length;\n\t\t\t\t\t\telse if (ignoreLastRow)\n\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t\tif (comments && row.substr(0, commentsLen) == comments)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdata = [];\n\t\t\t\t\t\t\tpushRow(row.split(delim));\n\t\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpushRow(row.split(delim));\n\t\t\t\t\t\tif (preview && i >= preview)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdata = data.slice(0, preview);\n\t\t\t\t\t\t\treturn returnable(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn returnable();\n\t\t\t\t}\n\t\n\t\t\t\tvar nextDelim = input.indexOf(delim, cursor);\n\t\t\t\tvar nextNewline = input.indexOf(newline, cursor);\n\t\n\t\t\t\t// Parser loop\n\t\t\t\tfor (;;)\n\t\t\t\t{\n\t\t\t\t\t// Field has opening quote\n\t\t\t\t\tif (input[cursor] == '\"')\n\t\t\t\t\t{\n\t\t\t\t\t\t// Start our search for the closing quote where the cursor is\n\t\t\t\t\t\tvar quoteSearch = cursor;\n\t\n\t\t\t\t\t\t// Skip the opening quote\n\t\t\t\t\t\tcursor++;\n\t\n\t\t\t\t\t\tfor (;;)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Find closing quote\n\t\t\t\t\t\t\tvar quoteSearch = input.indexOf('\"', quoteSearch+1);\n\t\n\t\t\t\t\t\t\tif (quoteSearch === -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (!ignoreLastRow) {\n\t\t\t\t\t\t\t\t\t// No closing quote... what a pity\n\t\t\t\t\t\t\t\t\terrors.push({\n\t\t\t\t\t\t\t\t\t\ttype: \"Quotes\",\n\t\t\t\t\t\t\t\t\t\tcode: \"MissingQuotes\",\n\t\t\t\t\t\t\t\t\t\tmessage: \"Quoted field unterminated\",\n\t\t\t\t\t\t\t\t\t\trow: data.length,\t// row has yet to be inserted\n\t\t\t\t\t\t\t\t\t\tindex: cursor\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn finish();\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif (quoteSearch === inputLen-1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Closing quote at EOF\n\t\t\t\t\t\t\t\tvar value = input.substring(cursor, quoteSearch).replace(/\"\"/g, '\"');\n\t\t\t\t\t\t\t\treturn finish(value);\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// If this quote is escaped, it's part of the data; skip it\n\t\t\t\t\t\t\tif (input[quoteSearch+1] == '\"')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tquoteSearch++;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif (input[quoteSearch+1] == delim)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Closing quote followed by delimiter\n\t\t\t\t\t\t\t\trow.push(input.substring(cursor, quoteSearch).replace(/\"\"/g, '\"'));\n\t\t\t\t\t\t\t\tcursor = quoteSearch + 1 + delimLen;\n\t\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif (input.substr(quoteSearch+1, newlineLen) === newline)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Closing quote followed by newline\n\t\t\t\t\t\t\t\trow.push(input.substring(cursor, quoteSearch).replace(/\"\"/g, '\"'));\n\t\t\t\t\t\t\t\tsaveRow(quoteSearch + 1 + newlineLen);\n\t\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\t// because we may have skipped the nextDelim in the quoted field\n\t\n\t\t\t\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (preview && data.length >= preview)\n\t\t\t\t\t\t\t\t\treturn returnable(true);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Comment found at start of new line\n\t\t\t\t\tif (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (nextNewline == -1)\t// Comment ends at EOF\n\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t\tcursor = nextNewline + newlineLen;\n\t\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Next delimiter comes before next newline, so we've reached end of field\n\t\t\t\t\tif (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1))\n\t\t\t\t\t{\n\t\t\t\t\t\trow.push(input.substring(cursor, nextDelim));\n\t\t\t\t\t\tcursor = nextDelim + delimLen;\n\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// End of row\n\t\t\t\t\tif (nextNewline !== -1)\n\t\t\t\t\t{\n\t\t\t\t\t\trow.push(input.substring(cursor, nextNewline));\n\t\t\t\t\t\tsaveRow(nextNewline + newlineLen);\n\t\n\t\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif (preview && data.length >= preview)\n\t\t\t\t\t\t\treturn returnable(true);\n\t\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\n\t\n\t\t\t\treturn finish();\n\t\n\t\n\t\t\t\tfunction pushRow(row)\n\t\t\t\t{\n\t\t\t\t\tdata.push(row);\n\t\t\t\t\tlastCursor = cursor;\n\t\t\t\t}\n\t\n\t\t\t\t/**\n\t\t\t\t * Appends the remaining input from cursor to the end into\n\t\t\t\t * row, saves the row, calls step, and returns the results.\n\t\t\t\t */\n\t\t\t\tfunction finish(value)\n\t\t\t\t{\n\t\t\t\t\tif (ignoreLastRow)\n\t\t\t\t\t\treturn returnable();\n\t\t\t\t\tif (typeof value === 'undefined')\n\t\t\t\t\t\tvalue = input.substr(cursor);\n\t\t\t\t\trow.push(value);\n\t\t\t\t\tcursor = inputLen;\t// important in case parsing is paused\n\t\t\t\t\tpushRow(row);\n\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t\tdoStep();\n\t\t\t\t\treturn returnable();\n\t\t\t\t}\n\t\n\t\t\t\t/**\n\t\t\t\t * Appends the current row to the results. It sets the cursor\n\t\t\t\t * to newCursor and finds the nextNewline. The caller should\n\t\t\t\t * take care to execute user's step function and check for\n\t\t\t\t * preview and end parsing if necessary.\n\t\t\t\t */\n\t\t\t\tfunction saveRow(newCursor)\n\t\t\t\t{\n\t\t\t\t\tcursor = newCursor;\n\t\t\t\t\tpushRow(row);\n\t\t\t\t\trow = [];\n\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t}\n\t\n\t\t\t\t/** Returns an object with the results, errors, and meta. */\n\t\t\t\tfunction returnable(stopped)\n\t\t\t\t{\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: data,\n\t\t\t\t\t\terrors: errors,\n\t\t\t\t\t\tmeta: {\n\t\t\t\t\t\t\tdelimiter: delim,\n\t\t\t\t\t\t\tlinebreak: newline,\n\t\t\t\t\t\t\taborted: aborted,\n\t\t\t\t\t\t\ttruncated: !!stopped,\n\t\t\t\t\t\t\tcursor: lastCursor + (baseIndex || 0)\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\n\t\t\t\t/** Executes the user's step function and resets data & errors. */\n\t\t\t\tfunction doStep()\n\t\t\t\t{\n\t\t\t\t\tstep(returnable());\n\t\t\t\t\tdata = [], errors = [];\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\t/** Sets the abort flag */\n\t\t\tthis.abort = function()\n\t\t\t{\n\t\t\t\taborted = true;\n\t\t\t};\n\t\n\t\t\t/** Gets the cursor position */\n\t\t\tthis.getCharIndex = function()\n\t\t\t{\n\t\t\t\treturn cursor;\n\t\t\t};\n\t\t}\n\t\n\t\n\t\t// If you need to load Papa Parse asynchronously and you also need worker threads, hard-code\n\t\t// the script path here. See: https://github.com/mholt/PapaParse/issues/87#issuecomment-57885358\n\t\tfunction getScriptPath()\n\t\t{\n\t\t\tvar scripts = document.getElementsByTagName('script');\n\t\t\treturn scripts.length ? scripts[scripts.length - 1].src : '';\n\t\t}\n\t\n\t\tfunction newWorker()\n\t\t{\n\t\t\tif (!Papa.WORKERS_SUPPORTED)\n\t\t\t\treturn false;\n\t\t\tif (!LOADED_SYNC && Papa.SCRIPT_PATH === null)\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Script path cannot be determined automatically when Papa Parse is loaded asynchronously. ' +\n\t\t\t\t\t'You need to set Papa.SCRIPT_PATH manually.'\n\t\t\t\t);\n\t\t\tvar workerUrl = Papa.SCRIPT_PATH || AUTO_SCRIPT_PATH;\n\t\t\t// Append \"papaworker\" to the search string to tell papaparse that this is our worker.\n\t\t\tworkerUrl += (workerUrl.indexOf('?') !== -1 ? '&' : '?') + 'papaworker';\n\t\t\tvar w = new global.Worker(workerUrl);\n\t\t\tw.onmessage = mainThreadReceivedMessage;\n\t\t\tw.id = workerIdCounter++;\n\t\t\tworkers[w.id] = w;\n\t\t\treturn w;\n\t\t}\n\t\n\t\t/** Callback when main thread receives a message */\n\t\tfunction mainThreadReceivedMessage(e)\n\t\t{\n\t\t\tvar msg = e.data;\n\t\t\tvar worker = workers[msg.workerId];\n\t\t\tvar aborted = false;\n\t\n\t\t\tif (msg.error)\n\t\t\t\tworker.userError(msg.error, msg.file);\n\t\t\telse if (msg.results && msg.results.data)\n\t\t\t{\n\t\t\t\tvar abort = function() {\n\t\t\t\t\taborted = true;\n\t\t\t\t\tcompleteWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });\n\t\t\t\t};\n\t\n\t\t\t\tvar handle = {\n\t\t\t\t\tabort: abort,\n\t\t\t\t\tpause: notImplemented,\n\t\t\t\t\tresume: notImplemented\n\t\t\t\t};\n\t\n\t\t\t\tif (isFunction(worker.userStep))\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < msg.results.data.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tworker.userStep({\n\t\t\t\t\t\t\tdata: [msg.results.data[i]],\n\t\t\t\t\t\t\terrors: msg.results.errors,\n\t\t\t\t\t\t\tmeta: msg.results.meta\n\t\t\t\t\t\t}, handle);\n\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdelete msg.results;\t// free memory ASAP\n\t\t\t\t}\n\t\t\t\telse if (isFunction(worker.userChunk))\n\t\t\t\t{\n\t\t\t\t\tworker.userChunk(msg.results, handle, msg.file);\n\t\t\t\t\tdelete msg.results;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (msg.finished && !aborted)\n\t\t\t\tcompleteWorker(msg.workerId, msg.results);\n\t\t}\n\t\n\t\tfunction completeWorker(workerId, results) {\n\t\t\tvar worker = workers[workerId];\n\t\t\tif (isFunction(worker.userComplete))\n\t\t\t\tworker.userComplete(results);\n\t\t\tworker.terminate();\n\t\t\tdelete workers[workerId];\n\t\t}\n\t\n\t\tfunction notImplemented() {\n\t\t\tthrow \"Not implemented.\";\n\t\t}\n\t\n\t\t/** Callback when worker thread receives a message */\n\t\tfunction workerThreadReceivedMessage(e)\n\t\t{\n\t\t\tvar msg = e.data;\n\t\n\t\t\tif (typeof Papa.WORKER_ID === 'undefined' && msg)\n\t\t\t\tPapa.WORKER_ID = msg.workerId;\n\t\n\t\t\tif (typeof msg.input === 'string')\n\t\t\t{\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\tresults: Papa.parse(msg.input, msg.config),\n\t\t\t\t\tfinished: true\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if ((global.File && msg.input instanceof File) || msg.input instanceof Object)\t// thank you, Safari (see issue #106)\n\t\t\t{\n\t\t\t\tvar results = Papa.parse(msg.input, msg.config);\n\t\t\t\tif (results)\n\t\t\t\t\tglobal.postMessage({\n\t\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\t\tresults: results,\n\t\t\t\t\t\tfinished: true\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\n\t\t/** Makes a deep copy of an array or object (mostly) */\n\t\tfunction copy(obj)\n\t\t{\n\t\t\tif (typeof obj !== 'object')\n\t\t\t\treturn obj;\n\t\t\tvar cpy = obj instanceof Array ? [] : {};\n\t\t\tfor (var key in obj)\n\t\t\t\tcpy[key] = copy(obj[key]);\n\t\t\treturn cpy;\n\t\t}\n\t\n\t\tfunction bindFunction(f, self)\n\t\t{\n\t\t\treturn function() { f.apply(self, arguments); };\n\t\t}\n\t\n\t\tfunction isFunction(func)\n\t\t{\n\t\t\treturn typeof func === 'function';\n\t\t}\n\t})(typeof window !== 'undefined' ? window : this);\n\n\n/***/ },\n/* 69 */,\n/* 70 */,\n/* 71 */,\n/* 72 */,\n/* 73 */,\n/* 74 */,\n/* 75 */,\n/* 76 */,\n/* 77 */,\n/* 78 */,\n/* 79 */,\n/* 80 */,\n/* 81 */,\n/* 82 */,\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(92), __esModule: true };\n\n/***/ },\n/* 84 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(93), __esModule: true };\n\n/***/ },\n/* 85 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(94), __esModule: true };\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(95), __esModule: true };\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(98), __esModule: true };\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(100), __esModule: true };\n\n/***/ },\n/* 89 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(101), __esModule: true };\n\n/***/ },\n/* 90 */\n/***/ function(module, exports) {\n\n\t'use strict'\n\t\n\texports.byteLength = byteLength\n\texports.toByteArray = toByteArray\n\texports.fromByteArray = fromByteArray\n\t\n\tvar lookup = []\n\tvar revLookup = []\n\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\t\n\tvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n\tfor (var i = 0, len = code.length; i < len; ++i) {\n\t  lookup[i] = code[i]\n\t  revLookup[code.charCodeAt(i)] = i\n\t}\n\t\n\trevLookup['-'.charCodeAt(0)] = 62\n\trevLookup['_'.charCodeAt(0)] = 63\n\t\n\tfunction placeHoldersCount (b64) {\n\t  var len = b64.length\n\t  if (len % 4 > 0) {\n\t    throw new Error('Invalid string. Length must be a multiple of 4')\n\t  }\n\t\n\t  // the number of equal signs (place holders)\n\t  // if there are two placeholders, than the two characters before it\n\t  // represent one byte\n\t  // if there is only one, then the three characters before it represent 2 bytes\n\t  // this is just a cheap hack to not do indexOf twice\n\t  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n\t}\n\t\n\tfunction byteLength (b64) {\n\t  // base64 is 4/3 + up to two characters of the original data\n\t  return b64.length * 3 / 4 - placeHoldersCount(b64)\n\t}\n\t\n\tfunction toByteArray (b64) {\n\t  var i, j, l, tmp, placeHolders, arr\n\t  var len = b64.length\n\t  placeHolders = placeHoldersCount(b64)\n\t\n\t  arr = new Arr(len * 3 / 4 - placeHolders)\n\t\n\t  // if there are placeholders, only get up to the last complete 4 chars\n\t  l = placeHolders > 0 ? len - 4 : len\n\t\n\t  var L = 0\n\t\n\t  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n\t    arr[L++] = (tmp >> 16) & 0xFF\n\t    arr[L++] = (tmp >> 8) & 0xFF\n\t    arr[L++] = tmp & 0xFF\n\t  }\n\t\n\t  if (placeHolders === 2) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n\t    arr[L++] = tmp & 0xFF\n\t  } else if (placeHolders === 1) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n\t    arr[L++] = (tmp >> 8) & 0xFF\n\t    arr[L++] = tmp & 0xFF\n\t  }\n\t\n\t  return arr\n\t}\n\t\n\tfunction tripletToBase64 (num) {\n\t  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n\t}\n\t\n\tfunction encodeChunk (uint8, start, end) {\n\t  var tmp\n\t  var output = []\n\t  for (var i = start; i < end; i += 3) {\n\t    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t    output.push(tripletToBase64(tmp))\n\t  }\n\t  return output.join('')\n\t}\n\t\n\tfunction fromByteArray (uint8) {\n\t  var tmp\n\t  var len = uint8.length\n\t  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n\t  var output = ''\n\t  var parts = []\n\t  var maxChunkLength = 16383 // must be multiple of 3\n\t\n\t  // go through the array every three bytes, we'll deal with trailing stuff later\n\t  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n\t    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n\t  }\n\t\n\t  // pad the end with zeros, but make sure to not forget the extra bytes\n\t  if (extraBytes === 1) {\n\t    tmp = uint8[len - 1]\n\t    output += lookup[tmp >> 2]\n\t    output += lookup[(tmp << 4) & 0x3F]\n\t    output += '=='\n\t  } else if (extraBytes === 2) {\n\t    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n\t    output += lookup[tmp >> 10]\n\t    output += lookup[(tmp >> 4) & 0x3F]\n\t    output += lookup[(tmp << 2) & 0x3F]\n\t    output += '='\n\t  }\n\t\n\t  parts.push(output)\n\t\n\t  return parts.join('')\n\t}\n\n\n/***/ },\n/* 91 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(62);\n\t__webpack_require__(61);\n\tmodule.exports = __webpack_require__(122);\n\n/***/ },\n/* 92 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar core  = __webpack_require__(1)\n\t  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});\n\tmodule.exports = function stringify(it){ // eslint-disable-line no-unused-vars\n\t  return $JSON.stringify.apply($JSON, arguments);\n\t};\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(124);\n\tmodule.exports = __webpack_require__(1).Object.assign;\n\n/***/ },\n/* 94 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(125);\n\tvar $Object = __webpack_require__(1).Object;\n\tmodule.exports = function create(P, D){\n\t  return $Object.create(P, D);\n\t};\n\n/***/ },\n/* 95 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(126);\n\tvar $Object = __webpack_require__(1).Object;\n\tmodule.exports = function defineProperty(it, key, desc){\n\t  return $Object.defineProperty(it, key, desc);\n\t};\n\n/***/ },\n/* 96 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(127);\n\tmodule.exports = __webpack_require__(1).Object.getPrototypeOf;\n\n/***/ },\n/* 97 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(128);\n\tmodule.exports = __webpack_require__(1).Object.keys;\n\n/***/ },\n/* 98 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(129);\n\tmodule.exports = __webpack_require__(1).Object.setPrototypeOf;\n\n/***/ },\n/* 99 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(132);\n\tmodule.exports = __webpack_require__(1).Object.values;\n\n/***/ },\n/* 100 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(131);\n\t__webpack_require__(130);\n\t__webpack_require__(133);\n\t__webpack_require__(134);\n\tmodule.exports = __webpack_require__(1).Symbol;\n\n/***/ },\n/* 101 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(61);\n\t__webpack_require__(62);\n\tmodule.exports = __webpack_require__(40).f('iterator');\n\n/***/ },\n/* 102 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n\t  return it;\n\t};\n\n/***/ },\n/* 103 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(){ /* empty */ };\n\n/***/ },\n/* 104 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// false -> Array#indexOf\n\t// true  -> Array#includes\n\tvar toIObject = __webpack_require__(6)\n\t  , toLength  = __webpack_require__(120)\n\t  , toIndex   = __webpack_require__(119);\n\tmodule.exports = function(IS_INCLUDES){\n\t  return function($this, el, fromIndex){\n\t    var O      = toIObject($this)\n\t      , length = toLength(O.length)\n\t      , index  = toIndex(fromIndex, length)\n\t      , value;\n\t    // Array#includes uses SameValueZero equality algorithm\n\t    if(IS_INCLUDES && el != el)while(length > index){\n\t      value = O[index++];\n\t      if(value != value)return true;\n\t    // Array#toIndex ignores holes, Array#includes - not\n\t    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n\t      if(O[index] === el)return IS_INCLUDES || index || 0;\n\t    } return !IS_INCLUDES && -1;\n\t  };\n\t};\n\n/***/ },\n/* 105 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// getting tag from 19.1.3.6 Object.prototype.toString()\n\tvar cof = __webpack_require__(28)\n\t  , TAG = __webpack_require__(7)('toStringTag')\n\t  // ES3 wrong here\n\t  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\t\n\t// fallback for IE11 Script Access Denied error\n\tvar tryGet = function(it, key){\n\t  try {\n\t    return it[key];\n\t  } catch(e){ /* empty */ }\n\t};\n\t\n\tmodule.exports = function(it){\n\t  var O, T, B;\n\t  return it === undefined ? 'Undefined' : it === null ? 'Null'\n\t    // @@toStringTag case\n\t    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n\t    // builtinTag case\n\t    : ARG ? cof(O)\n\t    // ES3 arguments fallback\n\t    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n\t};\n\n/***/ },\n/* 106 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// all enumerable object keys, includes symbols\n\tvar getKeys = __webpack_require__(11)\n\t  , gOPS    = __webpack_require__(33)\n\t  , pIE     = __webpack_require__(19);\n\tmodule.exports = function(it){\n\t  var result     = getKeys(it)\n\t    , getSymbols = gOPS.f;\n\t  if(getSymbols){\n\t    var symbols = getSymbols(it)\n\t      , isEnum  = pIE.f\n\t      , i       = 0\n\t      , key;\n\t    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);\n\t  } return result;\n\t};\n\n/***/ },\n/* 107 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(5).document && document.documentElement;\n\n/***/ },\n/* 108 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.2.2 IsArray(argument)\n\tvar cof = __webpack_require__(28);\n\tmodule.exports = Array.isArray || function isArray(arg){\n\t  return cof(arg) == 'Array';\n\t};\n\n/***/ },\n/* 109 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar create         = __webpack_require__(32)\n\t  , descriptor     = __webpack_require__(24)\n\t  , setToStringTag = __webpack_require__(34)\n\t  , IteratorPrototype = {};\n\t\n\t// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\t__webpack_require__(15)(IteratorPrototype, __webpack_require__(7)('iterator'), function(){ return this; });\n\t\n\tmodule.exports = function(Constructor, NAME, next){\n\t  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n\t  setToStringTag(Constructor, NAME + ' Iterator');\n\t};\n\n/***/ },\n/* 110 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(done, value){\n\t  return {value: value, done: !!done};\n\t};\n\n/***/ },\n/* 111 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar getKeys   = __webpack_require__(11)\n\t  , toIObject = __webpack_require__(6);\n\tmodule.exports = function(object, el){\n\t  var O      = toIObject(object)\n\t    , keys   = getKeys(O)\n\t    , length = keys.length\n\t    , index  = 0\n\t    , key;\n\t  while(length > index)if(O[key = keys[index++]] === el)return key;\n\t};\n\n/***/ },\n/* 112 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar META     = __webpack_require__(26)('meta')\n\t  , isObject = __webpack_require__(18)\n\t  , has      = __webpack_require__(9)\n\t  , setDesc  = __webpack_require__(10).f\n\t  , id       = 0;\n\tvar isExtensible = Object.isExtensible || function(){\n\t  return true;\n\t};\n\tvar FREEZE = !__webpack_require__(14)(function(){\n\t  return isExtensible(Object.preventExtensions({}));\n\t});\n\tvar setMeta = function(it){\n\t  setDesc(it, META, {value: {\n\t    i: 'O' + ++id, // object ID\n\t    w: {}          // weak collections IDs\n\t  }});\n\t};\n\tvar fastKey = function(it, create){\n\t  // return primitive with prefix\n\t  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n\t  if(!has(it, META)){\n\t    // can't set metadata to uncaught frozen object\n\t    if(!isExtensible(it))return 'F';\n\t    // not necessary to add metadata\n\t    if(!create)return 'E';\n\t    // add missing metadata\n\t    setMeta(it);\n\t  // return object ID\n\t  } return it[META].i;\n\t};\n\tvar getWeak = function(it, create){\n\t  if(!has(it, META)){\n\t    // can't set metadata to uncaught frozen object\n\t    if(!isExtensible(it))return true;\n\t    // not necessary to add metadata\n\t    if(!create)return false;\n\t    // add missing metadata\n\t    setMeta(it);\n\t  // return hash weak collections IDs\n\t  } return it[META].w;\n\t};\n\t// add metadata on freeze-family methods calling\n\tvar onFreeze = function(it){\n\t  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);\n\t  return it;\n\t};\n\tvar meta = module.exports = {\n\t  KEY:      META,\n\t  NEED:     false,\n\t  fastKey:  fastKey,\n\t  getWeak:  getWeak,\n\t  onFreeze: onFreeze\n\t};\n\n/***/ },\n/* 113 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// 19.1.2.1 Object.assign(target, source, ...)\n\tvar getKeys  = __webpack_require__(11)\n\t  , gOPS     = __webpack_require__(33)\n\t  , pIE      = __webpack_require__(19)\n\t  , toObject = __webpack_require__(25)\n\t  , IObject  = __webpack_require__(53)\n\t  , $assign  = Object.assign;\n\t\n\t// should work with symbols and should have deterministic property order (V8 bug)\n\tmodule.exports = !$assign || __webpack_require__(14)(function(){\n\t  var A = {}\n\t    , B = {}\n\t    , S = Symbol()\n\t    , K = 'abcdefghijklmnopqrst';\n\t  A[S] = 7;\n\t  K.split('').forEach(function(k){ B[k] = k; });\n\t  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n\t}) ? function assign(target, source){ // eslint-disable-line no-unused-vars\n\t  var T     = toObject(target)\n\t    , aLen  = arguments.length\n\t    , index = 1\n\t    , getSymbols = gOPS.f\n\t    , isEnum     = pIE.f;\n\t  while(aLen > index){\n\t    var S      = IObject(arguments[index++])\n\t      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)\n\t      , length = keys.length\n\t      , j      = 0\n\t      , key;\n\t    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];\n\t  } return T;\n\t} : $assign;\n\n/***/ },\n/* 114 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar dP       = __webpack_require__(10)\n\t  , anObject = __webpack_require__(13)\n\t  , getKeys  = __webpack_require__(11);\n\t\n\tmodule.exports = __webpack_require__(8) ? Object.defineProperties : function defineProperties(O, Properties){\n\t  anObject(O);\n\t  var keys   = getKeys(Properties)\n\t    , length = keys.length\n\t    , i = 0\n\t    , P;\n\t  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\n\t  return O;\n\t};\n\n/***/ },\n/* 115 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\n\tvar toIObject = __webpack_require__(6)\n\t  , gOPN      = __webpack_require__(56).f\n\t  , toString  = {}.toString;\n\t\n\tvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n\t  ? Object.getOwnPropertyNames(window) : [];\n\t\n\tvar getWindowNames = function(it){\n\t  try {\n\t    return gOPN(it);\n\t  } catch(e){\n\t    return windowNames.slice();\n\t  }\n\t};\n\t\n\tmodule.exports.f = function getOwnPropertyNames(it){\n\t  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n\t};\n\n\n/***/ },\n/* 116 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar getKeys   = __webpack_require__(11)\n\t  , toIObject = __webpack_require__(6)\n\t  , isEnum    = __webpack_require__(19).f;\n\tmodule.exports = function(isEntries){\n\t  return function(it){\n\t    var O      = toIObject(it)\n\t      , keys   = getKeys(O)\n\t      , length = keys.length\n\t      , i      = 0\n\t      , result = []\n\t      , key;\n\t    while(length > i)if(isEnum.call(O, key = keys[i++])){\n\t      result.push(isEntries ? [key, O[key]] : O[key]);\n\t    } return result;\n\t  };\n\t};\n\n/***/ },\n/* 117 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Works with __proto__ only. Old v8 can't work with null proto objects.\n\t/* eslint-disable no-proto */\n\tvar isObject = __webpack_require__(18)\n\t  , anObject = __webpack_require__(13);\n\tvar check = function(O, proto){\n\t  anObject(O);\n\t  if(!isObject(proto) && proto !== null)throw TypeError(proto + \": can't set as prototype!\");\n\t};\n\tmodule.exports = {\n\t  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n\t    function(test, buggy, set){\n\t      try {\n\t        set = __webpack_require__(50)(Function.call, __webpack_require__(55).f(Object.prototype, '__proto__').set, 2);\n\t        set(test, []);\n\t        buggy = !(test instanceof Array);\n\t      } catch(e){ buggy = true; }\n\t      return function setPrototypeOf(O, proto){\n\t        check(O, proto);\n\t        if(buggy)O.__proto__ = proto;\n\t        else set(O, proto);\n\t        return O;\n\t      };\n\t    }({}, false) : undefined),\n\t  check: check\n\t};\n\n/***/ },\n/* 118 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(37)\n\t  , defined   = __webpack_require__(29);\n\t// true  -> String#at\n\t// false -> String#codePointAt\n\tmodule.exports = function(TO_STRING){\n\t  return function(that, pos){\n\t    var s = String(defined(that))\n\t      , i = toInteger(pos)\n\t      , l = s.length\n\t      , a, b;\n\t    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n\t    a = s.charCodeAt(i);\n\t    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n\t      ? TO_STRING ? s.charAt(i) : a\n\t      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n\t  };\n\t};\n\n/***/ },\n/* 119 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(37)\n\t  , max       = Math.max\n\t  , min       = Math.min;\n\tmodule.exports = function(index, length){\n\t  index = toInteger(index);\n\t  return index < 0 ? max(index + length, 0) : min(index, length);\n\t};\n\n/***/ },\n/* 120 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.15 ToLength\n\tvar toInteger = __webpack_require__(37)\n\t  , min       = Math.min;\n\tmodule.exports = function(it){\n\t  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n\t};\n\n/***/ },\n/* 121 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar classof   = __webpack_require__(105)\n\t  , ITERATOR  = __webpack_require__(7)('iterator')\n\t  , Iterators = __webpack_require__(23);\n\tmodule.exports = __webpack_require__(1).getIteratorMethod = function(it){\n\t  if(it != undefined)return it[ITERATOR]\n\t    || it['@@iterator']\n\t    || Iterators[classof(it)];\n\t};\n\n/***/ },\n/* 122 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar anObject = __webpack_require__(13)\n\t  , get      = __webpack_require__(121);\n\tmodule.exports = __webpack_require__(1).getIterator = function(it){\n\t  var iterFn = get(it);\n\t  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');\n\t  return anObject(iterFn.call(it));\n\t};\n\n/***/ },\n/* 123 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar addToUnscopables = __webpack_require__(103)\n\t  , step             = __webpack_require__(110)\n\t  , Iterators        = __webpack_require__(23)\n\t  , toIObject        = __webpack_require__(6);\n\t\n\t// 22.1.3.4 Array.prototype.entries()\n\t// 22.1.3.13 Array.prototype.keys()\n\t// 22.1.3.29 Array.prototype.values()\n\t// 22.1.3.30 Array.prototype[@@iterator]()\n\tmodule.exports = __webpack_require__(54)(Array, 'Array', function(iterated, kind){\n\t  this._t = toIObject(iterated); // target\n\t  this._i = 0;                   // next index\n\t  this._k = kind;                // kind\n\t// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , kind  = this._k\n\t    , index = this._i++;\n\t  if(!O || index >= O.length){\n\t    this._t = undefined;\n\t    return step(1);\n\t  }\n\t  if(kind == 'keys'  )return step(0, index);\n\t  if(kind == 'values')return step(0, O[index]);\n\t  return step(0, [index, O[index]]);\n\t}, 'values');\n\t\n\t// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\n\tIterators.Arguments = Iterators.Array;\n\t\n\taddToUnscopables('keys');\n\taddToUnscopables('values');\n\taddToUnscopables('entries');\n\n/***/ },\n/* 124 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.3.1 Object.assign(target, source)\n\tvar $export = __webpack_require__(4);\n\t\n\t$export($export.S + $export.F, 'Object', {assign: __webpack_require__(113)});\n\n/***/ },\n/* 125 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $export = __webpack_require__(4)\n\t// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n\t$export($export.S, 'Object', {create: __webpack_require__(32)});\n\n/***/ },\n/* 126 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $export = __webpack_require__(4);\n\t// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\n\t$export($export.S + $export.F * !__webpack_require__(8), 'Object', {defineProperty: __webpack_require__(10).f});\n\n/***/ },\n/* 127 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.9 Object.getPrototypeOf(O)\n\tvar toObject        = __webpack_require__(25)\n\t  , $getPrototypeOf = __webpack_require__(57);\n\t\n\t__webpack_require__(59)('getPrototypeOf', function(){\n\t  return function getPrototypeOf(it){\n\t    return $getPrototypeOf(toObject(it));\n\t  };\n\t});\n\n/***/ },\n/* 128 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.14 Object.keys(O)\n\tvar toObject = __webpack_require__(25)\n\t  , $keys    = __webpack_require__(11);\n\t\n\t__webpack_require__(59)('keys', function(){\n\t  return function keys(it){\n\t    return $keys(toObject(it));\n\t  };\n\t});\n\n/***/ },\n/* 129 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.3.19 Object.setPrototypeOf(O, proto)\n\tvar $export = __webpack_require__(4);\n\t$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(117).set});\n\n/***/ },\n/* 130 */\n/***/ function(module, exports) {\n\n\n\n/***/ },\n/* 131 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// ECMAScript 6 symbols shim\n\tvar global         = __webpack_require__(5)\n\t  , has            = __webpack_require__(9)\n\t  , DESCRIPTORS    = __webpack_require__(8)\n\t  , $export        = __webpack_require__(4)\n\t  , redefine       = __webpack_require__(60)\n\t  , META           = __webpack_require__(112).KEY\n\t  , $fails         = __webpack_require__(14)\n\t  , shared         = __webpack_require__(36)\n\t  , setToStringTag = __webpack_require__(34)\n\t  , uid            = __webpack_require__(26)\n\t  , wks            = __webpack_require__(7)\n\t  , wksExt         = __webpack_require__(40)\n\t  , wksDefine      = __webpack_require__(39)\n\t  , keyOf          = __webpack_require__(111)\n\t  , enumKeys       = __webpack_require__(106)\n\t  , isArray        = __webpack_require__(108)\n\t  , anObject       = __webpack_require__(13)\n\t  , toIObject      = __webpack_require__(6)\n\t  , toPrimitive    = __webpack_require__(38)\n\t  , createDesc     = __webpack_require__(24)\n\t  , _create        = __webpack_require__(32)\n\t  , gOPNExt        = __webpack_require__(115)\n\t  , $GOPD          = __webpack_require__(55)\n\t  , $DP            = __webpack_require__(10)\n\t  , $keys          = __webpack_require__(11)\n\t  , gOPD           = $GOPD.f\n\t  , dP             = $DP.f\n\t  , gOPN           = gOPNExt.f\n\t  , $Symbol        = global.Symbol\n\t  , $JSON          = global.JSON\n\t  , _stringify     = $JSON && $JSON.stringify\n\t  , PROTOTYPE      = 'prototype'\n\t  , HIDDEN         = wks('_hidden')\n\t  , TO_PRIMITIVE   = wks('toPrimitive')\n\t  , isEnum         = {}.propertyIsEnumerable\n\t  , SymbolRegistry = shared('symbol-registry')\n\t  , AllSymbols     = shared('symbols')\n\t  , OPSymbols      = shared('op-symbols')\n\t  , ObjectProto    = Object[PROTOTYPE]\n\t  , USE_NATIVE     = typeof $Symbol == 'function'\n\t  , QObject        = global.QObject;\n\t// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\n\tvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\t\n\t// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\n\tvar setSymbolDesc = DESCRIPTORS && $fails(function(){\n\t  return _create(dP({}, 'a', {\n\t    get: function(){ return dP(this, 'a', {value: 7}).a; }\n\t  })).a != 7;\n\t}) ? function(it, key, D){\n\t  var protoDesc = gOPD(ObjectProto, key);\n\t  if(protoDesc)delete ObjectProto[key];\n\t  dP(it, key, D);\n\t  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);\n\t} : dP;\n\t\n\tvar wrap = function(tag){\n\t  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n\t  sym._k = tag;\n\t  return sym;\n\t};\n\t\n\tvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){\n\t  return typeof it == 'symbol';\n\t} : function(it){\n\t  return it instanceof $Symbol;\n\t};\n\t\n\tvar $defineProperty = function defineProperty(it, key, D){\n\t  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);\n\t  anObject(it);\n\t  key = toPrimitive(key, true);\n\t  anObject(D);\n\t  if(has(AllSymbols, key)){\n\t    if(!D.enumerable){\n\t      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));\n\t      it[HIDDEN][key] = true;\n\t    } else {\n\t      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n\t      D = _create(D, {enumerable: createDesc(0, false)});\n\t    } return setSymbolDesc(it, key, D);\n\t  } return dP(it, key, D);\n\t};\n\tvar $defineProperties = function defineProperties(it, P){\n\t  anObject(it);\n\t  var keys = enumKeys(P = toIObject(P))\n\t    , i    = 0\n\t    , l = keys.length\n\t    , key;\n\t  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n\t  return it;\n\t};\n\tvar $create = function create(it, P){\n\t  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n\t};\n\tvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n\t  var E = isEnum.call(this, key = toPrimitive(key, true));\n\t  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;\n\t  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n\t};\n\tvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n\t  it  = toIObject(it);\n\t  key = toPrimitive(key, true);\n\t  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;\n\t  var D = gOPD(it, key);\n\t  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n\t  return D;\n\t};\n\tvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n\t  var names  = gOPN(toIObject(it))\n\t    , result = []\n\t    , i      = 0\n\t    , key;\n\t  while(names.length > i){\n\t    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);\n\t  } return result;\n\t};\n\tvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n\t  var IS_OP  = it === ObjectProto\n\t    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))\n\t    , result = []\n\t    , i      = 0\n\t    , key;\n\t  while(names.length > i){\n\t    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);\n\t  } return result;\n\t};\n\t\n\t// 19.4.1.1 Symbol([description])\n\tif(!USE_NATIVE){\n\t  $Symbol = function Symbol(){\n\t    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');\n\t    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n\t    var $set = function(value){\n\t      if(this === ObjectProto)$set.call(OPSymbols, value);\n\t      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n\t      setSymbolDesc(this, tag, createDesc(1, value));\n\t    };\n\t    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});\n\t    return wrap(tag);\n\t  };\n\t  redefine($Symbol[PROTOTYPE], 'toString', function toString(){\n\t    return this._k;\n\t  });\n\t\n\t  $GOPD.f = $getOwnPropertyDescriptor;\n\t  $DP.f   = $defineProperty;\n\t  __webpack_require__(56).f = gOPNExt.f = $getOwnPropertyNames;\n\t  __webpack_require__(19).f  = $propertyIsEnumerable;\n\t  __webpack_require__(33).f = $getOwnPropertySymbols;\n\t\n\t  if(DESCRIPTORS && !__webpack_require__(31)){\n\t    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n\t  }\n\t\n\t  wksExt.f = function(name){\n\t    return wrap(wks(name));\n\t  }\n\t}\n\t\n\t$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});\n\t\n\tfor(var symbols = (\n\t  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n\t  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n\t).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);\n\t\n\tfor(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);\n\t\n\t$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n\t  // 19.4.2.1 Symbol.for(key)\n\t  'for': function(key){\n\t    return has(SymbolRegistry, key += '')\n\t      ? SymbolRegistry[key]\n\t      : SymbolRegistry[key] = $Symbol(key);\n\t  },\n\t  // 19.4.2.5 Symbol.keyFor(sym)\n\t  keyFor: function keyFor(key){\n\t    if(isSymbol(key))return keyOf(SymbolRegistry, key);\n\t    throw TypeError(key + ' is not a symbol!');\n\t  },\n\t  useSetter: function(){ setter = true; },\n\t  useSimple: function(){ setter = false; }\n\t});\n\t\n\t$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n\t  // 19.1.2.2 Object.create(O [, Properties])\n\t  create: $create,\n\t  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n\t  defineProperty: $defineProperty,\n\t  // 19.1.2.3 Object.defineProperties(O, Properties)\n\t  defineProperties: $defineProperties,\n\t  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n\t  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n\t  // 19.1.2.7 Object.getOwnPropertyNames(O)\n\t  getOwnPropertyNames: $getOwnPropertyNames,\n\t  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n\t  getOwnPropertySymbols: $getOwnPropertySymbols\n\t});\n\t\n\t// 24.3.2 JSON.stringify(value [, replacer [, space]])\n\t$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){\n\t  var S = $Symbol();\n\t  // MS Edge converts symbol values to JSON as {}\n\t  // WebKit converts symbol values to JSON as null\n\t  // V8 throws on boxed symbols\n\t  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n\t})), 'JSON', {\n\t  stringify: function stringify(it){\n\t    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n\t    var args = [it]\n\t      , i    = 1\n\t      , replacer, $replacer;\n\t    while(arguments.length > i)args.push(arguments[i++]);\n\t    replacer = args[1];\n\t    if(typeof replacer == 'function')$replacer = replacer;\n\t    if($replacer || !isArray(replacer))replacer = function(key, value){\n\t      if($replacer)value = $replacer.call(this, key, value);\n\t      if(!isSymbol(value))return value;\n\t    };\n\t    args[1] = replacer;\n\t    return _stringify.apply($JSON, args);\n\t  }\n\t});\n\t\n\t// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n\t$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(15)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n\t// 19.4.3.5 Symbol.prototype[@@toStringTag]\n\tsetToStringTag($Symbol, 'Symbol');\n\t// 20.2.1.9 Math[@@toStringTag]\n\tsetToStringTag(Math, 'Math', true);\n\t// 24.3.3 JSON[@@toStringTag]\n\tsetToStringTag(global.JSON, 'JSON', true);\n\n/***/ },\n/* 132 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// https://github.com/tc39/proposal-object-values-entries\n\tvar $export = __webpack_require__(4)\n\t  , $values = __webpack_require__(116)(false);\n\t\n\t$export($export.S, 'Object', {\n\t  values: function values(it){\n\t    return $values(it);\n\t  }\n\t});\n\n/***/ },\n/* 133 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(39)('asyncIterator');\n\n/***/ },\n/* 134 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(39)('observable');\n\n/***/ },\n/* 135 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// https://d3js.org Version 4.3.0. Copyright 2016 Mike Bostock.\n\t(function (global, factory) {\n\t   true ? factory(exports) :\n\t  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t  (factory((global.d3 = global.d3 || {})));\n\t}(this, (function (exports) { 'use strict';\n\t\n\tvar version = \"4.3.0\";\n\t\n\tvar ascending = function(a, b) {\n\t  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n\t};\n\t\n\tvar bisector = function(compare) {\n\t  if (compare.length === 1) compare = ascendingComparator(compare);\n\t  return {\n\t    left: function(a, x, lo, hi) {\n\t      if (lo == null) lo = 0;\n\t      if (hi == null) hi = a.length;\n\t      while (lo < hi) {\n\t        var mid = lo + hi >>> 1;\n\t        if (compare(a[mid], x) < 0) lo = mid + 1;\n\t        else hi = mid;\n\t      }\n\t      return lo;\n\t    },\n\t    right: function(a, x, lo, hi) {\n\t      if (lo == null) lo = 0;\n\t      if (hi == null) hi = a.length;\n\t      while (lo < hi) {\n\t        var mid = lo + hi >>> 1;\n\t        if (compare(a[mid], x) > 0) hi = mid;\n\t        else lo = mid + 1;\n\t      }\n\t      return lo;\n\t    }\n\t  };\n\t};\n\t\n\tfunction ascendingComparator(f) {\n\t  return function(d, x) {\n\t    return ascending(f(d), x);\n\t  };\n\t}\n\t\n\tvar ascendingBisect = bisector(ascending);\n\tvar bisectRight = ascendingBisect.right;\n\tvar bisectLeft = ascendingBisect.left;\n\t\n\tvar descending = function(a, b) {\n\t  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n\t};\n\t\n\tvar number = function(x) {\n\t  return x === null ? NaN : +x;\n\t};\n\t\n\tvar variance = function(array, f) {\n\t  var n = array.length,\n\t      m = 0,\n\t      a,\n\t      d,\n\t      s = 0,\n\t      i = -1,\n\t      j = 0;\n\t\n\t  if (f == null) {\n\t    while (++i < n) {\n\t      if (!isNaN(a = number(array[i]))) {\n\t        d = a - m;\n\t        m += d / ++j;\n\t        s += d * (a - m);\n\t      }\n\t    }\n\t  }\n\t\n\t  else {\n\t    while (++i < n) {\n\t      if (!isNaN(a = number(f(array[i], i, array)))) {\n\t        d = a - m;\n\t        m += d / ++j;\n\t        s += d * (a - m);\n\t      }\n\t    }\n\t  }\n\t\n\t  if (j > 1) return s / (j - 1);\n\t};\n\t\n\tvar deviation = function(array, f) {\n\t  var v = variance(array, f);\n\t  return v ? Math.sqrt(v) : v;\n\t};\n\t\n\tvar extent = function(array, f) {\n\t  var i = -1,\n\t      n = array.length,\n\t      a,\n\t      b,\n\t      c;\n\t\n\t  if (f == null) {\n\t    while (++i < n) if ((b = array[i]) != null && b >= b) { a = c = b; break; }\n\t    while (++i < n) if ((b = array[i]) != null) {\n\t      if (a > b) a = b;\n\t      if (c < b) c = b;\n\t    }\n\t  }\n\t\n\t  else {\n\t    while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = c = b; break; }\n\t    while (++i < n) if ((b = f(array[i], i, array)) != null) {\n\t      if (a > b) a = b;\n\t      if (c < b) c = b;\n\t    }\n\t  }\n\t\n\t  return [a, c];\n\t};\n\t\n\tvar array = Array.prototype;\n\t\n\tvar slice = array.slice;\n\tvar map = array.map;\n\t\n\tvar constant$1 = function(x) {\n\t  return function() {\n\t    return x;\n\t  };\n\t};\n\t\n\tvar identity = function(x) {\n\t  return x;\n\t};\n\t\n\tvar range = function(start, stop, step) {\n\t  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n\t\n\t  var i = -1,\n\t      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n\t      range = new Array(n);\n\t\n\t  while (++i < n) {\n\t    range[i] = start + i * step;\n\t  }\n\t\n\t  return range;\n\t};\n\t\n\tvar e10 = Math.sqrt(50);\n\tvar e5 = Math.sqrt(10);\n\tvar e2 = Math.sqrt(2);\n\t\n\tvar ticks = function(start, stop, count) {\n\t  var step = tickStep(start, stop, count);\n\t  return range(\n\t    Math.ceil(start / step) * step,\n\t    Math.floor(stop / step) * step + step / 2, // inclusive\n\t    step\n\t  );\n\t};\n\t\n\tfunction tickStep(start, stop, count) {\n\t  var step0 = Math.abs(stop - start) / Math.max(0, count),\n\t      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),\n\t      error = step0 / step1;\n\t  if (error >= e10) step1 *= 10;\n\t  else if (error >= e5) step1 *= 5;\n\t  else if (error >= e2) step1 *= 2;\n\t  return stop < start ? -step1 : step1;\n\t}\n\t\n\tvar sturges = function(values) {\n\t  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;\n\t};\n\t\n\tvar histogram = function() {\n\t  var value = identity,\n\t      domain = extent,\n\t      threshold = sturges;\n\t\n\t  function histogram(data) {\n\t    var i,\n\t        n = data.length,\n\t        x,\n\t        values = new Array(n);\n\t\n\t    for (i = 0; i < n; ++i) {\n\t      values[i] = value(data[i], i, data);\n\t    }\n\t\n\t    var xz = domain(values),\n\t        x0 = xz[0],\n\t        x1 = xz[1],\n\t        tz = threshold(values, x0, x1);\n\t\n\t    // Convert number of thresholds into uniform thresholds.\n\t    if (!Array.isArray(tz)) tz = ticks(x0, x1, tz);\n\t\n\t    // Remove any thresholds outside the domain.\n\t    var m = tz.length;\n\t    while (tz[0] <= x0) tz.shift(), --m;\n\t    while (tz[m - 1] >= x1) tz.pop(), --m;\n\t\n\t    var bins = new Array(m + 1),\n\t        bin;\n\t\n\t    // Initialize bins.\n\t    for (i = 0; i <= m; ++i) {\n\t      bin = bins[i] = [];\n\t      bin.x0 = i > 0 ? tz[i - 1] : x0;\n\t      bin.x1 = i < m ? tz[i] : x1;\n\t    }\n\t\n\t    // Assign data to bins by value, ignoring any outside the domain.\n\t    for (i = 0; i < n; ++i) {\n\t      x = values[i];\n\t      if (x0 <= x && x <= x1) {\n\t        bins[bisectRight(tz, x, 0, m)].push(data[i]);\n\t      }\n\t    }\n\t\n\t    return bins;\n\t  }\n\t\n\t  histogram.value = function(_) {\n\t    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant$1(_), histogram) : value;\n\t  };\n\t\n\t  histogram.domain = function(_) {\n\t    return arguments.length ? (domain = typeof _ === \"function\" ? _ : constant$1([_[0], _[1]]), histogram) : domain;\n\t  };\n\t\n\t  histogram.thresholds = function(_) {\n\t    return arguments.length ? (threshold = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant$1(slice.call(_)) : constant$1(_), histogram) : threshold;\n\t  };\n\t\n\t  return histogram;\n\t};\n\t\n\tvar threshold = function(array, p, f) {\n\t  if (f == null) f = number;\n\t  if (!(n = array.length)) return;\n\t  if ((p = +p) <= 0 || n < 2) return +f(array[0], 0, array);\n\t  if (p >= 1) return +f(array[n - 1], n - 1, array);\n\t  var n,\n\t      h = (n - 1) * p,\n\t      i = Math.floor(h),\n\t      a = +f(array[i], i, array),\n\t      b = +f(array[i + 1], i + 1, array);\n\t  return a + (b - a) * (h - i);\n\t};\n\t\n\tvar freedmanDiaconis = function(values, min, max) {\n\t  values = map.call(values, number).sort(ascending);\n\t  return Math.ceil((max - min) / (2 * (threshold(values, 0.75) - threshold(values, 0.25)) * Math.pow(values.length, -1 / 3)));\n\t};\n\t\n\tvar scott = function(values, min, max) {\n\t  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));\n\t};\n\t\n\tvar max = function(array, f) {\n\t  var i = -1,\n\t      n = array.length,\n\t      a,\n\t      b;\n\t\n\t  if (f == null) {\n\t    while (++i < n) if ((b = array[i]) != null && b >= b) { a = b; break; }\n\t    while (++i < n) if ((b = array[i]) != null && b > a) a = b;\n\t  }\n\t\n\t  else {\n\t    while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = b; break; }\n\t    while (++i < n) if ((b = f(array[i], i, array)) != null && b > a) a = b;\n\t  }\n\t\n\t  return a;\n\t};\n\t\n\tvar mean = function(array, f) {\n\t  var s = 0,\n\t      n = array.length,\n\t      a,\n\t      i = -1,\n\t      j = n;\n\t\n\t  if (f == null) {\n\t    while (++i < n) if (!isNaN(a = number(array[i]))) s += a; else --j;\n\t  }\n\t\n\t  else {\n\t    while (++i < n) if (!isNaN(a = number(f(array[i], i, array)))) s += a; else --j;\n\t  }\n\t\n\t  if (j) return s / j;\n\t};\n\t\n\tvar median = function(array, f) {\n\t  var numbers = [],\n\t      n = array.length,\n\t      a,\n\t      i = -1;\n\t\n\t  if (f == null) {\n\t    while (++i < n) if (!isNaN(a = number(array[i]))) numbers.push(a);\n\t  }\n\t\n\t  else {\n\t    while (++i < n) if (!isNaN(a = number(f(array[i], i, array)))) numbers.push(a);\n\t  }\n\t\n\t  return threshold(numbers.sort(ascending), 0.5);\n\t};\n\t\n\tvar merge = function(arrays) {\n\t  var n = arrays.length,\n\t      m,\n\t      i = -1,\n\t      j = 0,\n\t      merged,\n\t      array;\n\t\n\t  while (++i < n) j += arrays[i].length;\n\t  merged = new Array(j);\n\t\n\t  while (--n >= 0) {\n\t    array = arrays[n];\n\t    m = array.length;\n\t    while (--m >= 0) {\n\t      merged[--j] = array[m];\n\t    }\n\t  }\n\t\n\t  return merged;\n\t};\n\t\n\tvar min = function(array, f) {\n\t  var i = -1,\n\t      n = array.length,\n\t      a,\n\t      b;\n\t\n\t  if (f == null) {\n\t    while (++i < n) if ((b = array[i]) != null && b >= b) { a = b; break; }\n\t    while (++i < n) if ((b = array[i]) != null && a > b) a = b;\n\t  }\n\t\n\t  else {\n\t    while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = b; break; }\n\t    while (++i < n) if ((b = f(array[i], i, array)) != null && a > b) a = b;\n\t  }\n\t\n\t  return a;\n\t};\n\t\n\tvar pairs = function(array) {\n\t  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);\n\t  while (i < n) pairs[i] = [p, p = array[++i]];\n\t  return pairs;\n\t};\n\t\n\tvar permute = function(array, indexes) {\n\t  var i = indexes.length, permutes = new Array(i);\n\t  while (i--) permutes[i] = array[indexes[i]];\n\t  return permutes;\n\t};\n\t\n\tvar scan = function(array, compare) {\n\t  if (!(n = array.length)) return;\n\t  var i = 0,\n\t      n,\n\t      j = 0,\n\t      xi,\n\t      xj = array[j];\n\t\n\t  if (!compare) compare = ascending;\n\t\n\t  while (++i < n) if (compare(xi = array[i], xj) < 0 || compare(xj, xj) !== 0) xj = xi, j = i;\n\t\n\t  if (compare(xj, xj) === 0) return j;\n\t};\n\t\n\tvar shuffle = function(array, i0, i1) {\n\t  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),\n\t      t,\n\t      i;\n\t\n\t  while (m) {\n\t    i = Math.random() * m-- | 0;\n\t    t = array[m + i0];\n\t    array[m + i0] = array[i + i0];\n\t    array[i + i0] = t;\n\t  }\n\t\n\t  return array;\n\t};\n\t\n\tvar sum = function(array, f) {\n\t  var s = 0,\n\t      n = array.length,\n\t      a,\n\t      i = -1;\n\t\n\t  if (f == null) {\n\t    while (++i < n) if (a = +array[i]) s += a; // Note: zero and null are equivalent.\n\t  }\n\t\n\t  else {\n\t    while (++i < n) if (a = +f(array[i], i, array)) s += a;\n\t  }\n\t\n\t  return s;\n\t};\n\t\n\tvar transpose = function(matrix) {\n\t  if (!(n = matrix.length)) return [];\n\t  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {\n\t    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {\n\t      row[j] = matrix[j][i];\n\t    }\n\t  }\n\t  return transpose;\n\t};\n\t\n\tfunction length(d) {\n\t  return d.length;\n\t}\n\t\n\tvar zip = function() {\n\t  return transpose(arguments);\n\t};\n\t\n\tvar prefix = \"$\";\n\t\n\tfunction Map() {}\n\t\n\tMap.prototype = map$1.prototype = {\n\t  constructor: Map,\n\t  has: function(key) {\n\t    return (prefix + key) in this;\n\t  },\n\t  get: function(key) {\n\t    return this[prefix + key];\n\t  },\n\t  set: function(key, value) {\n\t    this[prefix + key] = value;\n\t    return this;\n\t  },\n\t  remove: function(key) {\n\t    var property = prefix + key;\n\t    return property in this && delete this[property];\n\t  },\n\t  clear: function() {\n\t    for (var property in this) if (property[0] === prefix) delete this[property];\n\t  },\n\t  keys: function() {\n\t    var keys = [];\n\t    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));\n\t    return keys;\n\t  },\n\t  values: function() {\n\t    var values = [];\n\t    for (var property in this) if (property[0] === prefix) values.push(this[property]);\n\t    return values;\n\t  },\n\t  entries: function() {\n\t    var entries = [];\n\t    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});\n\t    return entries;\n\t  },\n\t  size: function() {\n\t    var size = 0;\n\t    for (var property in this) if (property[0] === prefix) ++size;\n\t    return size;\n\t  },\n\t  empty: function() {\n\t    for (var property in this) if (property[0] === prefix) return false;\n\t    return true;\n\t  },\n\t  each: function(f) {\n\t    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);\n\t  }\n\t};\n\t\n\tfunction map$1(object, f) {\n\t  var map = new Map;\n\t\n\t  // Copy constructor.\n\t  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });\n\t\n\t  // Index array by numeric index or specified key function.\n\t  else if (Array.isArray(object)) {\n\t    var i = -1,\n\t        n = object.length,\n\t        o;\n\t\n\t    if (f == null) while (++i < n) map.set(i, object[i]);\n\t    else while (++i < n) map.set(f(o = object[i], i, object), o);\n\t  }\n\t\n\t  // Convert object to map.\n\t  else if (object) for (var key in object) map.set(key, object[key]);\n\t\n\t  return map;\n\t}\n\t\n\tvar nest = function() {\n\t  var keys = [],\n\t      sortKeys = [],\n\t      sortValues,\n\t      rollup,\n\t      nest;\n\t\n\t  function apply(array, depth, createResult, setResult) {\n\t    if (depth >= keys.length) return rollup != null\n\t        ? rollup(array) : (sortValues != null\n\t        ? array.sort(sortValues)\n\t        : array);\n\t\n\t    var i = -1,\n\t        n = array.length,\n\t        key = keys[depth++],\n\t        keyValue,\n\t        value,\n\t        valuesByKey = map$1(),\n\t        values,\n\t        result = createResult();\n\t\n\t    while (++i < n) {\n\t      if (values = valuesByKey.get(keyValue = key(value = array[i]) + \"\")) {\n\t        values.push(value);\n\t      } else {\n\t        valuesByKey.set(keyValue, [value]);\n\t      }\n\t    }\n\t\n\t    valuesByKey.each(function(values, key) {\n\t      setResult(result, key, apply(values, depth, createResult, setResult));\n\t    });\n\t\n\t    return result;\n\t  }\n\t\n\t  function entries(map, depth) {\n\t    if (++depth > keys.length) return map;\n\t    var array, sortKey = sortKeys[depth - 1];\n\t    if (rollup != null && depth >= keys.length) array = map.entries();\n\t    else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });\n\t    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;\n\t  }\n\t\n\t  return nest = {\n\t    object: function(array) { return apply(array, 0, createObject, setObject); },\n\t    map: function(array) { return apply(array, 0, createMap, setMap); },\n\t    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },\n\t    key: function(d) { keys.push(d); return nest; },\n\t    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },\n\t    sortValues: function(order) { sortValues = order; return nest; },\n\t    rollup: function(f) { rollup = f; return nest; }\n\t  };\n\t};\n\t\n\tfunction createObject() {\n\t  return {};\n\t}\n\t\n\tfunction setObject(object, key, value) {\n\t  object[key] = value;\n\t}\n\t\n\tfunction createMap() {\n\t  return map$1();\n\t}\n\t\n\tfunction setMap(map, key, value) {\n\t  map.set(key, value);\n\t}\n\t\n\tfunction Set() {}\n\t\n\tvar proto = map$1.prototype;\n\t\n\tSet.prototype = set.prototype = {\n\t  constructor: Set,\n\t  has: proto.has,\n\t  add: function(value) {\n\t    value += \"\";\n\t    this[prefix + value] = value;\n\t    return this;\n\t  },\n\t  remove: proto.remove,\n\t  clear: proto.clear,\n\t  values: proto.keys,\n\t  size: proto.size,\n\t  empty: proto.empty,\n\t  each: proto.each\n\t};\n\t\n\tfunction set(object, f) {\n\t  var set = new Set;\n\t\n\t  // Copy constructor.\n\t  if (object instanceof Set) object.each(function(value) { set.add(value); });\n\t\n\t  // Otherwise, assume it’s an array.\n\t  else if (object) {\n\t    var i = -1, n = object.length;\n\t    if (f == null) while (++i < n) set.add(object[i]);\n\t    else while (++i < n) set.add(f(object[i], i, object));\n\t  }\n\t\n\t  return set;\n\t}\n\t\n\tvar keys = function(map) {\n\t  var keys = [];\n\t  for (var key in map) keys.push(key);\n\t  return keys;\n\t};\n\t\n\tvar values = function(map) {\n\t  var values = [];\n\t  for (var key in map) values.push(map[key]);\n\t  return values;\n\t};\n\t\n\tvar entries = function(map) {\n\t  var entries = [];\n\t  for (var key in map) entries.push({key: key, value: map[key]});\n\t  return entries;\n\t};\n\t\n\tvar uniform = function(min, max) {\n\t  min = min == null ? 0 : +min;\n\t  max = max == null ? 1 : +max;\n\t  if (arguments.length === 1) max = min, min = 0;\n\t  else max -= min;\n\t  return function() {\n\t    return Math.random() * max + min;\n\t  };\n\t};\n\t\n\tvar normal = function(mu, sigma) {\n\t  var x, r;\n\t  mu = mu == null ? 0 : +mu;\n\t  sigma = sigma == null ? 1 : +sigma;\n\t  return function() {\n\t    var y;\n\t\n\t    // If available, use the second previously-generated uniform random.\n\t    if (x != null) y = x, x = null;\n\t\n\t    // Otherwise, generate a new x and y.\n\t    else do {\n\t      x = Math.random() * 2 - 1;\n\t      y = Math.random() * 2 - 1;\n\t      r = x * x + y * y;\n\t    } while (!r || r > 1);\n\t\n\t    return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);\n\t  };\n\t};\n\t\n\tvar logNormal = function() {\n\t  var randomNormal = normal.apply(this, arguments);\n\t  return function() {\n\t    return Math.exp(randomNormal());\n\t  };\n\t};\n\t\n\tvar irwinHall = function(n) {\n\t  return function() {\n\t    for (var sum = 0, i = 0; i < n; ++i) sum += Math.random();\n\t    return sum;\n\t  };\n\t};\n\t\n\tvar bates = function(n) {\n\t  var randomIrwinHall = irwinHall(n);\n\t  return function() {\n\t    return randomIrwinHall() / n;\n\t  };\n\t};\n\t\n\tvar exponential = function(lambda) {\n\t  return function() {\n\t    return -Math.log(1 - Math.random()) / lambda;\n\t  };\n\t};\n\t\n\tfunction linear(t) {\n\t  return +t;\n\t}\n\t\n\tfunction quadIn(t) {\n\t  return t * t;\n\t}\n\t\n\tfunction quadOut(t) {\n\t  return t * (2 - t);\n\t}\n\t\n\tfunction quadInOut(t) {\n\t  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;\n\t}\n\t\n\tfunction cubicIn(t) {\n\t  return t * t * t;\n\t}\n\t\n\tfunction cubicOut(t) {\n\t  return --t * t * t + 1;\n\t}\n\t\n\tfunction cubicInOut(t) {\n\t  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\n\t}\n\t\n\tvar exponent = 3;\n\t\n\tvar polyIn = (function custom(e) {\n\t  e = +e;\n\t\n\t  function polyIn(t) {\n\t    return Math.pow(t, e);\n\t  }\n\t\n\t  polyIn.exponent = custom;\n\t\n\t  return polyIn;\n\t})(exponent);\n\t\n\tvar polyOut = (function custom(e) {\n\t  e = +e;\n\t\n\t  function polyOut(t) {\n\t    return 1 - Math.pow(1 - t, e);\n\t  }\n\t\n\t  polyOut.exponent = custom;\n\t\n\t  return polyOut;\n\t})(exponent);\n\t\n\tvar polyInOut = (function custom(e) {\n\t  e = +e;\n\t\n\t  function polyInOut(t) {\n\t    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;\n\t  }\n\t\n\t  polyInOut.exponent = custom;\n\t\n\t  return polyInOut;\n\t})(exponent);\n\t\n\tvar pi = Math.PI;\n\tvar halfPi = pi / 2;\n\t\n\tfunction sinIn(t) {\n\t  return 1 - Math.cos(t * halfPi);\n\t}\n\t\n\tfunction sinOut(t) {\n\t  return Math.sin(t * halfPi);\n\t}\n\t\n\tfunction sinInOut(t) {\n\t  return (1 - Math.cos(pi * t)) / 2;\n\t}\n\t\n\tfunction expIn(t) {\n\t  return Math.pow(2, 10 * t - 10);\n\t}\n\t\n\tfunction expOut(t) {\n\t  return 1 - Math.pow(2, -10 * t);\n\t}\n\t\n\tfunction expInOut(t) {\n\t  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;\n\t}\n\t\n\tfunction circleIn(t) {\n\t  return 1 - Math.sqrt(1 - t * t);\n\t}\n\t\n\tfunction circleOut(t) {\n\t  return Math.sqrt(1 - --t * t);\n\t}\n\t\n\tfunction circleInOut(t) {\n\t  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;\n\t}\n\t\n\tvar b1 = 4 / 11;\n\tvar b2 = 6 / 11;\n\tvar b3 = 8 / 11;\n\tvar b4 = 3 / 4;\n\tvar b5 = 9 / 11;\n\tvar b6 = 10 / 11;\n\tvar b7 = 15 / 16;\n\tvar b8 = 21 / 22;\n\tvar b9 = 63 / 64;\n\tvar b0 = 1 / b1 / b1;\n\t\n\tfunction bounceIn(t) {\n\t  return 1 - bounceOut(1 - t);\n\t}\n\t\n\tfunction bounceOut(t) {\n\t  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;\n\t}\n\t\n\tfunction bounceInOut(t) {\n\t  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;\n\t}\n\t\n\tvar overshoot = 1.70158;\n\t\n\tvar backIn = (function custom(s) {\n\t  s = +s;\n\t\n\t  function backIn(t) {\n\t    return t * t * ((s + 1) * t - s);\n\t  }\n\t\n\t  backIn.overshoot = custom;\n\t\n\t  return backIn;\n\t})(overshoot);\n\t\n\tvar backOut = (function custom(s) {\n\t  s = +s;\n\t\n\t  function backOut(t) {\n\t    return --t * t * ((s + 1) * t + s) + 1;\n\t  }\n\t\n\t  backOut.overshoot = custom;\n\t\n\t  return backOut;\n\t})(overshoot);\n\t\n\tvar backInOut = (function custom(s) {\n\t  s = +s;\n\t\n\t  function backInOut(t) {\n\t    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;\n\t  }\n\t\n\t  backInOut.overshoot = custom;\n\t\n\t  return backInOut;\n\t})(overshoot);\n\t\n\tvar tau = 2 * Math.PI;\n\tvar amplitude = 1;\n\tvar period = 0.3;\n\t\n\tvar elasticIn = (function custom(a, p) {\n\t  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);\n\t\n\t  function elasticIn(t) {\n\t    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);\n\t  }\n\t\n\t  elasticIn.amplitude = function(a) { return custom(a, p * tau); };\n\t  elasticIn.period = function(p) { return custom(a, p); };\n\t\n\t  return elasticIn;\n\t})(amplitude, period);\n\t\n\tvar elasticOut = (function custom(a, p) {\n\t  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);\n\t\n\t  function elasticOut(t) {\n\t    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);\n\t  }\n\t\n\t  elasticOut.amplitude = function(a) { return custom(a, p * tau); };\n\t  elasticOut.period = function(p) { return custom(a, p); };\n\t\n\t  return elasticOut;\n\t})(amplitude, period);\n\t\n\tvar elasticInOut = (function custom(a, p) {\n\t  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);\n\t\n\t  function elasticInOut(t) {\n\t    return ((t = t * 2 - 1) < 0\n\t        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)\n\t        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;\n\t  }\n\t\n\t  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };\n\t  elasticInOut.period = function(p) { return custom(a, p); };\n\t\n\t  return elasticInOut;\n\t})(amplitude, period);\n\t\n\tvar area = function(polygon) {\n\t  var i = -1,\n\t      n = polygon.length,\n\t      a,\n\t      b = polygon[n - 1],\n\t      area = 0;\n\t\n\t  while (++i < n) {\n\t    a = b;\n\t    b = polygon[i];\n\t    area += a[1] * b[0] - a[0] * b[1];\n\t  }\n\t\n\t  return area / 2;\n\t};\n\t\n\tvar centroid = function(polygon) {\n\t  var i = -1,\n\t      n = polygon.length,\n\t      x = 0,\n\t      y = 0,\n\t      a,\n\t      b = polygon[n - 1],\n\t      c,\n\t      k = 0;\n\t\n\t  while (++i < n) {\n\t    a = b;\n\t    b = polygon[i];\n\t    k += c = a[0] * b[1] - b[0] * a[1];\n\t    x += (a[0] + b[0]) * c;\n\t    y += (a[1] + b[1]) * c;\n\t  }\n\t\n\t  return k *= 3, [x / k, y / k];\n\t};\n\t\n\t// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of\n\t// the 3D cross product in a quadrant I Cartesian coordinate system (+x is\n\t// right, +y is up). Returns a positive value if ABC is counter-clockwise,\n\t// negative if clockwise, and zero if the points are collinear.\n\tvar cross = function(a, b, c) {\n\t  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\n\t};\n\t\n\tfunction lexicographicOrder(a, b) {\n\t  return a[0] - b[0] || a[1] - b[1];\n\t}\n\t\n\t// Computes the upper convex hull per the monotone chain algorithm.\n\t// Assumes points.length >= 3, is sorted by x, unique in y.\n\t// Returns an array of indices into points in left-to-right order.\n\tfunction computeUpperHullIndexes(points) {\n\t  var n = points.length,\n\t      indexes = [0, 1],\n\t      size = 2;\n\t\n\t  for (var i = 2; i < n; ++i) {\n\t    while (size > 1 && cross(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;\n\t    indexes[size++] = i;\n\t  }\n\t\n\t  return indexes.slice(0, size); // remove popped points\n\t}\n\t\n\tvar hull = function(points) {\n\t  if ((n = points.length) < 3) return null;\n\t\n\t  var i,\n\t      n,\n\t      sortedPoints = new Array(n),\n\t      flippedPoints = new Array(n);\n\t\n\t  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];\n\t  sortedPoints.sort(lexicographicOrder);\n\t  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];\n\t\n\t  var upperIndexes = computeUpperHullIndexes(sortedPoints),\n\t      lowerIndexes = computeUpperHullIndexes(flippedPoints);\n\t\n\t  // Construct the hull polygon, removing possible duplicate endpoints.\n\t  var skipLeft = lowerIndexes[0] === upperIndexes[0],\n\t      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],\n\t      hull = [];\n\t\n\t  // Add upper hull in right-to-l order.\n\t  // Then add lower hull in left-to-right order.\n\t  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);\n\t  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);\n\t\n\t  return hull;\n\t};\n\t\n\tvar contains = function(polygon, point) {\n\t  var n = polygon.length,\n\t      p = polygon[n - 1],\n\t      x = point[0], y = point[1],\n\t      x0 = p[0], y0 = p[1],\n\t      x1, y1,\n\t      inside = false;\n\t\n\t  for (var i = 0; i < n; ++i) {\n\t    p = polygon[i], x1 = p[0], y1 = p[1];\n\t    if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;\n\t    x0 = x1, y0 = y1;\n\t  }\n\t\n\t  return inside;\n\t};\n\t\n\tvar length$1 = function(polygon) {\n\t  var i = -1,\n\t      n = polygon.length,\n\t      b = polygon[n - 1],\n\t      xa,\n\t      ya,\n\t      xb = b[0],\n\t      yb = b[1],\n\t      perimeter = 0;\n\t\n\t  while (++i < n) {\n\t    xa = xb;\n\t    ya = yb;\n\t    b = polygon[i];\n\t    xb = b[0];\n\t    yb = b[1];\n\t    xa -= xb;\n\t    ya -= yb;\n\t    perimeter += Math.sqrt(xa * xa + ya * ya);\n\t  }\n\t\n\t  return perimeter;\n\t};\n\t\n\tvar pi$1 = Math.PI;\n\tvar tau$1 = 2 * pi$1;\n\tvar epsilon = 1e-6;\n\tvar tauEpsilon = tau$1 - epsilon;\n\t\n\tfunction Path() {\n\t  this._x0 = this._y0 = // start of current subpath\n\t  this._x1 = this._y1 = null; // end of current subpath\n\t  this._ = [];\n\t}\n\t\n\tfunction path() {\n\t  return new Path;\n\t}\n\t\n\tPath.prototype = path.prototype = {\n\t  constructor: Path,\n\t  moveTo: function(x, y) {\n\t    this._.push(\"M\", this._x0 = this._x1 = +x, \",\", this._y0 = this._y1 = +y);\n\t  },\n\t  closePath: function() {\n\t    if (this._x1 !== null) {\n\t      this._x1 = this._x0, this._y1 = this._y0;\n\t      this._.push(\"Z\");\n\t    }\n\t  },\n\t  lineTo: function(x, y) {\n\t    this._.push(\"L\", this._x1 = +x, \",\", this._y1 = +y);\n\t  },\n\t  quadraticCurveTo: function(x1, y1, x, y) {\n\t    this._.push(\"Q\", +x1, \",\", +y1, \",\", this._x1 = +x, \",\", this._y1 = +y);\n\t  },\n\t  bezierCurveTo: function(x1, y1, x2, y2, x, y) {\n\t    this._.push(\"C\", +x1, \",\", +y1, \",\", +x2, \",\", +y2, \",\", this._x1 = +x, \",\", this._y1 = +y);\n\t  },\n\t  arcTo: function(x1, y1, x2, y2, r) {\n\t    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;\n\t    var x0 = this._x1,\n\t        y0 = this._y1,\n\t        x21 = x2 - x1,\n\t        y21 = y2 - y1,\n\t        x01 = x0 - x1,\n\t        y01 = y0 - y1,\n\t        l01_2 = x01 * x01 + y01 * y01;\n\t\n\t    // Is the radius negative? Error.\n\t    if (r < 0) throw new Error(\"negative radius: \" + r);\n\t\n\t    // Is this path empty? Move to (x1,y1).\n\t    if (this._x1 === null) {\n\t      this._.push(\n\t        \"M\", this._x1 = x1, \",\", this._y1 = y1\n\t      );\n\t    }\n\t\n\t    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.\n\t    else if (!(l01_2 > epsilon)) {}\n\t\n\t    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?\n\t    // Equivalently, is (x1,y1) coincident with (x2,y2)?\n\t    // Or, is the radius zero? Line to (x1,y1).\n\t    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {\n\t      this._.push(\n\t        \"L\", this._x1 = x1, \",\", this._y1 = y1\n\t      );\n\t    }\n\t\n\t    // Otherwise, draw an arc!\n\t    else {\n\t      var x20 = x2 - x0,\n\t          y20 = y2 - y0,\n\t          l21_2 = x21 * x21 + y21 * y21,\n\t          l20_2 = x20 * x20 + y20 * y20,\n\t          l21 = Math.sqrt(l21_2),\n\t          l01 = Math.sqrt(l01_2),\n\t          l = r * Math.tan((pi$1 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),\n\t          t01 = l / l01,\n\t          t21 = l / l21;\n\t\n\t      // If the start tangent is not coincident with (x0,y0), line to.\n\t      if (Math.abs(t01 - 1) > epsilon) {\n\t        this._.push(\n\t          \"L\", x1 + t01 * x01, \",\", y1 + t01 * y01\n\t        );\n\t      }\n\t\n\t      this._.push(\n\t        \"A\", r, \",\", r, \",0,0,\", +(y01 * x20 > x01 * y20), \",\", this._x1 = x1 + t21 * x21, \",\", this._y1 = y1 + t21 * y21\n\t      );\n\t    }\n\t  },\n\t  arc: function(x, y, r, a0, a1, ccw) {\n\t    x = +x, y = +y, r = +r;\n\t    var dx = r * Math.cos(a0),\n\t        dy = r * Math.sin(a0),\n\t        x0 = x + dx,\n\t        y0 = y + dy,\n\t        cw = 1 ^ ccw,\n\t        da = ccw ? a0 - a1 : a1 - a0;\n\t\n\t    // Is the radius negative? Error.\n\t    if (r < 0) throw new Error(\"negative radius: \" + r);\n\t\n\t    // Is this path empty? Move to (x0,y0).\n\t    if (this._x1 === null) {\n\t      this._.push(\n\t        \"M\", x0, \",\", y0\n\t      );\n\t    }\n\t\n\t    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).\n\t    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {\n\t      this._.push(\n\t        \"L\", x0, \",\", y0\n\t      );\n\t    }\n\t\n\t    // Is this arc empty? We’re done.\n\t    if (!r) return;\n\t\n\t    // Is this a complete circle? Draw two arcs to complete the circle.\n\t    if (da > tauEpsilon) {\n\t      this._.push(\n\t        \"A\", r, \",\", r, \",0,1,\", cw, \",\", x - dx, \",\", y - dy,\n\t        \"A\", r, \",\", r, \",0,1,\", cw, \",\", this._x1 = x0, \",\", this._y1 = y0\n\t      );\n\t    }\n\t\n\t    // Otherwise, draw an arc!\n\t    else {\n\t      if (da < 0) da = da % tau$1 + tau$1;\n\t      this._.push(\n\t        \"A\", r, \",\", r, \",0,\", +(da >= pi$1), \",\", cw, \",\", this._x1 = x + r * Math.cos(a1), \",\", this._y1 = y + r * Math.sin(a1)\n\t      );\n\t    }\n\t  },\n\t  rect: function(x, y, w, h) {\n\t    this._.push(\"M\", this._x0 = this._x1 = +x, \",\", this._y0 = this._y1 = +y, \"h\", +w, \"v\", +h, \"h\", -w, \"Z\");\n\t  },\n\t  toString: function() {\n\t    return this._.join(\"\");\n\t  }\n\t};\n\t\n\tvar tree_add = function(d) {\n\t  var x = +this._x.call(null, d),\n\t      y = +this._y.call(null, d);\n\t  return add(this.cover(x, y), x, y, d);\n\t};\n\t\n\tfunction add(tree, x, y, d) {\n\t  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points\n\t\n\t  var parent,\n\t      node = tree._root,\n\t      leaf = {data: d},\n\t      x0 = tree._x0,\n\t      y0 = tree._y0,\n\t      x1 = tree._x1,\n\t      y1 = tree._y1,\n\t      xm,\n\t      ym,\n\t      xp,\n\t      yp,\n\t      right,\n\t      bottom,\n\t      i,\n\t      j;\n\t\n\t  // If the tree is empty, initialize the root as a leaf.\n\t  if (!node) return tree._root = leaf, tree;\n\t\n\t  // Find the existing leaf for the new point, or add it.\n\t  while (node.length) {\n\t    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n\t    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n\t    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;\n\t  }\n\t\n\t  // Is the new point is exactly coincident with the existing point?\n\t  xp = +tree._x.call(null, node.data);\n\t  yp = +tree._y.call(null, node.data);\n\t  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;\n\t\n\t  // Otherwise, split the leaf node until the old and new point are separated.\n\t  do {\n\t    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);\n\t    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n\t    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n\t  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));\n\t  return parent[j] = node, parent[i] = leaf, tree;\n\t}\n\t\n\tfunction addAll(data) {\n\t  var d, i, n = data.length,\n\t      x,\n\t      y,\n\t      xz = new Array(n),\n\t      yz = new Array(n),\n\t      x0 = Infinity,\n\t      y0 = Infinity,\n\t      x1 = -Infinity,\n\t      y1 = -Infinity;\n\t\n\t  // Compute the points and their extent.\n\t  for (i = 0; i < n; ++i) {\n\t    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;\n\t    xz[i] = x;\n\t    yz[i] = y;\n\t    if (x < x0) x0 = x;\n\t    if (x > x1) x1 = x;\n\t    if (y < y0) y0 = y;\n\t    if (y > y1) y1 = y;\n\t  }\n\t\n\t  // If there were no (valid) points, inherit the existing extent.\n\t  if (x1 < x0) x0 = this._x0, x1 = this._x1;\n\t  if (y1 < y0) y0 = this._y0, y1 = this._y1;\n\t\n\t  // Expand the tree to cover the new points.\n\t  this.cover(x0, y0).cover(x1, y1);\n\t\n\t  // Add the new points.\n\t  for (i = 0; i < n; ++i) {\n\t    add(this, xz[i], yz[i], data[i]);\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\tvar tree_cover = function(x, y) {\n\t  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points\n\t\n\t  var x0 = this._x0,\n\t      y0 = this._y0,\n\t      x1 = this._x1,\n\t      y1 = this._y1;\n\t\n\t  // If the quadtree has no extent, initialize them.\n\t  // Integer extent are necessary so that if we later double the extent,\n\t  // the existing quadrant boundaries don’t change due to floating point error!\n\t  if (isNaN(x0)) {\n\t    x1 = (x0 = Math.floor(x)) + 1;\n\t    y1 = (y0 = Math.floor(y)) + 1;\n\t  }\n\t\n\t  // Otherwise, double repeatedly to cover.\n\t  else if (x0 > x || x > x1 || y0 > y || y > y1) {\n\t    var z = x1 - x0,\n\t        node = this._root,\n\t        parent,\n\t        i;\n\t\n\t    switch (i = (y < (y0 + y1) / 2) << 1 | (x < (x0 + x1) / 2)) {\n\t      case 0: {\n\t        do parent = new Array(4), parent[i] = node, node = parent;\n\t        while (z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1);\n\t        break;\n\t      }\n\t      case 1: {\n\t        do parent = new Array(4), parent[i] = node, node = parent;\n\t        while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1);\n\t        break;\n\t      }\n\t      case 2: {\n\t        do parent = new Array(4), parent[i] = node, node = parent;\n\t        while (z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y);\n\t        break;\n\t      }\n\t      case 3: {\n\t        do parent = new Array(4), parent[i] = node, node = parent;\n\t        while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y);\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (this._root && this._root.length) this._root = node;\n\t  }\n\t\n\t  // If the quadtree covers the point already, just return.\n\t  else return this;\n\t\n\t  this._x0 = x0;\n\t  this._y0 = y0;\n\t  this._x1 = x1;\n\t  this._y1 = y1;\n\t  return this;\n\t};\n\t\n\tvar tree_data = function() {\n\t  var data = [];\n\t  this.visit(function(node) {\n\t    if (!node.length) do data.push(node.data); while (node = node.next)\n\t  });\n\t  return data;\n\t};\n\t\n\tvar tree_extent = function(_) {\n\t  return arguments.length\n\t      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])\n\t      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];\n\t};\n\t\n\tvar Quad = function(node, x0, y0, x1, y1) {\n\t  this.node = node;\n\t  this.x0 = x0;\n\t  this.y0 = y0;\n\t  this.x1 = x1;\n\t  this.y1 = y1;\n\t};\n\t\n\tvar tree_find = function(x, y, radius) {\n\t  var data,\n\t      x0 = this._x0,\n\t      y0 = this._y0,\n\t      x1,\n\t      y1,\n\t      x2,\n\t      y2,\n\t      x3 = this._x1,\n\t      y3 = this._y1,\n\t      quads = [],\n\t      node = this._root,\n\t      q,\n\t      i;\n\t\n\t  if (node) quads.push(new Quad(node, x0, y0, x3, y3));\n\t  if (radius == null) radius = Infinity;\n\t  else {\n\t    x0 = x - radius, y0 = y - radius;\n\t    x3 = x + radius, y3 = y + radius;\n\t    radius *= radius;\n\t  }\n\t\n\t  while (q = quads.pop()) {\n\t\n\t    // Stop searching if this quadrant can’t contain a closer node.\n\t    if (!(node = q.node)\n\t        || (x1 = q.x0) > x3\n\t        || (y1 = q.y0) > y3\n\t        || (x2 = q.x1) < x0\n\t        || (y2 = q.y1) < y0) continue;\n\t\n\t    // Bisect the current quadrant.\n\t    if (node.length) {\n\t      var xm = (x1 + x2) / 2,\n\t          ym = (y1 + y2) / 2;\n\t\n\t      quads.push(\n\t        new Quad(node[3], xm, ym, x2, y2),\n\t        new Quad(node[2], x1, ym, xm, y2),\n\t        new Quad(node[1], xm, y1, x2, ym),\n\t        new Quad(node[0], x1, y1, xm, ym)\n\t      );\n\t\n\t      // Visit the closest quadrant first.\n\t      if (i = (y >= ym) << 1 | (x >= xm)) {\n\t        q = quads[quads.length - 1];\n\t        quads[quads.length - 1] = quads[quads.length - 1 - i];\n\t        quads[quads.length - 1 - i] = q;\n\t      }\n\t    }\n\t\n\t    // Visit this point. (Visiting coincident points isn’t necessary!)\n\t    else {\n\t      var dx = x - +this._x.call(null, node.data),\n\t          dy = y - +this._y.call(null, node.data),\n\t          d2 = dx * dx + dy * dy;\n\t      if (d2 < radius) {\n\t        var d = Math.sqrt(radius = d2);\n\t        x0 = x - d, y0 = y - d;\n\t        x3 = x + d, y3 = y + d;\n\t        data = node.data;\n\t      }\n\t    }\n\t  }\n\t\n\t  return data;\n\t};\n\t\n\tvar tree_remove = function(d) {\n\t  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points\n\t\n\t  var parent,\n\t      node = this._root,\n\t      retainer,\n\t      previous,\n\t      next,\n\t      x0 = this._x0,\n\t      y0 = this._y0,\n\t      x1 = this._x1,\n\t      y1 = this._y1,\n\t      x,\n\t      y,\n\t      xm,\n\t      ym,\n\t      right,\n\t      bottom,\n\t      i,\n\t      j;\n\t\n\t  // If the tree is empty, initialize the root as a leaf.\n\t  if (!node) return this;\n\t\n\t  // Find the leaf node for the point.\n\t  // While descending, also retain the deepest parent with a non-removed sibling.\n\t  if (node.length) while (true) {\n\t    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n\t    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n\t    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;\n\t    if (!node.length) break;\n\t    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;\n\t  }\n\t\n\t  // Find the point to remove.\n\t  while (node.data !== d) if (!(previous = node, node = node.next)) return this;\n\t  if (next = node.next) delete node.next;\n\t\n\t  // If there are multiple coincident points, remove just the point.\n\t  if (previous) return (next ? previous.next = next : delete previous.next), this;\n\t\n\t  // If this is the root point, remove it.\n\t  if (!parent) return this._root = next, this;\n\t\n\t  // Remove this leaf.\n\t  next ? parent[i] = next : delete parent[i];\n\t\n\t  // If the parent now contains exactly one leaf, collapse superfluous parents.\n\t  if ((node = parent[0] || parent[1] || parent[2] || parent[3])\n\t      && node === (parent[3] || parent[2] || parent[1] || parent[0])\n\t      && !node.length) {\n\t    if (retainer) retainer[j] = node;\n\t    else this._root = node;\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tfunction removeAll(data) {\n\t  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);\n\t  return this;\n\t}\n\t\n\tvar tree_root = function() {\n\t  return this._root;\n\t};\n\t\n\tvar tree_size = function() {\n\t  var size = 0;\n\t  this.visit(function(node) {\n\t    if (!node.length) do ++size; while (node = node.next)\n\t  });\n\t  return size;\n\t};\n\t\n\tvar tree_visit = function(callback) {\n\t  var quads = [], q, node = this._root, child, x0, y0, x1, y1;\n\t  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));\n\t  while (q = quads.pop()) {\n\t    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {\n\t      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n\t      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));\n\t      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));\n\t      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));\n\t      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));\n\t    }\n\t  }\n\t  return this;\n\t};\n\t\n\tvar tree_visitAfter = function(callback) {\n\t  var quads = [], next = [], q;\n\t  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));\n\t  while (q = quads.pop()) {\n\t    var node = q.node;\n\t    if (node.length) {\n\t      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n\t      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));\n\t      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));\n\t      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));\n\t      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));\n\t    }\n\t    next.push(q);\n\t  }\n\t  while (q = next.pop()) {\n\t    callback(q.node, q.x0, q.y0, q.x1, q.y1);\n\t  }\n\t  return this;\n\t};\n\t\n\tfunction defaultX(d) {\n\t  return d[0];\n\t}\n\t\n\tvar tree_x = function(_) {\n\t  return arguments.length ? (this._x = _, this) : this._x;\n\t};\n\t\n\tfunction defaultY(d) {\n\t  return d[1];\n\t}\n\t\n\tvar tree_y = function(_) {\n\t  return arguments.length ? (this._y = _, this) : this._y;\n\t};\n\t\n\tfunction quadtree(nodes, x, y) {\n\t  var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);\n\t  return nodes == null ? tree : tree.addAll(nodes);\n\t}\n\t\n\tfunction Quadtree(x, y, x0, y0, x1, y1) {\n\t  this._x = x;\n\t  this._y = y;\n\t  this._x0 = x0;\n\t  this._y0 = y0;\n\t  this._x1 = x1;\n\t  this._y1 = y1;\n\t  this._root = undefined;\n\t}\n\t\n\tfunction leaf_copy(leaf) {\n\t  var copy = {data: leaf.data}, next = copy;\n\t  while (leaf = leaf.next) next = next.next = {data: leaf.data};\n\t  return copy;\n\t}\n\t\n\tvar treeProto = quadtree.prototype = Quadtree.prototype;\n\t\n\ttreeProto.copy = function() {\n\t  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),\n\t      node = this._root,\n\t      nodes,\n\t      child;\n\t\n\t  if (!node) return copy;\n\t\n\t  if (!node.length) return copy._root = leaf_copy(node), copy;\n\t\n\t  nodes = [{source: node, target: copy._root = new Array(4)}];\n\t  while (node = nodes.pop()) {\n\t    for (var i = 0; i < 4; ++i) {\n\t      if (child = node.source[i]) {\n\t        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});\n\t        else node.target[i] = leaf_copy(child);\n\t      }\n\t    }\n\t  }\n\t\n\t  return copy;\n\t};\n\t\n\ttreeProto.add = tree_add;\n\ttreeProto.addAll = addAll;\n\ttreeProto.cover = tree_cover;\n\ttreeProto.data = tree_data;\n\ttreeProto.extent = tree_extent;\n\ttreeProto.find = tree_find;\n\ttreeProto.remove = tree_remove;\n\ttreeProto.removeAll = removeAll;\n\ttreeProto.root = tree_root;\n\ttreeProto.size = tree_size;\n\ttreeProto.visit = tree_visit;\n\ttreeProto.visitAfter = tree_visitAfter;\n\ttreeProto.x = tree_x;\n\ttreeProto.y = tree_y;\n\t\n\tvar slice$1 = [].slice;\n\t\n\tvar noabort = {};\n\t\n\tfunction Queue(size) {\n\t  if (!(size >= 1)) throw new Error;\n\t  this._size = size;\n\t  this._call =\n\t  this._error = null;\n\t  this._tasks = [];\n\t  this._data = [];\n\t  this._waiting =\n\t  this._active =\n\t  this._ended =\n\t  this._start = 0; // inside a synchronous task callback?\n\t}\n\t\n\tQueue.prototype = queue.prototype = {\n\t  constructor: Queue,\n\t  defer: function(callback) {\n\t    if (typeof callback !== \"function\" || this._call) throw new Error;\n\t    if (this._error != null) return this;\n\t    var t = slice$1.call(arguments, 1);\n\t    t.push(callback);\n\t    ++this._waiting, this._tasks.push(t);\n\t    poke(this);\n\t    return this;\n\t  },\n\t  abort: function() {\n\t    if (this._error == null) abort(this, new Error(\"abort\"));\n\t    return this;\n\t  },\n\t  await: function(callback) {\n\t    if (typeof callback !== \"function\" || this._call) throw new Error;\n\t    this._call = function(error, results) { callback.apply(null, [error].concat(results)); };\n\t    maybeNotify(this);\n\t    return this;\n\t  },\n\t  awaitAll: function(callback) {\n\t    if (typeof callback !== \"function\" || this._call) throw new Error;\n\t    this._call = callback;\n\t    maybeNotify(this);\n\t    return this;\n\t  }\n\t};\n\t\n\tfunction poke(q) {\n\t  if (!q._start) {\n\t    try { start(q); } // let the current task complete\n\t    catch (e) {\n\t      if (q._tasks[q._ended + q._active - 1]) abort(q, e); // task errored synchronously\n\t      else if (!q._data) throw e; // await callback errored synchronously\n\t    }\n\t  }\n\t}\n\t\n\tfunction start(q) {\n\t  while (q._start = q._waiting && q._active < q._size) {\n\t    var i = q._ended + q._active,\n\t        t = q._tasks[i],\n\t        j = t.length - 1,\n\t        c = t[j];\n\t    t[j] = end(q, i);\n\t    --q._waiting, ++q._active;\n\t    t = c.apply(null, t);\n\t    if (!q._tasks[i]) continue; // task finished synchronously\n\t    q._tasks[i] = t || noabort;\n\t  }\n\t}\n\t\n\tfunction end(q, i) {\n\t  return function(e, r) {\n\t    if (!q._tasks[i]) return; // ignore multiple callbacks\n\t    --q._active, ++q._ended;\n\t    q._tasks[i] = null;\n\t    if (q._error != null) return; // ignore secondary errors\n\t    if (e != null) {\n\t      abort(q, e);\n\t    } else {\n\t      q._data[i] = r;\n\t      if (q._waiting) poke(q);\n\t      else maybeNotify(q);\n\t    }\n\t  };\n\t}\n\t\n\tfunction abort(q, e) {\n\t  var i = q._tasks.length, t;\n\t  q._error = e; // ignore active callbacks\n\t  q._data = undefined; // allow gc\n\t  q._waiting = NaN; // prevent starting\n\t\n\t  while (--i >= 0) {\n\t    if (t = q._tasks[i]) {\n\t      q._tasks[i] = null;\n\t      if (t.abort) {\n\t        try { t.abort(); }\n\t        catch (e) { /* ignore */ }\n\t      }\n\t    }\n\t  }\n\t\n\t  q._active = NaN; // allow notification\n\t  maybeNotify(q);\n\t}\n\t\n\tfunction maybeNotify(q) {\n\t  if (!q._active && q._call) {\n\t    var d = q._data;\n\t    q._data = undefined; // allow gc\n\t    q._call(q._error, d);\n\t  }\n\t}\n\t\n\tfunction queue(concurrency) {\n\t  return new Queue(arguments.length ? +concurrency : Infinity);\n\t}\n\t\n\tvar constant$2 = function(x) {\n\t  return function constant() {\n\t    return x;\n\t  };\n\t};\n\t\n\tvar epsilon$1 = 1e-12;\n\tvar pi$2 = Math.PI;\n\tvar halfPi$1 = pi$2 / 2;\n\tvar tau$2 = 2 * pi$2;\n\t\n\tfunction arcInnerRadius(d) {\n\t  return d.innerRadius;\n\t}\n\t\n\tfunction arcOuterRadius(d) {\n\t  return d.outerRadius;\n\t}\n\t\n\tfunction arcStartAngle(d) {\n\t  return d.startAngle;\n\t}\n\t\n\tfunction arcEndAngle(d) {\n\t  return d.endAngle;\n\t}\n\t\n\tfunction arcPadAngle(d) {\n\t  return d && d.padAngle; // Note: optional!\n\t}\n\t\n\tfunction asin(x) {\n\t  return x >= 1 ? halfPi$1 : x <= -1 ? -halfPi$1 : Math.asin(x);\n\t}\n\t\n\tfunction intersect(x0, y0, x1, y1, x2, y2, x3, y3) {\n\t  var x10 = x1 - x0, y10 = y1 - y0,\n\t      x32 = x3 - x2, y32 = y3 - y2,\n\t      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);\n\t  return [x0 + t * x10, y0 + t * y10];\n\t}\n\t\n\t// Compute perpendicular offset line of length rc.\n\t// http://mathworld.wolfram.com/Circle-LineIntersection.html\n\tfunction cornerTangents(x0, y0, x1, y1, r1, rc, cw) {\n\t  var x01 = x0 - x1,\n\t      y01 = y0 - y1,\n\t      lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01),\n\t      ox = lo * y01,\n\t      oy = -lo * x01,\n\t      x11 = x0 + ox,\n\t      y11 = y0 + oy,\n\t      x10 = x1 + ox,\n\t      y10 = y1 + oy,\n\t      x00 = (x11 + x10) / 2,\n\t      y00 = (y11 + y10) / 2,\n\t      dx = x10 - x11,\n\t      dy = y10 - y11,\n\t      d2 = dx * dx + dy * dy,\n\t      r = r1 - rc,\n\t      D = x11 * y10 - x10 * y11,\n\t      d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)),\n\t      cx0 = (D * dy - dx * d) / d2,\n\t      cy0 = (-D * dx - dy * d) / d2,\n\t      cx1 = (D * dy + dx * d) / d2,\n\t      cy1 = (-D * dx + dy * d) / d2,\n\t      dx0 = cx0 - x00,\n\t      dy0 = cy0 - y00,\n\t      dx1 = cx1 - x00,\n\t      dy1 = cy1 - y00;\n\t\n\t  // Pick the closer of the two intersection points.\n\t  // TODO Is there a faster way to determine which intersection to use?\n\t  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;\n\t\n\t  return {\n\t    cx: cx0,\n\t    cy: cy0,\n\t    x01: -ox,\n\t    y01: -oy,\n\t    x11: cx0 * (r1 / r - 1),\n\t    y11: cy0 * (r1 / r - 1)\n\t  };\n\t}\n\t\n\tvar arc = function() {\n\t  var innerRadius = arcInnerRadius,\n\t      outerRadius = arcOuterRadius,\n\t      cornerRadius = constant$2(0),\n\t      padRadius = null,\n\t      startAngle = arcStartAngle,\n\t      endAngle = arcEndAngle,\n\t      padAngle = arcPadAngle,\n\t      context = null;\n\t\n\t  function arc() {\n\t    var buffer,\n\t        r,\n\t        r0 = +innerRadius.apply(this, arguments),\n\t        r1 = +outerRadius.apply(this, arguments),\n\t        a0 = startAngle.apply(this, arguments) - halfPi$1,\n\t        a1 = endAngle.apply(this, arguments) - halfPi$1,\n\t        da = Math.abs(a1 - a0),\n\t        cw = a1 > a0;\n\t\n\t    if (!context) context = buffer = path();\n\t\n\t    // Ensure that the outer radius is always larger than the inner radius.\n\t    if (r1 < r0) r = r1, r1 = r0, r0 = r;\n\t\n\t    // Is it a point?\n\t    if (!(r1 > epsilon$1)) context.moveTo(0, 0);\n\t\n\t    // Or is it a circle or annulus?\n\t    else if (da > tau$2 - epsilon$1) {\n\t      context.moveTo(r1 * Math.cos(a0), r1 * Math.sin(a0));\n\t      context.arc(0, 0, r1, a0, a1, !cw);\n\t      if (r0 > epsilon$1) {\n\t        context.moveTo(r0 * Math.cos(a1), r0 * Math.sin(a1));\n\t        context.arc(0, 0, r0, a1, a0, cw);\n\t      }\n\t    }\n\t\n\t    // Or is it a circular or annular sector?\n\t    else {\n\t      var a01 = a0,\n\t          a11 = a1,\n\t          a00 = a0,\n\t          a10 = a1,\n\t          da0 = da,\n\t          da1 = da,\n\t          ap = padAngle.apply(this, arguments) / 2,\n\t          rp = (ap > epsilon$1) && (padRadius ? +padRadius.apply(this, arguments) : Math.sqrt(r0 * r0 + r1 * r1)),\n\t          rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),\n\t          rc0 = rc,\n\t          rc1 = rc,\n\t          t0,\n\t          t1;\n\t\n\t      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.\n\t      if (rp > epsilon$1) {\n\t        var p0 = asin(rp / r0 * Math.sin(ap)),\n\t            p1 = asin(rp / r1 * Math.sin(ap));\n\t        if ((da0 -= p0 * 2) > epsilon$1) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;\n\t        else da0 = 0, a00 = a10 = (a0 + a1) / 2;\n\t        if ((da1 -= p1 * 2) > epsilon$1) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;\n\t        else da1 = 0, a01 = a11 = (a0 + a1) / 2;\n\t      }\n\t\n\t      var x01 = r1 * Math.cos(a01),\n\t          y01 = r1 * Math.sin(a01),\n\t          x10 = r0 * Math.cos(a10),\n\t          y10 = r0 * Math.sin(a10);\n\t\n\t      // Apply rounded corners?\n\t      if (rc > epsilon$1) {\n\t        var x11 = r1 * Math.cos(a11),\n\t            y11 = r1 * Math.sin(a11),\n\t            x00 = r0 * Math.cos(a00),\n\t            y00 = r0 * Math.sin(a00);\n\t\n\t        // Restrict the corner radius according to the sector angle.\n\t        if (da < pi$2) {\n\t          var oc = da0 > epsilon$1 ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],\n\t              ax = x01 - oc[0],\n\t              ay = y01 - oc[1],\n\t              bx = x11 - oc[0],\n\t              by = y11 - oc[1],\n\t              kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2),\n\t              lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);\n\t          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));\n\t          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));\n\t        }\n\t      }\n\t\n\t      // Is the sector collapsed to a line?\n\t      if (!(da1 > epsilon$1)) context.moveTo(x01, y01);\n\t\n\t      // Does the sector’s outer ring have rounded corners?\n\t      else if (rc1 > epsilon$1) {\n\t        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);\n\t        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);\n\t\n\t        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);\n\t\n\t        // Have the corners merged?\n\t        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);\n\t\n\t        // Otherwise, draw the two corners and the ring.\n\t        else {\n\t          context.arc(t0.cx, t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);\n\t          context.arc(0, 0, r1, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);\n\t          context.arc(t1.cx, t1.cy, rc1, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);\n\t        }\n\t      }\n\t\n\t      // Or is the outer ring just a circular arc?\n\t      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);\n\t\n\t      // Is there no inner ring, and it’s a circular sector?\n\t      // Or perhaps it’s an annular sector collapsed due to padding?\n\t      if (!(r0 > epsilon$1) || !(da0 > epsilon$1)) context.lineTo(x10, y10);\n\t\n\t      // Does the sector’s inner ring (or point) have rounded corners?\n\t      else if (rc0 > epsilon$1) {\n\t        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);\n\t        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);\n\t\n\t        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);\n\t\n\t        // Have the corners merged?\n\t        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);\n\t\n\t        // Otherwise, draw the two corners and the ring.\n\t        else {\n\t          context.arc(t0.cx, t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);\n\t          context.arc(0, 0, r0, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);\n\t          context.arc(t1.cx, t1.cy, rc0, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);\n\t        }\n\t      }\n\t\n\t      // Or is the inner ring just a circular arc?\n\t      else context.arc(0, 0, r0, a10, a00, cw);\n\t    }\n\t\n\t    context.closePath();\n\t\n\t    if (buffer) return context = null, buffer + \"\" || null;\n\t  }\n\t\n\t  arc.centroid = function() {\n\t    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,\n\t        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$2 / 2;\n\t    return [Math.cos(a) * r, Math.sin(a) * r];\n\t  };\n\t\n\t  arc.innerRadius = function(_) {\n\t    return arguments.length ? (innerRadius = typeof _ === \"function\" ? _ : constant$2(+_), arc) : innerRadius;\n\t  };\n\t\n\t  arc.outerRadius = function(_) {\n\t    return arguments.length ? (outerRadius = typeof _ === \"function\" ? _ : constant$2(+_), arc) : outerRadius;\n\t  };\n\t\n\t  arc.cornerRadius = function(_) {\n\t    return arguments.length ? (cornerRadius = typeof _ === \"function\" ? _ : constant$2(+_), arc) : cornerRadius;\n\t  };\n\t\n\t  arc.padRadius = function(_) {\n\t    return arguments.length ? (padRadius = _ == null ? null : typeof _ === \"function\" ? _ : constant$2(+_), arc) : padRadius;\n\t  };\n\t\n\t  arc.startAngle = function(_) {\n\t    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant$2(+_), arc) : startAngle;\n\t  };\n\t\n\t  arc.endAngle = function(_) {\n\t    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant$2(+_), arc) : endAngle;\n\t  };\n\t\n\t  arc.padAngle = function(_) {\n\t    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant$2(+_), arc) : padAngle;\n\t  };\n\t\n\t  arc.context = function(_) {\n\t    return arguments.length ? ((context = _ == null ? null : _), arc) : context;\n\t  };\n\t\n\t  return arc;\n\t};\n\t\n\tfunction Linear(context) {\n\t  this._context = context;\n\t}\n\t\n\tLinear.prototype = {\n\t  areaStart: function() {\n\t    this._line = 0;\n\t  },\n\t  areaEnd: function() {\n\t    this._line = NaN;\n\t  },\n\t  lineStart: function() {\n\t    this._point = 0;\n\t  },\n\t  lineEnd: function() {\n\t    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n\t    this._line = 1 - this._line;\n\t  },\n\t  point: function(x, y) {\n\t    x = +x, y = +y;\n\t    switch (this._point) {\n\t      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n\t      case 1: this._point = 2; // proceed\n\t      default: this._context.lineTo(x, y); break;\n\t    }\n\t  }\n\t};\n\t\n\tvar curveLinear = function(context) {\n\t  return new Linear(context);\n\t};\n\t\n\tfunction x(p) {\n\t  return p[0];\n\t}\n\t\n\tfunction y(p) {\n\t  return p[1];\n\t}\n\t\n\tvar line = function() {\n\t  var x$$1 = x,\n\t      y$$1 = y,\n\t      defined = constant$2(true),\n\t      context = null,\n\t      curve = curveLinear,\n\t      output = null;\n\t\n\t  function line(data) {\n\t    var i,\n\t        n = data.length,\n\t        d,\n\t        defined0 = false,\n\t        buffer;\n\t\n\t    if (context == null) output = curve(buffer = path());\n\t\n\t    for (i = 0; i <= n; ++i) {\n\t      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n\t        if (defined0 = !defined0) output.lineStart();\n\t        else output.lineEnd();\n\t      }\n\t      if (defined0) output.point(+x$$1(d, i, data), +y$$1(d, i, data));\n\t    }\n\t\n\t    if (buffer) return output = null, buffer + \"\" || null;\n\t  }\n\t\n\t  line.x = function(_) {\n\t    return arguments.length ? (x$$1 = typeof _ === \"function\" ? _ : constant$2(+_), line) : x$$1;\n\t  };\n\t\n\t  line.y = function(_) {\n\t    return arguments.length ? (y$$1 = typeof _ === \"function\" ? _ : constant$2(+_), line) : y$$1;\n\t  };\n\t\n\t  line.defined = function(_) {\n\t    return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant$2(!!_), line) : defined;\n\t  };\n\t\n\t  line.curve = function(_) {\n\t    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;\n\t  };\n\t\n\t  line.context = function(_) {\n\t    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;\n\t  };\n\t\n\t  return line;\n\t};\n\t\n\tvar area$1 = function() {\n\t  var x0 = x,\n\t      x1 = null,\n\t      y0 = constant$2(0),\n\t      y1 = y,\n\t      defined = constant$2(true),\n\t      context = null,\n\t      curve = curveLinear,\n\t      output = null;\n\t\n\t  function area(data) {\n\t    var i,\n\t        j,\n\t        k,\n\t        n = data.length,\n\t        d,\n\t        defined0 = false,\n\t        buffer,\n\t        x0z = new Array(n),\n\t        y0z = new Array(n);\n\t\n\t    if (context == null) output = curve(buffer = path());\n\t\n\t    for (i = 0; i <= n; ++i) {\n\t      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n\t        if (defined0 = !defined0) {\n\t          j = i;\n\t          output.areaStart();\n\t          output.lineStart();\n\t        } else {\n\t          output.lineEnd();\n\t          output.lineStart();\n\t          for (k = i - 1; k >= j; --k) {\n\t            output.point(x0z[k], y0z[k]);\n\t          }\n\t          output.lineEnd();\n\t          output.areaEnd();\n\t        }\n\t      }\n\t      if (defined0) {\n\t        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);\n\t        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);\n\t      }\n\t    }\n\t\n\t    if (buffer) return output = null, buffer + \"\" || null;\n\t  }\n\t\n\t  function arealine() {\n\t    return line().defined(defined).curve(curve).context(context);\n\t  }\n\t\n\t  area.x = function(_) {\n\t    return arguments.length ? (x0 = typeof _ === \"function\" ? _ : constant$2(+_), x1 = null, area) : x0;\n\t  };\n\t\n\t  area.x0 = function(_) {\n\t    return arguments.length ? (x0 = typeof _ === \"function\" ? _ : constant$2(+_), area) : x0;\n\t  };\n\t\n\t  area.x1 = function(_) {\n\t    return arguments.length ? (x1 = _ == null ? null : typeof _ === \"function\" ? _ : constant$2(+_), area) : x1;\n\t  };\n\t\n\t  area.y = function(_) {\n\t    return arguments.length ? (y0 = typeof _ === \"function\" ? _ : constant$2(+_), y1 = null, area) : y0;\n\t  };\n\t\n\t  area.y0 = function(_) {\n\t    return arguments.length ? (y0 = typeof _ === \"function\" ? _ : constant$2(+_), area) : y0;\n\t  };\n\t\n\t  area.y1 = function(_) {\n\t    return arguments.length ? (y1 = _ == null ? null : typeof _ === \"function\" ? _ : constant$2(+_), area) : y1;\n\t  };\n\t\n\t  area.lineX0 =\n\t  area.lineY0 = function() {\n\t    return arealine().x(x0).y(y0);\n\t  };\n\t\n\t  area.lineY1 = function() {\n\t    return arealine().x(x0).y(y1);\n\t  };\n\t\n\t  area.lineX1 = function() {\n\t    return arealine().x(x1).y(y0);\n\t  };\n\t\n\t  area.defined = function(_) {\n\t    return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant$2(!!_), area) : defined;\n\t  };\n\t\n\t  area.curve = function(_) {\n\t    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;\n\t  };\n\t\n\t  area.context = function(_) {\n\t    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;\n\t  };\n\t\n\t  return area;\n\t};\n\t\n\tvar descending$1 = function(a, b) {\n\t  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n\t};\n\t\n\tvar identity$1 = function(d) {\n\t  return d;\n\t};\n\t\n\tvar pie = function() {\n\t  var value = identity$1,\n\t      sortValues = descending$1,\n\t      sort = null,\n\t      startAngle = constant$2(0),\n\t      endAngle = constant$2(tau$2),\n\t      padAngle = constant$2(0);\n\t\n\t  function pie(data) {\n\t    var i,\n\t        n = data.length,\n\t        j,\n\t        k,\n\t        sum = 0,\n\t        index = new Array(n),\n\t        arcs = new Array(n),\n\t        a0 = +startAngle.apply(this, arguments),\n\t        da = Math.min(tau$2, Math.max(-tau$2, endAngle.apply(this, arguments) - a0)),\n\t        a1,\n\t        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),\n\t        pa = p * (da < 0 ? -1 : 1),\n\t        v;\n\t\n\t    for (i = 0; i < n; ++i) {\n\t      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {\n\t        sum += v;\n\t      }\n\t    }\n\t\n\t    // Optionally sort the arcs by previously-computed values or by data.\n\t    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });\n\t    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });\n\t\n\t    // Compute the arcs! They are stored in the original data's order.\n\t    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {\n\t      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {\n\t        data: data[j],\n\t        index: i,\n\t        value: v,\n\t        startAngle: a0,\n\t        endAngle: a1,\n\t        padAngle: p\n\t      };\n\t    }\n\t\n\t    return arcs;\n\t  }\n\t\n\t  pie.value = function(_) {\n\t    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant$2(+_), pie) : value;\n\t  };\n\t\n\t  pie.sortValues = function(_) {\n\t    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;\n\t  };\n\t\n\t  pie.sort = function(_) {\n\t    return arguments.length ? (sort = _, sortValues = null, pie) : sort;\n\t  };\n\t\n\t  pie.startAngle = function(_) {\n\t    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant$2(+_), pie) : startAngle;\n\t  };\n\t\n\t  pie.endAngle = function(_) {\n\t    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant$2(+_), pie) : endAngle;\n\t  };\n\t\n\t  pie.padAngle = function(_) {\n\t    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant$2(+_), pie) : padAngle;\n\t  };\n\t\n\t  return pie;\n\t};\n\t\n\tvar curveRadialLinear = curveRadial(curveLinear);\n\t\n\tfunction Radial(curve) {\n\t  this._curve = curve;\n\t}\n\t\n\tRadial.prototype = {\n\t  areaStart: function() {\n\t    this._curve.areaStart();\n\t  },\n\t  areaEnd: function() {\n\t    this._curve.areaEnd();\n\t  },\n\t  lineStart: function() {\n\t    this._curve.lineStart();\n\t  },\n\t  lineEnd: function() {\n\t    this._curve.lineEnd();\n\t  },\n\t  point: function(a, r) {\n\t    this._curve.point(r * Math.sin(a), r * -Math.cos(a));\n\t  }\n\t};\n\t\n\tfunction curveRadial(curve) {\n\t\n\t  function radial(context) {\n\t    return new Radial(curve(context));\n\t  }\n\t\n\t  radial._curve = curve;\n\t\n\t  return radial;\n\t}\n\t\n\tfunction radialLine(l) {\n\t  var c = l.curve;\n\t\n\t  l.angle = l.x, delete l.x;\n\t  l.radius = l.y, delete l.y;\n\t\n\t  l.curve = function(_) {\n\t    return arguments.length ? c(curveRadial(_)) : c()._curve;\n\t  };\n\t\n\t  return l;\n\t}\n\t\n\tvar radialLine$1 = function() {\n\t  return radialLine(line().curve(curveRadialLinear));\n\t};\n\t\n\tvar radialArea = function() {\n\t  var a = area$1().curve(curveRadialLinear),\n\t      c = a.curve,\n\t      x0 = a.lineX0,\n\t      x1 = a.lineX1,\n\t      y0 = a.lineY0,\n\t      y1 = a.lineY1;\n\t\n\t  a.angle = a.x, delete a.x;\n\t  a.startAngle = a.x0, delete a.x0;\n\t  a.endAngle = a.x1, delete a.x1;\n\t  a.radius = a.y, delete a.y;\n\t  a.innerRadius = a.y0, delete a.y0;\n\t  a.outerRadius = a.y1, delete a.y1;\n\t  a.lineStartAngle = function() { return radialLine(x0()); }, delete a.lineX0;\n\t  a.lineEndAngle = function() { return radialLine(x1()); }, delete a.lineX1;\n\t  a.lineInnerRadius = function() { return radialLine(y0()); }, delete a.lineY0;\n\t  a.lineOuterRadius = function() { return radialLine(y1()); }, delete a.lineY1;\n\t\n\t  a.curve = function(_) {\n\t    return arguments.length ? c(curveRadial(_)) : c()._curve;\n\t  };\n\t\n\t  return a;\n\t};\n\t\n\tvar circle = {\n\t  draw: function(context, size) {\n\t    var r = Math.sqrt(size / pi$2);\n\t    context.moveTo(r, 0);\n\t    context.arc(0, 0, r, 0, tau$2);\n\t  }\n\t};\n\t\n\tvar cross$1 = {\n\t  draw: function(context, size) {\n\t    var r = Math.sqrt(size / 5) / 2;\n\t    context.moveTo(-3 * r, -r);\n\t    context.lineTo(-r, -r);\n\t    context.lineTo(-r, -3 * r);\n\t    context.lineTo(r, -3 * r);\n\t    context.lineTo(r, -r);\n\t    context.lineTo(3 * r, -r);\n\t    context.lineTo(3 * r, r);\n\t    context.lineTo(r, r);\n\t    context.lineTo(r, 3 * r);\n\t    context.lineTo(-r, 3 * r);\n\t    context.lineTo(-r, r);\n\t    context.lineTo(-3 * r, r);\n\t    context.closePath();\n\t  }\n\t};\n\t\n\tvar tan30 = Math.sqrt(1 / 3);\n\tvar tan30_2 = tan30 * 2;\n\t\n\tvar diamond = {\n\t  draw: function(context, size) {\n\t    var y = Math.sqrt(size / tan30_2),\n\t        x = y * tan30;\n\t    context.moveTo(0, -y);\n\t    context.lineTo(x, 0);\n\t    context.lineTo(0, y);\n\t    context.lineTo(-x, 0);\n\t    context.closePath();\n\t  }\n\t};\n\t\n\tvar ka = 0.89081309152928522810;\n\tvar kr = Math.sin(pi$2 / 10) / Math.sin(7 * pi$2 / 10);\n\tvar kx = Math.sin(tau$2 / 10) * kr;\n\tvar ky = -Math.cos(tau$2 / 10) * kr;\n\t\n\tvar star = {\n\t  draw: function(context, size) {\n\t    var r = Math.sqrt(size * ka),\n\t        x = kx * r,\n\t        y = ky * r;\n\t    context.moveTo(0, -r);\n\t    context.lineTo(x, y);\n\t    for (var i = 1; i < 5; ++i) {\n\t      var a = tau$2 * i / 5,\n\t          c = Math.cos(a),\n\t          s = Math.sin(a);\n\t      context.lineTo(s * r, -c * r);\n\t      context.lineTo(c * x - s * y, s * x + c * y);\n\t    }\n\t    context.closePath();\n\t  }\n\t};\n\t\n\tvar square = {\n\t  draw: function(context, size) {\n\t    var w = Math.sqrt(size),\n\t        x = -w / 2;\n\t    context.rect(x, x, w, w);\n\t  }\n\t};\n\t\n\tvar sqrt3 = Math.sqrt(3);\n\t\n\tvar triangle = {\n\t  draw: function(context, size) {\n\t    var y = -Math.sqrt(size / (sqrt3 * 3));\n\t    context.moveTo(0, y * 2);\n\t    context.lineTo(-sqrt3 * y, -y);\n\t    context.lineTo(sqrt3 * y, -y);\n\t    context.closePath();\n\t  }\n\t};\n\t\n\tvar c = -0.5;\n\tvar s = Math.sqrt(3) / 2;\n\tvar k = 1 / Math.sqrt(12);\n\tvar a = (k / 2 + 1) * 3;\n\t\n\tvar wye = {\n\t  draw: function(context, size) {\n\t    var r = Math.sqrt(size / a),\n\t        x0 = r / 2,\n\t        y0 = r * k,\n\t        x1 = x0,\n\t        y1 = r * k + r,\n\t        x2 = -x1,\n\t        y2 = y1;\n\t    context.moveTo(x0, y0);\n\t    context.lineTo(x1, y1);\n\t    context.lineTo(x2, y2);\n\t    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);\n\t    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);\n\t    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);\n\t    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);\n\t    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);\n\t    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);\n\t    context.closePath();\n\t  }\n\t};\n\t\n\tvar symbols = [\n\t  circle,\n\t  cross$1,\n\t  diamond,\n\t  square,\n\t  star,\n\t  triangle,\n\t  wye\n\t];\n\t\n\tvar symbol = function() {\n\t  var type = constant$2(circle),\n\t      size = constant$2(64),\n\t      context = null;\n\t\n\t  function symbol() {\n\t    var buffer;\n\t    if (!context) context = buffer = path();\n\t    type.apply(this, arguments).draw(context, +size.apply(this, arguments));\n\t    if (buffer) return context = null, buffer + \"\" || null;\n\t  }\n\t\n\t  symbol.type = function(_) {\n\t    return arguments.length ? (type = typeof _ === \"function\" ? _ : constant$2(_), symbol) : type;\n\t  };\n\t\n\t  symbol.size = function(_) {\n\t    return arguments.length ? (size = typeof _ === \"function\" ? _ : constant$2(+_), symbol) : size;\n\t  };\n\t\n\t  symbol.context = function(_) {\n\t    return arguments.length ? (context = _ == null ? null : _, symbol) : context;\n\t  };\n\t\n\t  return symbol;\n\t};\n\t\n\tvar noop = function() {};\n\t\n\tfunction point(that, x, y) {\n\t  that._context.bezierCurveTo(\n\t    (2 * that._x0 + that._x1) / 3,\n\t    (2 * that._y0 + that._y1) / 3,\n\t    (that._x0 + 2 * that._x1) / 3,\n\t    (that._y0 + 2 * that._y1) / 3,\n\t    (that._x0 + 4 * that._x1 + x) / 6,\n\t    (that._y0 + 4 * that._y1 + y) / 6\n\t  );\n\t}\n\t\n\tfunction Basis(context) {\n\t  this._context = context;\n\t}\n\t\n\tBasis.prototype = {\n\t  areaStart: function() {\n\t    this._line = 0;\n\t  },\n\t  areaEnd: function() {\n\t    this._line = NaN;\n\t  },\n\t  lineStart: function() {\n\t    this._x0 = this._x1 =\n\t    this._y0 = this._y1 = NaN;\n\t    this._point = 0;\n\t  },\n\t  lineEnd: function() {\n\t    switch (this._point) {\n\t      case 3: point(this, this._x1, this._y1); // proceed\n\t      case 2: this._context.lineTo(this._x1, this._y1); break;\n\t    }\n\t    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n\t    this._line = 1 - this._line;\n\t  },\n\t  point: function(x, y) {\n\t    x = +x, y = +y;\n\t    switch (this._point) {\n\t      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n\t      case 1: this._point = 2; break;\n\t      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed\n\t      default: point(this, x, y); break;\n\t    }\n\t    this._x0 = this._x1, this._x1 = x;\n\t    this._y0 = this._y1, this._y1 = y;\n\t  }\n\t};\n\t\n\tvar basis = function(context) {\n\t  return new Basis(context);\n\t};\n\t\n\tfunction BasisClosed(context) {\n\t  this._context = context;\n\t}\n\t\n\tBasisClosed.prototype = {\n\t  areaStart: noop,\n\t  areaEnd: noop,\n\t  lineStart: function() {\n\t    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =\n\t    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;\n\t    this._point = 0;\n\t  },\n\t  lineEnd: function() {\n\t    switch (this._point) {\n\t      case 1: {\n\t        this._context.moveTo(this._x2, this._y2);\n\t        this._context.closePath();\n\t        break;\n\t      }\n\t      case 2: {\n\t        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);\n\t        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);\n\t        this._context.closePath();\n\t        break;\n\t      }\n\t      case 3: {\n\t        this.point(this._x2, this._y2);\n\t        this.point(this._x3, this._y3);\n\t        this.point(this._x4, this._y4);\n\t        break;\n\t      }\n\t    }\n\t  },\n\t  point: function(x, y) {\n\t    x = +x, y = +y;\n\t    switch (this._point) {\n\t      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;\n\t      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;\n\t      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;\n\t      default: point(this, x, y); break;\n\t    }\n\t    this._x0 = this._x1, this._x1 = x;\n\t    this._y0 = this._y1, this._y1 = y;\n\t  }\n\t};\n\t\n\tvar basisClosed = function(context) {\n\t  return new BasisClosed(context);\n\t};\n\t\n\tfunction BasisOpen(context) {\n\t  this._context = context;\n\t}\n\t\n\tBasisOpen.prototype = {\n\t  areaStart: function() {\n\t    this._line = 0;\n\t  },\n\t  areaEnd: function() {\n\t    this._line = NaN;\n\t  },\n\t  lineStart: function() {\n\t    this._x0 = this._x1 =\n\t    this._y0 = this._y1 = NaN;\n\t    this._point = 0;\n\t  },\n\t  lineEnd: function() {\n\t    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n\t    this._line = 1 - this._line;\n\t  },\n\t  point: function(x, y) {\n\t    x = +x, y = +y;\n\t    switch (this._point) {\n\t      case 0: this._point = 1; break;\n\t      case 1: this._point = 2; break;\n\t      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;\n\t      case 3: this._point = 4; // proceed\n\t      default: point(this, x, y); break;\n\t    }\n\t    this._x0 = this._x1, this._x1 = x;\n\t    this._y0 = this._y1, this._y1 = y;\n\t  }\n\t};\n\t\n\tvar basisOpen = function(context) {\n\t  return new BasisOpen(context);\n\t};\n\t\n\tfunction Bundle(context, beta) {\n\t  this._basis = new Basis(context);\n\t  this._beta = beta;\n\t}\n\t\n\tBundle.prototype = {\n\t  lineStart: function() {\n\t    this._x = [];\n\t    this._y = [];\n\t    this._basis.lineStart();\n\t  },\n\t  lineEnd: function() {\n\t    var x = this._x,\n\t        y = this._y,\n\t        j = x.length - 1;\n\t\n\t    if (j > 0) {\n\t      var x0 = x[0],\n\t          y0 = y[0],\n\t          dx = x[j] - x0,\n\t          dy = y[j] - y0,\n\t          i = -1,\n\t          t;\n\t\n\t      while (++i <= j) {\n\t        t = i / j;\n\t        this._basis.point(\n\t          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),\n\t          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)\n\t        );\n\t      }\n\t    }\n\t\n\t    this._x = this._y = null;\n\t    this._basis.lineEnd();\n\t  },\n\t  point: function(x, y) {\n\t    this._x.push(+x);\n\t    this._y.push(+y);\n\t  }\n\t};\n\t\n\tvar bundle = (function custom(beta) {\n\t\n\t  function bundle(context) {\n\t    return beta === 1 ? new Basis(context) : new Bundle(context, beta);\n\t  }\n\t\n\t  bundle.beta = function(beta) {\n\t    return custom(+beta);\n\t  };\n\t\n\t  return bundle;\n\t})(0.85);\n\t\n\tfunction point$1(that, x, y) {\n\t  that._context.bezierCurveTo(\n\t    that._x1 + that._k * (that._x2 - that._x0),\n\t    that._y1 + that._k * (that._y2 - that._y0),\n\t    that._x2 + that._k * (that._x1 - x),\n\t    that._y2 + that._k * (that._y1 - y),\n\t    that._x2,\n\t    that._y2\n\t  );\n\t}\n\t\n\tfunction Cardinal(context, tension) {\n\t  this._context = context;\n\t  this._k = (1 - tension) / 6;\n\t}\n\t\n\tCardinal.prototype = {\n\t  areaStart: function() {\n\t    this._line = 0;\n\t  },\n\t  areaEnd: function() {\n\t    this._line = NaN;\n\t  },\n\t  lineStart: function() {\n\t    this._x0 = this._x1 = this._x2 =\n\t    this._y0 = this._y1 = this._y2 = NaN;\n\t    this._point = 0;\n\t  },\n\t  lineEnd: function() {\n\t    switch (this._point) {\n\t      case 2: this._context.lineTo(this._x2, this._y2); break;\n\t      case 3: point$1(this, this._x1, this._y1); break;\n\t    }\n\t    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n\t    this._line = 1 - this._line;\n\t  },\n\t  point: function(x, y) {\n\t    x = +x, y = +y;\n\t    switch (this._point) {\n\t      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n\t      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;\n\t      case 2: this._point = 3; // proceed\n\t      default: point$1(this, x, y); break;\n\t    }\n\t    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n\t    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n\t  }\n\t};\n\t\n\tvar cardinal = (function custom(tension) {\n\t\n\t  function cardinal(context) {\n\t    return new Cardinal(context, tension);\n\t  }\n\t\n\t  cardinal.tension = function(tension) {\n\t    return custom(+tension);\n\t  };\n\t\n\t  return cardinal;\n\t})(0);\n\t\n\tfunction CardinalClosed(context, tension) {\n\t  this._context = context;\n\t  this._k = (1 - tension) / 6;\n\t}\n\t\n\tCardinalClosed.prototype = {\n\t  areaStart: noop,\n\t  areaEnd: noop,\n\t  lineStart: function() {\n\t    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =\n\t    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n\t    this._point = 0;\n\t  },\n\t  lineEnd: function() {\n\t    switch (this._point) {\n\t      case 1: {\n\t        this._context.moveTo(this._x3, this._y3);\n\t        this._context.closePath();\n\t        break;\n\t      }\n\t      case 2: {\n\t        this._context.lineTo(this._x3, this._y3);\n\t        this._context.closePath();\n\t        break;\n\t      }\n\t      case 3: {\n\t        this.point(this._x3, this._y3);\n\t        this.point(this._x4, this._y4);\n\t        this.point(this._x5, this._y5);\n\t        break;\n\t      }\n\t    }\n\t  },\n\t  point: function(x, y) {\n\t    x = +x, y = +y;\n\t    switch (this._point) {\n\t      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;\n\t      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;\n\t      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;\n\t      default: point$1(this, x, y); break;\n\t    }\n\t    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n\t    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n\t  }\n\t};\n\t\n\tvar cardinalClosed = (function custom(tension) {\n\t\n\t  function cardinal(context) {\n\t    return new CardinalClosed(context, tension);\n\t  }\n\t\n\t  cardinal.tension = function(tension) {\n\t    return custom(+tension);\n\t  };\n\t\n\t  return cardinal;\n\t})(0);\n\t\n\tfunction CardinalOpen(context, tension) {\n\t  this._context = context;\n\t  this._k = (1 - tension) / 6;\n\t}\n\t\n\tCardinalOpen.prototype = {\n\t  areaStart: function() {\n\t    this._line = 0;\n\t  },\n\t  areaEnd: function() {\n\t    this._line = NaN;\n\t  },\n\t  lineStart: function() {\n\t    this._x0 = this._x1 = this._x2 =\n\t    this._y0 = this._y1 = this._y2 = NaN;\n\t    this._point = 0;\n\t  },\n\t  lineEnd: function() {\n\t    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n\t    this._line = 1 - this._line;\n\t  },\n\t  point: function(x, y) {\n\t    x = +x, y = +y;\n\t    switch (this._point) {\n\t      case 0: this._point = 1; break;\n\t      case 1: this._point = 2; break;\n\t      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;\n\t      case 3: this._point = 4; // proceed\n\t      default: point$1(this, x, y); break;\n\t    }\n\t    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n\t    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n\t  }\n\t};\n\t\n\tvar cardinalOpen = (function custom(tension) {\n\t\n\t  function cardinal(context) {\n\t    return new CardinalOpen(context, tension);\n\t  }\n\t\n\t  cardinal.tension = function(tension) {\n\t    return custom(+tension);\n\t  };\n\t\n\t  return cardinal;\n\t})(0);\n\t\n\tfunction point$2(that, x, y) {\n\t  var x1 = that._x1,\n\t      y1 = that._y1,\n\t      x2 = that._x2,\n\t      y2 = that._y2;\n\t\n\t  if (that._l01_a > epsilon$1) {\n\t    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,\n\t        n = 3 * that._l01_a * (that._l01_a + that._l12_a);\n\t    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;\n\t    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;\n\t  }\n\t\n\t  if (that._l23_a > epsilon$1) {\n\t    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,\n\t        m = 3 * that._l23_a * (that._l23_a + that._l12_a);\n\t    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;\n\t    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;\n\t  }\n\t\n\t  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);\n\t}\n\t\n\tfunction CatmullRom(context, alpha) {\n\t  this._context = context;\n\t  this._alpha = alpha;\n\t}\n\t\n\tCatmullRom.prototype = {\n\t  areaStart: function() {\n\t    this._line = 0;\n\t  },\n\t  areaEnd: function() {\n\t    this._line = NaN;\n\t  },\n\t  lineStart: function() {\n\t    this._x0 = this._x1 = this._x2 =\n\t    this._y0 = this._y1 = this._y2 = NaN;\n\t    this._l01_a = this._l12_a = this._l23_a =\n\t    this._l01_2a = this._l12_2a = this._l23_2a =\n\t    this._point = 0;\n\t  },\n\t  lineEnd: function() {\n\t    switch (this._point) {\n\t      case 2: this._context.lineTo(this._x2, this._y2); break;\n\t      case 3: this.point(this._x2, this._y2); break;\n\t    }\n\t    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n\t    this._line = 1 - this._line;\n\t  },\n\t  point: function(x, y) {\n\t    x = +x, y = +y;\n\t\n\t    if (this._point) {\n\t      var x23 = this._x2 - x,\n\t          y23 = this._y2 - y;\n\t      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n\t    }\n\t\n\t    switch (this._point) {\n\t      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n\t      case 1: this._point = 2; break;\n\t      case 2: this._point = 3; // proceed\n\t      default: point$2(this, x, y); break;\n\t    }\n\t\n\t    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n\t    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n\t    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n\t    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n\t  }\n\t};\n\t\n\tvar catmullRom = (function custom(alpha) {\n\t\n\t  function catmullRom(context) {\n\t    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);\n\t  }\n\t\n\t  catmullRom.alpha = function(alpha) {\n\t    return custom(+alpha);\n\t  };\n\t\n\t  return catmullRom;\n\t})(0.5);\n\t\n\tfunction CatmullRomClosed(context, alpha) {\n\t  this._context = context;\n\t  this._alpha = alpha;\n\t}\n\t\n\tCatmullRomClosed.prototype = {\n\t  areaStart: noop,\n\t  areaEnd: noop,\n\t  lineStart: function() {\n\t    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =\n\t    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n\t    this._l01_a = this._l12_a = this._l23_a =\n\t    this._l01_2a = this._l12_2a = this._l23_2a =\n\t    this._point = 0;\n\t  },\n\t  lineEnd: function() {\n\t    switch (this._point) {\n\t      case 1: {\n\t        this._context.moveTo(this._x3, this._y3);\n\t        this._context.closePath();\n\t        break;\n\t      }\n\t      case 2: {\n\t        this._context.lineTo(this._x3, this._y3);\n\t        this._context.closePath();\n\t        break;\n\t      }\n\t      case 3: {\n\t        this.point(this._x3, this._y3);\n\t        this.point(this._x4, this._y4);\n\t        this.point(this._x5, this._y5);\n\t        break;\n\t      }\n\t    }\n\t  },\n\t  point: function(x, y) {\n\t    x = +x, y = +y;\n\t\n\t    if (this._point) {\n\t      var x23 = this._x2 - x,\n\t          y23 = this._y2 - y;\n\t      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n\t    }\n\t\n\t    switch (this._point) {\n\t      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;\n\t      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;\n\t      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;\n\t      default: point$2(this, x, y); break;\n\t    }\n\t\n\t    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n\t    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n\t    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n\t    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n\t  }\n\t};\n\t\n\tvar catmullRomClosed = (function custom(alpha) {\n\t\n\t  function catmullRom(context) {\n\t    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);\n\t  }\n\t\n\t  catmullRom.alpha = function(alpha) {\n\t    return custom(+alpha);\n\t  };\n\t\n\t  return catmullRom;\n\t})(0.5);\n\t\n\tfunction CatmullRomOpen(context, alpha) {\n\t  this._context = context;\n\t  this._alpha = alpha;\n\t}\n\t\n\tCatmullRomOpen.prototype = {\n\t  areaStart: function() {\n\t    this._line = 0;\n\t  },\n\t  areaEnd: function() {\n\t    this._line = NaN;\n\t  },\n\t  lineStart: function() {\n\t    this._x0 = this._x1 = this._x2 =\n\t    this._y0 = this._y1 = this._y2 = NaN;\n\t    this._l01_a = this._l12_a = this._l23_a =\n\t    this._l01_2a = this._l12_2a = this._l23_2a =\n\t    this._point = 0;\n\t  },\n\t  lineEnd: function() {\n\t    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n\t    this._line = 1 - this._line;\n\t  },\n\t  point: function(x, y) {\n\t    x = +x, y = +y;\n\t\n\t    if (this._point) {\n\t      var x23 = this._x2 - x,\n\t          y23 = this._y2 - y;\n\t      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n\t    }\n\t\n\t    switch (this._point) {\n\t      case 0: this._point = 1; break;\n\t      case 1: this._point = 2; break;\n\t      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;\n\t      case 3: this._point = 4; // proceed\n\t      default: point$2(this, x, y); break;\n\t    }\n\t\n\t    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n\t    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n\t    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n\t    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n\t  }\n\t};\n\t\n\tvar catmullRomOpen = (function custom(alpha) {\n\t\n\t  function catmullRom(context) {\n\t    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);\n\t  }\n\t\n\t  catmullRom.alpha = function(alpha) {\n\t    return custom(+alpha);\n\t  };\n\t\n\t  return catmullRom;\n\t})(0.5);\n\t\n\tfunction LinearClosed(context) {\n\t  this._context = context;\n\t}\n\t\n\tLinearClosed.prototype = {\n\t  areaStart: noop,\n\t  areaEnd: noop,\n\t  lineStart: function() {\n\t    this._point = 0;\n\t  },\n\t  lineEnd: function() {\n\t    if (this._point) this._context.closePath();\n\t  },\n\t  point: function(x, y) {\n\t    x = +x, y = +y;\n\t    if (this._point) this._context.lineTo(x, y);\n\t    else this._point = 1, this._context.moveTo(x, y);\n\t  }\n\t};\n\t\n\tvar linearClosed = function(context) {\n\t  return new LinearClosed(context);\n\t};\n\t\n\tfunction sign(x) {\n\t  return x < 0 ? -1 : 1;\n\t}\n\t\n\t// Calculate the slopes of the tangents (Hermite-type interpolation) based on\n\t// the following paper: Steffen, M. 1990. A Simple Method for Monotonic\n\t// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.\n\t// NOV(II), P. 443, 1990.\n\tfunction slope3(that, x2, y2) {\n\t  var h0 = that._x1 - that._x0,\n\t      h1 = x2 - that._x1,\n\t      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),\n\t      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),\n\t      p = (s0 * h1 + s1 * h0) / (h0 + h1);\n\t  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;\n\t}\n\t\n\t// Calculate a one-sided slope.\n\tfunction slope2(that, t) {\n\t  var h = that._x1 - that._x0;\n\t  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;\n\t}\n\t\n\t// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations\n\t// \"you can express cubic Hermite interpolation in terms of cubic Bézier curves\n\t// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1\".\n\tfunction point$3(that, t0, t1) {\n\t  var x0 = that._x0,\n\t      y0 = that._y0,\n\t      x1 = that._x1,\n\t      y1 = that._y1,\n\t      dx = (x1 - x0) / 3;\n\t  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);\n\t}\n\t\n\tfunction MonotoneX(context) {\n\t  this._context = context;\n\t}\n\t\n\tMonotoneX.prototype = {\n\t  areaStart: function() {\n\t    this._line = 0;\n\t  },\n\t  areaEnd: function() {\n\t    this._line = NaN;\n\t  },\n\t  lineStart: function() {\n\t    this._x0 = this._x1 =\n\t    this._y0 = this._y1 =\n\t    this._t0 = NaN;\n\t    this._point = 0;\n\t  },\n\t  lineEnd: function() {\n\t    switch (this._point) {\n\t      case 2: this._context.lineTo(this._x1, this._y1); break;\n\t      case 3: point$3(this, this._t0, slope2(this, this._t0)); break;\n\t    }\n\t    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n\t    this._line = 1 - this._line;\n\t  },\n\t  point: function(x, y) {\n\t    var t1 = NaN;\n\t\n\t    x = +x, y = +y;\n\t    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.\n\t    switch (this._point) {\n\t      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n\t      case 1: this._point = 2; break;\n\t      case 2: this._point = 3; point$3(this, slope2(this, t1 = slope3(this, x, y)), t1); break;\n\t      default: point$3(this, this._t0, t1 = slope3(this, x, y)); break;\n\t    }\n\t\n\t    this._x0 = this._x1, this._x1 = x;\n\t    this._y0 = this._y1, this._y1 = y;\n\t    this._t0 = t1;\n\t  }\n\t};\n\t\n\tfunction MonotoneY(context) {\n\t  this._context = new ReflectContext(context);\n\t}\n\t\n\t(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {\n\t  MonotoneX.prototype.point.call(this, y, x);\n\t};\n\t\n\tfunction ReflectContext(context) {\n\t  this._context = context;\n\t}\n\t\n\tReflectContext.prototype = {\n\t  moveTo: function(x, y) { this._context.moveTo(y, x); },\n\t  closePath: function() { this._context.closePath(); },\n\t  lineTo: function(x, y) { this._context.lineTo(y, x); },\n\t  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }\n\t};\n\t\n\tfunction monotoneX(context) {\n\t  return new MonotoneX(context);\n\t}\n\t\n\tfunction monotoneY(context) {\n\t  return new MonotoneY(context);\n\t}\n\t\n\tfunction Natural(context) {\n\t  this._context = context;\n\t}\n\t\n\tNatural.prototype = {\n\t  areaStart: function() {\n\t    this._line = 0;\n\t  },\n\t  areaEnd: function() {\n\t    this._line = NaN;\n\t  },\n\t  lineStart: function() {\n\t    this._x = [];\n\t    this._y = [];\n\t  },\n\t  lineEnd: function() {\n\t    var x = this._x,\n\t        y = this._y,\n\t        n = x.length;\n\t\n\t    if (n) {\n\t      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);\n\t      if (n === 2) {\n\t        this._context.lineTo(x[1], y[1]);\n\t      } else {\n\t        var px = controlPoints(x),\n\t            py = controlPoints(y);\n\t        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {\n\t          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);\n\t        }\n\t      }\n\t    }\n\t\n\t    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();\n\t    this._line = 1 - this._line;\n\t    this._x = this._y = null;\n\t  },\n\t  point: function(x, y) {\n\t    this._x.push(+x);\n\t    this._y.push(+y);\n\t  }\n\t};\n\t\n\t// See https://www.particleincell.com/2012/bezier-splines/ for derivation.\n\tfunction controlPoints(x) {\n\t  var i,\n\t      n = x.length - 1,\n\t      m,\n\t      a = new Array(n),\n\t      b = new Array(n),\n\t      r = new Array(n);\n\t  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];\n\t  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];\n\t  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];\n\t  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];\n\t  a[n - 1] = r[n - 1] / b[n - 1];\n\t  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];\n\t  b[n - 1] = (x[n] + a[n - 1]) / 2;\n\t  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];\n\t  return [a, b];\n\t}\n\t\n\tvar natural = function(context) {\n\t  return new Natural(context);\n\t};\n\t\n\tfunction Step(context, t) {\n\t  this._context = context;\n\t  this._t = t;\n\t}\n\t\n\tStep.prototype = {\n\t  areaStart: function() {\n\t    this._line = 0;\n\t  },\n\t  areaEnd: function() {\n\t    this._line = NaN;\n\t  },\n\t  lineStart: function() {\n\t    this._x = this._y = NaN;\n\t    this._point = 0;\n\t  },\n\t  lineEnd: function() {\n\t    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);\n\t    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n\t    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;\n\t  },\n\t  point: function(x, y) {\n\t    x = +x, y = +y;\n\t    switch (this._point) {\n\t      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n\t      case 1: this._point = 2; // proceed\n\t      default: {\n\t        if (this._t <= 0) {\n\t          this._context.lineTo(this._x, y);\n\t          this._context.lineTo(x, y);\n\t        } else {\n\t          var x1 = this._x * (1 - this._t) + x * this._t;\n\t          this._context.lineTo(x1, this._y);\n\t          this._context.lineTo(x1, y);\n\t        }\n\t        break;\n\t      }\n\t    }\n\t    this._x = x, this._y = y;\n\t  }\n\t};\n\t\n\tvar step = function(context) {\n\t  return new Step(context, 0.5);\n\t};\n\t\n\tfunction stepBefore(context) {\n\t  return new Step(context, 0);\n\t}\n\t\n\tfunction stepAfter(context) {\n\t  return new Step(context, 1);\n\t}\n\t\n\tvar slice$2 = Array.prototype.slice;\n\t\n\tvar none = function(series, order) {\n\t  if (!((n = series.length) > 1)) return;\n\t  for (var i = 1, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {\n\t    s0 = s1, s1 = series[order[i]];\n\t    for (var j = 0; j < m; ++j) {\n\t      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];\n\t    }\n\t  }\n\t};\n\t\n\tvar none$1 = function(series) {\n\t  var n = series.length, o = new Array(n);\n\t  while (--n >= 0) o[n] = n;\n\t  return o;\n\t};\n\t\n\tfunction stackValue(d, key) {\n\t  return d[key];\n\t}\n\t\n\tvar stack = function() {\n\t  var keys = constant$2([]),\n\t      order = none$1,\n\t      offset = none,\n\t      value = stackValue;\n\t\n\t  function stack(data) {\n\t    var kz = keys.apply(this, arguments),\n\t        i,\n\t        m = data.length,\n\t        n = kz.length,\n\t        sz = new Array(n),\n\t        oz;\n\t\n\t    for (i = 0; i < n; ++i) {\n\t      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {\n\t        si[j] = sij = [0, +value(data[j], ki, j, data)];\n\t        sij.data = data[j];\n\t      }\n\t      si.key = ki;\n\t    }\n\t\n\t    for (i = 0, oz = order(sz); i < n; ++i) {\n\t      sz[oz[i]].index = i;\n\t    }\n\t\n\t    offset(sz, oz);\n\t    return sz;\n\t  }\n\t\n\t  stack.keys = function(_) {\n\t    return arguments.length ? (keys = typeof _ === \"function\" ? _ : constant$2(slice$2.call(_)), stack) : keys;\n\t  };\n\t\n\t  stack.value = function(_) {\n\t    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant$2(+_), stack) : value;\n\t  };\n\t\n\t  stack.order = function(_) {\n\t    return arguments.length ? (order = _ == null ? none$1 : typeof _ === \"function\" ? _ : constant$2(slice$2.call(_)), stack) : order;\n\t  };\n\t\n\t  stack.offset = function(_) {\n\t    return arguments.length ? (offset = _ == null ? none : _, stack) : offset;\n\t  };\n\t\n\t  return stack;\n\t};\n\t\n\tvar expand = function(series, order) {\n\t  if (!((n = series.length) > 0)) return;\n\t  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {\n\t    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;\n\t    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;\n\t  }\n\t  none(series, order);\n\t};\n\t\n\tvar silhouette = function(series, order) {\n\t  if (!((n = series.length) > 0)) return;\n\t  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {\n\t    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;\n\t    s0[j][1] += s0[j][0] = -y / 2;\n\t  }\n\t  none(series, order);\n\t};\n\t\n\tvar wiggle = function(series, order) {\n\t  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;\n\t  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {\n\t    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {\n\t      var si = series[order[i]],\n\t          sij0 = si[j][1] || 0,\n\t          sij1 = si[j - 1][1] || 0,\n\t          s3 = (sij0 - sij1) / 2;\n\t      for (var k = 0; k < i; ++k) {\n\t        var sk = series[order[k]],\n\t            skj0 = sk[j][1] || 0,\n\t            skj1 = sk[j - 1][1] || 0;\n\t        s3 += skj0 - skj1;\n\t      }\n\t      s1 += sij0, s2 += s3 * sij0;\n\t    }\n\t    s0[j - 1][1] += s0[j - 1][0] = y;\n\t    if (s1) y -= s2 / s1;\n\t  }\n\t  s0[j - 1][1] += s0[j - 1][0] = y;\n\t  none(series, order);\n\t};\n\t\n\tvar ascending$1 = function(series) {\n\t  var sums = series.map(sum$1);\n\t  return none$1(series).sort(function(a, b) { return sums[a] - sums[b]; });\n\t};\n\t\n\tfunction sum$1(series) {\n\t  var s = 0, i = -1, n = series.length, v;\n\t  while (++i < n) if (v = +series[i][1]) s += v;\n\t  return s;\n\t}\n\t\n\tvar descending$2 = function(series) {\n\t  return ascending$1(series).reverse();\n\t};\n\t\n\tvar insideOut = function(series) {\n\t  var n = series.length,\n\t      i,\n\t      j,\n\t      sums = series.map(sum$1),\n\t      order = none$1(series).sort(function(a, b) { return sums[b] - sums[a]; }),\n\t      top = 0,\n\t      bottom = 0,\n\t      tops = [],\n\t      bottoms = [];\n\t\n\t  for (i = 0; i < n; ++i) {\n\t    j = order[i];\n\t    if (top < bottom) {\n\t      top += sums[j];\n\t      tops.push(j);\n\t    } else {\n\t      bottom += sums[j];\n\t      bottoms.push(j);\n\t    }\n\t  }\n\t\n\t  return bottoms.reverse().concat(tops);\n\t};\n\t\n\tvar reverse = function(series) {\n\t  return none$1(series).reverse();\n\t};\n\t\n\tvar define = function(constructor, factory, prototype) {\n\t  constructor.prototype = factory.prototype = prototype;\n\t  prototype.constructor = constructor;\n\t};\n\t\n\tfunction extend(parent, definition) {\n\t  var prototype = Object.create(parent.prototype);\n\t  for (var key in definition) prototype[key] = definition[key];\n\t  return prototype;\n\t}\n\t\n\tfunction Color() {}\n\t\n\tvar darker = 0.7;\n\tvar brighter = 1 / darker;\n\t\n\tvar reHex3 = /^#([0-9a-f]{3})$/;\n\tvar reHex6 = /^#([0-9a-f]{6})$/;\n\tvar reRgbInteger = /^rgb\\(\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*\\)$/;\n\tvar reRgbPercent = /^rgb\\(\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n\tvar reRgbaInteger = /^rgba\\(\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)\\s*\\)$/;\n\tvar reRgbaPercent = /^rgba\\(\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)\\s*\\)$/;\n\tvar reHslPercent = /^hsl\\(\\s*([-+]?\\d+(?:\\.\\d+)?)\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n\tvar reHslaPercent = /^hsla\\(\\s*([-+]?\\d+(?:\\.\\d+)?)\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)\\s*\\)$/;\n\t\n\tvar named = {\n\t  aliceblue: 0xf0f8ff,\n\t  antiquewhite: 0xfaebd7,\n\t  aqua: 0x00ffff,\n\t  aquamarine: 0x7fffd4,\n\t  azure: 0xf0ffff,\n\t  beige: 0xf5f5dc,\n\t  bisque: 0xffe4c4,\n\t  black: 0x000000,\n\t  blanchedalmond: 0xffebcd,\n\t  blue: 0x0000ff,\n\t  blueviolet: 0x8a2be2,\n\t  brown: 0xa52a2a,\n\t  burlywood: 0xdeb887,\n\t  cadetblue: 0x5f9ea0,\n\t  chartreuse: 0x7fff00,\n\t  chocolate: 0xd2691e,\n\t  coral: 0xff7f50,\n\t  cornflowerblue: 0x6495ed,\n\t  cornsilk: 0xfff8dc,\n\t  crimson: 0xdc143c,\n\t  cyan: 0x00ffff,\n\t  darkblue: 0x00008b,\n\t  darkcyan: 0x008b8b,\n\t  darkgoldenrod: 0xb8860b,\n\t  darkgray: 0xa9a9a9,\n\t  darkgreen: 0x006400,\n\t  darkgrey: 0xa9a9a9,\n\t  darkkhaki: 0xbdb76b,\n\t  darkmagenta: 0x8b008b,\n\t  darkolivegreen: 0x556b2f,\n\t  darkorange: 0xff8c00,\n\t  darkorchid: 0x9932cc,\n\t  darkred: 0x8b0000,\n\t  darksalmon: 0xe9967a,\n\t  darkseagreen: 0x8fbc8f,\n\t  darkslateblue: 0x483d8b,\n\t  darkslategray: 0x2f4f4f,\n\t  darkslategrey: 0x2f4f4f,\n\t  darkturquoise: 0x00ced1,\n\t  darkviolet: 0x9400d3,\n\t  deeppink: 0xff1493,\n\t  deepskyblue: 0x00bfff,\n\t  dimgray: 0x696969,\n\t  dimgrey: 0x696969,\n\t  dodgerblue: 0x1e90ff,\n\t  firebrick: 0xb22222,\n\t  floralwhite: 0xfffaf0,\n\t  forestgreen: 0x228b22,\n\t  fuchsia: 0xff00ff,\n\t  gainsboro: 0xdcdcdc,\n\t  ghostwhite: 0xf8f8ff,\n\t  gold: 0xffd700,\n\t  goldenrod: 0xdaa520,\n\t  gray: 0x808080,\n\t  green: 0x008000,\n\t  greenyellow: 0xadff2f,\n\t  grey: 0x808080,\n\t  honeydew: 0xf0fff0,\n\t  hotpink: 0xff69b4,\n\t  indianred: 0xcd5c5c,\n\t  indigo: 0x4b0082,\n\t  ivory: 0xfffff0,\n\t  khaki: 0xf0e68c,\n\t  lavender: 0xe6e6fa,\n\t  lavenderblush: 0xfff0f5,\n\t  lawngreen: 0x7cfc00,\n\t  lemonchiffon: 0xfffacd,\n\t  lightblue: 0xadd8e6,\n\t  lightcoral: 0xf08080,\n\t  lightcyan: 0xe0ffff,\n\t  lightgoldenrodyellow: 0xfafad2,\n\t  lightgray: 0xd3d3d3,\n\t  lightgreen: 0x90ee90,\n\t  lightgrey: 0xd3d3d3,\n\t  lightpink: 0xffb6c1,\n\t  lightsalmon: 0xffa07a,\n\t  lightseagreen: 0x20b2aa,\n\t  lightskyblue: 0x87cefa,\n\t  lightslategray: 0x778899,\n\t  lightslategrey: 0x778899,\n\t  lightsteelblue: 0xb0c4de,\n\t  lightyellow: 0xffffe0,\n\t  lime: 0x00ff00,\n\t  limegreen: 0x32cd32,\n\t  linen: 0xfaf0e6,\n\t  magenta: 0xff00ff,\n\t  maroon: 0x800000,\n\t  mediumaquamarine: 0x66cdaa,\n\t  mediumblue: 0x0000cd,\n\t  mediumorchid: 0xba55d3,\n\t  mediumpurple: 0x9370db,\n\t  mediumseagreen: 0x3cb371,\n\t  mediumslateblue: 0x7b68ee,\n\t  mediumspringgreen: 0x00fa9a,\n\t  mediumturquoise: 0x48d1cc,\n\t  mediumvioletred: 0xc71585,\n\t  midnightblue: 0x191970,\n\t  mintcream: 0xf5fffa,\n\t  mistyrose: 0xffe4e1,\n\t  moccasin: 0xffe4b5,\n\t  navajowhite: 0xffdead,\n\t  navy: 0x000080,\n\t  oldlace: 0xfdf5e6,\n\t  olive: 0x808000,\n\t  olivedrab: 0x6b8e23,\n\t  orange: 0xffa500,\n\t  orangered: 0xff4500,\n\t  orchid: 0xda70d6,\n\t  palegoldenrod: 0xeee8aa,\n\t  palegreen: 0x98fb98,\n\t  paleturquoise: 0xafeeee,\n\t  palevioletred: 0xdb7093,\n\t  papayawhip: 0xffefd5,\n\t  peachpuff: 0xffdab9,\n\t  peru: 0xcd853f,\n\t  pink: 0xffc0cb,\n\t  plum: 0xdda0dd,\n\t  powderblue: 0xb0e0e6,\n\t  purple: 0x800080,\n\t  rebeccapurple: 0x663399,\n\t  red: 0xff0000,\n\t  rosybrown: 0xbc8f8f,\n\t  royalblue: 0x4169e1,\n\t  saddlebrown: 0x8b4513,\n\t  salmon: 0xfa8072,\n\t  sandybrown: 0xf4a460,\n\t  seagreen: 0x2e8b57,\n\t  seashell: 0xfff5ee,\n\t  sienna: 0xa0522d,\n\t  silver: 0xc0c0c0,\n\t  skyblue: 0x87ceeb,\n\t  slateblue: 0x6a5acd,\n\t  slategray: 0x708090,\n\t  slategrey: 0x708090,\n\t  snow: 0xfffafa,\n\t  springgreen: 0x00ff7f,\n\t  steelblue: 0x4682b4,\n\t  tan: 0xd2b48c,\n\t  teal: 0x008080,\n\t  thistle: 0xd8bfd8,\n\t  tomato: 0xff6347,\n\t  turquoise: 0x40e0d0,\n\t  violet: 0xee82ee,\n\t  wheat: 0xf5deb3,\n\t  white: 0xffffff,\n\t  whitesmoke: 0xf5f5f5,\n\t  yellow: 0xffff00,\n\t  yellowgreen: 0x9acd32\n\t};\n\t\n\tdefine(Color, color, {\n\t  displayable: function() {\n\t    return this.rgb().displayable();\n\t  },\n\t  toString: function() {\n\t    return this.rgb() + \"\";\n\t  }\n\t});\n\t\n\tfunction color(format) {\n\t  var m;\n\t  format = (format + \"\").trim().toLowerCase();\n\t  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00\n\t      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000\n\t      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)\n\t      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)\n\t      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)\n\t      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)\n\t      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)\n\t      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)\n\t      : named.hasOwnProperty(format) ? rgbn(named[format])\n\t      : format === \"transparent\" ? new Rgb(NaN, NaN, NaN, 0)\n\t      : null;\n\t}\n\t\n\tfunction rgbn(n) {\n\t  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);\n\t}\n\t\n\tfunction rgba(r, g, b, a) {\n\t  if (a <= 0) r = g = b = NaN;\n\t  return new Rgb(r, g, b, a);\n\t}\n\t\n\tfunction rgbConvert(o) {\n\t  if (!(o instanceof Color)) o = color(o);\n\t  if (!o) return new Rgb;\n\t  o = o.rgb();\n\t  return new Rgb(o.r, o.g, o.b, o.opacity);\n\t}\n\t\n\tfunction rgb(r, g, b, opacity) {\n\t  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);\n\t}\n\t\n\tfunction Rgb(r, g, b, opacity) {\n\t  this.r = +r;\n\t  this.g = +g;\n\t  this.b = +b;\n\t  this.opacity = +opacity;\n\t}\n\t\n\tdefine(Rgb, rgb, extend(Color, {\n\t  brighter: function(k) {\n\t    k = k == null ? brighter : Math.pow(brighter, k);\n\t    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);\n\t  },\n\t  darker: function(k) {\n\t    k = k == null ? darker : Math.pow(darker, k);\n\t    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);\n\t  },\n\t  rgb: function() {\n\t    return this;\n\t  },\n\t  displayable: function() {\n\t    return (0 <= this.r && this.r <= 255)\n\t        && (0 <= this.g && this.g <= 255)\n\t        && (0 <= this.b && this.b <= 255)\n\t        && (0 <= this.opacity && this.opacity <= 1);\n\t  },\n\t  toString: function() {\n\t    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));\n\t    return (a === 1 ? \"rgb(\" : \"rgba(\")\n\t        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + \", \"\n\t        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + \", \"\n\t        + Math.max(0, Math.min(255, Math.round(this.b) || 0))\n\t        + (a === 1 ? \")\" : \", \" + a + \")\");\n\t  }\n\t}));\n\t\n\tfunction hsla(h, s, l, a) {\n\t  if (a <= 0) h = s = l = NaN;\n\t  else if (l <= 0 || l >= 1) h = s = NaN;\n\t  else if (s <= 0) h = NaN;\n\t  return new Hsl(h, s, l, a);\n\t}\n\t\n\tfunction hslConvert(o) {\n\t  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);\n\t  if (!(o instanceof Color)) o = color(o);\n\t  if (!o) return new Hsl;\n\t  if (o instanceof Hsl) return o;\n\t  o = o.rgb();\n\t  var r = o.r / 255,\n\t      g = o.g / 255,\n\t      b = o.b / 255,\n\t      min = Math.min(r, g, b),\n\t      max = Math.max(r, g, b),\n\t      h = NaN,\n\t      s = max - min,\n\t      l = (max + min) / 2;\n\t  if (s) {\n\t    if (r === max) h = (g - b) / s + (g < b) * 6;\n\t    else if (g === max) h = (b - r) / s + 2;\n\t    else h = (r - g) / s + 4;\n\t    s /= l < 0.5 ? max + min : 2 - max - min;\n\t    h *= 60;\n\t  } else {\n\t    s = l > 0 && l < 1 ? 0 : h;\n\t  }\n\t  return new Hsl(h, s, l, o.opacity);\n\t}\n\t\n\tfunction hsl(h, s, l, opacity) {\n\t  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);\n\t}\n\t\n\tfunction Hsl(h, s, l, opacity) {\n\t  this.h = +h;\n\t  this.s = +s;\n\t  this.l = +l;\n\t  this.opacity = +opacity;\n\t}\n\t\n\tdefine(Hsl, hsl, extend(Color, {\n\t  brighter: function(k) {\n\t    k = k == null ? brighter : Math.pow(brighter, k);\n\t    return new Hsl(this.h, this.s, this.l * k, this.opacity);\n\t  },\n\t  darker: function(k) {\n\t    k = k == null ? darker : Math.pow(darker, k);\n\t    return new Hsl(this.h, this.s, this.l * k, this.opacity);\n\t  },\n\t  rgb: function() {\n\t    var h = this.h % 360 + (this.h < 0) * 360,\n\t        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,\n\t        l = this.l,\n\t        m2 = l + (l < 0.5 ? l : 1 - l) * s,\n\t        m1 = 2 * l - m2;\n\t    return new Rgb(\n\t      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),\n\t      hsl2rgb(h, m1, m2),\n\t      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),\n\t      this.opacity\n\t    );\n\t  },\n\t  displayable: function() {\n\t    return (0 <= this.s && this.s <= 1 || isNaN(this.s))\n\t        && (0 <= this.l && this.l <= 1)\n\t        && (0 <= this.opacity && this.opacity <= 1);\n\t  }\n\t}));\n\t\n\t/* From FvD 13.37, CSS Color Module Level 3 */\n\tfunction hsl2rgb(h, m1, m2) {\n\t  return (h < 60 ? m1 + (m2 - m1) * h / 60\n\t      : h < 180 ? m2\n\t      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60\n\t      : m1) * 255;\n\t}\n\t\n\tvar deg2rad = Math.PI / 180;\n\tvar rad2deg = 180 / Math.PI;\n\t\n\tvar Kn = 18;\n\tvar Xn = 0.950470;\n\tvar Yn = 1;\n\tvar Zn = 1.088830;\n\tvar t0 = 4 / 29;\n\tvar t1 = 6 / 29;\n\tvar t2 = 3 * t1 * t1;\n\tvar t3 = t1 * t1 * t1;\n\t\n\tfunction labConvert(o) {\n\t  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);\n\t  if (o instanceof Hcl) {\n\t    var h = o.h * deg2rad;\n\t    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);\n\t  }\n\t  if (!(o instanceof Rgb)) o = rgbConvert(o);\n\t  var b = rgb2xyz(o.r),\n\t      a = rgb2xyz(o.g),\n\t      l = rgb2xyz(o.b),\n\t      x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),\n\t      y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),\n\t      z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);\n\t  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);\n\t}\n\t\n\tfunction lab(l, a, b, opacity) {\n\t  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);\n\t}\n\t\n\tfunction Lab(l, a, b, opacity) {\n\t  this.l = +l;\n\t  this.a = +a;\n\t  this.b = +b;\n\t  this.opacity = +opacity;\n\t}\n\t\n\tdefine(Lab, lab, extend(Color, {\n\t  brighter: function(k) {\n\t    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);\n\t  },\n\t  darker: function(k) {\n\t    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);\n\t  },\n\t  rgb: function() {\n\t    var y = (this.l + 16) / 116,\n\t        x = isNaN(this.a) ? y : y + this.a / 500,\n\t        z = isNaN(this.b) ? y : y - this.b / 200;\n\t    y = Yn * lab2xyz(y);\n\t    x = Xn * lab2xyz(x);\n\t    z = Zn * lab2xyz(z);\n\t    return new Rgb(\n\t      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB\n\t      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),\n\t      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z),\n\t      this.opacity\n\t    );\n\t  }\n\t}));\n\t\n\tfunction xyz2lab(t) {\n\t  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n\t}\n\t\n\tfunction lab2xyz(t) {\n\t  return t > t1 ? t * t * t : t2 * (t - t0);\n\t}\n\t\n\tfunction xyz2rgb(x) {\n\t  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);\n\t}\n\t\n\tfunction rgb2xyz(x) {\n\t  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n\t}\n\t\n\tfunction hclConvert(o) {\n\t  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);\n\t  if (!(o instanceof Lab)) o = labConvert(o);\n\t  var h = Math.atan2(o.b, o.a) * rad2deg;\n\t  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);\n\t}\n\t\n\tfunction hcl(h, c, l, opacity) {\n\t  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);\n\t}\n\t\n\tfunction Hcl(h, c, l, opacity) {\n\t  this.h = +h;\n\t  this.c = +c;\n\t  this.l = +l;\n\t  this.opacity = +opacity;\n\t}\n\t\n\tdefine(Hcl, hcl, extend(Color, {\n\t  brighter: function(k) {\n\t    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);\n\t  },\n\t  darker: function(k) {\n\t    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);\n\t  },\n\t  rgb: function() {\n\t    return labConvert(this).rgb();\n\t  }\n\t}));\n\t\n\tvar A = -0.14861;\n\tvar B = +1.78277;\n\tvar C = -0.29227;\n\tvar D = -0.90649;\n\tvar E = +1.97294;\n\tvar ED = E * D;\n\tvar EB = E * B;\n\tvar BC_DA = B * C - D * A;\n\t\n\tfunction cubehelixConvert(o) {\n\t  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);\n\t  if (!(o instanceof Rgb)) o = rgbConvert(o);\n\t  var r = o.r / 255,\n\t      g = o.g / 255,\n\t      b = o.b / 255,\n\t      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),\n\t      bl = b - l,\n\t      k = (E * (g - l) - C * bl) / D,\n\t      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1\n\t      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;\n\t  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);\n\t}\n\t\n\tfunction cubehelix(h, s, l, opacity) {\n\t  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);\n\t}\n\t\n\tfunction Cubehelix(h, s, l, opacity) {\n\t  this.h = +h;\n\t  this.s = +s;\n\t  this.l = +l;\n\t  this.opacity = +opacity;\n\t}\n\t\n\tdefine(Cubehelix, cubehelix, extend(Color, {\n\t  brighter: function(k) {\n\t    k = k == null ? brighter : Math.pow(brighter, k);\n\t    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);\n\t  },\n\t  darker: function(k) {\n\t    k = k == null ? darker : Math.pow(darker, k);\n\t    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);\n\t  },\n\t  rgb: function() {\n\t    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,\n\t        l = +this.l,\n\t        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),\n\t        cosh = Math.cos(h),\n\t        sinh = Math.sin(h);\n\t    return new Rgb(\n\t      255 * (l + a * (A * cosh + B * sinh)),\n\t      255 * (l + a * (C * cosh + D * sinh)),\n\t      255 * (l + a * (E * cosh)),\n\t      this.opacity\n\t    );\n\t  }\n\t}));\n\t\n\tfunction basis$1(t1, v0, v1, v2, v3) {\n\t  var t2 = t1 * t1, t3 = t2 * t1;\n\t  return ((1 - 3 * t1 + 3 * t2 - t3) * v0\n\t      + (4 - 6 * t2 + 3 * t3) * v1\n\t      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2\n\t      + t3 * v3) / 6;\n\t}\n\t\n\tvar basis$2 = function(values) {\n\t  var n = values.length - 1;\n\t  return function(t) {\n\t    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),\n\t        v1 = values[i],\n\t        v2 = values[i + 1],\n\t        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,\n\t        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;\n\t    return basis$1((t - i / n) * n, v0, v1, v2, v3);\n\t  };\n\t};\n\t\n\tvar basisClosed$1 = function(values) {\n\t  var n = values.length;\n\t  return function(t) {\n\t    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),\n\t        v0 = values[(i + n - 1) % n],\n\t        v1 = values[i % n],\n\t        v2 = values[(i + 1) % n],\n\t        v3 = values[(i + 2) % n];\n\t    return basis$1((t - i / n) * n, v0, v1, v2, v3);\n\t  };\n\t};\n\t\n\tvar constant$3 = function(x) {\n\t  return function() {\n\t    return x;\n\t  };\n\t};\n\t\n\tfunction linear$1(a, d) {\n\t  return function(t) {\n\t    return a + t * d;\n\t  };\n\t}\n\t\n\tfunction exponential$1(a, b, y) {\n\t  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {\n\t    return Math.pow(a + t * b, y);\n\t  };\n\t}\n\t\n\tfunction hue(a, b) {\n\t  var d = b - a;\n\t  return d ? linear$1(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$3(isNaN(a) ? b : a);\n\t}\n\t\n\tfunction gamma(y) {\n\t  return (y = +y) === 1 ? nogamma : function(a, b) {\n\t    return b - a ? exponential$1(a, b, y) : constant$3(isNaN(a) ? b : a);\n\t  };\n\t}\n\t\n\tfunction nogamma(a, b) {\n\t  var d = b - a;\n\t  return d ? linear$1(a, d) : constant$3(isNaN(a) ? b : a);\n\t}\n\t\n\tvar interpolateRgb = (function rgbGamma(y) {\n\t  var color$$1 = gamma(y);\n\t\n\t  function rgb$$1(start, end) {\n\t    var r = color$$1((start = rgb(start)).r, (end = rgb(end)).r),\n\t        g = color$$1(start.g, end.g),\n\t        b = color$$1(start.b, end.b),\n\t        opacity = color$$1(start.opacity, end.opacity);\n\t    return function(t) {\n\t      start.r = r(t);\n\t      start.g = g(t);\n\t      start.b = b(t);\n\t      start.opacity = opacity(t);\n\t      return start + \"\";\n\t    };\n\t  }\n\t\n\t  rgb$$1.gamma = rgbGamma;\n\t\n\t  return rgb$$1;\n\t})(1);\n\t\n\tfunction rgbSpline(spline) {\n\t  return function(colors) {\n\t    var n = colors.length,\n\t        r = new Array(n),\n\t        g = new Array(n),\n\t        b = new Array(n),\n\t        i, color$$1;\n\t    for (i = 0; i < n; ++i) {\n\t      color$$1 = rgb(colors[i]);\n\t      r[i] = color$$1.r || 0;\n\t      g[i] = color$$1.g || 0;\n\t      b[i] = color$$1.b || 0;\n\t    }\n\t    r = spline(r);\n\t    g = spline(g);\n\t    b = spline(b);\n\t    color$$1.opacity = 1;\n\t    return function(t) {\n\t      color$$1.r = r(t);\n\t      color$$1.g = g(t);\n\t      color$$1.b = b(t);\n\t      return color$$1 + \"\";\n\t    };\n\t  };\n\t}\n\t\n\tvar rgbBasis = rgbSpline(basis$2);\n\tvar rgbBasisClosed = rgbSpline(basisClosed$1);\n\t\n\tvar array$1 = function(a, b) {\n\t  var nb = b ? b.length : 0,\n\t      na = a ? Math.min(nb, a.length) : 0,\n\t      x = new Array(nb),\n\t      c = new Array(nb),\n\t      i;\n\t\n\t  for (i = 0; i < na; ++i) x[i] = interpolate(a[i], b[i]);\n\t  for (; i < nb; ++i) c[i] = b[i];\n\t\n\t  return function(t) {\n\t    for (i = 0; i < na; ++i) c[i] = x[i](t);\n\t    return c;\n\t  };\n\t};\n\t\n\tvar date = function(a, b) {\n\t  var d = new Date;\n\t  return a = +a, b -= a, function(t) {\n\t    return d.setTime(a + b * t), d;\n\t  };\n\t};\n\t\n\tvar interpolateNumber = function(a, b) {\n\t  return a = +a, b -= a, function(t) {\n\t    return a + b * t;\n\t  };\n\t};\n\t\n\tvar object = function(a, b) {\n\t  var i = {},\n\t      c = {},\n\t      k;\n\t\n\t  if (a === null || typeof a !== \"object\") a = {};\n\t  if (b === null || typeof b !== \"object\") b = {};\n\t\n\t  for (k in b) {\n\t    if (k in a) {\n\t      i[k] = interpolate(a[k], b[k]);\n\t    } else {\n\t      c[k] = b[k];\n\t    }\n\t  }\n\t\n\t  return function(t) {\n\t    for (k in i) c[k] = i[k](t);\n\t    return c;\n\t  };\n\t};\n\t\n\tvar reA = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g;\n\tvar reB = new RegExp(reA.source, \"g\");\n\t\n\tfunction zero(b) {\n\t  return function() {\n\t    return b;\n\t  };\n\t}\n\t\n\tfunction one(b) {\n\t  return function(t) {\n\t    return b(t) + \"\";\n\t  };\n\t}\n\t\n\tvar interpolateString = function(a, b) {\n\t  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b\n\t      am, // current match in a\n\t      bm, // current match in b\n\t      bs, // string preceding current number in b, if any\n\t      i = -1, // index in s\n\t      s = [], // string constants and placeholders\n\t      q = []; // number interpolators\n\t\n\t  // Coerce inputs to strings.\n\t  a = a + \"\", b = b + \"\";\n\t\n\t  // Interpolate pairs of numbers in a & b.\n\t  while ((am = reA.exec(a))\n\t      && (bm = reB.exec(b))) {\n\t    if ((bs = bm.index) > bi) { // a string precedes the next number in b\n\t      bs = b.slice(bi, bs);\n\t      if (s[i]) s[i] += bs; // coalesce with previous string\n\t      else s[++i] = bs;\n\t    }\n\t    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match\n\t      if (s[i]) s[i] += bm; // coalesce with previous string\n\t      else s[++i] = bm;\n\t    } else { // interpolate non-matching numbers\n\t      s[++i] = null;\n\t      q.push({i: i, x: interpolateNumber(am, bm)});\n\t    }\n\t    bi = reB.lastIndex;\n\t  }\n\t\n\t  // Add remains of b.\n\t  if (bi < b.length) {\n\t    bs = b.slice(bi);\n\t    if (s[i]) s[i] += bs; // coalesce with previous string\n\t    else s[++i] = bs;\n\t  }\n\t\n\t  // Special optimization for only a single match.\n\t  // Otherwise, interpolate each of the numbers and rejoin the string.\n\t  return s.length < 2 ? (q[0]\n\t      ? one(q[0].x)\n\t      : zero(b))\n\t      : (b = q.length, function(t) {\n\t          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);\n\t          return s.join(\"\");\n\t        });\n\t};\n\t\n\tvar interpolate = function(a, b) {\n\t  var t = typeof b, c;\n\t  return b == null || t === \"boolean\" ? constant$3(b)\n\t      : (t === \"number\" ? interpolateNumber\n\t      : t === \"string\" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)\n\t      : b instanceof color ? interpolateRgb\n\t      : b instanceof Date ? date\n\t      : Array.isArray(b) ? array$1\n\t      : isNaN(b) ? object\n\t      : interpolateNumber)(a, b);\n\t};\n\t\n\tvar interpolateRound = function(a, b) {\n\t  return a = +a, b -= a, function(t) {\n\t    return Math.round(a + b * t);\n\t  };\n\t};\n\t\n\tvar degrees = 180 / Math.PI;\n\t\n\tvar identity$2 = {\n\t  translateX: 0,\n\t  translateY: 0,\n\t  rotate: 0,\n\t  skewX: 0,\n\t  scaleX: 1,\n\t  scaleY: 1\n\t};\n\t\n\tvar decompose = function(a, b, c, d, e, f) {\n\t  var scaleX, scaleY, skewX;\n\t  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;\n\t  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;\n\t  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;\n\t  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;\n\t  return {\n\t    translateX: e,\n\t    translateY: f,\n\t    rotate: Math.atan2(b, a) * degrees,\n\t    skewX: Math.atan(skewX) * degrees,\n\t    scaleX: scaleX,\n\t    scaleY: scaleY\n\t  };\n\t};\n\t\n\tvar cssNode;\n\tvar cssRoot;\n\tvar cssView;\n\tvar svgNode;\n\t\n\tfunction parseCss(value) {\n\t  if (value === \"none\") return identity$2;\n\t  if (!cssNode) cssNode = document.createElement(\"DIV\"), cssRoot = document.documentElement, cssView = document.defaultView;\n\t  cssNode.style.transform = value;\n\t  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue(\"transform\");\n\t  cssRoot.removeChild(cssNode);\n\t  value = value.slice(7, -1).split(\",\");\n\t  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);\n\t}\n\t\n\tfunction parseSvg(value) {\n\t  if (value == null) return identity$2;\n\t  if (!svgNode) svgNode = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n\t  svgNode.setAttribute(\"transform\", value);\n\t  if (!(value = svgNode.transform.baseVal.consolidate())) return identity$2;\n\t  value = value.matrix;\n\t  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);\n\t}\n\t\n\tfunction interpolateTransform(parse, pxComma, pxParen, degParen) {\n\t\n\t  function pop(s) {\n\t    return s.length ? s.pop() + \" \" : \"\";\n\t  }\n\t\n\t  function translate(xa, ya, xb, yb, s, q) {\n\t    if (xa !== xb || ya !== yb) {\n\t      var i = s.push(\"translate(\", null, pxComma, null, pxParen);\n\t      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});\n\t    } else if (xb || yb) {\n\t      s.push(\"translate(\" + xb + pxComma + yb + pxParen);\n\t    }\n\t  }\n\t\n\t  function rotate(a, b, s, q) {\n\t    if (a !== b) {\n\t      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path\n\t      q.push({i: s.push(pop(s) + \"rotate(\", null, degParen) - 2, x: interpolateNumber(a, b)});\n\t    } else if (b) {\n\t      s.push(pop(s) + \"rotate(\" + b + degParen);\n\t    }\n\t  }\n\t\n\t  function skewX(a, b, s, q) {\n\t    if (a !== b) {\n\t      q.push({i: s.push(pop(s) + \"skewX(\", null, degParen) - 2, x: interpolateNumber(a, b)});\n\t    } else if (b) {\n\t      s.push(pop(s) + \"skewX(\" + b + degParen);\n\t    }\n\t  }\n\t\n\t  function scale(xa, ya, xb, yb, s, q) {\n\t    if (xa !== xb || ya !== yb) {\n\t      var i = s.push(pop(s) + \"scale(\", null, \",\", null, \")\");\n\t      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});\n\t    } else if (xb !== 1 || yb !== 1) {\n\t      s.push(pop(s) + \"scale(\" + xb + \",\" + yb + \")\");\n\t    }\n\t  }\n\t\n\t  return function(a, b) {\n\t    var s = [], // string constants and placeholders\n\t        q = []; // number interpolators\n\t    a = parse(a), b = parse(b);\n\t    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);\n\t    rotate(a.rotate, b.rotate, s, q);\n\t    skewX(a.skewX, b.skewX, s, q);\n\t    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);\n\t    a = b = null; // gc\n\t    return function(t) {\n\t      var i = -1, n = q.length, o;\n\t      while (++i < n) s[(o = q[i]).i] = o.x(t);\n\t      return s.join(\"\");\n\t    };\n\t  };\n\t}\n\t\n\tvar interpolateTransformCss = interpolateTransform(parseCss, \"px, \", \"px)\", \"deg)\");\n\tvar interpolateTransformSvg = interpolateTransform(parseSvg, \", \", \")\", \")\");\n\t\n\tvar rho = Math.SQRT2;\n\tvar rho2 = 2;\n\tvar rho4 = 4;\n\tvar epsilon2 = 1e-12;\n\t\n\tfunction cosh(x) {\n\t  return ((x = Math.exp(x)) + 1 / x) / 2;\n\t}\n\t\n\tfunction sinh(x) {\n\t  return ((x = Math.exp(x)) - 1 / x) / 2;\n\t}\n\t\n\tfunction tanh(x) {\n\t  return ((x = Math.exp(2 * x)) - 1) / (x + 1);\n\t}\n\t\n\t// p0 = [ux0, uy0, w0]\n\t// p1 = [ux1, uy1, w1]\n\tvar interpolateZoom = function(p0, p1) {\n\t  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],\n\t      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],\n\t      dx = ux1 - ux0,\n\t      dy = uy1 - uy0,\n\t      d2 = dx * dx + dy * dy,\n\t      i,\n\t      S;\n\t\n\t  // Special case for u0 ≅ u1.\n\t  if (d2 < epsilon2) {\n\t    S = Math.log(w1 / w0) / rho;\n\t    i = function(t) {\n\t      return [\n\t        ux0 + t * dx,\n\t        uy0 + t * dy,\n\t        w0 * Math.exp(rho * t * S)\n\t      ];\n\t    };\n\t  }\n\t\n\t  // General case.\n\t  else {\n\t    var d1 = Math.sqrt(d2),\n\t        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),\n\t        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),\n\t        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),\n\t        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n\t    S = (r1 - r0) / rho;\n\t    i = function(t) {\n\t      var s = t * S,\n\t          coshr0 = cosh(r0),\n\t          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));\n\t      return [\n\t        ux0 + u * dx,\n\t        uy0 + u * dy,\n\t        w0 * coshr0 / cosh(rho * s + r0)\n\t      ];\n\t    };\n\t  }\n\t\n\t  i.duration = S * 1000;\n\t\n\t  return i;\n\t};\n\t\n\tfunction hsl$1(hue$$1) {\n\t  return function(start, end) {\n\t    var h = hue$$1((start = hsl(start)).h, (end = hsl(end)).h),\n\t        s = nogamma(start.s, end.s),\n\t        l = nogamma(start.l, end.l),\n\t        opacity = nogamma(start.opacity, end.opacity);\n\t    return function(t) {\n\t      start.h = h(t);\n\t      start.s = s(t);\n\t      start.l = l(t);\n\t      start.opacity = opacity(t);\n\t      return start + \"\";\n\t    };\n\t  }\n\t}\n\t\n\tvar hsl$2 = hsl$1(hue);\n\tvar hslLong = hsl$1(nogamma);\n\t\n\tfunction lab$1(start, end) {\n\t  var l = nogamma((start = lab(start)).l, (end = lab(end)).l),\n\t      a = nogamma(start.a, end.a),\n\t      b = nogamma(start.b, end.b),\n\t      opacity = nogamma(start.opacity, end.opacity);\n\t  return function(t) {\n\t    start.l = l(t);\n\t    start.a = a(t);\n\t    start.b = b(t);\n\t    start.opacity = opacity(t);\n\t    return start + \"\";\n\t  };\n\t}\n\t\n\tfunction hcl$1(hue$$1) {\n\t  return function(start, end) {\n\t    var h = hue$$1((start = hcl(start)).h, (end = hcl(end)).h),\n\t        c = nogamma(start.c, end.c),\n\t        l = nogamma(start.l, end.l),\n\t        opacity = nogamma(start.opacity, end.opacity);\n\t    return function(t) {\n\t      start.h = h(t);\n\t      start.c = c(t);\n\t      start.l = l(t);\n\t      start.opacity = opacity(t);\n\t      return start + \"\";\n\t    };\n\t  }\n\t}\n\t\n\tvar hcl$2 = hcl$1(hue);\n\tvar hclLong = hcl$1(nogamma);\n\t\n\tfunction cubehelix$1(hue$$1) {\n\t  return (function cubehelixGamma(y) {\n\t    y = +y;\n\t\n\t    function cubehelix$$1(start, end) {\n\t      var h = hue$$1((start = cubehelix(start)).h, (end = cubehelix(end)).h),\n\t          s = nogamma(start.s, end.s),\n\t          l = nogamma(start.l, end.l),\n\t          opacity = nogamma(start.opacity, end.opacity);\n\t      return function(t) {\n\t        start.h = h(t);\n\t        start.s = s(t);\n\t        start.l = l(Math.pow(t, y));\n\t        start.opacity = opacity(t);\n\t        return start + \"\";\n\t      };\n\t    }\n\t\n\t    cubehelix$$1.gamma = cubehelixGamma;\n\t\n\t    return cubehelix$$1;\n\t  })(1);\n\t}\n\t\n\tvar cubehelix$2 = cubehelix$1(hue);\n\tvar cubehelixLong = cubehelix$1(nogamma);\n\t\n\tvar quantize = function(interpolator, n) {\n\t  var samples = new Array(n);\n\t  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));\n\t  return samples;\n\t};\n\t\n\tvar noop$1 = {value: function() {}};\n\t\n\tfunction dispatch() {\n\t  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {\n\t    if (!(t = arguments[i] + \"\") || (t in _)) throw new Error(\"illegal type: \" + t);\n\t    _[t] = [];\n\t  }\n\t  return new Dispatch(_);\n\t}\n\t\n\tfunction Dispatch(_) {\n\t  this._ = _;\n\t}\n\t\n\tfunction parseTypenames(typenames, types) {\n\t  return typenames.trim().split(/^|\\s+/).map(function(t) {\n\t    var name = \"\", i = t.indexOf(\".\");\n\t    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n\t    if (t && !types.hasOwnProperty(t)) throw new Error(\"unknown type: \" + t);\n\t    return {type: t, name: name};\n\t  });\n\t}\n\t\n\tDispatch.prototype = dispatch.prototype = {\n\t  constructor: Dispatch,\n\t  on: function(typename, callback) {\n\t    var _ = this._,\n\t        T = parseTypenames(typename + \"\", _),\n\t        t,\n\t        i = -1,\n\t        n = T.length;\n\t\n\t    // If no callback was specified, return the callback of the given type and name.\n\t    if (arguments.length < 2) {\n\t      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;\n\t      return;\n\t    }\n\t\n\t    // If a type was specified, set the callback for the given type and name.\n\t    // Otherwise, if a null callback was specified, remove callbacks of the given name.\n\t    if (callback != null && typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback);\n\t    while (++i < n) {\n\t      if (t = (typename = T[i]).type) _[t] = set$2(_[t], typename.name, callback);\n\t      else if (callback == null) for (t in _) _[t] = set$2(_[t], typename.name, null);\n\t    }\n\t\n\t    return this;\n\t  },\n\t  copy: function() {\n\t    var copy = {}, _ = this._;\n\t    for (var t in _) copy[t] = _[t].slice();\n\t    return new Dispatch(copy);\n\t  },\n\t  call: function(type, that) {\n\t    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];\n\t    if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n\t    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n\t  },\n\t  apply: function(type, that, args) {\n\t    if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n\t    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n\t  }\n\t};\n\t\n\tfunction get(type, name) {\n\t  for (var i = 0, n = type.length, c; i < n; ++i) {\n\t    if ((c = type[i]).name === name) {\n\t      return c.value;\n\t    }\n\t  }\n\t}\n\t\n\tfunction set$2(type, name, callback) {\n\t  for (var i = 0, n = type.length; i < n; ++i) {\n\t    if (type[i].name === name) {\n\t      type[i] = noop$1, type = type.slice(0, i).concat(type.slice(i + 1));\n\t      break;\n\t    }\n\t  }\n\t  if (callback != null) type.push({name: name, value: callback});\n\t  return type;\n\t}\n\t\n\tfunction objectConverter(columns) {\n\t  return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n\t    return JSON.stringify(name) + \": d[\" + i + \"]\";\n\t  }).join(\",\") + \"}\");\n\t}\n\t\n\tfunction customConverter(columns, f) {\n\t  var object = objectConverter(columns);\n\t  return function(row, i) {\n\t    return f(object(row), i, columns);\n\t  };\n\t}\n\t\n\t// Compute unique columns in order of discovery.\n\tfunction inferColumns(rows) {\n\t  var columnSet = Object.create(null),\n\t      columns = [];\n\t\n\t  rows.forEach(function(row) {\n\t    for (var column in row) {\n\t      if (!(column in columnSet)) {\n\t        columns.push(columnSet[column] = column);\n\t      }\n\t    }\n\t  });\n\t\n\t  return columns;\n\t}\n\t\n\tvar dsv = function(delimiter) {\n\t  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n]\"),\n\t      delimiterCode = delimiter.charCodeAt(0);\n\t\n\t  function parse(text, f) {\n\t    var convert, columns, rows = parseRows(text, function(row, i) {\n\t      if (convert) return convert(row, i - 1);\n\t      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n\t    });\n\t    rows.columns = columns;\n\t    return rows;\n\t  }\n\t\n\t  function parseRows(text, f) {\n\t    var EOL = {}, // sentinel value for end-of-line\n\t        EOF = {}, // sentinel value for end-of-file\n\t        rows = [], // output rows\n\t        N = text.length,\n\t        I = 0, // current character index\n\t        n = 0, // the current line number\n\t        t, // the current token\n\t        eol; // is the current token followed by EOL?\n\t\n\t    function token() {\n\t      if (I >= N) return EOF; // special case: end of file\n\t      if (eol) return eol = false, EOL; // special case: end of line\n\t\n\t      // special case: quotes\n\t      var j = I, c;\n\t      if (text.charCodeAt(j) === 34) {\n\t        var i = j;\n\t        while (i++ < N) {\n\t          if (text.charCodeAt(i) === 34) {\n\t            if (text.charCodeAt(i + 1) !== 34) break;\n\t            ++i;\n\t          }\n\t        }\n\t        I = i + 2;\n\t        c = text.charCodeAt(i + 1);\n\t        if (c === 13) {\n\t          eol = true;\n\t          if (text.charCodeAt(i + 2) === 10) ++I;\n\t        } else if (c === 10) {\n\t          eol = true;\n\t        }\n\t        return text.slice(j + 1, i).replace(/\"\"/g, \"\\\"\");\n\t      }\n\t\n\t      // common case: find next delimiter or newline\n\t      while (I < N) {\n\t        var k = 1;\n\t        c = text.charCodeAt(I++);\n\t        if (c === 10) eol = true; // \\n\n\t        else if (c === 13) { eol = true; if (text.charCodeAt(I) === 10) ++I, ++k; } // \\r|\\r\\n\n\t        else if (c !== delimiterCode) continue;\n\t        return text.slice(j, I - k);\n\t      }\n\t\n\t      // special case: last token before EOF\n\t      return text.slice(j);\n\t    }\n\t\n\t    while ((t = token()) !== EOF) {\n\t      var a = [];\n\t      while (t !== EOL && t !== EOF) {\n\t        a.push(t);\n\t        t = token();\n\t      }\n\t      if (f && (a = f(a, n++)) == null) continue;\n\t      rows.push(a);\n\t    }\n\t\n\t    return rows;\n\t  }\n\t\n\t  function format(rows, columns) {\n\t    if (columns == null) columns = inferColumns(rows);\n\t    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {\n\t      return columns.map(function(column) {\n\t        return formatValue(row[column]);\n\t      }).join(delimiter);\n\t    })).join(\"\\n\");\n\t  }\n\t\n\t  function formatRows(rows) {\n\t    return rows.map(formatRow).join(\"\\n\");\n\t  }\n\t\n\t  function formatRow(row) {\n\t    return row.map(formatValue).join(delimiter);\n\t  }\n\t\n\t  function formatValue(text) {\n\t    return text == null ? \"\"\n\t        : reFormat.test(text += \"\") ? \"\\\"\" + text.replace(/\\\"/g, \"\\\"\\\"\") + \"\\\"\"\n\t        : text;\n\t  }\n\t\n\t  return {\n\t    parse: parse,\n\t    parseRows: parseRows,\n\t    format: format,\n\t    formatRows: formatRows\n\t  };\n\t};\n\t\n\tvar csv = dsv(\",\");\n\t\n\tvar csvParse = csv.parse;\n\tvar csvParseRows = csv.parseRows;\n\tvar csvFormat = csv.format;\n\tvar csvFormatRows = csv.formatRows;\n\t\n\tvar tsv = dsv(\"\\t\");\n\t\n\tvar tsvParse = tsv.parse;\n\tvar tsvParseRows = tsv.parseRows;\n\tvar tsvFormat = tsv.format;\n\tvar tsvFormatRows = tsv.formatRows;\n\t\n\tvar request = function(url, callback) {\n\t  var request,\n\t      event = dispatch(\"beforesend\", \"progress\", \"load\", \"error\"),\n\t      mimeType,\n\t      headers = map$1(),\n\t      xhr = new XMLHttpRequest,\n\t      user = null,\n\t      password = null,\n\t      response,\n\t      responseType,\n\t      timeout = 0;\n\t\n\t  // If IE does not support CORS, use XDomainRequest.\n\t  if (typeof XDomainRequest !== \"undefined\"\n\t      && !(\"withCredentials\" in xhr)\n\t      && /^(http(s)?:)?\\/\\//.test(url)) xhr = new XDomainRequest;\n\t\n\t  \"onload\" in xhr\n\t      ? xhr.onload = xhr.onerror = xhr.ontimeout = respond\n\t      : xhr.onreadystatechange = function(o) { xhr.readyState > 3 && respond(o); };\n\t\n\t  function respond(o) {\n\t    var status = xhr.status, result;\n\t    if (!status && hasResponse(xhr)\n\t        || status >= 200 && status < 300\n\t        || status === 304) {\n\t      if (response) {\n\t        try {\n\t          result = response.call(request, xhr);\n\t        } catch (e) {\n\t          event.call(\"error\", request, e);\n\t          return;\n\t        }\n\t      } else {\n\t        result = xhr;\n\t      }\n\t      event.call(\"load\", request, result);\n\t    } else {\n\t      event.call(\"error\", request, o);\n\t    }\n\t  }\n\t\n\t  xhr.onprogress = function(e) {\n\t    event.call(\"progress\", request, e);\n\t  };\n\t\n\t  request = {\n\t    header: function(name, value) {\n\t      name = (name + \"\").toLowerCase();\n\t      if (arguments.length < 2) return headers.get(name);\n\t      if (value == null) headers.remove(name);\n\t      else headers.set(name, value + \"\");\n\t      return request;\n\t    },\n\t\n\t    // If mimeType is non-null and no Accept header is set, a default is used.\n\t    mimeType: function(value) {\n\t      if (!arguments.length) return mimeType;\n\t      mimeType = value == null ? null : value + \"\";\n\t      return request;\n\t    },\n\t\n\t    // Specifies what type the response value should take;\n\t    // for instance, arraybuffer, blob, document, or text.\n\t    responseType: function(value) {\n\t      if (!arguments.length) return responseType;\n\t      responseType = value;\n\t      return request;\n\t    },\n\t\n\t    timeout: function(value) {\n\t      if (!arguments.length) return timeout;\n\t      timeout = +value;\n\t      return request;\n\t    },\n\t\n\t    user: function(value) {\n\t      return arguments.length < 1 ? user : (user = value == null ? null : value + \"\", request);\n\t    },\n\t\n\t    password: function(value) {\n\t      return arguments.length < 1 ? password : (password = value == null ? null : value + \"\", request);\n\t    },\n\t\n\t    // Specify how to convert the response content to a specific type;\n\t    // changes the callback value on \"load\" events.\n\t    response: function(value) {\n\t      response = value;\n\t      return request;\n\t    },\n\t\n\t    // Alias for send(\"GET\", …).\n\t    get: function(data, callback) {\n\t      return request.send(\"GET\", data, callback);\n\t    },\n\t\n\t    // Alias for send(\"POST\", …).\n\t    post: function(data, callback) {\n\t      return request.send(\"POST\", data, callback);\n\t    },\n\t\n\t    // If callback is non-null, it will be used for error and load events.\n\t    send: function(method, data, callback) {\n\t      xhr.open(method, url, true, user, password);\n\t      if (mimeType != null && !headers.has(\"accept\")) headers.set(\"accept\", mimeType + \",*/*\");\n\t      if (xhr.setRequestHeader) headers.each(function(value, name) { xhr.setRequestHeader(name, value); });\n\t      if (mimeType != null && xhr.overrideMimeType) xhr.overrideMimeType(mimeType);\n\t      if (responseType != null) xhr.responseType = responseType;\n\t      if (timeout > 0) xhr.timeout = timeout;\n\t      if (callback == null && typeof data === \"function\") callback = data, data = null;\n\t      if (callback != null && callback.length === 1) callback = fixCallback(callback);\n\t      if (callback != null) request.on(\"error\", callback).on(\"load\", function(xhr) { callback(null, xhr); });\n\t      event.call(\"beforesend\", request, xhr);\n\t      xhr.send(data == null ? null : data);\n\t      return request;\n\t    },\n\t\n\t    abort: function() {\n\t      xhr.abort();\n\t      return request;\n\t    },\n\t\n\t    on: function() {\n\t      var value = event.on.apply(event, arguments);\n\t      return value === event ? request : value;\n\t    }\n\t  };\n\t\n\t  if (callback != null) {\n\t    if (typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback);\n\t    return request.get(callback);\n\t  }\n\t\n\t  return request;\n\t};\n\t\n\tfunction fixCallback(callback) {\n\t  return function(error, xhr) {\n\t    callback(error == null ? xhr : null);\n\t  };\n\t}\n\t\n\tfunction hasResponse(xhr) {\n\t  var type = xhr.responseType;\n\t  return type && type !== \"text\"\n\t      ? xhr.response // null on error\n\t      : xhr.responseText; // \"\" on error\n\t}\n\t\n\tvar type = function(defaultMimeType, response) {\n\t  return function(url, callback) {\n\t    var r = request(url).mimeType(defaultMimeType).response(response);\n\t    if (callback != null) {\n\t      if (typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback);\n\t      return r.get(callback);\n\t    }\n\t    return r;\n\t  };\n\t};\n\t\n\tvar html = type(\"text/html\", function(xhr) {\n\t  return document.createRange().createContextualFragment(xhr.responseText);\n\t});\n\t\n\tvar json = type(\"application/json\", function(xhr) {\n\t  return JSON.parse(xhr.responseText);\n\t});\n\t\n\tvar text = type(\"text/plain\", function(xhr) {\n\t  return xhr.responseText;\n\t});\n\t\n\tvar xml = type(\"application/xml\", function(xhr) {\n\t  var xml = xhr.responseXML;\n\t  if (!xml) throw new Error(\"parse error\");\n\t  return xml;\n\t});\n\t\n\tvar dsv$1 = function(defaultMimeType, parse) {\n\t  return function(url, row, callback) {\n\t    if (arguments.length < 3) callback = row, row = null;\n\t    var r = request(url).mimeType(defaultMimeType);\n\t    r.row = function(_) { return arguments.length ? r.response(responseOf(parse, row = _)) : row; };\n\t    r.row(row);\n\t    return callback ? r.get(callback) : r;\n\t  };\n\t};\n\t\n\tfunction responseOf(parse, row) {\n\t  return function(request$$1) {\n\t    return parse(request$$1.responseText, row);\n\t  };\n\t}\n\t\n\tvar csv$1 = dsv$1(\"text/csv\", csvParse);\n\t\n\tvar tsv$1 = dsv$1(\"text/tab-separated-values\", tsvParse);\n\t\n\tvar frame = 0;\n\tvar timeout = 0;\n\tvar interval = 0;\n\tvar pokeDelay = 1000;\n\tvar taskHead;\n\tvar taskTail;\n\tvar clockLast = 0;\n\tvar clockNow = 0;\n\tvar clockSkew = 0;\n\tvar clock = typeof performance === \"object\" && performance.now ? performance : Date;\n\tvar setFrame = typeof requestAnimationFrame === \"function\" ? requestAnimationFrame : function(f) { setTimeout(f, 17); };\n\t\n\tfunction now() {\n\t  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);\n\t}\n\t\n\tfunction clearNow() {\n\t  clockNow = 0;\n\t}\n\t\n\tfunction Timer() {\n\t  this._call =\n\t  this._time =\n\t  this._next = null;\n\t}\n\t\n\tTimer.prototype = timer.prototype = {\n\t  constructor: Timer,\n\t  restart: function(callback, delay, time) {\n\t    if (typeof callback !== \"function\") throw new TypeError(\"callback is not a function\");\n\t    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);\n\t    if (!this._next && taskTail !== this) {\n\t      if (taskTail) taskTail._next = this;\n\t      else taskHead = this;\n\t      taskTail = this;\n\t    }\n\t    this._call = callback;\n\t    this._time = time;\n\t    sleep();\n\t  },\n\t  stop: function() {\n\t    if (this._call) {\n\t      this._call = null;\n\t      this._time = Infinity;\n\t      sleep();\n\t    }\n\t  }\n\t};\n\t\n\tfunction timer(callback, delay, time) {\n\t  var t = new Timer;\n\t  t.restart(callback, delay, time);\n\t  return t;\n\t}\n\t\n\tfunction timerFlush() {\n\t  now(); // Get the current time, if not already set.\n\t  ++frame; // Pretend we’ve set an alarm, if we haven’t already.\n\t  var t = taskHead, e;\n\t  while (t) {\n\t    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);\n\t    t = t._next;\n\t  }\n\t  --frame;\n\t}\n\t\n\tfunction wake() {\n\t  clockNow = (clockLast = clock.now()) + clockSkew;\n\t  frame = timeout = 0;\n\t  try {\n\t    timerFlush();\n\t  } finally {\n\t    frame = 0;\n\t    nap();\n\t    clockNow = 0;\n\t  }\n\t}\n\t\n\tfunction poke$1() {\n\t  var now = clock.now(), delay = now - clockLast;\n\t  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;\n\t}\n\t\n\tfunction nap() {\n\t  var t0, t1 = taskHead, t2, time = Infinity;\n\t  while (t1) {\n\t    if (t1._call) {\n\t      if (time > t1._time) time = t1._time;\n\t      t0 = t1, t1 = t1._next;\n\t    } else {\n\t      t2 = t1._next, t1._next = null;\n\t      t1 = t0 ? t0._next = t2 : taskHead = t2;\n\t    }\n\t  }\n\t  taskTail = t0;\n\t  sleep(time);\n\t}\n\t\n\tfunction sleep(time) {\n\t  if (frame) return; // Soonest alarm already set, or will be.\n\t  if (timeout) timeout = clearTimeout(timeout);\n\t  var delay = time - clockNow;\n\t  if (delay > 24) {\n\t    if (time < Infinity) timeout = setTimeout(wake, delay);\n\t    if (interval) interval = clearInterval(interval);\n\t  } else {\n\t    if (!interval) interval = setInterval(poke$1, pokeDelay);\n\t    frame = 1, setFrame(wake);\n\t  }\n\t}\n\t\n\tvar timeout$1 = function(callback, delay, time) {\n\t  var t = new Timer;\n\t  delay = delay == null ? 0 : +delay;\n\t  t.restart(function(elapsed) {\n\t    t.stop();\n\t    callback(elapsed + delay);\n\t  }, delay, time);\n\t  return t;\n\t};\n\t\n\tvar interval$1 = function(callback, delay, time) {\n\t  var t = new Timer, total = delay;\n\t  if (delay == null) return t.restart(callback, delay, time), t;\n\t  delay = +delay, time = time == null ? now() : +time;\n\t  t.restart(function tick(elapsed) {\n\t    elapsed += total;\n\t    t.restart(tick, total += delay, time);\n\t    callback(elapsed);\n\t  }, delay, time);\n\t  return t;\n\t};\n\t\n\tvar t0$1 = new Date;\n\tvar t1$1 = new Date;\n\t\n\tfunction newInterval(floori, offseti, count, field) {\n\t\n\t  function interval(date) {\n\t    return floori(date = new Date(+date)), date;\n\t  }\n\t\n\t  interval.floor = interval;\n\t\n\t  interval.ceil = function(date) {\n\t    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;\n\t  };\n\t\n\t  interval.round = function(date) {\n\t    var d0 = interval(date),\n\t        d1 = interval.ceil(date);\n\t    return date - d0 < d1 - date ? d0 : d1;\n\t  };\n\t\n\t  interval.offset = function(date, step) {\n\t    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n\t  };\n\t\n\t  interval.range = function(start, stop, step) {\n\t    var range = [];\n\t    start = interval.ceil(start);\n\t    step = step == null ? 1 : Math.floor(step);\n\t    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n\t    do range.push(new Date(+start)); while (offseti(start, step), floori(start), start < stop)\n\t    return range;\n\t  };\n\t\n\t  interval.filter = function(test) {\n\t    return newInterval(function(date) {\n\t      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);\n\t    }, function(date, step) {\n\t      if (date >= date) while (--step >= 0) while (offseti(date, 1), !test(date)) {} // eslint-disable-line no-empty\n\t    });\n\t  };\n\t\n\t  if (count) {\n\t    interval.count = function(start, end) {\n\t      t0$1.setTime(+start), t1$1.setTime(+end);\n\t      floori(t0$1), floori(t1$1);\n\t      return Math.floor(count(t0$1, t1$1));\n\t    };\n\t\n\t    interval.every = function(step) {\n\t      step = Math.floor(step);\n\t      return !isFinite(step) || !(step > 0) ? null\n\t          : !(step > 1) ? interval\n\t          : interval.filter(field\n\t              ? function(d) { return field(d) % step === 0; }\n\t              : function(d) { return interval.count(0, d) % step === 0; });\n\t    };\n\t  }\n\t\n\t  return interval;\n\t}\n\t\n\tvar millisecond = newInterval(function() {\n\t  // noop\n\t}, function(date, step) {\n\t  date.setTime(+date + step);\n\t}, function(start, end) {\n\t  return end - start;\n\t});\n\t\n\t// An optimized implementation for this simple case.\n\tmillisecond.every = function(k) {\n\t  k = Math.floor(k);\n\t  if (!isFinite(k) || !(k > 0)) return null;\n\t  if (!(k > 1)) return millisecond;\n\t  return newInterval(function(date) {\n\t    date.setTime(Math.floor(date / k) * k);\n\t  }, function(date, step) {\n\t    date.setTime(+date + step * k);\n\t  }, function(start, end) {\n\t    return (end - start) / k;\n\t  });\n\t};\n\t\n\tvar milliseconds = millisecond.range;\n\t\n\tvar durationSecond = 1e3;\n\tvar durationMinute = 6e4;\n\tvar durationHour = 36e5;\n\tvar durationDay = 864e5;\n\tvar durationWeek = 6048e5;\n\t\n\tvar second = newInterval(function(date) {\n\t  date.setTime(Math.floor(date / durationSecond) * durationSecond);\n\t}, function(date, step) {\n\t  date.setTime(+date + step * durationSecond);\n\t}, function(start, end) {\n\t  return (end - start) / durationSecond;\n\t}, function(date) {\n\t  return date.getUTCSeconds();\n\t});\n\t\n\tvar seconds = second.range;\n\t\n\tvar minute = newInterval(function(date) {\n\t  date.setTime(Math.floor(date / durationMinute) * durationMinute);\n\t}, function(date, step) {\n\t  date.setTime(+date + step * durationMinute);\n\t}, function(start, end) {\n\t  return (end - start) / durationMinute;\n\t}, function(date) {\n\t  return date.getMinutes();\n\t});\n\t\n\tvar minutes = minute.range;\n\t\n\tvar hour = newInterval(function(date) {\n\t  var offset = date.getTimezoneOffset() * durationMinute % durationHour;\n\t  if (offset < 0) offset += durationHour;\n\t  date.setTime(Math.floor((+date - offset) / durationHour) * durationHour + offset);\n\t}, function(date, step) {\n\t  date.setTime(+date + step * durationHour);\n\t}, function(start, end) {\n\t  return (end - start) / durationHour;\n\t}, function(date) {\n\t  return date.getHours();\n\t});\n\t\n\tvar hours = hour.range;\n\t\n\tvar day = newInterval(function(date) {\n\t  date.setHours(0, 0, 0, 0);\n\t}, function(date, step) {\n\t  date.setDate(date.getDate() + step);\n\t}, function(start, end) {\n\t  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;\n\t}, function(date) {\n\t  return date.getDate() - 1;\n\t});\n\t\n\tvar days = day.range;\n\t\n\tfunction weekday(i) {\n\t  return newInterval(function(date) {\n\t    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n\t    date.setHours(0, 0, 0, 0);\n\t  }, function(date, step) {\n\t    date.setDate(date.getDate() + step * 7);\n\t  }, function(start, end) {\n\t    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;\n\t  });\n\t}\n\t\n\tvar sunday = weekday(0);\n\tvar monday = weekday(1);\n\tvar tuesday = weekday(2);\n\tvar wednesday = weekday(3);\n\tvar thursday = weekday(4);\n\tvar friday = weekday(5);\n\tvar saturday = weekday(6);\n\t\n\tvar sundays = sunday.range;\n\tvar mondays = monday.range;\n\tvar tuesdays = tuesday.range;\n\tvar wednesdays = wednesday.range;\n\tvar thursdays = thursday.range;\n\tvar fridays = friday.range;\n\tvar saturdays = saturday.range;\n\t\n\tvar month = newInterval(function(date) {\n\t  date.setDate(1);\n\t  date.setHours(0, 0, 0, 0);\n\t}, function(date, step) {\n\t  date.setMonth(date.getMonth() + step);\n\t}, function(start, end) {\n\t  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n\t}, function(date) {\n\t  return date.getMonth();\n\t});\n\t\n\tvar months = month.range;\n\t\n\tvar year = newInterval(function(date) {\n\t  date.setMonth(0, 1);\n\t  date.setHours(0, 0, 0, 0);\n\t}, function(date, step) {\n\t  date.setFullYear(date.getFullYear() + step);\n\t}, function(start, end) {\n\t  return end.getFullYear() - start.getFullYear();\n\t}, function(date) {\n\t  return date.getFullYear();\n\t});\n\t\n\t// An optimized implementation for this simple case.\n\tyear.every = function(k) {\n\t  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {\n\t    date.setFullYear(Math.floor(date.getFullYear() / k) * k);\n\t    date.setMonth(0, 1);\n\t    date.setHours(0, 0, 0, 0);\n\t  }, function(date, step) {\n\t    date.setFullYear(date.getFullYear() + step * k);\n\t  });\n\t};\n\t\n\tvar years = year.range;\n\t\n\tvar utcMinute = newInterval(function(date) {\n\t  date.setUTCSeconds(0, 0);\n\t}, function(date, step) {\n\t  date.setTime(+date + step * durationMinute);\n\t}, function(start, end) {\n\t  return (end - start) / durationMinute;\n\t}, function(date) {\n\t  return date.getUTCMinutes();\n\t});\n\t\n\tvar utcMinutes = utcMinute.range;\n\t\n\tvar utcHour = newInterval(function(date) {\n\t  date.setUTCMinutes(0, 0, 0);\n\t}, function(date, step) {\n\t  date.setTime(+date + step * durationHour);\n\t}, function(start, end) {\n\t  return (end - start) / durationHour;\n\t}, function(date) {\n\t  return date.getUTCHours();\n\t});\n\t\n\tvar utcHours = utcHour.range;\n\t\n\tvar utcDay = newInterval(function(date) {\n\t  date.setUTCHours(0, 0, 0, 0);\n\t}, function(date, step) {\n\t  date.setUTCDate(date.getUTCDate() + step);\n\t}, function(start, end) {\n\t  return (end - start) / durationDay;\n\t}, function(date) {\n\t  return date.getUTCDate() - 1;\n\t});\n\t\n\tvar utcDays = utcDay.range;\n\t\n\tfunction utcWeekday(i) {\n\t  return newInterval(function(date) {\n\t    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n\t    date.setUTCHours(0, 0, 0, 0);\n\t  }, function(date, step) {\n\t    date.setUTCDate(date.getUTCDate() + step * 7);\n\t  }, function(start, end) {\n\t    return (end - start) / durationWeek;\n\t  });\n\t}\n\t\n\tvar utcSunday = utcWeekday(0);\n\tvar utcMonday = utcWeekday(1);\n\tvar utcTuesday = utcWeekday(2);\n\tvar utcWednesday = utcWeekday(3);\n\tvar utcThursday = utcWeekday(4);\n\tvar utcFriday = utcWeekday(5);\n\tvar utcSaturday = utcWeekday(6);\n\t\n\tvar utcSundays = utcSunday.range;\n\tvar utcMondays = utcMonday.range;\n\tvar utcTuesdays = utcTuesday.range;\n\tvar utcWednesdays = utcWednesday.range;\n\tvar utcThursdays = utcThursday.range;\n\tvar utcFridays = utcFriday.range;\n\tvar utcSaturdays = utcSaturday.range;\n\t\n\tvar utcMonth = newInterval(function(date) {\n\t  date.setUTCDate(1);\n\t  date.setUTCHours(0, 0, 0, 0);\n\t}, function(date, step) {\n\t  date.setUTCMonth(date.getUTCMonth() + step);\n\t}, function(start, end) {\n\t  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n\t}, function(date) {\n\t  return date.getUTCMonth();\n\t});\n\t\n\tvar utcMonths = utcMonth.range;\n\t\n\tvar utcYear = newInterval(function(date) {\n\t  date.setUTCMonth(0, 1);\n\t  date.setUTCHours(0, 0, 0, 0);\n\t}, function(date, step) {\n\t  date.setUTCFullYear(date.getUTCFullYear() + step);\n\t}, function(start, end) {\n\t  return end.getUTCFullYear() - start.getUTCFullYear();\n\t}, function(date) {\n\t  return date.getUTCFullYear();\n\t});\n\t\n\t// An optimized implementation for this simple case.\n\tutcYear.every = function(k) {\n\t  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {\n\t    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);\n\t    date.setUTCMonth(0, 1);\n\t    date.setUTCHours(0, 0, 0, 0);\n\t  }, function(date, step) {\n\t    date.setUTCFullYear(date.getUTCFullYear() + step * k);\n\t  });\n\t};\n\t\n\tvar utcYears = utcYear.range;\n\t\n\t// Computes the decimal coefficient and exponent of the specified number x with\n\t// significant digits p, where x is positive and p is in [1, 21] or undefined.\n\t// For example, formatDecimal(1.23) returns [\"123\", 0].\n\tvar formatDecimal = function(x, p) {\n\t  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, ±Infinity\n\t  var i, coefficient = x.slice(0, i);\n\t\n\t  // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n\t  // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n\t  return [\n\t    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n\t    +x.slice(i + 1)\n\t  ];\n\t};\n\t\n\tvar exponent$1 = function(x) {\n\t  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;\n\t};\n\t\n\tvar formatGroup = function(grouping, thousands) {\n\t  return function(value, width) {\n\t    var i = value.length,\n\t        t = [],\n\t        j = 0,\n\t        g = grouping[0],\n\t        length = 0;\n\t\n\t    while (i > 0 && g > 0) {\n\t      if (length + g + 1 > width) g = Math.max(1, width - length);\n\t      t.push(value.substring(i -= g, i + g));\n\t      if ((length += g + 1) > width) break;\n\t      g = grouping[j = (j + 1) % grouping.length];\n\t    }\n\t\n\t    return t.reverse().join(thousands);\n\t  };\n\t};\n\t\n\tvar formatDefault = function(x, p) {\n\t  x = x.toPrecision(p);\n\t\n\t  out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {\n\t    switch (x[i]) {\n\t      case \".\": i0 = i1 = i; break;\n\t      case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n\t      case \"e\": break out;\n\t      default: if (i0 > 0) i0 = 0; break;\n\t    }\n\t  }\n\t\n\t  return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;\n\t};\n\t\n\tvar prefixExponent;\n\t\n\tvar formatPrefixAuto = function(x, p) {\n\t  var d = formatDecimal(x, p);\n\t  if (!d) return x + \"\";\n\t  var coefficient = d[0],\n\t      exponent = d[1],\n\t      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n\t      n = coefficient.length;\n\t  return i === n ? coefficient\n\t      : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n\t      : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n\t      : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!\n\t};\n\t\n\tvar formatRounded = function(x, p) {\n\t  var d = formatDecimal(x, p);\n\t  if (!d) return x + \"\";\n\t  var coefficient = d[0],\n\t      exponent = d[1];\n\t  return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n\t      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n\t      : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n\t};\n\t\n\tvar formatTypes = {\n\t  \"\": formatDefault,\n\t  \"%\": function(x, p) { return (x * 100).toFixed(p); },\n\t  \"b\": function(x) { return Math.round(x).toString(2); },\n\t  \"c\": function(x) { return x + \"\"; },\n\t  \"d\": function(x) { return Math.round(x).toString(10); },\n\t  \"e\": function(x, p) { return x.toExponential(p); },\n\t  \"f\": function(x, p) { return x.toFixed(p); },\n\t  \"g\": function(x, p) { return x.toPrecision(p); },\n\t  \"o\": function(x) { return Math.round(x).toString(8); },\n\t  \"p\": function(x, p) { return formatRounded(x * 100, p); },\n\t  \"r\": formatRounded,\n\t  \"s\": formatPrefixAuto,\n\t  \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); },\n\t  \"x\": function(x) { return Math.round(x).toString(16); }\n\t};\n\t\n\t// [[fill]align][sign][symbol][0][width][,][.precision][type]\n\tvar re = /^(?:(.)?([<>=^]))?([+\\-\\( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?([a-z%])?$/i;\n\t\n\tvar formatSpecifier = function(specifier) {\n\t  return new FormatSpecifier(specifier);\n\t};\n\t\n\tfunction FormatSpecifier(specifier) {\n\t  if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n\t\n\t  var match,\n\t      fill = match[1] || \" \",\n\t      align = match[2] || \">\",\n\t      sign = match[3] || \"-\",\n\t      symbol = match[4] || \"\",\n\t      zero = !!match[5],\n\t      width = match[6] && +match[6],\n\t      comma = !!match[7],\n\t      precision = match[8] && +match[8].slice(1),\n\t      type = match[9] || \"\";\n\t\n\t  // The \"n\" type is an alias for \",g\".\n\t  if (type === \"n\") comma = true, type = \"g\";\n\t\n\t  // Map invalid types to the default format.\n\t  else if (!formatTypes[type]) type = \"\";\n\t\n\t  // If zero fill is specified, padding goes after sign and before digits.\n\t  if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\t\n\t  this.fill = fill;\n\t  this.align = align;\n\t  this.sign = sign;\n\t  this.symbol = symbol;\n\t  this.zero = zero;\n\t  this.width = width;\n\t  this.comma = comma;\n\t  this.precision = precision;\n\t  this.type = type;\n\t}\n\t\n\tFormatSpecifier.prototype.toString = function() {\n\t  return this.fill\n\t      + this.align\n\t      + this.sign\n\t      + this.symbol\n\t      + (this.zero ? \"0\" : \"\")\n\t      + (this.width == null ? \"\" : Math.max(1, this.width | 0))\n\t      + (this.comma ? \",\" : \"\")\n\t      + (this.precision == null ? \"\" : \".\" + Math.max(0, this.precision | 0))\n\t      + this.type;\n\t};\n\t\n\tvar prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"\\xB5\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\t\n\tfunction identity$3(x) {\n\t  return x;\n\t}\n\t\n\tvar formatLocale = function(locale) {\n\t  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity$3,\n\t      currency = locale.currency,\n\t      decimal = locale.decimal;\n\t\n\t  function newFormat(specifier) {\n\t    specifier = formatSpecifier(specifier);\n\t\n\t    var fill = specifier.fill,\n\t        align = specifier.align,\n\t        sign = specifier.sign,\n\t        symbol = specifier.symbol,\n\t        zero = specifier.zero,\n\t        width = specifier.width,\n\t        comma = specifier.comma,\n\t        precision = specifier.precision,\n\t        type = specifier.type;\n\t\n\t    // Compute the prefix and suffix.\n\t    // For SI-prefix, the suffix is lazily computed.\n\t    var prefix = symbol === \"$\" ? currency[0] : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n\t        suffix = symbol === \"$\" ? currency[1] : /[%p]/.test(type) ? \"%\" : \"\";\n\t\n\t    // What format function should we use?\n\t    // Is this an integer type?\n\t    // Can this type generate exponential notation?\n\t    var formatType = formatTypes[type],\n\t        maybeSuffix = !type || /[defgprs%]/.test(type);\n\t\n\t    // Set the default precision if not specified,\n\t    // or clamp the specified precision to the supported range.\n\t    // For significant precision, it must be in [1, 21].\n\t    // For fixed precision, it must be in [0, 20].\n\t    precision = precision == null ? (type ? 6 : 12)\n\t        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n\t        : Math.max(0, Math.min(20, precision));\n\t\n\t    function format(value) {\n\t      var valuePrefix = prefix,\n\t          valueSuffix = suffix,\n\t          i, n, c;\n\t\n\t      if (type === \"c\") {\n\t        valueSuffix = formatType(value) + valueSuffix;\n\t        value = \"\";\n\t      } else {\n\t        value = +value;\n\t\n\t        // Convert negative to positive, and compute the prefix.\n\t        // Note that -0 is not less than 0, but 1 / -0 is!\n\t        var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);\n\t\n\t        // Perform the initial formatting.\n\t        value = formatType(value, precision);\n\t\n\t        // If the original value was negative, it may be rounded to zero during\n\t        // formatting; treat this as (positive) zero.\n\t        if (valueNegative) {\n\t          i = -1, n = value.length;\n\t          valueNegative = false;\n\t          while (++i < n) {\n\t            if (c = value.charCodeAt(i), (48 < c && c < 58)\n\t                || (type === \"x\" && 96 < c && c < 103)\n\t                || (type === \"X\" && 64 < c && c < 71)) {\n\t              valueNegative = true;\n\t              break;\n\t            }\n\t          }\n\t        }\n\t\n\t        // Compute the prefix and suffix.\n\t        valuePrefix = (valueNegative ? (sign === \"(\" ? sign : \"-\") : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n\t        valueSuffix = valueSuffix + (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\t\n\t        // Break the formatted value into the integer “value” part that can be\n\t        // grouped, and fractional or exponential “suffix” part that is not.\n\t        if (maybeSuffix) {\n\t          i = -1, n = value.length;\n\t          while (++i < n) {\n\t            if (c = value.charCodeAt(i), 48 > c || c > 57) {\n\t              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n\t              value = value.slice(0, i);\n\t              break;\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      // If the fill character is not \"0\", grouping is applied before padding.\n\t      if (comma && !zero) value = group(value, Infinity);\n\t\n\t      // Compute the padding.\n\t      var length = valuePrefix.length + value.length + valueSuffix.length,\n\t          padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\t\n\t      // If the fill character is \"0\", grouping is applied after padding.\n\t      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\t\n\t      // Reconstruct the final output based on the desired alignment.\n\t      switch (align) {\n\t        case \"<\": return valuePrefix + value + valueSuffix + padding;\n\t        case \"=\": return valuePrefix + padding + value + valueSuffix;\n\t        case \"^\": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);\n\t      }\n\t      return padding + valuePrefix + value + valueSuffix;\n\t    }\n\t\n\t    format.toString = function() {\n\t      return specifier + \"\";\n\t    };\n\t\n\t    return format;\n\t  }\n\t\n\t  function formatPrefix(specifier, value) {\n\t    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n\t        e = Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3,\n\t        k = Math.pow(10, -e),\n\t        prefix = prefixes[8 + e / 3];\n\t    return function(value) {\n\t      return f(k * value) + prefix;\n\t    };\n\t  }\n\t\n\t  return {\n\t    format: newFormat,\n\t    formatPrefix: formatPrefix\n\t  };\n\t};\n\t\n\tvar locale$1;\n\t\n\t\n\t\n\tdefaultLocale({\n\t  decimal: \".\",\n\t  thousands: \",\",\n\t  grouping: [3],\n\t  currency: [\"$\", \"\"]\n\t});\n\t\n\tfunction defaultLocale(definition) {\n\t  locale$1 = formatLocale(definition);\n\t  exports.format = locale$1.format;\n\t  exports.formatPrefix = locale$1.formatPrefix;\n\t  return locale$1;\n\t}\n\t\n\tvar precisionFixed = function(step) {\n\t  return Math.max(0, -exponent$1(Math.abs(step)));\n\t};\n\t\n\tvar precisionPrefix = function(step, value) {\n\t  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3 - exponent$1(Math.abs(step)));\n\t};\n\t\n\tvar precisionRound = function(step, max) {\n\t  step = Math.abs(step), max = Math.abs(max) - step;\n\t  return Math.max(0, exponent$1(max) - exponent$1(step)) + 1;\n\t};\n\t\n\tfunction localDate(d) {\n\t  if (0 <= d.y && d.y < 100) {\n\t    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n\t    date.setFullYear(d.y);\n\t    return date;\n\t  }\n\t  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n\t}\n\t\n\tfunction utcDate(d) {\n\t  if (0 <= d.y && d.y < 100) {\n\t    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n\t    date.setUTCFullYear(d.y);\n\t    return date;\n\t  }\n\t  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n\t}\n\t\n\tfunction newYear(y) {\n\t  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};\n\t}\n\t\n\tfunction formatLocale$1(locale) {\n\t  var locale_dateTime = locale.dateTime,\n\t      locale_date = locale.date,\n\t      locale_time = locale.time,\n\t      locale_periods = locale.periods,\n\t      locale_weekdays = locale.days,\n\t      locale_shortWeekdays = locale.shortDays,\n\t      locale_months = locale.months,\n\t      locale_shortMonths = locale.shortMonths;\n\t\n\t  var periodRe = formatRe(locale_periods),\n\t      periodLookup = formatLookup(locale_periods),\n\t      weekdayRe = formatRe(locale_weekdays),\n\t      weekdayLookup = formatLookup(locale_weekdays),\n\t      shortWeekdayRe = formatRe(locale_shortWeekdays),\n\t      shortWeekdayLookup = formatLookup(locale_shortWeekdays),\n\t      monthRe = formatRe(locale_months),\n\t      monthLookup = formatLookup(locale_months),\n\t      shortMonthRe = formatRe(locale_shortMonths),\n\t      shortMonthLookup = formatLookup(locale_shortMonths);\n\t\n\t  var formats = {\n\t    \"a\": formatShortWeekday,\n\t    \"A\": formatWeekday,\n\t    \"b\": formatShortMonth,\n\t    \"B\": formatMonth,\n\t    \"c\": null,\n\t    \"d\": formatDayOfMonth,\n\t    \"e\": formatDayOfMonth,\n\t    \"H\": formatHour24,\n\t    \"I\": formatHour12,\n\t    \"j\": formatDayOfYear,\n\t    \"L\": formatMilliseconds,\n\t    \"m\": formatMonthNumber,\n\t    \"M\": formatMinutes,\n\t    \"p\": formatPeriod,\n\t    \"S\": formatSeconds,\n\t    \"U\": formatWeekNumberSunday,\n\t    \"w\": formatWeekdayNumber,\n\t    \"W\": formatWeekNumberMonday,\n\t    \"x\": null,\n\t    \"X\": null,\n\t    \"y\": formatYear,\n\t    \"Y\": formatFullYear,\n\t    \"Z\": formatZone,\n\t    \"%\": formatLiteralPercent\n\t  };\n\t\n\t  var utcFormats = {\n\t    \"a\": formatUTCShortWeekday,\n\t    \"A\": formatUTCWeekday,\n\t    \"b\": formatUTCShortMonth,\n\t    \"B\": formatUTCMonth,\n\t    \"c\": null,\n\t    \"d\": formatUTCDayOfMonth,\n\t    \"e\": formatUTCDayOfMonth,\n\t    \"H\": formatUTCHour24,\n\t    \"I\": formatUTCHour12,\n\t    \"j\": formatUTCDayOfYear,\n\t    \"L\": formatUTCMilliseconds,\n\t    \"m\": formatUTCMonthNumber,\n\t    \"M\": formatUTCMinutes,\n\t    \"p\": formatUTCPeriod,\n\t    \"S\": formatUTCSeconds,\n\t    \"U\": formatUTCWeekNumberSunday,\n\t    \"w\": formatUTCWeekdayNumber,\n\t    \"W\": formatUTCWeekNumberMonday,\n\t    \"x\": null,\n\t    \"X\": null,\n\t    \"y\": formatUTCYear,\n\t    \"Y\": formatUTCFullYear,\n\t    \"Z\": formatUTCZone,\n\t    \"%\": formatLiteralPercent\n\t  };\n\t\n\t  var parses = {\n\t    \"a\": parseShortWeekday,\n\t    \"A\": parseWeekday,\n\t    \"b\": parseShortMonth,\n\t    \"B\": parseMonth,\n\t    \"c\": parseLocaleDateTime,\n\t    \"d\": parseDayOfMonth,\n\t    \"e\": parseDayOfMonth,\n\t    \"H\": parseHour24,\n\t    \"I\": parseHour24,\n\t    \"j\": parseDayOfYear,\n\t    \"L\": parseMilliseconds,\n\t    \"m\": parseMonthNumber,\n\t    \"M\": parseMinutes,\n\t    \"p\": parsePeriod,\n\t    \"S\": parseSeconds,\n\t    \"U\": parseWeekNumberSunday,\n\t    \"w\": parseWeekdayNumber,\n\t    \"W\": parseWeekNumberMonday,\n\t    \"x\": parseLocaleDate,\n\t    \"X\": parseLocaleTime,\n\t    \"y\": parseYear,\n\t    \"Y\": parseFullYear,\n\t    \"Z\": parseZone,\n\t    \"%\": parseLiteralPercent\n\t  };\n\t\n\t  // These recursive directive definitions must be deferred.\n\t  formats.x = newFormat(locale_date, formats);\n\t  formats.X = newFormat(locale_time, formats);\n\t  formats.c = newFormat(locale_dateTime, formats);\n\t  utcFormats.x = newFormat(locale_date, utcFormats);\n\t  utcFormats.X = newFormat(locale_time, utcFormats);\n\t  utcFormats.c = newFormat(locale_dateTime, utcFormats);\n\t\n\t  function newFormat(specifier, formats) {\n\t    return function(date) {\n\t      var string = [],\n\t          i = -1,\n\t          j = 0,\n\t          n = specifier.length,\n\t          c,\n\t          pad,\n\t          format;\n\t\n\t      if (!(date instanceof Date)) date = new Date(+date);\n\t\n\t      while (++i < n) {\n\t        if (specifier.charCodeAt(i) === 37) {\n\t          string.push(specifier.slice(j, i));\n\t          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);\n\t          else pad = c === \"e\" ? \" \" : \"0\";\n\t          if (format = formats[c]) c = format(date, pad);\n\t          string.push(c);\n\t          j = i + 1;\n\t        }\n\t      }\n\t\n\t      string.push(specifier.slice(j, i));\n\t      return string.join(\"\");\n\t    };\n\t  }\n\t\n\t  function newParse(specifier, newDate) {\n\t    return function(string) {\n\t      var d = newYear(1900),\n\t          i = parseSpecifier(d, specifier, string += \"\", 0);\n\t      if (i != string.length) return null;\n\t\n\t      // The am-pm flag is 0 for AM, and 1 for PM.\n\t      if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n\t\n\t      // Convert day-of-week and week-of-year to day-of-year.\n\t      if (\"W\" in d || \"U\" in d) {\n\t        if (!(\"w\" in d)) d.w = \"W\" in d ? 1 : 0;\n\t        var day$$1 = \"Z\" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();\n\t        d.m = 0;\n\t        d.d = \"W\" in d ? (d.w + 6) % 7 + d.W * 7 - (day$$1 + 5) % 7 : d.w + d.U * 7 - (day$$1 + 6) % 7;\n\t      }\n\t\n\t      // If a time zone is specified, all fields are interpreted as UTC and then\n\t      // offset according to the specified time zone.\n\t      if (\"Z\" in d) {\n\t        d.H += d.Z / 100 | 0;\n\t        d.M += d.Z % 100;\n\t        return utcDate(d);\n\t      }\n\t\n\t      // Otherwise, all fields are in local time.\n\t      return newDate(d);\n\t    };\n\t  }\n\t\n\t  function parseSpecifier(d, specifier, string, j) {\n\t    var i = 0,\n\t        n = specifier.length,\n\t        m = string.length,\n\t        c,\n\t        parse;\n\t\n\t    while (i < n) {\n\t      if (j >= m) return -1;\n\t      c = specifier.charCodeAt(i++);\n\t      if (c === 37) {\n\t        c = specifier.charAt(i++);\n\t        parse = parses[c in pads ? specifier.charAt(i++) : c];\n\t        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;\n\t      } else if (c != string.charCodeAt(j++)) {\n\t        return -1;\n\t      }\n\t    }\n\t\n\t    return j;\n\t  }\n\t\n\t  function parsePeriod(d, string, i) {\n\t    var n = periodRe.exec(string.slice(i));\n\t    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n\t  }\n\t\n\t  function parseShortWeekday(d, string, i) {\n\t    var n = shortWeekdayRe.exec(string.slice(i));\n\t    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n\t  }\n\t\n\t  function parseWeekday(d, string, i) {\n\t    var n = weekdayRe.exec(string.slice(i));\n\t    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n\t  }\n\t\n\t  function parseShortMonth(d, string, i) {\n\t    var n = shortMonthRe.exec(string.slice(i));\n\t    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n\t  }\n\t\n\t  function parseMonth(d, string, i) {\n\t    var n = monthRe.exec(string.slice(i));\n\t    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n\t  }\n\t\n\t  function parseLocaleDateTime(d, string, i) {\n\t    return parseSpecifier(d, locale_dateTime, string, i);\n\t  }\n\t\n\t  function parseLocaleDate(d, string, i) {\n\t    return parseSpecifier(d, locale_date, string, i);\n\t  }\n\t\n\t  function parseLocaleTime(d, string, i) {\n\t    return parseSpecifier(d, locale_time, string, i);\n\t  }\n\t\n\t  function formatShortWeekday(d) {\n\t    return locale_shortWeekdays[d.getDay()];\n\t  }\n\t\n\t  function formatWeekday(d) {\n\t    return locale_weekdays[d.getDay()];\n\t  }\n\t\n\t  function formatShortMonth(d) {\n\t    return locale_shortMonths[d.getMonth()];\n\t  }\n\t\n\t  function formatMonth(d) {\n\t    return locale_months[d.getMonth()];\n\t  }\n\t\n\t  function formatPeriod(d) {\n\t    return locale_periods[+(d.getHours() >= 12)];\n\t  }\n\t\n\t  function formatUTCShortWeekday(d) {\n\t    return locale_shortWeekdays[d.getUTCDay()];\n\t  }\n\t\n\t  function formatUTCWeekday(d) {\n\t    return locale_weekdays[d.getUTCDay()];\n\t  }\n\t\n\t  function formatUTCShortMonth(d) {\n\t    return locale_shortMonths[d.getUTCMonth()];\n\t  }\n\t\n\t  function formatUTCMonth(d) {\n\t    return locale_months[d.getUTCMonth()];\n\t  }\n\t\n\t  function formatUTCPeriod(d) {\n\t    return locale_periods[+(d.getUTCHours() >= 12)];\n\t  }\n\t\n\t  return {\n\t    format: function(specifier) {\n\t      var f = newFormat(specifier += \"\", formats);\n\t      f.toString = function() { return specifier; };\n\t      return f;\n\t    },\n\t    parse: function(specifier) {\n\t      var p = newParse(specifier += \"\", localDate);\n\t      p.toString = function() { return specifier; };\n\t      return p;\n\t    },\n\t    utcFormat: function(specifier) {\n\t      var f = newFormat(specifier += \"\", utcFormats);\n\t      f.toString = function() { return specifier; };\n\t      return f;\n\t    },\n\t    utcParse: function(specifier) {\n\t      var p = newParse(specifier, utcDate);\n\t      p.toString = function() { return specifier; };\n\t      return p;\n\t    }\n\t  };\n\t}\n\t\n\tvar pads = {\"-\": \"\", \"_\": \" \", \"0\": \"0\"};\n\tvar numberRe = /^\\s*\\d+/;\n\tvar percentRe = /^%/;\n\tvar requoteRe = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\t\n\tfunction pad(value, fill, width) {\n\t  var sign = value < 0 ? \"-\" : \"\",\n\t      string = (sign ? -value : value) + \"\",\n\t      length = string.length;\n\t  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n\t}\n\t\n\tfunction requote(s) {\n\t  return s.replace(requoteRe, \"\\\\$&\");\n\t}\n\t\n\tfunction formatRe(names) {\n\t  return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n\t}\n\t\n\tfunction formatLookup(names) {\n\t  var map = {}, i = -1, n = names.length;\n\t  while (++i < n) map[names[i].toLowerCase()] = i;\n\t  return map;\n\t}\n\t\n\tfunction parseWeekdayNumber(d, string, i) {\n\t  var n = numberRe.exec(string.slice(i, i + 1));\n\t  return n ? (d.w = +n[0], i + n[0].length) : -1;\n\t}\n\t\n\tfunction parseWeekNumberSunday(d, string, i) {\n\t  var n = numberRe.exec(string.slice(i));\n\t  return n ? (d.U = +n[0], i + n[0].length) : -1;\n\t}\n\t\n\tfunction parseWeekNumberMonday(d, string, i) {\n\t  var n = numberRe.exec(string.slice(i));\n\t  return n ? (d.W = +n[0], i + n[0].length) : -1;\n\t}\n\t\n\tfunction parseFullYear(d, string, i) {\n\t  var n = numberRe.exec(string.slice(i, i + 4));\n\t  return n ? (d.y = +n[0], i + n[0].length) : -1;\n\t}\n\t\n\tfunction parseYear(d, string, i) {\n\t  var n = numberRe.exec(string.slice(i, i + 2));\n\t  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;\n\t}\n\t\n\tfunction parseZone(d, string, i) {\n\t  var n = /^(Z)|([+-]\\d\\d)(?:\\:?(\\d\\d))?/.exec(string.slice(i, i + 6));\n\t  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || \"00\")), i + n[0].length) : -1;\n\t}\n\t\n\tfunction parseMonthNumber(d, string, i) {\n\t  var n = numberRe.exec(string.slice(i, i + 2));\n\t  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n\t}\n\t\n\tfunction parseDayOfMonth(d, string, i) {\n\t  var n = numberRe.exec(string.slice(i, i + 2));\n\t  return n ? (d.d = +n[0], i + n[0].length) : -1;\n\t}\n\t\n\tfunction parseDayOfYear(d, string, i) {\n\t  var n = numberRe.exec(string.slice(i, i + 3));\n\t  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n\t}\n\t\n\tfunction parseHour24(d, string, i) {\n\t  var n = numberRe.exec(string.slice(i, i + 2));\n\t  return n ? (d.H = +n[0], i + n[0].length) : -1;\n\t}\n\t\n\tfunction parseMinutes(d, string, i) {\n\t  var n = numberRe.exec(string.slice(i, i + 2));\n\t  return n ? (d.M = +n[0], i + n[0].length) : -1;\n\t}\n\t\n\tfunction parseSeconds(d, string, i) {\n\t  var n = numberRe.exec(string.slice(i, i + 2));\n\t  return n ? (d.S = +n[0], i + n[0].length) : -1;\n\t}\n\t\n\tfunction parseMilliseconds(d, string, i) {\n\t  var n = numberRe.exec(string.slice(i, i + 3));\n\t  return n ? (d.L = +n[0], i + n[0].length) : -1;\n\t}\n\t\n\tfunction parseLiteralPercent(d, string, i) {\n\t  var n = percentRe.exec(string.slice(i, i + 1));\n\t  return n ? i + n[0].length : -1;\n\t}\n\t\n\tfunction formatDayOfMonth(d, p) {\n\t  return pad(d.getDate(), p, 2);\n\t}\n\t\n\tfunction formatHour24(d, p) {\n\t  return pad(d.getHours(), p, 2);\n\t}\n\t\n\tfunction formatHour12(d, p) {\n\t  return pad(d.getHours() % 12 || 12, p, 2);\n\t}\n\t\n\tfunction formatDayOfYear(d, p) {\n\t  return pad(1 + day.count(year(d), d), p, 3);\n\t}\n\t\n\tfunction formatMilliseconds(d, p) {\n\t  return pad(d.getMilliseconds(), p, 3);\n\t}\n\t\n\tfunction formatMonthNumber(d, p) {\n\t  return pad(d.getMonth() + 1, p, 2);\n\t}\n\t\n\tfunction formatMinutes(d, p) {\n\t  return pad(d.getMinutes(), p, 2);\n\t}\n\t\n\tfunction formatSeconds(d, p) {\n\t  return pad(d.getSeconds(), p, 2);\n\t}\n\t\n\tfunction formatWeekNumberSunday(d, p) {\n\t  return pad(sunday.count(year(d), d), p, 2);\n\t}\n\t\n\tfunction formatWeekdayNumber(d) {\n\t  return d.getDay();\n\t}\n\t\n\tfunction formatWeekNumberMonday(d, p) {\n\t  return pad(monday.count(year(d), d), p, 2);\n\t}\n\t\n\tfunction formatYear(d, p) {\n\t  return pad(d.getFullYear() % 100, p, 2);\n\t}\n\t\n\tfunction formatFullYear(d, p) {\n\t  return pad(d.getFullYear() % 10000, p, 4);\n\t}\n\t\n\tfunction formatZone(d) {\n\t  var z = d.getTimezoneOffset();\n\t  return (z > 0 ? \"-\" : (z *= -1, \"+\"))\n\t      + pad(z / 60 | 0, \"0\", 2)\n\t      + pad(z % 60, \"0\", 2);\n\t}\n\t\n\tfunction formatUTCDayOfMonth(d, p) {\n\t  return pad(d.getUTCDate(), p, 2);\n\t}\n\t\n\tfunction formatUTCHour24(d, p) {\n\t  return pad(d.getUTCHours(), p, 2);\n\t}\n\t\n\tfunction formatUTCHour12(d, p) {\n\t  return pad(d.getUTCHours() % 12 || 12, p, 2);\n\t}\n\t\n\tfunction formatUTCDayOfYear(d, p) {\n\t  return pad(1 + utcDay.count(utcYear(d), d), p, 3);\n\t}\n\t\n\tfunction formatUTCMilliseconds(d, p) {\n\t  return pad(d.getUTCMilliseconds(), p, 3);\n\t}\n\t\n\tfunction formatUTCMonthNumber(d, p) {\n\t  return pad(d.getUTCMonth() + 1, p, 2);\n\t}\n\t\n\tfunction formatUTCMinutes(d, p) {\n\t  return pad(d.getUTCMinutes(), p, 2);\n\t}\n\t\n\tfunction formatUTCSeconds(d, p) {\n\t  return pad(d.getUTCSeconds(), p, 2);\n\t}\n\t\n\tfunction formatUTCWeekNumberSunday(d, p) {\n\t  return pad(utcSunday.count(utcYear(d), d), p, 2);\n\t}\n\t\n\tfunction formatUTCWeekdayNumber(d) {\n\t  return d.getUTCDay();\n\t}\n\t\n\tfunction formatUTCWeekNumberMonday(d, p) {\n\t  return pad(utcMonday.count(utcYear(d), d), p, 2);\n\t}\n\t\n\tfunction formatUTCYear(d, p) {\n\t  return pad(d.getUTCFullYear() % 100, p, 2);\n\t}\n\t\n\tfunction formatUTCFullYear(d, p) {\n\t  return pad(d.getUTCFullYear() % 10000, p, 4);\n\t}\n\t\n\tfunction formatUTCZone() {\n\t  return \"+0000\";\n\t}\n\t\n\tfunction formatLiteralPercent() {\n\t  return \"%\";\n\t}\n\t\n\tvar locale$2;\n\t\n\t\n\t\n\t\n\t\n\tdefaultLocale$1({\n\t  dateTime: \"%x, %X\",\n\t  date: \"%-m/%-d/%Y\",\n\t  time: \"%-I:%M:%S %p\",\n\t  periods: [\"AM\", \"PM\"],\n\t  days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n\t  shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n\t  months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n\t  shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n\t});\n\t\n\tfunction defaultLocale$1(definition) {\n\t  locale$2 = formatLocale$1(definition);\n\t  exports.timeFormat = locale$2.format;\n\t  exports.timeParse = locale$2.parse;\n\t  exports.utcFormat = locale$2.utcFormat;\n\t  exports.utcParse = locale$2.utcParse;\n\t  return locale$2;\n\t}\n\t\n\tvar isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\n\t\n\tfunction formatIsoNative(date) {\n\t  return date.toISOString();\n\t}\n\t\n\tvar formatIso = Date.prototype.toISOString\n\t    ? formatIsoNative\n\t    : exports.utcFormat(isoSpecifier);\n\t\n\tfunction parseIsoNative(string) {\n\t  var date = new Date(string);\n\t  return isNaN(date) ? null : date;\n\t}\n\t\n\tvar parseIso = +new Date(\"2000-01-01T00:00:00.000Z\")\n\t    ? parseIsoNative\n\t    : exports.utcParse(isoSpecifier);\n\t\n\tvar array$2 = Array.prototype;\n\t\n\tvar map$3 = array$2.map;\n\tvar slice$3 = array$2.slice;\n\t\n\tvar implicit = {name: \"implicit\"};\n\t\n\tfunction ordinal(range) {\n\t  var index = map$1(),\n\t      domain = [],\n\t      unknown = implicit;\n\t\n\t  range = range == null ? [] : slice$3.call(range);\n\t\n\t  function scale(d) {\n\t    var key = d + \"\", i = index.get(key);\n\t    if (!i) {\n\t      if (unknown !== implicit) return unknown;\n\t      index.set(key, i = domain.push(d));\n\t    }\n\t    return range[(i - 1) % range.length];\n\t  }\n\t\n\t  scale.domain = function(_) {\n\t    if (!arguments.length) return domain.slice();\n\t    domain = [], index = map$1();\n\t    var i = -1, n = _.length, d, key;\n\t    while (++i < n) if (!index.has(key = (d = _[i]) + \"\")) index.set(key, domain.push(d));\n\t    return scale;\n\t  };\n\t\n\t  scale.range = function(_) {\n\t    return arguments.length ? (range = slice$3.call(_), scale) : range.slice();\n\t  };\n\t\n\t  scale.unknown = function(_) {\n\t    return arguments.length ? (unknown = _, scale) : unknown;\n\t  };\n\t\n\t  scale.copy = function() {\n\t    return ordinal()\n\t        .domain(domain)\n\t        .range(range)\n\t        .unknown(unknown);\n\t  };\n\t\n\t  return scale;\n\t}\n\t\n\tfunction band() {\n\t  var scale = ordinal().unknown(undefined),\n\t      domain = scale.domain,\n\t      ordinalRange = scale.range,\n\t      range$$1 = [0, 1],\n\t      step,\n\t      bandwidth,\n\t      round = false,\n\t      paddingInner = 0,\n\t      paddingOuter = 0,\n\t      align = 0.5;\n\t\n\t  delete scale.unknown;\n\t\n\t  function rescale() {\n\t    var n = domain().length,\n\t        reverse = range$$1[1] < range$$1[0],\n\t        start = range$$1[reverse - 0],\n\t        stop = range$$1[1 - reverse];\n\t    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);\n\t    if (round) step = Math.floor(step);\n\t    start += (stop - start - step * (n - paddingInner)) * align;\n\t    bandwidth = step * (1 - paddingInner);\n\t    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);\n\t    var values = range(n).map(function(i) { return start + step * i; });\n\t    return ordinalRange(reverse ? values.reverse() : values);\n\t  }\n\t\n\t  scale.domain = function(_) {\n\t    return arguments.length ? (domain(_), rescale()) : domain();\n\t  };\n\t\n\t  scale.range = function(_) {\n\t    return arguments.length ? (range$$1 = [+_[0], +_[1]], rescale()) : range$$1.slice();\n\t  };\n\t\n\t  scale.rangeRound = function(_) {\n\t    return range$$1 = [+_[0], +_[1]], round = true, rescale();\n\t  };\n\t\n\t  scale.bandwidth = function() {\n\t    return bandwidth;\n\t  };\n\t\n\t  scale.step = function() {\n\t    return step;\n\t  };\n\t\n\t  scale.round = function(_) {\n\t    return arguments.length ? (round = !!_, rescale()) : round;\n\t  };\n\t\n\t  scale.padding = function(_) {\n\t    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;\n\t  };\n\t\n\t  scale.paddingInner = function(_) {\n\t    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;\n\t  };\n\t\n\t  scale.paddingOuter = function(_) {\n\t    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;\n\t  };\n\t\n\t  scale.align = function(_) {\n\t    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;\n\t  };\n\t\n\t  scale.copy = function() {\n\t    return band()\n\t        .domain(domain())\n\t        .range(range$$1)\n\t        .round(round)\n\t        .paddingInner(paddingInner)\n\t        .paddingOuter(paddingOuter)\n\t        .align(align);\n\t  };\n\t\n\t  return rescale();\n\t}\n\t\n\tfunction pointish(scale) {\n\t  var copy = scale.copy;\n\t\n\t  scale.padding = scale.paddingOuter;\n\t  delete scale.paddingInner;\n\t  delete scale.paddingOuter;\n\t\n\t  scale.copy = function() {\n\t    return pointish(copy());\n\t  };\n\t\n\t  return scale;\n\t}\n\t\n\tfunction point$4() {\n\t  return pointish(band().paddingInner(1));\n\t}\n\t\n\tvar constant$4 = function(x) {\n\t  return function() {\n\t    return x;\n\t  };\n\t};\n\t\n\tvar number$1 = function(x) {\n\t  return +x;\n\t};\n\t\n\tvar unit = [0, 1];\n\t\n\tfunction deinterpolateLinear(a, b) {\n\t  return (b -= (a = +a))\n\t      ? function(x) { return (x - a) / b; }\n\t      : constant$4(b);\n\t}\n\t\n\tfunction deinterpolateClamp(deinterpolate) {\n\t  return function(a, b) {\n\t    var d = deinterpolate(a = +a, b = +b);\n\t    return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };\n\t  };\n\t}\n\t\n\tfunction reinterpolateClamp(reinterpolate) {\n\t  return function(a, b) {\n\t    var r = reinterpolate(a = +a, b = +b);\n\t    return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };\n\t  };\n\t}\n\t\n\tfunction bimap(domain, range$$1, deinterpolate, reinterpolate) {\n\t  var d0 = domain[0], d1 = domain[1], r0 = range$$1[0], r1 = range$$1[1];\n\t  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);\n\t  else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);\n\t  return function(x) { return r0(d0(x)); };\n\t}\n\t\n\tfunction polymap(domain, range$$1, deinterpolate, reinterpolate) {\n\t  var j = Math.min(domain.length, range$$1.length) - 1,\n\t      d = new Array(j),\n\t      r = new Array(j),\n\t      i = -1;\n\t\n\t  // Reverse descending domains.\n\t  if (domain[j] < domain[0]) {\n\t    domain = domain.slice().reverse();\n\t    range$$1 = range$$1.slice().reverse();\n\t  }\n\t\n\t  while (++i < j) {\n\t    d[i] = deinterpolate(domain[i], domain[i + 1]);\n\t    r[i] = reinterpolate(range$$1[i], range$$1[i + 1]);\n\t  }\n\t\n\t  return function(x) {\n\t    var i = bisectRight(domain, x, 1, j) - 1;\n\t    return r[i](d[i](x));\n\t  };\n\t}\n\t\n\tfunction copy(source, target) {\n\t  return target\n\t      .domain(source.domain())\n\t      .range(source.range())\n\t      .interpolate(source.interpolate())\n\t      .clamp(source.clamp());\n\t}\n\t\n\t// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].\n\t// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].\n\tfunction continuous(deinterpolate, reinterpolate) {\n\t  var domain = unit,\n\t      range$$1 = unit,\n\t      interpolate$$1 = interpolate,\n\t      clamp = false,\n\t      piecewise,\n\t      output,\n\t      input;\n\t\n\t  function rescale() {\n\t    piecewise = Math.min(domain.length, range$$1.length) > 2 ? polymap : bimap;\n\t    output = input = null;\n\t    return scale;\n\t  }\n\t\n\t  function scale(x) {\n\t    return (output || (output = piecewise(domain, range$$1, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate$$1)))(+x);\n\t  }\n\t\n\t  scale.invert = function(y) {\n\t    return (input || (input = piecewise(range$$1, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);\n\t  };\n\t\n\t  scale.domain = function(_) {\n\t    return arguments.length ? (domain = map$3.call(_, number$1), rescale()) : domain.slice();\n\t  };\n\t\n\t  scale.range = function(_) {\n\t    return arguments.length ? (range$$1 = slice$3.call(_), rescale()) : range$$1.slice();\n\t  };\n\t\n\t  scale.rangeRound = function(_) {\n\t    return range$$1 = slice$3.call(_), interpolate$$1 = interpolateRound, rescale();\n\t  };\n\t\n\t  scale.clamp = function(_) {\n\t    return arguments.length ? (clamp = !!_, rescale()) : clamp;\n\t  };\n\t\n\t  scale.interpolate = function(_) {\n\t    return arguments.length ? (interpolate$$1 = _, rescale()) : interpolate$$1;\n\t  };\n\t\n\t  return rescale();\n\t}\n\t\n\tvar tickFormat = function(domain, count, specifier) {\n\t  var start = domain[0],\n\t      stop = domain[domain.length - 1],\n\t      step = tickStep(start, stop, count == null ? 10 : count),\n\t      precision;\n\t  specifier = formatSpecifier(specifier == null ? \",f\" : specifier);\n\t  switch (specifier.type) {\n\t    case \"s\": {\n\t      var value = Math.max(Math.abs(start), Math.abs(stop));\n\t      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;\n\t      return exports.formatPrefix(specifier, value);\n\t    }\n\t    case \"\":\n\t    case \"e\":\n\t    case \"g\":\n\t    case \"p\":\n\t    case \"r\": {\n\t      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === \"e\");\n\t      break;\n\t    }\n\t    case \"f\":\n\t    case \"%\": {\n\t      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === \"%\") * 2;\n\t      break;\n\t    }\n\t  }\n\t  return exports.format(specifier);\n\t};\n\t\n\tfunction linearish(scale) {\n\t  var domain = scale.domain;\n\t\n\t  scale.ticks = function(count) {\n\t    var d = domain();\n\t    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);\n\t  };\n\t\n\t  scale.tickFormat = function(count, specifier) {\n\t    return tickFormat(domain(), count, specifier);\n\t  };\n\t\n\t  scale.nice = function(count) {\n\t    var d = domain(),\n\t        i = d.length - 1,\n\t        n = count == null ? 10 : count,\n\t        start = d[0],\n\t        stop = d[i],\n\t        step = tickStep(start, stop, n);\n\t\n\t    if (step) {\n\t      step = tickStep(Math.floor(start / step) * step, Math.ceil(stop / step) * step, n);\n\t      d[0] = Math.floor(start / step) * step;\n\t      d[i] = Math.ceil(stop / step) * step;\n\t      domain(d);\n\t    }\n\t\n\t    return scale;\n\t  };\n\t\n\t  return scale;\n\t}\n\t\n\tfunction linear$2() {\n\t  var scale = continuous(deinterpolateLinear, interpolateNumber);\n\t\n\t  scale.copy = function() {\n\t    return copy(scale, linear$2());\n\t  };\n\t\n\t  return linearish(scale);\n\t}\n\t\n\tfunction identity$4() {\n\t  var domain = [0, 1];\n\t\n\t  function scale(x) {\n\t    return +x;\n\t  }\n\t\n\t  scale.invert = scale;\n\t\n\t  scale.domain = scale.range = function(_) {\n\t    return arguments.length ? (domain = map$3.call(_, number$1), scale) : domain.slice();\n\t  };\n\t\n\t  scale.copy = function() {\n\t    return identity$4().domain(domain);\n\t  };\n\t\n\t  return linearish(scale);\n\t}\n\t\n\tvar nice = function(domain, interval) {\n\t  domain = domain.slice();\n\t\n\t  var i0 = 0,\n\t      i1 = domain.length - 1,\n\t      x0 = domain[i0],\n\t      x1 = domain[i1],\n\t      t;\n\t\n\t  if (x1 < x0) {\n\t    t = i0, i0 = i1, i1 = t;\n\t    t = x0, x0 = x1, x1 = t;\n\t  }\n\t\n\t  domain[i0] = interval.floor(x0);\n\t  domain[i1] = interval.ceil(x1);\n\t  return domain;\n\t};\n\t\n\tfunction deinterpolate(a, b) {\n\t  return (b = Math.log(b / a))\n\t      ? function(x) { return Math.log(x / a) / b; }\n\t      : constant$4(b);\n\t}\n\t\n\tfunction reinterpolate(a, b) {\n\t  return a < 0\n\t      ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }\n\t      : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };\n\t}\n\t\n\tfunction pow10(x) {\n\t  return isFinite(x) ? +(\"1e\" + x) : x < 0 ? 0 : x;\n\t}\n\t\n\tfunction powp(base) {\n\t  return base === 10 ? pow10\n\t      : base === Math.E ? Math.exp\n\t      : function(x) { return Math.pow(base, x); };\n\t}\n\t\n\tfunction logp(base) {\n\t  return base === Math.E ? Math.log\n\t      : base === 10 && Math.log10\n\t      || base === 2 && Math.log2\n\t      || (base = Math.log(base), function(x) { return Math.log(x) / base; });\n\t}\n\t\n\tfunction reflect(f) {\n\t  return function(x) {\n\t    return -f(-x);\n\t  };\n\t}\n\t\n\tfunction log() {\n\t  var scale = continuous(deinterpolate, reinterpolate).domain([1, 10]),\n\t      domain = scale.domain,\n\t      base = 10,\n\t      logs = logp(10),\n\t      pows = powp(10);\n\t\n\t  function rescale() {\n\t    logs = logp(base), pows = powp(base);\n\t    if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);\n\t    return scale;\n\t  }\n\t\n\t  scale.base = function(_) {\n\t    return arguments.length ? (base = +_, rescale()) : base;\n\t  };\n\t\n\t  scale.domain = function(_) {\n\t    return arguments.length ? (domain(_), rescale()) : domain();\n\t  };\n\t\n\t  scale.ticks = function(count) {\n\t    var d = domain(),\n\t        u = d[0],\n\t        v = d[d.length - 1],\n\t        r;\n\t\n\t    if (r = v < u) i = u, u = v, v = i;\n\t\n\t    var i = logs(u),\n\t        j = logs(v),\n\t        p,\n\t        k,\n\t        t,\n\t        n = count == null ? 10 : +count,\n\t        z = [];\n\t\n\t    if (!(base % 1) && j - i < n) {\n\t      i = Math.round(i) - 1, j = Math.round(j) + 1;\n\t      if (u > 0) for (; i < j; ++i) {\n\t        for (k = 1, p = pows(i); k < base; ++k) {\n\t          t = p * k;\n\t          if (t < u) continue;\n\t          if (t > v) break;\n\t          z.push(t);\n\t        }\n\t      } else for (; i < j; ++i) {\n\t        for (k = base - 1, p = pows(i); k >= 1; --k) {\n\t          t = p * k;\n\t          if (t < u) continue;\n\t          if (t > v) break;\n\t          z.push(t);\n\t        }\n\t      }\n\t    } else {\n\t      z = ticks(i, j, Math.min(j - i, n)).map(pows);\n\t    }\n\t\n\t    return r ? z.reverse() : z;\n\t  };\n\t\n\t  scale.tickFormat = function(count, specifier) {\n\t    if (specifier == null) specifier = base === 10 ? \".0e\" : \",\";\n\t    if (typeof specifier !== \"function\") specifier = exports.format(specifier);\n\t    if (count === Infinity) return specifier;\n\t    if (count == null) count = 10;\n\t    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?\n\t    return function(d) {\n\t      var i = d / pows(Math.round(logs(d)));\n\t      if (i * base < base - 0.5) i *= base;\n\t      return i <= k ? specifier(d) : \"\";\n\t    };\n\t  };\n\t\n\t  scale.nice = function() {\n\t    return domain(nice(domain(), {\n\t      floor: function(x) { return pows(Math.floor(logs(x))); },\n\t      ceil: function(x) { return pows(Math.ceil(logs(x))); }\n\t    }));\n\t  };\n\t\n\t  scale.copy = function() {\n\t    return copy(scale, log().base(base));\n\t  };\n\t\n\t  return scale;\n\t}\n\t\n\tfunction raise(x, exponent) {\n\t  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);\n\t}\n\t\n\tfunction pow() {\n\t  var exponent = 1,\n\t      scale = continuous(deinterpolate, reinterpolate),\n\t      domain = scale.domain;\n\t\n\t  function deinterpolate(a, b) {\n\t    return (b = raise(b, exponent) - (a = raise(a, exponent)))\n\t        ? function(x) { return (raise(x, exponent) - a) / b; }\n\t        : constant$4(b);\n\t  }\n\t\n\t  function reinterpolate(a, b) {\n\t    b = raise(b, exponent) - (a = raise(a, exponent));\n\t    return function(t) { return raise(a + b * t, 1 / exponent); };\n\t  }\n\t\n\t  scale.exponent = function(_) {\n\t    return arguments.length ? (exponent = +_, domain(domain())) : exponent;\n\t  };\n\t\n\t  scale.copy = function() {\n\t    return copy(scale, pow().exponent(exponent));\n\t  };\n\t\n\t  return linearish(scale);\n\t}\n\t\n\tfunction sqrt() {\n\t  return pow().exponent(0.5);\n\t}\n\t\n\tfunction quantile$$1() {\n\t  var domain = [],\n\t      range$$1 = [],\n\t      thresholds = [];\n\t\n\t  function rescale() {\n\t    var i = 0, n = Math.max(1, range$$1.length);\n\t    thresholds = new Array(n - 1);\n\t    while (++i < n) thresholds[i - 1] = threshold(domain, i / n);\n\t    return scale;\n\t  }\n\t\n\t  function scale(x) {\n\t    if (!isNaN(x = +x)) return range$$1[bisectRight(thresholds, x)];\n\t  }\n\t\n\t  scale.invertExtent = function(y) {\n\t    var i = range$$1.indexOf(y);\n\t    return i < 0 ? [NaN, NaN] : [\n\t      i > 0 ? thresholds[i - 1] : domain[0],\n\t      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]\n\t    ];\n\t  };\n\t\n\t  scale.domain = function(_) {\n\t    if (!arguments.length) return domain.slice();\n\t    domain = [];\n\t    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);\n\t    domain.sort(ascending);\n\t    return rescale();\n\t  };\n\t\n\t  scale.range = function(_) {\n\t    return arguments.length ? (range$$1 = slice$3.call(_), rescale()) : range$$1.slice();\n\t  };\n\t\n\t  scale.quantiles = function() {\n\t    return thresholds.slice();\n\t  };\n\t\n\t  scale.copy = function() {\n\t    return quantile$$1()\n\t        .domain(domain)\n\t        .range(range$$1);\n\t  };\n\t\n\t  return scale;\n\t}\n\t\n\tfunction quantize$1() {\n\t  var x0 = 0,\n\t      x1 = 1,\n\t      n = 1,\n\t      domain = [0.5],\n\t      range$$1 = [0, 1];\n\t\n\t  function scale(x) {\n\t    if (x <= x) return range$$1[bisectRight(domain, x, 0, n)];\n\t  }\n\t\n\t  function rescale() {\n\t    var i = -1;\n\t    domain = new Array(n);\n\t    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);\n\t    return scale;\n\t  }\n\t\n\t  scale.domain = function(_) {\n\t    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];\n\t  };\n\t\n\t  scale.range = function(_) {\n\t    return arguments.length ? (n = (range$$1 = slice$3.call(_)).length - 1, rescale()) : range$$1.slice();\n\t  };\n\t\n\t  scale.invertExtent = function(y) {\n\t    var i = range$$1.indexOf(y);\n\t    return i < 0 ? [NaN, NaN]\n\t        : i < 1 ? [x0, domain[0]]\n\t        : i >= n ? [domain[n - 1], x1]\n\t        : [domain[i - 1], domain[i]];\n\t  };\n\t\n\t  scale.copy = function() {\n\t    return quantize$1()\n\t        .domain([x0, x1])\n\t        .range(range$$1);\n\t  };\n\t\n\t  return linearish(scale);\n\t}\n\t\n\tfunction threshold$1() {\n\t  var domain = [0.5],\n\t      range$$1 = [0, 1],\n\t      n = 1;\n\t\n\t  function scale(x) {\n\t    if (x <= x) return range$$1[bisectRight(domain, x, 0, n)];\n\t  }\n\t\n\t  scale.domain = function(_) {\n\t    return arguments.length ? (domain = slice$3.call(_), n = Math.min(domain.length, range$$1.length - 1), scale) : domain.slice();\n\t  };\n\t\n\t  scale.range = function(_) {\n\t    return arguments.length ? (range$$1 = slice$3.call(_), n = Math.min(domain.length, range$$1.length - 1), scale) : range$$1.slice();\n\t  };\n\t\n\t  scale.invertExtent = function(y) {\n\t    var i = range$$1.indexOf(y);\n\t    return [domain[i - 1], domain[i]];\n\t  };\n\t\n\t  scale.copy = function() {\n\t    return threshold$1()\n\t        .domain(domain)\n\t        .range(range$$1);\n\t  };\n\t\n\t  return scale;\n\t}\n\t\n\tvar durationSecond$1 = 1000;\n\tvar durationMinute$1 = durationSecond$1 * 60;\n\tvar durationHour$1 = durationMinute$1 * 60;\n\tvar durationDay$1 = durationHour$1 * 24;\n\tvar durationWeek$1 = durationDay$1 * 7;\n\tvar durationMonth = durationDay$1 * 30;\n\tvar durationYear = durationDay$1 * 365;\n\t\n\tfunction date$1(t) {\n\t  return new Date(t);\n\t}\n\t\n\tfunction number$2(t) {\n\t  return t instanceof Date ? +t : +new Date(+t);\n\t}\n\t\n\tfunction calendar(year$$1, month$$1, week, day$$1, hour$$1, minute$$1, second$$1, millisecond$$1, format) {\n\t  var scale = continuous(deinterpolateLinear, interpolateNumber),\n\t      invert = scale.invert,\n\t      domain = scale.domain;\n\t\n\t  var formatMillisecond = format(\".%L\"),\n\t      formatSecond = format(\":%S\"),\n\t      formatMinute = format(\"%I:%M\"),\n\t      formatHour = format(\"%I %p\"),\n\t      formatDay = format(\"%a %d\"),\n\t      formatWeek = format(\"%b %d\"),\n\t      formatMonth = format(\"%B\"),\n\t      formatYear = format(\"%Y\");\n\t\n\t  var tickIntervals = [\n\t    [second$$1,  1,      durationSecond$1],\n\t    [second$$1,  5,  5 * durationSecond$1],\n\t    [second$$1, 15, 15 * durationSecond$1],\n\t    [second$$1, 30, 30 * durationSecond$1],\n\t    [minute$$1,  1,      durationMinute$1],\n\t    [minute$$1,  5,  5 * durationMinute$1],\n\t    [minute$$1, 15, 15 * durationMinute$1],\n\t    [minute$$1, 30, 30 * durationMinute$1],\n\t    [  hour$$1,  1,      durationHour$1  ],\n\t    [  hour$$1,  3,  3 * durationHour$1  ],\n\t    [  hour$$1,  6,  6 * durationHour$1  ],\n\t    [  hour$$1, 12, 12 * durationHour$1  ],\n\t    [   day$$1,  1,      durationDay$1   ],\n\t    [   day$$1,  2,  2 * durationDay$1   ],\n\t    [  week,  1,      durationWeek$1  ],\n\t    [ month$$1,  1,      durationMonth ],\n\t    [ month$$1,  3,  3 * durationMonth ],\n\t    [  year$$1,  1,      durationYear  ]\n\t  ];\n\t\n\t  function tickFormat(date) {\n\t    return (second$$1(date) < date ? formatMillisecond\n\t        : minute$$1(date) < date ? formatSecond\n\t        : hour$$1(date) < date ? formatMinute\n\t        : day$$1(date) < date ? formatHour\n\t        : month$$1(date) < date ? (week(date) < date ? formatDay : formatWeek)\n\t        : year$$1(date) < date ? formatMonth\n\t        : formatYear)(date);\n\t  }\n\t\n\t  function tickInterval(interval, start, stop, step) {\n\t    if (interval == null) interval = 10;\n\t\n\t    // If a desired tick count is specified, pick a reasonable tick interval\n\t    // based on the extent of the domain and a rough estimate of tick size.\n\t    // Otherwise, assume interval is already a time interval and use it.\n\t    if (typeof interval === \"number\") {\n\t      var target = Math.abs(stop - start) / interval,\n\t          i = bisector(function(i) { return i[2]; }).right(tickIntervals, target);\n\t      if (i === tickIntervals.length) {\n\t        step = tickStep(start / durationYear, stop / durationYear, interval);\n\t        interval = year$$1;\n\t      } else if (i) {\n\t        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];\n\t        step = i[1];\n\t        interval = i[0];\n\t      } else {\n\t        step = tickStep(start, stop, interval);\n\t        interval = millisecond$$1;\n\t      }\n\t    }\n\t\n\t    return step == null ? interval : interval.every(step);\n\t  }\n\t\n\t  scale.invert = function(y) {\n\t    return new Date(invert(y));\n\t  };\n\t\n\t  scale.domain = function(_) {\n\t    return arguments.length ? domain(map$3.call(_, number$2)) : domain().map(date$1);\n\t  };\n\t\n\t  scale.ticks = function(interval, step) {\n\t    var d = domain(),\n\t        t0 = d[0],\n\t        t1 = d[d.length - 1],\n\t        r = t1 < t0,\n\t        t;\n\t    if (r) t = t0, t0 = t1, t1 = t;\n\t    t = tickInterval(interval, t0, t1, step);\n\t    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop\n\t    return r ? t.reverse() : t;\n\t  };\n\t\n\t  scale.tickFormat = function(count, specifier) {\n\t    return specifier == null ? tickFormat : format(specifier);\n\t  };\n\t\n\t  scale.nice = function(interval, step) {\n\t    var d = domain();\n\t    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))\n\t        ? domain(nice(d, interval))\n\t        : scale;\n\t  };\n\t\n\t  scale.copy = function() {\n\t    return copy(scale, calendar(year$$1, month$$1, week, day$$1, hour$$1, minute$$1, second$$1, millisecond$$1, format));\n\t  };\n\t\n\t  return scale;\n\t}\n\t\n\tvar time = function() {\n\t  return calendar(year, month, sunday, day, hour, minute, second, millisecond, exports.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);\n\t};\n\t\n\tvar utcTime = function() {\n\t  return calendar(utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, millisecond, exports.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);\n\t};\n\t\n\tvar colors = function(s) {\n\t  return s.match(/.{6}/g).map(function(x) {\n\t    return \"#\" + x;\n\t  });\n\t};\n\t\n\tvar category10 = colors(\"1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf\");\n\t\n\tvar category20b = colors(\"393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6\");\n\t\n\tvar category20c = colors(\"3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9\");\n\t\n\tvar category20 = colors(\"1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5\");\n\t\n\tvar cubehelix$3 = cubehelixLong(cubehelix(300, 0.5, 0.0), cubehelix(-240, 0.5, 1.0));\n\t\n\tvar warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));\n\t\n\tvar cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));\n\t\n\tvar rainbow = cubehelix();\n\t\n\tvar rainbow$1 = function(t) {\n\t  if (t < 0 || t > 1) t -= Math.floor(t);\n\t  var ts = Math.abs(t - 0.5);\n\t  rainbow.h = 360 * t - 100;\n\t  rainbow.s = 1.5 - 1.5 * ts;\n\t  rainbow.l = 0.8 - 0.9 * ts;\n\t  return rainbow + \"\";\n\t};\n\t\n\tfunction ramp(range) {\n\t  var n = range.length;\n\t  return function(t) {\n\t    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];\n\t  };\n\t}\n\t\n\tvar viridis = ramp(colors(\"44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725\"));\n\t\n\tvar magma = ramp(colors(\"00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf\"));\n\t\n\tvar inferno = ramp(colors(\"00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4\"));\n\t\n\tvar plasma = ramp(colors(\"0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921\"));\n\t\n\tfunction sequential(interpolator) {\n\t  var x0 = 0,\n\t      x1 = 1,\n\t      clamp = false;\n\t\n\t  function scale(x) {\n\t    var t = (x - x0) / (x1 - x0);\n\t    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);\n\t  }\n\t\n\t  scale.domain = function(_) {\n\t    return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];\n\t  };\n\t\n\t  scale.clamp = function(_) {\n\t    return arguments.length ? (clamp = !!_, scale) : clamp;\n\t  };\n\t\n\t  scale.interpolator = function(_) {\n\t    return arguments.length ? (interpolator = _, scale) : interpolator;\n\t  };\n\t\n\t  scale.copy = function() {\n\t    return sequential(interpolator).domain([x0, x1]).clamp(clamp);\n\t  };\n\t\n\t  return linearish(scale);\n\t}\n\t\n\tvar xhtml = \"http://www.w3.org/1999/xhtml\";\n\t\n\tvar namespaces = {\n\t  svg: \"http://www.w3.org/2000/svg\",\n\t  xhtml: xhtml,\n\t  xlink: \"http://www.w3.org/1999/xlink\",\n\t  xml: \"http://www.w3.org/XML/1998/namespace\",\n\t  xmlns: \"http://www.w3.org/2000/xmlns/\"\n\t};\n\t\n\tvar namespace = function(name) {\n\t  var prefix = name += \"\", i = prefix.indexOf(\":\");\n\t  if (i >= 0 && (prefix = name.slice(0, i)) !== \"xmlns\") name = name.slice(i + 1);\n\t  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;\n\t};\n\t\n\tfunction creatorInherit(name) {\n\t  return function() {\n\t    var document = this.ownerDocument,\n\t        uri = this.namespaceURI;\n\t    return uri === xhtml && document.documentElement.namespaceURI === xhtml\n\t        ? document.createElement(name)\n\t        : document.createElementNS(uri, name);\n\t  };\n\t}\n\t\n\tfunction creatorFixed(fullname) {\n\t  return function() {\n\t    return this.ownerDocument.createElementNS(fullname.space, fullname.local);\n\t  };\n\t}\n\t\n\tvar creator = function(name) {\n\t  var fullname = namespace(name);\n\t  return (fullname.local\n\t      ? creatorFixed\n\t      : creatorInherit)(fullname);\n\t};\n\t\n\tvar nextId = 0;\n\t\n\tfunction local() {\n\t  return new Local;\n\t}\n\t\n\tfunction Local() {\n\t  this._ = \"@\" + (++nextId).toString(36);\n\t}\n\t\n\tLocal.prototype = local.prototype = {\n\t  constructor: Local,\n\t  get: function(node) {\n\t    var id = this._;\n\t    while (!(id in node)) if (!(node = node.parentNode)) return;\n\t    return node[id];\n\t  },\n\t  set: function(node, value) {\n\t    return node[this._] = value;\n\t  },\n\t  remove: function(node) {\n\t    return this._ in node && delete node[this._];\n\t  },\n\t  toString: function() {\n\t    return this._;\n\t  }\n\t};\n\t\n\tvar matcher = function(selector) {\n\t  return function() {\n\t    return this.matches(selector);\n\t  };\n\t};\n\t\n\tif (typeof document !== \"undefined\") {\n\t  var element = document.documentElement;\n\t  if (!element.matches) {\n\t    var vendorMatches = element.webkitMatchesSelector\n\t        || element.msMatchesSelector\n\t        || element.mozMatchesSelector\n\t        || element.oMatchesSelector;\n\t    matcher = function(selector) {\n\t      return function() {\n\t        return vendorMatches.call(this, selector);\n\t      };\n\t    };\n\t  }\n\t}\n\t\n\tvar matcher$1 = matcher;\n\t\n\tvar filterEvents = {};\n\t\n\texports.event = null;\n\t\n\tif (typeof document !== \"undefined\") {\n\t  var element$1 = document.documentElement;\n\t  if (!(\"onmouseenter\" in element$1)) {\n\t    filterEvents = {mouseenter: \"mouseover\", mouseleave: \"mouseout\"};\n\t  }\n\t}\n\t\n\tfunction filterContextListener(listener, index, group) {\n\t  listener = contextListener(listener, index, group);\n\t  return function(event) {\n\t    var related = event.relatedTarget;\n\t    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {\n\t      listener.call(this, event);\n\t    }\n\t  };\n\t}\n\t\n\tfunction contextListener(listener, index, group) {\n\t  return function(event1) {\n\t    var event0 = exports.event; // Events can be reentrant (e.g., focus).\n\t    exports.event = event1;\n\t    try {\n\t      listener.call(this, this.__data__, index, group);\n\t    } finally {\n\t      exports.event = event0;\n\t    }\n\t  };\n\t}\n\t\n\tfunction parseTypenames$1(typenames) {\n\t  return typenames.trim().split(/^|\\s+/).map(function(t) {\n\t    var name = \"\", i = t.indexOf(\".\");\n\t    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n\t    return {type: t, name: name};\n\t  });\n\t}\n\t\n\tfunction onRemove(typename) {\n\t  return function() {\n\t    var on = this.__on;\n\t    if (!on) return;\n\t    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {\n\t      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {\n\t        this.removeEventListener(o.type, o.listener, o.capture);\n\t      } else {\n\t        on[++i] = o;\n\t      }\n\t    }\n\t    if (++i) on.length = i;\n\t    else delete this.__on;\n\t  };\n\t}\n\t\n\tfunction onAdd(typename, value, capture) {\n\t  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;\n\t  return function(d, i, group) {\n\t    var on = this.__on, o, listener = wrap(value, i, group);\n\t    if (on) for (var j = 0, m = on.length; j < m; ++j) {\n\t      if ((o = on[j]).type === typename.type && o.name === typename.name) {\n\t        this.removeEventListener(o.type, o.listener, o.capture);\n\t        this.addEventListener(o.type, o.listener = listener, o.capture = capture);\n\t        o.value = value;\n\t        return;\n\t      }\n\t    }\n\t    this.addEventListener(typename.type, listener, capture);\n\t    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};\n\t    if (!on) this.__on = [o];\n\t    else on.push(o);\n\t  };\n\t}\n\t\n\tvar selection_on = function(typename, value, capture) {\n\t  var typenames = parseTypenames$1(typename + \"\"), i, n = typenames.length, t;\n\t\n\t  if (arguments.length < 2) {\n\t    var on = this.node().__on;\n\t    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {\n\t      for (i = 0, o = on[j]; i < n; ++i) {\n\t        if ((t = typenames[i]).type === o.type && t.name === o.name) {\n\t          return o.value;\n\t        }\n\t      }\n\t    }\n\t    return;\n\t  }\n\t\n\t  on = value ? onAdd : onRemove;\n\t  if (capture == null) capture = false;\n\t  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));\n\t  return this;\n\t};\n\t\n\tfunction customEvent(event1, listener, that, args) {\n\t  var event0 = exports.event;\n\t  event1.sourceEvent = exports.event;\n\t  exports.event = event1;\n\t  try {\n\t    return listener.apply(that, args);\n\t  } finally {\n\t    exports.event = event0;\n\t  }\n\t}\n\t\n\tvar sourceEvent = function() {\n\t  var current = exports.event, source;\n\t  while (source = current.sourceEvent) current = source;\n\t  return current;\n\t};\n\t\n\tvar point$5 = function(node, event) {\n\t  var svg = node.ownerSVGElement || node;\n\t\n\t  if (svg.createSVGPoint) {\n\t    var point = svg.createSVGPoint();\n\t    point.x = event.clientX, point.y = event.clientY;\n\t    point = point.matrixTransform(node.getScreenCTM().inverse());\n\t    return [point.x, point.y];\n\t  }\n\t\n\t  var rect = node.getBoundingClientRect();\n\t  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];\n\t};\n\t\n\tvar mouse = function(node) {\n\t  var event = sourceEvent();\n\t  if (event.changedTouches) event = event.changedTouches[0];\n\t  return point$5(node, event);\n\t};\n\t\n\tfunction none$2() {}\n\t\n\tvar selector = function(selector) {\n\t  return selector == null ? none$2 : function() {\n\t    return this.querySelector(selector);\n\t  };\n\t};\n\t\n\tvar selection_select = function(select) {\n\t  if (typeof select !== \"function\") select = selector(select);\n\t\n\t  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n\t    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {\n\t      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {\n\t        if (\"__data__\" in node) subnode.__data__ = node.__data__;\n\t        subgroup[i] = subnode;\n\t      }\n\t    }\n\t  }\n\t\n\t  return new Selection(subgroups, this._parents);\n\t};\n\t\n\tfunction empty() {\n\t  return [];\n\t}\n\t\n\tvar selectorAll = function(selector) {\n\t  return selector == null ? empty : function() {\n\t    return this.querySelectorAll(selector);\n\t  };\n\t};\n\t\n\tvar selection_selectAll = function(select) {\n\t  if (typeof select !== \"function\") select = selectorAll(select);\n\t\n\t  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {\n\t    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n\t      if (node = group[i]) {\n\t        subgroups.push(select.call(node, node.__data__, i, group));\n\t        parents.push(node);\n\t      }\n\t    }\n\t  }\n\t\n\t  return new Selection(subgroups, parents);\n\t};\n\t\n\tvar selection_filter = function(match) {\n\t  if (typeof match !== \"function\") match = matcher$1(match);\n\t\n\t  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n\t    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {\n\t      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {\n\t        subgroup.push(node);\n\t      }\n\t    }\n\t  }\n\t\n\t  return new Selection(subgroups, this._parents);\n\t};\n\t\n\tvar sparse = function(update) {\n\t  return new Array(update.length);\n\t};\n\t\n\tvar selection_enter = function() {\n\t  return new Selection(this._enter || this._groups.map(sparse), this._parents);\n\t};\n\t\n\tfunction EnterNode(parent, datum) {\n\t  this.ownerDocument = parent.ownerDocument;\n\t  this.namespaceURI = parent.namespaceURI;\n\t  this._next = null;\n\t  this._parent = parent;\n\t  this.__data__ = datum;\n\t}\n\t\n\tEnterNode.prototype = {\n\t  constructor: EnterNode,\n\t  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },\n\t  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },\n\t  querySelector: function(selector) { return this._parent.querySelector(selector); },\n\t  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }\n\t};\n\t\n\tvar constant$5 = function(x) {\n\t  return function() {\n\t    return x;\n\t  };\n\t};\n\t\n\tvar keyPrefix = \"$\"; // Protect against keys like “__proto__”.\n\t\n\tfunction bindIndex(parent, group, enter, update, exit, data) {\n\t  var i = 0,\n\t      node,\n\t      groupLength = group.length,\n\t      dataLength = data.length;\n\t\n\t  // Put any non-null nodes that fit into update.\n\t  // Put any null nodes into enter.\n\t  // Put any remaining data into enter.\n\t  for (; i < dataLength; ++i) {\n\t    if (node = group[i]) {\n\t      node.__data__ = data[i];\n\t      update[i] = node;\n\t    } else {\n\t      enter[i] = new EnterNode(parent, data[i]);\n\t    }\n\t  }\n\t\n\t  // Put any non-null nodes that don’t fit into exit.\n\t  for (; i < groupLength; ++i) {\n\t    if (node = group[i]) {\n\t      exit[i] = node;\n\t    }\n\t  }\n\t}\n\t\n\tfunction bindKey(parent, group, enter, update, exit, data, key) {\n\t  var i,\n\t      node,\n\t      nodeByKeyValue = {},\n\t      groupLength = group.length,\n\t      dataLength = data.length,\n\t      keyValues = new Array(groupLength),\n\t      keyValue;\n\t\n\t  // Compute the key for each node.\n\t  // If multiple nodes have the same key, the duplicates are added to exit.\n\t  for (i = 0; i < groupLength; ++i) {\n\t    if (node = group[i]) {\n\t      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);\n\t      if (keyValue in nodeByKeyValue) {\n\t        exit[i] = node;\n\t      } else {\n\t        nodeByKeyValue[keyValue] = node;\n\t      }\n\t    }\n\t  }\n\t\n\t  // Compute the key for each datum.\n\t  // If there a node associated with this key, join and add it to update.\n\t  // If there is not (or the key is a duplicate), add it to enter.\n\t  for (i = 0; i < dataLength; ++i) {\n\t    keyValue = keyPrefix + key.call(parent, data[i], i, data);\n\t    if (node = nodeByKeyValue[keyValue]) {\n\t      update[i] = node;\n\t      node.__data__ = data[i];\n\t      nodeByKeyValue[keyValue] = null;\n\t    } else {\n\t      enter[i] = new EnterNode(parent, data[i]);\n\t    }\n\t  }\n\t\n\t  // Add any remaining nodes that were not bound to data to exit.\n\t  for (i = 0; i < groupLength; ++i) {\n\t    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {\n\t      exit[i] = node;\n\t    }\n\t  }\n\t}\n\t\n\tvar selection_data = function(value, key) {\n\t  if (!value) {\n\t    data = new Array(this.size()), j = -1;\n\t    this.each(function(d) { data[++j] = d; });\n\t    return data;\n\t  }\n\t\n\t  var bind = key ? bindKey : bindIndex,\n\t      parents = this._parents,\n\t      groups = this._groups;\n\t\n\t  if (typeof value !== \"function\") value = constant$5(value);\n\t\n\t  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {\n\t    var parent = parents[j],\n\t        group = groups[j],\n\t        groupLength = group.length,\n\t        data = value.call(parent, parent && parent.__data__, j, parents),\n\t        dataLength = data.length,\n\t        enterGroup = enter[j] = new Array(dataLength),\n\t        updateGroup = update[j] = new Array(dataLength),\n\t        exitGroup = exit[j] = new Array(groupLength);\n\t\n\t    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);\n\t\n\t    // Now connect the enter nodes to their following update node, such that\n\t    // appendChild can insert the materialized enter node before this node,\n\t    // rather than at the end of the parent node.\n\t    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {\n\t      if (previous = enterGroup[i0]) {\n\t        if (i0 >= i1) i1 = i0 + 1;\n\t        while (!(next = updateGroup[i1]) && ++i1 < dataLength);\n\t        previous._next = next || null;\n\t      }\n\t    }\n\t  }\n\t\n\t  update = new Selection(update, parents);\n\t  update._enter = enter;\n\t  update._exit = exit;\n\t  return update;\n\t};\n\t\n\tvar selection_exit = function() {\n\t  return new Selection(this._exit || this._groups.map(sparse), this._parents);\n\t};\n\t\n\tvar selection_merge = function(selection) {\n\t\n\t  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {\n\t    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {\n\t      if (node = group0[i] || group1[i]) {\n\t        merge[i] = node;\n\t      }\n\t    }\n\t  }\n\t\n\t  for (; j < m0; ++j) {\n\t    merges[j] = groups0[j];\n\t  }\n\t\n\t  return new Selection(merges, this._parents);\n\t};\n\t\n\tvar selection_order = function() {\n\t\n\t  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {\n\t    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n\t      if (node = group[i]) {\n\t        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n\t        next = node;\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tvar selection_sort = function(compare) {\n\t  if (!compare) compare = ascending$2;\n\t\n\t  function compareNode(a, b) {\n\t    return a && b ? compare(a.__data__, b.__data__) : !a - !b;\n\t  }\n\t\n\t  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {\n\t    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {\n\t      if (node = group[i]) {\n\t        sortgroup[i] = node;\n\t      }\n\t    }\n\t    sortgroup.sort(compareNode);\n\t  }\n\t\n\t  return new Selection(sortgroups, this._parents).order();\n\t};\n\t\n\tfunction ascending$2(a, b) {\n\t  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n\t}\n\t\n\tvar selection_call = function() {\n\t  var callback = arguments[0];\n\t  arguments[0] = this;\n\t  callback.apply(null, arguments);\n\t  return this;\n\t};\n\t\n\tvar selection_nodes = function() {\n\t  var nodes = new Array(this.size()), i = -1;\n\t  this.each(function() { nodes[++i] = this; });\n\t  return nodes;\n\t};\n\t\n\tvar selection_node = function() {\n\t\n\t  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {\n\t    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {\n\t      var node = group[i];\n\t      if (node) return node;\n\t    }\n\t  }\n\t\n\t  return null;\n\t};\n\t\n\tvar selection_size = function() {\n\t  var size = 0;\n\t  this.each(function() { ++size; });\n\t  return size;\n\t};\n\t\n\tvar selection_empty = function() {\n\t  return !this.node();\n\t};\n\t\n\tvar selection_each = function(callback) {\n\t\n\t  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {\n\t    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {\n\t      if (node = group[i]) callback.call(node, node.__data__, i, group);\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tfunction attrRemove(name) {\n\t  return function() {\n\t    this.removeAttribute(name);\n\t  };\n\t}\n\t\n\tfunction attrRemoveNS(fullname) {\n\t  return function() {\n\t    this.removeAttributeNS(fullname.space, fullname.local);\n\t  };\n\t}\n\t\n\tfunction attrConstant(name, value) {\n\t  return function() {\n\t    this.setAttribute(name, value);\n\t  };\n\t}\n\t\n\tfunction attrConstantNS(fullname, value) {\n\t  return function() {\n\t    this.setAttributeNS(fullname.space, fullname.local, value);\n\t  };\n\t}\n\t\n\tfunction attrFunction(name, value) {\n\t  return function() {\n\t    var v = value.apply(this, arguments);\n\t    if (v == null) this.removeAttribute(name);\n\t    else this.setAttribute(name, v);\n\t  };\n\t}\n\t\n\tfunction attrFunctionNS(fullname, value) {\n\t  return function() {\n\t    var v = value.apply(this, arguments);\n\t    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);\n\t    else this.setAttributeNS(fullname.space, fullname.local, v);\n\t  };\n\t}\n\t\n\tvar selection_attr = function(name, value) {\n\t  var fullname = namespace(name);\n\t\n\t  if (arguments.length < 2) {\n\t    var node = this.node();\n\t    return fullname.local\n\t        ? node.getAttributeNS(fullname.space, fullname.local)\n\t        : node.getAttribute(fullname);\n\t  }\n\t\n\t  return this.each((value == null\n\t      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === \"function\"\n\t      ? (fullname.local ? attrFunctionNS : attrFunction)\n\t      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));\n\t};\n\t\n\tvar window = function(node) {\n\t  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node\n\t      || (node.document && node) // node is a Window\n\t      || node.defaultView; // node is a Document\n\t};\n\t\n\tfunction styleRemove(name) {\n\t  return function() {\n\t    this.style.removeProperty(name);\n\t  };\n\t}\n\t\n\tfunction styleConstant(name, value, priority) {\n\t  return function() {\n\t    this.style.setProperty(name, value, priority);\n\t  };\n\t}\n\t\n\tfunction styleFunction(name, value, priority) {\n\t  return function() {\n\t    var v = value.apply(this, arguments);\n\t    if (v == null) this.style.removeProperty(name);\n\t    else this.style.setProperty(name, v, priority);\n\t  };\n\t}\n\t\n\tvar selection_style = function(name, value, priority) {\n\t  var node;\n\t  return arguments.length > 1\n\t      ? this.each((value == null\n\t            ? styleRemove : typeof value === \"function\"\n\t            ? styleFunction\n\t            : styleConstant)(name, value, priority == null ? \"\" : priority))\n\t      : window(node = this.node())\n\t          .getComputedStyle(node, null)\n\t          .getPropertyValue(name);\n\t};\n\t\n\tfunction propertyRemove(name) {\n\t  return function() {\n\t    delete this[name];\n\t  };\n\t}\n\t\n\tfunction propertyConstant(name, value) {\n\t  return function() {\n\t    this[name] = value;\n\t  };\n\t}\n\t\n\tfunction propertyFunction(name, value) {\n\t  return function() {\n\t    var v = value.apply(this, arguments);\n\t    if (v == null) delete this[name];\n\t    else this[name] = v;\n\t  };\n\t}\n\t\n\tvar selection_property = function(name, value) {\n\t  return arguments.length > 1\n\t      ? this.each((value == null\n\t          ? propertyRemove : typeof value === \"function\"\n\t          ? propertyFunction\n\t          : propertyConstant)(name, value))\n\t      : this.node()[name];\n\t};\n\t\n\tfunction classArray(string) {\n\t  return string.trim().split(/^|\\s+/);\n\t}\n\t\n\tfunction classList(node) {\n\t  return node.classList || new ClassList(node);\n\t}\n\t\n\tfunction ClassList(node) {\n\t  this._node = node;\n\t  this._names = classArray(node.getAttribute(\"class\") || \"\");\n\t}\n\t\n\tClassList.prototype = {\n\t  add: function(name) {\n\t    var i = this._names.indexOf(name);\n\t    if (i < 0) {\n\t      this._names.push(name);\n\t      this._node.setAttribute(\"class\", this._names.join(\" \"));\n\t    }\n\t  },\n\t  remove: function(name) {\n\t    var i = this._names.indexOf(name);\n\t    if (i >= 0) {\n\t      this._names.splice(i, 1);\n\t      this._node.setAttribute(\"class\", this._names.join(\" \"));\n\t    }\n\t  },\n\t  contains: function(name) {\n\t    return this._names.indexOf(name) >= 0;\n\t  }\n\t};\n\t\n\tfunction classedAdd(node, names) {\n\t  var list = classList(node), i = -1, n = names.length;\n\t  while (++i < n) list.add(names[i]);\n\t}\n\t\n\tfunction classedRemove(node, names) {\n\t  var list = classList(node), i = -1, n = names.length;\n\t  while (++i < n) list.remove(names[i]);\n\t}\n\t\n\tfunction classedTrue(names) {\n\t  return function() {\n\t    classedAdd(this, names);\n\t  };\n\t}\n\t\n\tfunction classedFalse(names) {\n\t  return function() {\n\t    classedRemove(this, names);\n\t  };\n\t}\n\t\n\tfunction classedFunction(names, value) {\n\t  return function() {\n\t    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);\n\t  };\n\t}\n\t\n\tvar selection_classed = function(name, value) {\n\t  var names = classArray(name + \"\");\n\t\n\t  if (arguments.length < 2) {\n\t    var list = classList(this.node()), i = -1, n = names.length;\n\t    while (++i < n) if (!list.contains(names[i])) return false;\n\t    return true;\n\t  }\n\t\n\t  return this.each((typeof value === \"function\"\n\t      ? classedFunction : value\n\t      ? classedTrue\n\t      : classedFalse)(names, value));\n\t};\n\t\n\tfunction textRemove() {\n\t  this.textContent = \"\";\n\t}\n\t\n\tfunction textConstant(value) {\n\t  return function() {\n\t    this.textContent = value;\n\t  };\n\t}\n\t\n\tfunction textFunction(value) {\n\t  return function() {\n\t    var v = value.apply(this, arguments);\n\t    this.textContent = v == null ? \"\" : v;\n\t  };\n\t}\n\t\n\tvar selection_text = function(value) {\n\t  return arguments.length\n\t      ? this.each(value == null\n\t          ? textRemove : (typeof value === \"function\"\n\t          ? textFunction\n\t          : textConstant)(value))\n\t      : this.node().textContent;\n\t};\n\t\n\tfunction htmlRemove() {\n\t  this.innerHTML = \"\";\n\t}\n\t\n\tfunction htmlConstant(value) {\n\t  return function() {\n\t    this.innerHTML = value;\n\t  };\n\t}\n\t\n\tfunction htmlFunction(value) {\n\t  return function() {\n\t    var v = value.apply(this, arguments);\n\t    this.innerHTML = v == null ? \"\" : v;\n\t  };\n\t}\n\t\n\tvar selection_html = function(value) {\n\t  return arguments.length\n\t      ? this.each(value == null\n\t          ? htmlRemove : (typeof value === \"function\"\n\t          ? htmlFunction\n\t          : htmlConstant)(value))\n\t      : this.node().innerHTML;\n\t};\n\t\n\tfunction raise$1() {\n\t  if (this.nextSibling) this.parentNode.appendChild(this);\n\t}\n\t\n\tvar selection_raise = function() {\n\t  return this.each(raise$1);\n\t};\n\t\n\tfunction lower() {\n\t  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);\n\t}\n\t\n\tvar selection_lower = function() {\n\t  return this.each(lower);\n\t};\n\t\n\tvar selection_append = function(name) {\n\t  var create = typeof name === \"function\" ? name : creator(name);\n\t  return this.select(function() {\n\t    return this.appendChild(create.apply(this, arguments));\n\t  });\n\t};\n\t\n\tfunction constantNull() {\n\t  return null;\n\t}\n\t\n\tvar selection_insert = function(name, before) {\n\t  var create = typeof name === \"function\" ? name : creator(name),\n\t      select = before == null ? constantNull : typeof before === \"function\" ? before : selector(before);\n\t  return this.select(function() {\n\t    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);\n\t  });\n\t};\n\t\n\tfunction remove() {\n\t  var parent = this.parentNode;\n\t  if (parent) parent.removeChild(this);\n\t}\n\t\n\tvar selection_remove = function() {\n\t  return this.each(remove);\n\t};\n\t\n\tvar selection_datum = function(value) {\n\t  return arguments.length\n\t      ? this.property(\"__data__\", value)\n\t      : this.node().__data__;\n\t};\n\t\n\tfunction dispatchEvent(node, type, params) {\n\t  var window$$1 = window(node),\n\t      event = window$$1.CustomEvent;\n\t\n\t  if (event) {\n\t    event = new event(type, params);\n\t  } else {\n\t    event = window$$1.document.createEvent(\"Event\");\n\t    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;\n\t    else event.initEvent(type, false, false);\n\t  }\n\t\n\t  node.dispatchEvent(event);\n\t}\n\t\n\tfunction dispatchConstant(type, params) {\n\t  return function() {\n\t    return dispatchEvent(this, type, params);\n\t  };\n\t}\n\t\n\tfunction dispatchFunction(type, params) {\n\t  return function() {\n\t    return dispatchEvent(this, type, params.apply(this, arguments));\n\t  };\n\t}\n\t\n\tvar selection_dispatch = function(type, params) {\n\t  return this.each((typeof params === \"function\"\n\t      ? dispatchFunction\n\t      : dispatchConstant)(type, params));\n\t};\n\t\n\tvar root = [null];\n\t\n\tfunction Selection(groups, parents) {\n\t  this._groups = groups;\n\t  this._parents = parents;\n\t}\n\t\n\tfunction selection() {\n\t  return new Selection([[document.documentElement]], root);\n\t}\n\t\n\tSelection.prototype = selection.prototype = {\n\t  constructor: Selection,\n\t  select: selection_select,\n\t  selectAll: selection_selectAll,\n\t  filter: selection_filter,\n\t  data: selection_data,\n\t  enter: selection_enter,\n\t  exit: selection_exit,\n\t  merge: selection_merge,\n\t  order: selection_order,\n\t  sort: selection_sort,\n\t  call: selection_call,\n\t  nodes: selection_nodes,\n\t  node: selection_node,\n\t  size: selection_size,\n\t  empty: selection_empty,\n\t  each: selection_each,\n\t  attr: selection_attr,\n\t  style: selection_style,\n\t  property: selection_property,\n\t  classed: selection_classed,\n\t  text: selection_text,\n\t  html: selection_html,\n\t  raise: selection_raise,\n\t  lower: selection_lower,\n\t  append: selection_append,\n\t  insert: selection_insert,\n\t  remove: selection_remove,\n\t  datum: selection_datum,\n\t  on: selection_on,\n\t  dispatch: selection_dispatch\n\t};\n\t\n\tvar select = function(selector) {\n\t  return typeof selector === \"string\"\n\t      ? new Selection([[document.querySelector(selector)]], [document.documentElement])\n\t      : new Selection([[selector]], root);\n\t};\n\t\n\tvar selectAll = function(selector) {\n\t  return typeof selector === \"string\"\n\t      ? new Selection([document.querySelectorAll(selector)], [document.documentElement])\n\t      : new Selection([selector == null ? [] : selector], root);\n\t};\n\t\n\tvar touch = function(node, touches, identifier) {\n\t  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;\n\t\n\t  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {\n\t    if ((touch = touches[i]).identifier === identifier) {\n\t      return point$5(node, touch);\n\t    }\n\t  }\n\t\n\t  return null;\n\t};\n\t\n\tvar touches = function(node, touches) {\n\t  if (touches == null) touches = sourceEvent().touches;\n\t\n\t  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {\n\t    points[i] = point$5(node, touches[i]);\n\t  }\n\t\n\t  return points;\n\t};\n\t\n\tvar emptyOn = dispatch(\"start\", \"end\", \"interrupt\");\n\tvar emptyTween = [];\n\t\n\tvar CREATED = 0;\n\tvar SCHEDULED = 1;\n\tvar STARTING = 2;\n\tvar STARTED = 3;\n\tvar RUNNING = 4;\n\tvar ENDING = 5;\n\tvar ENDED = 6;\n\t\n\tvar schedule = function(node, name, id, index, group, timing) {\n\t  var schedules = node.__transition;\n\t  if (!schedules) node.__transition = {};\n\t  else if (id in schedules) return;\n\t  create(node, id, {\n\t    name: name,\n\t    index: index, // For context during callback.\n\t    group: group, // For context during callback.\n\t    on: emptyOn,\n\t    tween: emptyTween,\n\t    time: timing.time,\n\t    delay: timing.delay,\n\t    duration: timing.duration,\n\t    ease: timing.ease,\n\t    timer: null,\n\t    state: CREATED\n\t  });\n\t};\n\t\n\tfunction init(node, id) {\n\t  var schedule = node.__transition;\n\t  if (!schedule || !(schedule = schedule[id]) || schedule.state > CREATED) throw new Error(\"too late\");\n\t  return schedule;\n\t}\n\t\n\tfunction set$3(node, id) {\n\t  var schedule = node.__transition;\n\t  if (!schedule || !(schedule = schedule[id]) || schedule.state > STARTING) throw new Error(\"too late\");\n\t  return schedule;\n\t}\n\t\n\tfunction get$1(node, id) {\n\t  var schedule = node.__transition;\n\t  if (!schedule || !(schedule = schedule[id])) throw new Error(\"too late\");\n\t  return schedule;\n\t}\n\t\n\tfunction create(node, id, self) {\n\t  var schedules = node.__transition,\n\t      tween;\n\t\n\t  // Initialize the self timer when the transition is created.\n\t  // Note the actual delay is not known until the first callback!\n\t  schedules[id] = self;\n\t  self.timer = timer(schedule, 0, self.time);\n\t\n\t  function schedule(elapsed) {\n\t    self.state = SCHEDULED;\n\t    self.timer.restart(start, self.delay, self.time);\n\t\n\t    // If the elapsed delay is less than our first sleep, start immediately.\n\t    if (self.delay <= elapsed) start(elapsed - self.delay);\n\t  }\n\t\n\t  function start(elapsed) {\n\t    var i, j, n, o;\n\t\n\t    // If the state is not SCHEDULED, then we previously errored on start.\n\t    if (self.state !== SCHEDULED) return stop();\n\t\n\t    for (i in schedules) {\n\t      o = schedules[i];\n\t      if (o.name !== self.name) continue;\n\t\n\t      // While this element already has a starting transition during this frame,\n\t      // defer starting an interrupting transition until that transition has a\n\t      // chance to tick (and possibly end); see d3/d3-transition#54!\n\t      if (o.state === STARTED) return timeout$1(start);\n\t\n\t      // Interrupt the active transition, if any.\n\t      // Dispatch the interrupt event.\n\t      if (o.state === RUNNING) {\n\t        o.state = ENDED;\n\t        o.timer.stop();\n\t        o.on.call(\"interrupt\", node, node.__data__, o.index, o.group);\n\t        delete schedules[i];\n\t      }\n\t\n\t      // Cancel any pre-empted transitions. No interrupt event is dispatched\n\t      // because the cancelled transitions never started. Note that this also\n\t      // removes this transition from the pending list!\n\t      else if (+i < id) {\n\t        o.state = ENDED;\n\t        o.timer.stop();\n\t        delete schedules[i];\n\t      }\n\t    }\n\t\n\t    // Defer the first tick to end of the current frame; see d3/d3#1576.\n\t    // Note the transition may be canceled after start and before the first tick!\n\t    // Note this must be scheduled before the start event; see d3/d3-transition#16!\n\t    // Assuming this is successful, subsequent callbacks go straight to tick.\n\t    timeout$1(function() {\n\t      if (self.state === STARTED) {\n\t        self.state = RUNNING;\n\t        self.timer.restart(tick, self.delay, self.time);\n\t        tick(elapsed);\n\t      }\n\t    });\n\t\n\t    // Dispatch the start event.\n\t    // Note this must be done before the tween are initialized.\n\t    self.state = STARTING;\n\t    self.on.call(\"start\", node, node.__data__, self.index, self.group);\n\t    if (self.state !== STARTING) return; // interrupted\n\t    self.state = STARTED;\n\t\n\t    // Initialize the tween, deleting null tween.\n\t    tween = new Array(n = self.tween.length);\n\t    for (i = 0, j = -1; i < n; ++i) {\n\t      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {\n\t        tween[++j] = o;\n\t      }\n\t    }\n\t    tween.length = j + 1;\n\t  }\n\t\n\t  function tick(elapsed) {\n\t    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),\n\t        i = -1,\n\t        n = tween.length;\n\t\n\t    while (++i < n) {\n\t      tween[i].call(null, t);\n\t    }\n\t\n\t    // Dispatch the end event.\n\t    if (self.state === ENDING) {\n\t      self.on.call(\"end\", node, node.__data__, self.index, self.group);\n\t      stop();\n\t    }\n\t  }\n\t\n\t  function stop() {\n\t    self.state = ENDED;\n\t    self.timer.stop();\n\t    delete schedules[id];\n\t    for (var i in schedules) return; // eslint-disable-line no-unused-vars\n\t    delete node.__transition;\n\t  }\n\t}\n\t\n\tvar interrupt = function(node, name) {\n\t  var schedules = node.__transition,\n\t      schedule,\n\t      active,\n\t      empty = true,\n\t      i;\n\t\n\t  if (!schedules) return;\n\t\n\t  name = name == null ? null : name + \"\";\n\t\n\t  for (i in schedules) {\n\t    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }\n\t    active = schedule.state > STARTING && schedule.state < ENDING;\n\t    schedule.state = ENDED;\n\t    schedule.timer.stop();\n\t    if (active) schedule.on.call(\"interrupt\", node, node.__data__, schedule.index, schedule.group);\n\t    delete schedules[i];\n\t  }\n\t\n\t  if (empty) delete node.__transition;\n\t};\n\t\n\tvar selection_interrupt = function(name) {\n\t  return this.each(function() {\n\t    interrupt(this, name);\n\t  });\n\t};\n\t\n\tfunction tweenRemove(id, name) {\n\t  var tween0, tween1;\n\t  return function() {\n\t    var schedule = set$3(this, id),\n\t        tween = schedule.tween;\n\t\n\t    // If this node shared tween with the previous node,\n\t    // just assign the updated shared tween and we’re done!\n\t    // Otherwise, copy-on-write.\n\t    if (tween !== tween0) {\n\t      tween1 = tween0 = tween;\n\t      for (var i = 0, n = tween1.length; i < n; ++i) {\n\t        if (tween1[i].name === name) {\n\t          tween1 = tween1.slice();\n\t          tween1.splice(i, 1);\n\t          break;\n\t        }\n\t      }\n\t    }\n\t\n\t    schedule.tween = tween1;\n\t  };\n\t}\n\t\n\tfunction tweenFunction(id, name, value) {\n\t  var tween0, tween1;\n\t  if (typeof value !== \"function\") throw new Error;\n\t  return function() {\n\t    var schedule = set$3(this, id),\n\t        tween = schedule.tween;\n\t\n\t    // If this node shared tween with the previous node,\n\t    // just assign the updated shared tween and we’re done!\n\t    // Otherwise, copy-on-write.\n\t    if (tween !== tween0) {\n\t      tween1 = (tween0 = tween).slice();\n\t      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {\n\t        if (tween1[i].name === name) {\n\t          tween1[i] = t;\n\t          break;\n\t        }\n\t      }\n\t      if (i === n) tween1.push(t);\n\t    }\n\t\n\t    schedule.tween = tween1;\n\t  };\n\t}\n\t\n\tvar transition_tween = function(name, value) {\n\t  var id = this._id;\n\t\n\t  name += \"\";\n\t\n\t  if (arguments.length < 2) {\n\t    var tween = get$1(this.node(), id).tween;\n\t    for (var i = 0, n = tween.length, t; i < n; ++i) {\n\t      if ((t = tween[i]).name === name) {\n\t        return t.value;\n\t      }\n\t    }\n\t    return null;\n\t  }\n\t\n\t  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));\n\t};\n\t\n\tfunction tweenValue(transition, name, value) {\n\t  var id = transition._id;\n\t\n\t  transition.each(function() {\n\t    var schedule = set$3(this, id);\n\t    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);\n\t  });\n\t\n\t  return function(node) {\n\t    return get$1(node, id).value[name];\n\t  };\n\t}\n\t\n\tvar interpolate$1 = function(a, b) {\n\t  var c;\n\t  return (typeof b === \"number\" ? interpolateNumber\n\t      : b instanceof color ? interpolateRgb\n\t      : (c = color(b)) ? (b = c, interpolateRgb)\n\t      : interpolateString)(a, b);\n\t};\n\t\n\tfunction attrRemove$1(name) {\n\t  return function() {\n\t    this.removeAttribute(name);\n\t  };\n\t}\n\t\n\tfunction attrRemoveNS$1(fullname) {\n\t  return function() {\n\t    this.removeAttributeNS(fullname.space, fullname.local);\n\t  };\n\t}\n\t\n\tfunction attrConstant$1(name, interpolate$$1, value1) {\n\t  var value00,\n\t      interpolate0;\n\t  return function() {\n\t    var value0 = this.getAttribute(name);\n\t    return value0 === value1 ? null\n\t        : value0 === value00 ? interpolate0\n\t        : interpolate0 = interpolate$$1(value00 = value0, value1);\n\t  };\n\t}\n\t\n\tfunction attrConstantNS$1(fullname, interpolate$$1, value1) {\n\t  var value00,\n\t      interpolate0;\n\t  return function() {\n\t    var value0 = this.getAttributeNS(fullname.space, fullname.local);\n\t    return value0 === value1 ? null\n\t        : value0 === value00 ? interpolate0\n\t        : interpolate0 = interpolate$$1(value00 = value0, value1);\n\t  };\n\t}\n\t\n\tfunction attrFunction$1(name, interpolate$$1, value) {\n\t  var value00,\n\t      value10,\n\t      interpolate0;\n\t  return function() {\n\t    var value0, value1 = value(this);\n\t    if (value1 == null) return void this.removeAttribute(name);\n\t    value0 = this.getAttribute(name);\n\t    return value0 === value1 ? null\n\t        : value0 === value00 && value1 === value10 ? interpolate0\n\t        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n\t  };\n\t}\n\t\n\tfunction attrFunctionNS$1(fullname, interpolate$$1, value) {\n\t  var value00,\n\t      value10,\n\t      interpolate0;\n\t  return function() {\n\t    var value0, value1 = value(this);\n\t    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);\n\t    value0 = this.getAttributeNS(fullname.space, fullname.local);\n\t    return value0 === value1 ? null\n\t        : value0 === value00 && value1 === value10 ? interpolate0\n\t        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n\t  };\n\t}\n\t\n\tvar transition_attr = function(name, value) {\n\t  var fullname = namespace(name), i = fullname === \"transform\" ? interpolateTransformSvg : interpolate$1;\n\t  return this.attrTween(name, typeof value === \"function\"\n\t      ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, \"attr.\" + name, value))\n\t      : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname)\n\t      : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value));\n\t};\n\t\n\tfunction attrTweenNS(fullname, value) {\n\t  function tween() {\n\t    var node = this, i = value.apply(node, arguments);\n\t    return i && function(t) {\n\t      node.setAttributeNS(fullname.space, fullname.local, i(t));\n\t    };\n\t  }\n\t  tween._value = value;\n\t  return tween;\n\t}\n\t\n\tfunction attrTween(name, value) {\n\t  function tween() {\n\t    var node = this, i = value.apply(node, arguments);\n\t    return i && function(t) {\n\t      node.setAttribute(name, i(t));\n\t    };\n\t  }\n\t  tween._value = value;\n\t  return tween;\n\t}\n\t\n\tvar transition_attrTween = function(name, value) {\n\t  var key = \"attr.\" + name;\n\t  if (arguments.length < 2) return (key = this.tween(key)) && key._value;\n\t  if (value == null) return this.tween(key, null);\n\t  if (typeof value !== \"function\") throw new Error;\n\t  var fullname = namespace(name);\n\t  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));\n\t};\n\t\n\tfunction delayFunction(id, value) {\n\t  return function() {\n\t    init(this, id).delay = +value.apply(this, arguments);\n\t  };\n\t}\n\t\n\tfunction delayConstant(id, value) {\n\t  return value = +value, function() {\n\t    init(this, id).delay = value;\n\t  };\n\t}\n\t\n\tvar transition_delay = function(value) {\n\t  var id = this._id;\n\t\n\t  return arguments.length\n\t      ? this.each((typeof value === \"function\"\n\t          ? delayFunction\n\t          : delayConstant)(id, value))\n\t      : get$1(this.node(), id).delay;\n\t};\n\t\n\tfunction durationFunction(id, value) {\n\t  return function() {\n\t    set$3(this, id).duration = +value.apply(this, arguments);\n\t  };\n\t}\n\t\n\tfunction durationConstant(id, value) {\n\t  return value = +value, function() {\n\t    set$3(this, id).duration = value;\n\t  };\n\t}\n\t\n\tvar transition_duration = function(value) {\n\t  var id = this._id;\n\t\n\t  return arguments.length\n\t      ? this.each((typeof value === \"function\"\n\t          ? durationFunction\n\t          : durationConstant)(id, value))\n\t      : get$1(this.node(), id).duration;\n\t};\n\t\n\tfunction easeConstant(id, value) {\n\t  if (typeof value !== \"function\") throw new Error;\n\t  return function() {\n\t    set$3(this, id).ease = value;\n\t  };\n\t}\n\t\n\tvar transition_ease = function(value) {\n\t  var id = this._id;\n\t\n\t  return arguments.length\n\t      ? this.each(easeConstant(id, value))\n\t      : get$1(this.node(), id).ease;\n\t};\n\t\n\tvar transition_filter = function(match) {\n\t  if (typeof match !== \"function\") match = matcher$1(match);\n\t\n\t  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n\t    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {\n\t      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {\n\t        subgroup.push(node);\n\t      }\n\t    }\n\t  }\n\t\n\t  return new Transition(subgroups, this._parents, this._name, this._id);\n\t};\n\t\n\tvar transition_merge = function(transition) {\n\t  if (transition._id !== this._id) throw new Error;\n\t\n\t  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {\n\t    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {\n\t      if (node = group0[i] || group1[i]) {\n\t        merge[i] = node;\n\t      }\n\t    }\n\t  }\n\t\n\t  for (; j < m0; ++j) {\n\t    merges[j] = groups0[j];\n\t  }\n\t\n\t  return new Transition(merges, this._parents, this._name, this._id);\n\t};\n\t\n\tfunction start$1(name) {\n\t  return (name + \"\").trim().split(/^|\\s+/).every(function(t) {\n\t    var i = t.indexOf(\".\");\n\t    if (i >= 0) t = t.slice(0, i);\n\t    return !t || t === \"start\";\n\t  });\n\t}\n\t\n\tfunction onFunction(id, name, listener) {\n\t  var on0, on1, sit = start$1(name) ? init : set$3;\n\t  return function() {\n\t    var schedule = sit(this, id),\n\t        on = schedule.on;\n\t\n\t    // If this node shared a dispatch with the previous node,\n\t    // just assign the updated shared dispatch and we’re done!\n\t    // Otherwise, copy-on-write.\n\t    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);\n\t\n\t    schedule.on = on1;\n\t  };\n\t}\n\t\n\tvar transition_on = function(name, listener) {\n\t  var id = this._id;\n\t\n\t  return arguments.length < 2\n\t      ? get$1(this.node(), id).on.on(name)\n\t      : this.each(onFunction(id, name, listener));\n\t};\n\t\n\tfunction removeFunction(id) {\n\t  return function() {\n\t    var parent = this.parentNode;\n\t    for (var i in this.__transition) if (+i !== id) return;\n\t    if (parent) parent.removeChild(this);\n\t  };\n\t}\n\t\n\tvar transition_remove = function() {\n\t  return this.on(\"end.remove\", removeFunction(this._id));\n\t};\n\t\n\tvar transition_select = function(select$$1) {\n\t  var name = this._name,\n\t      id = this._id;\n\t\n\t  if (typeof select$$1 !== \"function\") select$$1 = selector(select$$1);\n\t\n\t  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n\t    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {\n\t      if ((node = group[i]) && (subnode = select$$1.call(node, node.__data__, i, group))) {\n\t        if (\"__data__\" in node) subnode.__data__ = node.__data__;\n\t        subgroup[i] = subnode;\n\t        schedule(subgroup[i], name, id, i, subgroup, get$1(node, id));\n\t      }\n\t    }\n\t  }\n\t\n\t  return new Transition(subgroups, this._parents, name, id);\n\t};\n\t\n\tvar transition_selectAll = function(select$$1) {\n\t  var name = this._name,\n\t      id = this._id;\n\t\n\t  if (typeof select$$1 !== \"function\") select$$1 = selectorAll(select$$1);\n\t\n\t  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {\n\t    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n\t      if (node = group[i]) {\n\t        for (var children = select$$1.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k < l; ++k) {\n\t          if (child = children[k]) {\n\t            schedule(child, name, id, k, children, inherit);\n\t          }\n\t        }\n\t        subgroups.push(children);\n\t        parents.push(node);\n\t      }\n\t    }\n\t  }\n\t\n\t  return new Transition(subgroups, parents, name, id);\n\t};\n\t\n\tvar Selection$1 = selection.prototype.constructor;\n\t\n\tvar transition_selection = function() {\n\t  return new Selection$1(this._groups, this._parents);\n\t};\n\t\n\tfunction styleRemove$1(name, interpolate$$1) {\n\t  var value00,\n\t      value10,\n\t      interpolate0;\n\t  return function() {\n\t    var style = window(this).getComputedStyle(this, null),\n\t        value0 = style.getPropertyValue(name),\n\t        value1 = (this.style.removeProperty(name), style.getPropertyValue(name));\n\t    return value0 === value1 ? null\n\t        : value0 === value00 && value1 === value10 ? interpolate0\n\t        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n\t  };\n\t}\n\t\n\tfunction styleRemoveEnd(name) {\n\t  return function() {\n\t    this.style.removeProperty(name);\n\t  };\n\t}\n\t\n\tfunction styleConstant$1(name, interpolate$$1, value1) {\n\t  var value00,\n\t      interpolate0;\n\t  return function() {\n\t    var value0 = window(this).getComputedStyle(this, null).getPropertyValue(name);\n\t    return value0 === value1 ? null\n\t        : value0 === value00 ? interpolate0\n\t        : interpolate0 = interpolate$$1(value00 = value0, value1);\n\t  };\n\t}\n\t\n\tfunction styleFunction$1(name, interpolate$$1, value) {\n\t  var value00,\n\t      value10,\n\t      interpolate0;\n\t  return function() {\n\t    var style = window(this).getComputedStyle(this, null),\n\t        value0 = style.getPropertyValue(name),\n\t        value1 = value(this);\n\t    if (value1 == null) value1 = (this.style.removeProperty(name), style.getPropertyValue(name));\n\t    return value0 === value1 ? null\n\t        : value0 === value00 && value1 === value10 ? interpolate0\n\t        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n\t  };\n\t}\n\t\n\tvar transition_style = function(name, value, priority) {\n\t  var i = (name += \"\") === \"transform\" ? interpolateTransformCss : interpolate$1;\n\t  return value == null ? this\n\t          .styleTween(name, styleRemove$1(name, i))\n\t          .on(\"end.style.\" + name, styleRemoveEnd(name))\n\t      : this.styleTween(name, typeof value === \"function\"\n\t          ? styleFunction$1(name, i, tweenValue(this, \"style.\" + name, value))\n\t          : styleConstant$1(name, i, value), priority);\n\t};\n\t\n\tfunction styleTween(name, value, priority) {\n\t  function tween() {\n\t    var node = this, i = value.apply(node, arguments);\n\t    return i && function(t) {\n\t      node.style.setProperty(name, i(t), priority);\n\t    };\n\t  }\n\t  tween._value = value;\n\t  return tween;\n\t}\n\t\n\tvar transition_styleTween = function(name, value, priority) {\n\t  var key = \"style.\" + (name += \"\");\n\t  if (arguments.length < 2) return (key = this.tween(key)) && key._value;\n\t  if (value == null) return this.tween(key, null);\n\t  if (typeof value !== \"function\") throw new Error;\n\t  return this.tween(key, styleTween(name, value, priority == null ? \"\" : priority));\n\t};\n\t\n\tfunction textConstant$1(value) {\n\t  return function() {\n\t    this.textContent = value;\n\t  };\n\t}\n\t\n\tfunction textFunction$1(value) {\n\t  return function() {\n\t    var value1 = value(this);\n\t    this.textContent = value1 == null ? \"\" : value1;\n\t  };\n\t}\n\t\n\tvar transition_text = function(value) {\n\t  return this.tween(\"text\", typeof value === \"function\"\n\t      ? textFunction$1(tweenValue(this, \"text\", value))\n\t      : textConstant$1(value == null ? \"\" : value + \"\"));\n\t};\n\t\n\tvar transition_transition = function() {\n\t  var name = this._name,\n\t      id0 = this._id,\n\t      id1 = newId();\n\t\n\t  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {\n\t    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n\t      if (node = group[i]) {\n\t        var inherit = get$1(node, id0);\n\t        schedule(node, name, id1, i, group, {\n\t          time: inherit.time + inherit.delay + inherit.duration,\n\t          delay: 0,\n\t          duration: inherit.duration,\n\t          ease: inherit.ease\n\t        });\n\t      }\n\t    }\n\t  }\n\t\n\t  return new Transition(groups, this._parents, name, id1);\n\t};\n\t\n\tvar id = 0;\n\t\n\tfunction Transition(groups, parents, name, id) {\n\t  this._groups = groups;\n\t  this._parents = parents;\n\t  this._name = name;\n\t  this._id = id;\n\t}\n\t\n\tfunction transition(name) {\n\t  return selection().transition(name);\n\t}\n\t\n\tfunction newId() {\n\t  return ++id;\n\t}\n\t\n\tvar selection_prototype = selection.prototype;\n\t\n\tTransition.prototype = transition.prototype = {\n\t  constructor: Transition,\n\t  select: transition_select,\n\t  selectAll: transition_selectAll,\n\t  filter: transition_filter,\n\t  merge: transition_merge,\n\t  selection: transition_selection,\n\t  transition: transition_transition,\n\t  call: selection_prototype.call,\n\t  nodes: selection_prototype.nodes,\n\t  node: selection_prototype.node,\n\t  size: selection_prototype.size,\n\t  empty: selection_prototype.empty,\n\t  each: selection_prototype.each,\n\t  on: transition_on,\n\t  attr: transition_attr,\n\t  attrTween: transition_attrTween,\n\t  style: transition_style,\n\t  styleTween: transition_styleTween,\n\t  text: transition_text,\n\t  remove: transition_remove,\n\t  tween: transition_tween,\n\t  delay: transition_delay,\n\t  duration: transition_duration,\n\t  ease: transition_ease\n\t};\n\t\n\tvar defaultTiming = {\n\t  time: null, // Set on use.\n\t  delay: 0,\n\t  duration: 250,\n\t  ease: cubicInOut\n\t};\n\t\n\tfunction inherit(node, id) {\n\t  var timing;\n\t  while (!(timing = node.__transition) || !(timing = timing[id])) {\n\t    if (!(node = node.parentNode)) {\n\t      return defaultTiming.time = now(), defaultTiming;\n\t    }\n\t  }\n\t  return timing;\n\t}\n\t\n\tvar selection_transition = function(name) {\n\t  var id,\n\t      timing;\n\t\n\t  if (name instanceof Transition) {\n\t    id = name._id, name = name._name;\n\t  } else {\n\t    id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + \"\";\n\t  }\n\t\n\t  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {\n\t    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n\t      if (node = group[i]) {\n\t        schedule(node, name, id, i, group, timing || inherit(node, id));\n\t      }\n\t    }\n\t  }\n\t\n\t  return new Transition(groups, this._parents, name, id);\n\t};\n\t\n\tselection.prototype.interrupt = selection_interrupt;\n\tselection.prototype.transition = selection_transition;\n\t\n\tvar root$1 = [null];\n\t\n\tvar active = function(node, name) {\n\t  var schedules = node.__transition,\n\t      schedule,\n\t      i;\n\t\n\t  if (schedules) {\n\t    name = name == null ? null : name + \"\";\n\t    for (i in schedules) {\n\t      if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {\n\t        return new Transition([[node]], root$1, name, +i);\n\t      }\n\t    }\n\t  }\n\t\n\t  return null;\n\t};\n\t\n\tvar slice$4 = Array.prototype.slice;\n\t\n\tvar identity$5 = function(x) {\n\t  return x;\n\t};\n\t\n\tvar top = 1;\n\tvar right = 2;\n\tvar bottom = 3;\n\tvar left = 4;\n\tvar epsilon$2 = 1e-6;\n\t\n\tfunction translateX(scale0, scale1, d) {\n\t  var x = scale0(d);\n\t  return \"translate(\" + (isFinite(x) ? x : scale1(d)) + \",0)\";\n\t}\n\t\n\tfunction translateY(scale0, scale1, d) {\n\t  var y = scale0(d);\n\t  return \"translate(0,\" + (isFinite(y) ? y : scale1(d)) + \")\";\n\t}\n\t\n\tfunction center(scale) {\n\t  var offset = scale.bandwidth() / 2;\n\t  if (scale.round()) offset = Math.round(offset);\n\t  return function(d) {\n\t    return scale(d) + offset;\n\t  };\n\t}\n\t\n\tfunction entering() {\n\t  return !this.__axis;\n\t}\n\t\n\tfunction axis(orient, scale) {\n\t  var tickArguments = [],\n\t      tickValues = null,\n\t      tickFormat = null,\n\t      tickSizeInner = 6,\n\t      tickSizeOuter = 6,\n\t      tickPadding = 3;\n\t\n\t  function axis(context) {\n\t    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,\n\t        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$5) : tickFormat,\n\t        spacing = Math.max(tickSizeInner, 0) + tickPadding,\n\t        transform = orient === top || orient === bottom ? translateX : translateY,\n\t        range = scale.range(),\n\t        range0 = range[0] + 0.5,\n\t        range1 = range[range.length - 1] + 0.5,\n\t        position = (scale.bandwidth ? center : identity$5)(scale.copy()),\n\t        selection = context.selection ? context.selection() : context,\n\t        path = selection.selectAll(\".domain\").data([null]),\n\t        tick = selection.selectAll(\".tick\").data(values, scale).order(),\n\t        tickExit = tick.exit(),\n\t        tickEnter = tick.enter().append(\"g\").attr(\"class\", \"tick\"),\n\t        line = tick.select(\"line\"),\n\t        text = tick.select(\"text\"),\n\t        k = orient === top || orient === left ? -1 : 1,\n\t        x, y = orient === left || orient === right ? (x = \"x\", \"y\") : (x = \"y\", \"x\");\n\t\n\t    path = path.merge(path.enter().insert(\"path\", \".tick\")\n\t        .attr(\"class\", \"domain\")\n\t        .attr(\"stroke\", \"#000\"));\n\t\n\t    tick = tick.merge(tickEnter);\n\t\n\t    line = line.merge(tickEnter.append(\"line\")\n\t        .attr(\"stroke\", \"#000\")\n\t        .attr(x + \"2\", k * tickSizeInner)\n\t        .attr(y + \"1\", 0.5)\n\t        .attr(y + \"2\", 0.5));\n\t\n\t    text = text.merge(tickEnter.append(\"text\")\n\t        .attr(\"fill\", \"#000\")\n\t        .attr(x, k * spacing)\n\t        .attr(y, 0.5)\n\t        .attr(\"dy\", orient === top ? \"0em\" : orient === bottom ? \"0.71em\" : \"0.32em\"));\n\t\n\t    if (context !== selection) {\n\t      path = path.transition(context);\n\t      tick = tick.transition(context);\n\t      line = line.transition(context);\n\t      text = text.transition(context);\n\t\n\t      tickExit = tickExit.transition(context)\n\t          .attr(\"opacity\", epsilon$2)\n\t          .attr(\"transform\", function(d) { return transform(position, this.parentNode.__axis || position, d); });\n\t\n\t      tickEnter\n\t          .attr(\"opacity\", epsilon$2)\n\t          .attr(\"transform\", function(d) { return transform(this.parentNode.__axis || position, position, d); });\n\t    }\n\t\n\t    tickExit.remove();\n\t\n\t    path\n\t        .attr(\"d\", orient === left || orient == right\n\t            ? \"M\" + k * tickSizeOuter + \",\" + range0 + \"H0.5V\" + range1 + \"H\" + k * tickSizeOuter\n\t            : \"M\" + range0 + \",\" + k * tickSizeOuter + \"V0.5H\" + range1 + \"V\" + k * tickSizeOuter);\n\t\n\t    tick\n\t        .attr(\"opacity\", 1)\n\t        .attr(\"transform\", function(d) { return transform(position, position, d); });\n\t\n\t    line\n\t        .attr(x + \"2\", k * tickSizeInner);\n\t\n\t    text\n\t        .attr(x, k * spacing)\n\t        .text(format);\n\t\n\t    selection.filter(entering)\n\t        .attr(\"fill\", \"none\")\n\t        .attr(\"font-size\", 10)\n\t        .attr(\"font-family\", \"sans-serif\")\n\t        .attr(\"text-anchor\", orient === right ? \"start\" : orient === left ? \"end\" : \"middle\");\n\t\n\t    selection\n\t        .each(function() { this.__axis = position; });\n\t  }\n\t\n\t  axis.scale = function(_) {\n\t    return arguments.length ? (scale = _, axis) : scale;\n\t  };\n\t\n\t  axis.ticks = function() {\n\t    return tickArguments = slice$4.call(arguments), axis;\n\t  };\n\t\n\t  axis.tickArguments = function(_) {\n\t    return arguments.length ? (tickArguments = _ == null ? [] : slice$4.call(_), axis) : tickArguments.slice();\n\t  };\n\t\n\t  axis.tickValues = function(_) {\n\t    return arguments.length ? (tickValues = _ == null ? null : slice$4.call(_), axis) : tickValues && tickValues.slice();\n\t  };\n\t\n\t  axis.tickFormat = function(_) {\n\t    return arguments.length ? (tickFormat = _, axis) : tickFormat;\n\t  };\n\t\n\t  axis.tickSize = function(_) {\n\t    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;\n\t  };\n\t\n\t  axis.tickSizeInner = function(_) {\n\t    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;\n\t  };\n\t\n\t  axis.tickSizeOuter = function(_) {\n\t    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;\n\t  };\n\t\n\t  axis.tickPadding = function(_) {\n\t    return arguments.length ? (tickPadding = +_, axis) : tickPadding;\n\t  };\n\t\n\t  return axis;\n\t}\n\t\n\tfunction axisTop(scale) {\n\t  return axis(top, scale);\n\t}\n\t\n\tfunction axisRight(scale) {\n\t  return axis(right, scale);\n\t}\n\t\n\tfunction axisBottom(scale) {\n\t  return axis(bottom, scale);\n\t}\n\t\n\tfunction axisLeft(scale) {\n\t  return axis(left, scale);\n\t}\n\t\n\tfunction defaultSeparation(a, b) {\n\t  return a.parent === b.parent ? 1 : 2;\n\t}\n\t\n\tfunction meanX(children) {\n\t  return children.reduce(meanXReduce, 0) / children.length;\n\t}\n\t\n\tfunction meanXReduce(x, c) {\n\t  return x + c.x;\n\t}\n\t\n\tfunction maxY(children) {\n\t  return 1 + children.reduce(maxYReduce, 0);\n\t}\n\t\n\tfunction maxYReduce(y, c) {\n\t  return Math.max(y, c.y);\n\t}\n\t\n\tfunction leafLeft(node) {\n\t  var children;\n\t  while (children = node.children) node = children[0];\n\t  return node;\n\t}\n\t\n\tfunction leafRight(node) {\n\t  var children;\n\t  while (children = node.children) node = children[children.length - 1];\n\t  return node;\n\t}\n\t\n\tvar cluster = function() {\n\t  var separation = defaultSeparation,\n\t      dx = 1,\n\t      dy = 1,\n\t      nodeSize = false;\n\t\n\t  function cluster(root) {\n\t    var previousNode,\n\t        x = 0;\n\t\n\t    // First walk, computing the initial x & y values.\n\t    root.eachAfter(function(node) {\n\t      var children = node.children;\n\t      if (children) {\n\t        node.x = meanX(children);\n\t        node.y = maxY(children);\n\t      } else {\n\t        node.x = previousNode ? x += separation(node, previousNode) : 0;\n\t        node.y = 0;\n\t        previousNode = node;\n\t      }\n\t    });\n\t\n\t    var left = leafLeft(root),\n\t        right = leafRight(root),\n\t        x0 = left.x - separation(left, right) / 2,\n\t        x1 = right.x + separation(right, left) / 2;\n\t\n\t    // Second walk, normalizing x & y to the desired size.\n\t    return root.eachAfter(nodeSize ? function(node) {\n\t      node.x = (node.x - root.x) * dx;\n\t      node.y = (root.y - node.y) * dy;\n\t    } : function(node) {\n\t      node.x = (node.x - x0) / (x1 - x0) * dx;\n\t      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;\n\t    });\n\t  }\n\t\n\t  cluster.separation = function(x) {\n\t    return arguments.length ? (separation = x, cluster) : separation;\n\t  };\n\t\n\t  cluster.size = function(x) {\n\t    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);\n\t  };\n\t\n\t  cluster.nodeSize = function(x) {\n\t    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);\n\t  };\n\t\n\t  return cluster;\n\t};\n\t\n\tvar node_each = function(callback) {\n\t  var node = this, current, next = [node], children, i, n;\n\t  do {\n\t    current = next.reverse(), next = [];\n\t    while (node = current.pop()) {\n\t      callback(node), children = node.children;\n\t      if (children) for (i = 0, n = children.length; i < n; ++i) {\n\t        next.push(children[i]);\n\t      }\n\t    }\n\t  } while (next.length);\n\t  return this;\n\t};\n\t\n\tvar node_eachBefore = function(callback) {\n\t  var node = this, nodes = [node], children, i;\n\t  while (node = nodes.pop()) {\n\t    callback(node), children = node.children;\n\t    if (children) for (i = children.length - 1; i >= 0; --i) {\n\t      nodes.push(children[i]);\n\t    }\n\t  }\n\t  return this;\n\t};\n\t\n\tvar node_eachAfter = function(callback) {\n\t  var node = this, nodes = [node], next = [], children, i, n;\n\t  while (node = nodes.pop()) {\n\t    next.push(node), children = node.children;\n\t    if (children) for (i = 0, n = children.length; i < n; ++i) {\n\t      nodes.push(children[i]);\n\t    }\n\t  }\n\t  while (node = next.pop()) {\n\t    callback(node);\n\t  }\n\t  return this;\n\t};\n\t\n\tvar node_sum = function(value) {\n\t  return this.eachAfter(function(node) {\n\t    var sum = +value(node.data) || 0,\n\t        children = node.children,\n\t        i = children && children.length;\n\t    while (--i >= 0) sum += children[i].value;\n\t    node.value = sum;\n\t  });\n\t};\n\t\n\tvar node_sort = function(compare) {\n\t  return this.eachBefore(function(node) {\n\t    if (node.children) {\n\t      node.children.sort(compare);\n\t    }\n\t  });\n\t};\n\t\n\tvar node_path = function(end) {\n\t  var start = this,\n\t      ancestor = leastCommonAncestor(start, end),\n\t      nodes = [start];\n\t  while (start !== ancestor) {\n\t    start = start.parent;\n\t    nodes.push(start);\n\t  }\n\t  var k = nodes.length;\n\t  while (end !== ancestor) {\n\t    nodes.splice(k, 0, end);\n\t    end = end.parent;\n\t  }\n\t  return nodes;\n\t};\n\t\n\tfunction leastCommonAncestor(a, b) {\n\t  if (a === b) return a;\n\t  var aNodes = a.ancestors(),\n\t      bNodes = b.ancestors(),\n\t      c = null;\n\t  a = aNodes.pop();\n\t  b = bNodes.pop();\n\t  while (a === b) {\n\t    c = a;\n\t    a = aNodes.pop();\n\t    b = bNodes.pop();\n\t  }\n\t  return c;\n\t}\n\t\n\tvar node_ancestors = function() {\n\t  var node = this, nodes = [node];\n\t  while (node = node.parent) {\n\t    nodes.push(node);\n\t  }\n\t  return nodes;\n\t};\n\t\n\tvar node_descendants = function() {\n\t  var nodes = [];\n\t  this.each(function(node) {\n\t    nodes.push(node);\n\t  });\n\t  return nodes;\n\t};\n\t\n\tvar node_leaves = function() {\n\t  var leaves = [];\n\t  this.eachBefore(function(node) {\n\t    if (!node.children) {\n\t      leaves.push(node);\n\t    }\n\t  });\n\t  return leaves;\n\t};\n\t\n\tvar node_links = function() {\n\t  var root = this, links = [];\n\t  root.each(function(node) {\n\t    if (node !== root) { // Don’t include the root’s parent, if any.\n\t      links.push({source: node.parent, target: node});\n\t    }\n\t  });\n\t  return links;\n\t};\n\t\n\tfunction hierarchy(data, children) {\n\t  var root = new Node(data),\n\t      valued = +data.value && (root.value = data.value),\n\t      node,\n\t      nodes = [root],\n\t      child,\n\t      childs,\n\t      i,\n\t      n;\n\t\n\t  if (children == null) children = defaultChildren;\n\t\n\t  while (node = nodes.pop()) {\n\t    if (valued) node.value = +node.data.value;\n\t    if ((childs = children(node.data)) && (n = childs.length)) {\n\t      node.children = new Array(n);\n\t      for (i = n - 1; i >= 0; --i) {\n\t        nodes.push(child = node.children[i] = new Node(childs[i]));\n\t        child.parent = node;\n\t        child.depth = node.depth + 1;\n\t      }\n\t    }\n\t  }\n\t\n\t  return root.eachBefore(computeHeight);\n\t}\n\t\n\tfunction node_copy() {\n\t  return hierarchy(this).eachBefore(copyData);\n\t}\n\t\n\tfunction defaultChildren(d) {\n\t  return d.children;\n\t}\n\t\n\tfunction copyData(node) {\n\t  node.data = node.data.data;\n\t}\n\t\n\tfunction computeHeight(node) {\n\t  var height = 0;\n\t  do node.height = height;\n\t  while ((node = node.parent) && (node.height < ++height));\n\t}\n\t\n\tfunction Node(data) {\n\t  this.data = data;\n\t  this.depth =\n\t  this.height = 0;\n\t  this.parent = null;\n\t}\n\t\n\tNode.prototype = hierarchy.prototype = {\n\t  constructor: Node,\n\t  each: node_each,\n\t  eachAfter: node_eachAfter,\n\t  eachBefore: node_eachBefore,\n\t  sum: node_sum,\n\t  sort: node_sort,\n\t  path: node_path,\n\t  ancestors: node_ancestors,\n\t  descendants: node_descendants,\n\t  leaves: node_leaves,\n\t  links: node_links,\n\t  copy: node_copy\n\t};\n\t\n\tfunction Node$2(value) {\n\t  this._ = value;\n\t  this.next = null;\n\t}\n\t\n\tvar shuffle$1 = function(array) {\n\t  var i,\n\t      n = (array = array.slice()).length,\n\t      head = null,\n\t      node = head;\n\t\n\t  while (n) {\n\t    var next = new Node$2(array[n - 1]);\n\t    if (node) node = node.next = next;\n\t    else node = head = next;\n\t    array[i] = array[--n];\n\t  }\n\t\n\t  return {\n\t    head: head,\n\t    tail: node\n\t  };\n\t};\n\t\n\tvar enclose = function(circles) {\n\t  return encloseN(shuffle$1(circles), []);\n\t};\n\t\n\tfunction encloses(a, b) {\n\t  var dx = b.x - a.x,\n\t      dy = b.y - a.y,\n\t      dr = a.r - b.r;\n\t  return dr * dr + 1e-6 > dx * dx + dy * dy;\n\t}\n\t\n\t// Returns the smallest circle that contains circles L and intersects circles B.\n\tfunction encloseN(L, B) {\n\t  var circle,\n\t      l0 = null,\n\t      l1 = L.head,\n\t      l2,\n\t      p1;\n\t\n\t  switch (B.length) {\n\t    case 1: circle = enclose1(B[0]); break;\n\t    case 2: circle = enclose2(B[0], B[1]); break;\n\t    case 3: circle = enclose3(B[0], B[1], B[2]); break;\n\t  }\n\t\n\t  while (l1) {\n\t    p1 = l1._, l2 = l1.next;\n\t    if (!circle || !encloses(circle, p1)) {\n\t\n\t      // Temporarily truncate L before l1.\n\t      if (l0) L.tail = l0, l0.next = null;\n\t      else L.head = L.tail = null;\n\t\n\t      B.push(p1);\n\t      circle = encloseN(L, B); // Note: reorders L!\n\t      B.pop();\n\t\n\t      // Move l1 to the front of L and reconnect the truncated list L.\n\t      if (L.head) l1.next = L.head, L.head = l1;\n\t      else l1.next = null, L.head = L.tail = l1;\n\t      l0 = L.tail, l0.next = l2;\n\t\n\t    } else {\n\t      l0 = l1;\n\t    }\n\t    l1 = l2;\n\t  }\n\t\n\t  L.tail = l0;\n\t  return circle;\n\t}\n\t\n\tfunction enclose1(a) {\n\t  return {\n\t    x: a.x,\n\t    y: a.y,\n\t    r: a.r\n\t  };\n\t}\n\t\n\tfunction enclose2(a, b) {\n\t  var x1 = a.x, y1 = a.y, r1 = a.r,\n\t      x2 = b.x, y2 = b.y, r2 = b.r,\n\t      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,\n\t      l = Math.sqrt(x21 * x21 + y21 * y21);\n\t  return {\n\t    x: (x1 + x2 + x21 / l * r21) / 2,\n\t    y: (y1 + y2 + y21 / l * r21) / 2,\n\t    r: (l + r1 + r2) / 2\n\t  };\n\t}\n\t\n\tfunction enclose3(a, b, c) {\n\t  var x1 = a.x, y1 = a.y, r1 = a.r,\n\t      x2 = b.x, y2 = b.y, r2 = b.r,\n\t      x3 = c.x, y3 = c.y, r3 = c.r,\n\t      a2 = 2 * (x1 - x2),\n\t      b2 = 2 * (y1 - y2),\n\t      c2 = 2 * (r2 - r1),\n\t      d2 = x1 * x1 + y1 * y1 - r1 * r1 - x2 * x2 - y2 * y2 + r2 * r2,\n\t      a3 = 2 * (x1 - x3),\n\t      b3 = 2 * (y1 - y3),\n\t      c3 = 2 * (r3 - r1),\n\t      d3 = x1 * x1 + y1 * y1 - r1 * r1 - x3 * x3 - y3 * y3 + r3 * r3,\n\t      ab = a3 * b2 - a2 * b3,\n\t      xa = (b2 * d3 - b3 * d2) / ab - x1,\n\t      xb = (b3 * c2 - b2 * c3) / ab,\n\t      ya = (a3 * d2 - a2 * d3) / ab - y1,\n\t      yb = (a2 * c3 - a3 * c2) / ab,\n\t      A = xb * xb + yb * yb - 1,\n\t      B = 2 * (xa * xb + ya * yb + r1),\n\t      C = xa * xa + ya * ya - r1 * r1,\n\t      r = (-B - Math.sqrt(B * B - 4 * A * C)) / (2 * A);\n\t  return {\n\t    x: xa + xb * r + x1,\n\t    y: ya + yb * r + y1,\n\t    r: r\n\t  };\n\t}\n\t\n\tfunction place(a, b, c) {\n\t  var ax = a.x,\n\t      ay = a.y,\n\t      da = b.r + c.r,\n\t      db = a.r + c.r,\n\t      dx = b.x - ax,\n\t      dy = b.y - ay,\n\t      dc = dx * dx + dy * dy;\n\t  if (dc) {\n\t    var x = 0.5 + ((db *= db) - (da *= da)) / (2 * dc),\n\t        y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);\n\t    c.x = ax + x * dx + y * dy;\n\t    c.y = ay + x * dy - y * dx;\n\t  } else {\n\t    c.x = ax + db;\n\t    c.y = ay;\n\t  }\n\t}\n\t\n\tfunction intersects(a, b) {\n\t  var dx = b.x - a.x,\n\t      dy = b.y - a.y,\n\t      dr = a.r + b.r;\n\t  return dr * dr > dx * dx + dy * dy;\n\t}\n\t\n\tfunction distance2(circle, x, y) {\n\t  var dx = circle.x - x,\n\t      dy = circle.y - y;\n\t  return dx * dx + dy * dy;\n\t}\n\t\n\tfunction Node$1(circle) {\n\t  this._ = circle;\n\t  this.next = null;\n\t  this.previous = null;\n\t}\n\t\n\tfunction packEnclose(circles) {\n\t  if (!(n = circles.length)) return 0;\n\t\n\t  var a, b, c, n;\n\t\n\t  // Place the first circle.\n\t  a = circles[0], a.x = 0, a.y = 0;\n\t  if (!(n > 1)) return a.r;\n\t\n\t  // Place the second circle.\n\t  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;\n\t  if (!(n > 2)) return a.r + b.r;\n\t\n\t  // Place the third circle.\n\t  place(b, a, c = circles[2]);\n\t\n\t  // Initialize the weighted centroid.\n\t  var aa = a.r * a.r,\n\t      ba = b.r * b.r,\n\t      ca = c.r * c.r,\n\t      oa = aa + ba + ca,\n\t      ox = aa * a.x + ba * b.x + ca * c.x,\n\t      oy = aa * a.y + ba * b.y + ca * c.y,\n\t      cx, cy, i, j, k, sj, sk;\n\t\n\t  // Initialize the front-chain using the first three circles a, b and c.\n\t  a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);\n\t  a.next = c.previous = b;\n\t  b.next = a.previous = c;\n\t  c.next = b.previous = a;\n\t\n\t  // Attempt to place each remaining circle…\n\t  pack: for (i = 3; i < n; ++i) {\n\t    place(a._, b._, c = circles[i]), c = new Node$1(c);\n\t\n\t    // If there are only three elements in the front-chain…\n\t    if ((k = a.previous) === (j = b.next)) {\n\t      // If the new circle intersects the third circle,\n\t      // rotate the front chain to try the next position.\n\t      if (intersects(j._, c._)) {\n\t        a = b, b = j, --i;\n\t        continue pack;\n\t      }\n\t    }\n\t\n\t    // Find the closest intersecting circle on the front-chain, if any.\n\t    else {\n\t      sj = j._.r, sk = k._.r;\n\t      do {\n\t        if (sj <= sk) {\n\t          if (intersects(j._, c._)) {\n\t            b = j, a.next = b, b.previous = a, --i;\n\t            continue pack;\n\t          }\n\t          j = j.next, sj += j._.r;\n\t        } else {\n\t          if (intersects(k._, c._)) {\n\t            a = k, a.next = b, b.previous = a, --i;\n\t            continue pack;\n\t          }\n\t          k = k.previous, sk += k._.r;\n\t        }\n\t      } while (j !== k.next);\n\t    }\n\t\n\t    // Success! Insert the new circle c between a and b.\n\t    c.previous = a, c.next = b, a.next = b.previous = b = c;\n\t\n\t    // Update the weighted centroid.\n\t    oa += ca = c._.r * c._.r;\n\t    ox += ca * c._.x;\n\t    oy += ca * c._.y;\n\t\n\t    // Compute the new closest circle a to centroid.\n\t    aa = distance2(a._, cx = ox / oa, cy = oy / oa);\n\t    while ((c = c.next) !== b) {\n\t      if ((ca = distance2(c._, cx, cy)) < aa) {\n\t        a = c, aa = ca;\n\t      }\n\t    }\n\t    b = a.next;\n\t  }\n\t\n\t  // Compute the enclosing circle of the front chain.\n\t  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);\n\t\n\t  // Translate the circles to put the enclosing circle around the origin.\n\t  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;\n\t\n\t  return c.r;\n\t}\n\t\n\tvar siblings = function(circles) {\n\t  packEnclose(circles);\n\t  return circles;\n\t};\n\t\n\tfunction optional(f) {\n\t  return f == null ? null : required(f);\n\t}\n\t\n\tfunction required(f) {\n\t  if (typeof f !== \"function\") throw new Error;\n\t  return f;\n\t}\n\t\n\tfunction constantZero() {\n\t  return 0;\n\t}\n\t\n\tvar constant$6 = function(x) {\n\t  return function() {\n\t    return x;\n\t  };\n\t};\n\t\n\tfunction defaultRadius(d) {\n\t  return Math.sqrt(d.value);\n\t}\n\t\n\tvar index = function() {\n\t  var radius = null,\n\t      dx = 1,\n\t      dy = 1,\n\t      padding = constantZero;\n\t\n\t  function pack(root) {\n\t    root.x = dx / 2, root.y = dy / 2;\n\t    if (radius) {\n\t      root.eachBefore(radiusLeaf(radius))\n\t          .eachAfter(packChildren(padding, 0.5))\n\t          .eachBefore(translateChild(1));\n\t    } else {\n\t      root.eachBefore(radiusLeaf(defaultRadius))\n\t          .eachAfter(packChildren(constantZero, 1))\n\t          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))\n\t          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));\n\t    }\n\t    return root;\n\t  }\n\t\n\t  pack.radius = function(x) {\n\t    return arguments.length ? (radius = optional(x), pack) : radius;\n\t  };\n\t\n\t  pack.size = function(x) {\n\t    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];\n\t  };\n\t\n\t  pack.padding = function(x) {\n\t    return arguments.length ? (padding = typeof x === \"function\" ? x : constant$6(+x), pack) : padding;\n\t  };\n\t\n\t  return pack;\n\t};\n\t\n\tfunction radiusLeaf(radius) {\n\t  return function(node) {\n\t    if (!node.children) {\n\t      node.r = Math.max(0, +radius(node) || 0);\n\t    }\n\t  };\n\t}\n\t\n\tfunction packChildren(padding, k) {\n\t  return function(node) {\n\t    if (children = node.children) {\n\t      var children,\n\t          i,\n\t          n = children.length,\n\t          r = padding(node) * k || 0,\n\t          e;\n\t\n\t      if (r) for (i = 0; i < n; ++i) children[i].r += r;\n\t      e = packEnclose(children);\n\t      if (r) for (i = 0; i < n; ++i) children[i].r -= r;\n\t      node.r = e + r;\n\t    }\n\t  };\n\t}\n\t\n\tfunction translateChild(k) {\n\t  return function(node) {\n\t    var parent = node.parent;\n\t    node.r *= k;\n\t    if (parent) {\n\t      node.x = parent.x + k * node.x;\n\t      node.y = parent.y + k * node.y;\n\t    }\n\t  };\n\t}\n\t\n\tvar roundNode = function(node) {\n\t  node.x0 = Math.round(node.x0);\n\t  node.y0 = Math.round(node.y0);\n\t  node.x1 = Math.round(node.x1);\n\t  node.y1 = Math.round(node.y1);\n\t};\n\t\n\tvar treemapDice = function(parent, x0, y0, x1, y1) {\n\t  var nodes = parent.children,\n\t      node,\n\t      i = -1,\n\t      n = nodes.length,\n\t      k = parent.value && (x1 - x0) / parent.value;\n\t\n\t  while (++i < n) {\n\t    node = nodes[i], node.y0 = y0, node.y1 = y1;\n\t    node.x0 = x0, node.x1 = x0 += node.value * k;\n\t  }\n\t};\n\t\n\tvar partition = function() {\n\t  var dx = 1,\n\t      dy = 1,\n\t      padding = 0,\n\t      round = false;\n\t\n\t  function partition(root) {\n\t    var n = root.height + 1;\n\t    root.x0 =\n\t    root.y0 = padding;\n\t    root.x1 = dx;\n\t    root.y1 = dy / n;\n\t    root.eachBefore(positionNode(dy, n));\n\t    if (round) root.eachBefore(roundNode);\n\t    return root;\n\t  }\n\t\n\t  function positionNode(dy, n) {\n\t    return function(node) {\n\t      if (node.children) {\n\t        treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);\n\t      }\n\t      var x0 = node.x0,\n\t          y0 = node.y0,\n\t          x1 = node.x1 - padding,\n\t          y1 = node.y1 - padding;\n\t      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;\n\t      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;\n\t      node.x0 = x0;\n\t      node.y0 = y0;\n\t      node.x1 = x1;\n\t      node.y1 = y1;\n\t    };\n\t  }\n\t\n\t  partition.round = function(x) {\n\t    return arguments.length ? (round = !!x, partition) : round;\n\t  };\n\t\n\t  partition.size = function(x) {\n\t    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];\n\t  };\n\t\n\t  partition.padding = function(x) {\n\t    return arguments.length ? (padding = +x, partition) : padding;\n\t  };\n\t\n\t  return partition;\n\t};\n\t\n\tvar keyPrefix$1 = \"$\";\n\tvar preroot = {depth: -1};\n\tvar ambiguous = {};\n\t\n\tfunction defaultId(d) {\n\t  return d.id;\n\t}\n\t\n\tfunction defaultParentId(d) {\n\t  return d.parentId;\n\t}\n\t\n\tvar stratify = function() {\n\t  var id = defaultId,\n\t      parentId = defaultParentId;\n\t\n\t  function stratify(data) {\n\t    var d,\n\t        i,\n\t        n = data.length,\n\t        root,\n\t        parent,\n\t        node,\n\t        nodes = new Array(n),\n\t        nodeId,\n\t        nodeKey,\n\t        nodeByKey = {};\n\t\n\t    for (i = 0; i < n; ++i) {\n\t      d = data[i], node = nodes[i] = new Node(d);\n\t      if ((nodeId = id(d, i, data)) != null && (nodeId += \"\")) {\n\t        nodeKey = keyPrefix$1 + (node.id = nodeId);\n\t        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;\n\t      }\n\t    }\n\t\n\t    for (i = 0; i < n; ++i) {\n\t      node = nodes[i], nodeId = parentId(data[i], i, data);\n\t      if (nodeId == null || !(nodeId += \"\")) {\n\t        if (root) throw new Error(\"multiple roots\");\n\t        root = node;\n\t      } else {\n\t        parent = nodeByKey[keyPrefix$1 + nodeId];\n\t        if (!parent) throw new Error(\"missing: \" + nodeId);\n\t        if (parent === ambiguous) throw new Error(\"ambiguous: \" + nodeId);\n\t        if (parent.children) parent.children.push(node);\n\t        else parent.children = [node];\n\t        node.parent = parent;\n\t      }\n\t    }\n\t\n\t    if (!root) throw new Error(\"no root\");\n\t    root.parent = preroot;\n\t    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);\n\t    root.parent = null;\n\t    if (n > 0) throw new Error(\"cycle\");\n\t\n\t    return root;\n\t  }\n\t\n\t  stratify.id = function(x) {\n\t    return arguments.length ? (id = required(x), stratify) : id;\n\t  };\n\t\n\t  stratify.parentId = function(x) {\n\t    return arguments.length ? (parentId = required(x), stratify) : parentId;\n\t  };\n\t\n\t  return stratify;\n\t};\n\t\n\tfunction defaultSeparation$1(a, b) {\n\t  return a.parent === b.parent ? 1 : 2;\n\t}\n\t\n\t// function radialSeparation(a, b) {\n\t//   return (a.parent === b.parent ? 1 : 2) / a.depth;\n\t// }\n\t\n\t// This function is used to traverse the left contour of a subtree (or\n\t// subforest). It returns the successor of v on this contour. This successor is\n\t// either given by the leftmost child of v or by the thread of v. The function\n\t// returns null if and only if v is on the highest level of its subtree.\n\tfunction nextLeft(v) {\n\t  var children = v.children;\n\t  return children ? children[0] : v.t;\n\t}\n\t\n\t// This function works analogously to nextLeft.\n\tfunction nextRight(v) {\n\t  var children = v.children;\n\t  return children ? children[children.length - 1] : v.t;\n\t}\n\t\n\t// Shifts the current subtree rooted at w+. This is done by increasing\n\t// prelim(w+) and mod(w+) by shift.\n\tfunction moveSubtree(wm, wp, shift) {\n\t  var change = shift / (wp.i - wm.i);\n\t  wp.c -= change;\n\t  wp.s += shift;\n\t  wm.c += change;\n\t  wp.z += shift;\n\t  wp.m += shift;\n\t}\n\t\n\t// All other shifts, applied to the smaller subtrees between w- and w+, are\n\t// performed by this function. To prepare the shifts, we have to adjust\n\t// change(w+), shift(w+), and change(w-).\n\tfunction executeShifts(v) {\n\t  var shift = 0,\n\t      change = 0,\n\t      children = v.children,\n\t      i = children.length,\n\t      w;\n\t  while (--i >= 0) {\n\t    w = children[i];\n\t    w.z += shift;\n\t    w.m += shift;\n\t    shift += w.s + (change += w.c);\n\t  }\n\t}\n\t\n\t// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,\n\t// returns the specified (default) ancestor.\n\tfunction nextAncestor(vim, v, ancestor) {\n\t  return vim.a.parent === v.parent ? vim.a : ancestor;\n\t}\n\t\n\tfunction TreeNode(node, i) {\n\t  this._ = node;\n\t  this.parent = null;\n\t  this.children = null;\n\t  this.A = null; // default ancestor\n\t  this.a = this; // ancestor\n\t  this.z = 0; // prelim\n\t  this.m = 0; // mod\n\t  this.c = 0; // change\n\t  this.s = 0; // shift\n\t  this.t = null; // thread\n\t  this.i = i; // number\n\t}\n\t\n\tTreeNode.prototype = Object.create(Node.prototype);\n\t\n\tfunction treeRoot(root) {\n\t  var tree = new TreeNode(root, 0),\n\t      node,\n\t      nodes = [tree],\n\t      child,\n\t      children,\n\t      i,\n\t      n;\n\t\n\t  while (node = nodes.pop()) {\n\t    if (children = node._.children) {\n\t      node.children = new Array(n = children.length);\n\t      for (i = n - 1; i >= 0; --i) {\n\t        nodes.push(child = node.children[i] = new TreeNode(children[i], i));\n\t        child.parent = node;\n\t      }\n\t    }\n\t  }\n\t\n\t  (tree.parent = new TreeNode(null, 0)).children = [tree];\n\t  return tree;\n\t}\n\t\n\t// Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\n\tvar tree = function() {\n\t  var separation = defaultSeparation$1,\n\t      dx = 1,\n\t      dy = 1,\n\t      nodeSize = null;\n\t\n\t  function tree(root) {\n\t    var t = treeRoot(root);\n\t\n\t    // Compute the layout using Buchheim et al.’s algorithm.\n\t    t.eachAfter(firstWalk), t.parent.m = -t.z;\n\t    t.eachBefore(secondWalk);\n\t\n\t    // If a fixed node size is specified, scale x and y.\n\t    if (nodeSize) root.eachBefore(sizeNode);\n\t\n\t    // If a fixed tree size is specified, scale x and y based on the extent.\n\t    // Compute the left-most, right-most, and depth-most nodes for extents.\n\t    else {\n\t      var left = root,\n\t          right = root,\n\t          bottom = root;\n\t      root.eachBefore(function(node) {\n\t        if (node.x < left.x) left = node;\n\t        if (node.x > right.x) right = node;\n\t        if (node.depth > bottom.depth) bottom = node;\n\t      });\n\t      var s = left === right ? 1 : separation(left, right) / 2,\n\t          tx = s - left.x,\n\t          kx = dx / (right.x + s + tx),\n\t          ky = dy / (bottom.depth || 1);\n\t      root.eachBefore(function(node) {\n\t        node.x = (node.x + tx) * kx;\n\t        node.y = node.depth * ky;\n\t      });\n\t    }\n\t\n\t    return root;\n\t  }\n\t\n\t  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is\n\t  // applied recursively to the children of v, as well as the function\n\t  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the\n\t  // node v is placed to the midpoint of its outermost children.\n\t  function firstWalk(v) {\n\t    var children = v.children,\n\t        siblings = v.parent.children,\n\t        w = v.i ? siblings[v.i - 1] : null;\n\t    if (children) {\n\t      executeShifts(v);\n\t      var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n\t      if (w) {\n\t        v.z = w.z + separation(v._, w._);\n\t        v.m = v.z - midpoint;\n\t      } else {\n\t        v.z = midpoint;\n\t      }\n\t    } else if (w) {\n\t      v.z = w.z + separation(v._, w._);\n\t    }\n\t    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n\t  }\n\t\n\t  // Computes all real x-coordinates by summing up the modifiers recursively.\n\t  function secondWalk(v) {\n\t    v._.x = v.z + v.parent.m;\n\t    v.m += v.parent.m;\n\t  }\n\t\n\t  // The core of the algorithm. Here, a new subtree is combined with the\n\t  // previous subtrees. Threads are used to traverse the inside and outside\n\t  // contours of the left and right subtree up to the highest common level. The\n\t  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the\n\t  // superscript o means outside and i means inside, the subscript - means left\n\t  // subtree and + means right subtree. For summing up the modifiers along the\n\t  // contour, we use respective variables si+, si-, so-, and so+. Whenever two\n\t  // nodes of the inside contours conflict, we compute the left one of the\n\t  // greatest uncommon ancestors using the function ANCESTOR and call MOVE\n\t  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.\n\t  // Finally, we add a new thread (if necessary).\n\t  function apportion(v, w, ancestor) {\n\t    if (w) {\n\t      var vip = v,\n\t          vop = v,\n\t          vim = w,\n\t          vom = vip.parent.children[0],\n\t          sip = vip.m,\n\t          sop = vop.m,\n\t          sim = vim.m,\n\t          som = vom.m,\n\t          shift;\n\t      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\n\t        vom = nextLeft(vom);\n\t        vop = nextRight(vop);\n\t        vop.a = v;\n\t        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n\t        if (shift > 0) {\n\t          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);\n\t          sip += shift;\n\t          sop += shift;\n\t        }\n\t        sim += vim.m;\n\t        sip += vip.m;\n\t        som += vom.m;\n\t        sop += vop.m;\n\t      }\n\t      if (vim && !nextRight(vop)) {\n\t        vop.t = vim;\n\t        vop.m += sim - sop;\n\t      }\n\t      if (vip && !nextLeft(vom)) {\n\t        vom.t = vip;\n\t        vom.m += sip - som;\n\t        ancestor = v;\n\t      }\n\t    }\n\t    return ancestor;\n\t  }\n\t\n\t  function sizeNode(node) {\n\t    node.x *= dx;\n\t    node.y = node.depth * dy;\n\t  }\n\t\n\t  tree.separation = function(x) {\n\t    return arguments.length ? (separation = x, tree) : separation;\n\t  };\n\t\n\t  tree.size = function(x) {\n\t    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);\n\t  };\n\t\n\t  tree.nodeSize = function(x) {\n\t    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);\n\t  };\n\t\n\t  return tree;\n\t};\n\t\n\tvar treemapSlice = function(parent, x0, y0, x1, y1) {\n\t  var nodes = parent.children,\n\t      node,\n\t      i = -1,\n\t      n = nodes.length,\n\t      k = parent.value && (y1 - y0) / parent.value;\n\t\n\t  while (++i < n) {\n\t    node = nodes[i], node.x0 = x0, node.x1 = x1;\n\t    node.y0 = y0, node.y1 = y0 += node.value * k;\n\t  }\n\t};\n\t\n\tvar phi = (1 + Math.sqrt(5)) / 2;\n\t\n\tfunction squarifyRatio(ratio, parent, x0, y0, x1, y1) {\n\t  var rows = [],\n\t      nodes = parent.children,\n\t      row,\n\t      nodeValue,\n\t      i0 = 0,\n\t      i1,\n\t      n = nodes.length,\n\t      dx, dy,\n\t      value = parent.value,\n\t      sumValue,\n\t      minValue,\n\t      maxValue,\n\t      newRatio,\n\t      minRatio,\n\t      alpha,\n\t      beta;\n\t\n\t  while (i0 < n) {\n\t    dx = x1 - x0, dy = y1 - y0;\n\t    minValue = maxValue = sumValue = nodes[i0].value;\n\t    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n\t    beta = sumValue * sumValue * alpha;\n\t    minRatio = Math.max(maxValue / beta, beta / minValue);\n\t\n\t    // Keep adding nodes while the aspect ratio maintains or improves.\n\t    for (i1 = i0 + 1; i1 < n; ++i1) {\n\t      sumValue += nodeValue = nodes[i1].value;\n\t      if (nodeValue < minValue) minValue = nodeValue;\n\t      if (nodeValue > maxValue) maxValue = nodeValue;\n\t      beta = sumValue * sumValue * alpha;\n\t      newRatio = Math.max(maxValue / beta, beta / minValue);\n\t      if (newRatio > minRatio) { sumValue -= nodeValue; break; }\n\t      minRatio = newRatio;\n\t    }\n\t\n\t    // Position and record the row orientation.\n\t    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});\n\t    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);\n\t    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);\n\t    value -= sumValue, i0 = i1;\n\t  }\n\t\n\t  return rows;\n\t}\n\t\n\tvar squarify = (function custom(ratio) {\n\t\n\t  function squarify(parent, x0, y0, x1, y1) {\n\t    squarifyRatio(ratio, parent, x0, y0, x1, y1);\n\t  }\n\t\n\t  squarify.ratio = function(x) {\n\t    return custom((x = +x) > 1 ? x : 1);\n\t  };\n\t\n\t  return squarify;\n\t})(phi);\n\t\n\tvar index$1 = function() {\n\t  var tile = squarify,\n\t      round = false,\n\t      dx = 1,\n\t      dy = 1,\n\t      paddingStack = [0],\n\t      paddingInner = constantZero,\n\t      paddingTop = constantZero,\n\t      paddingRight = constantZero,\n\t      paddingBottom = constantZero,\n\t      paddingLeft = constantZero;\n\t\n\t  function treemap(root) {\n\t    root.x0 =\n\t    root.y0 = 0;\n\t    root.x1 = dx;\n\t    root.y1 = dy;\n\t    root.eachBefore(positionNode);\n\t    paddingStack = [0];\n\t    if (round) root.eachBefore(roundNode);\n\t    return root;\n\t  }\n\t\n\t  function positionNode(node) {\n\t    var p = paddingStack[node.depth],\n\t        x0 = node.x0 + p,\n\t        y0 = node.y0 + p,\n\t        x1 = node.x1 - p,\n\t        y1 = node.y1 - p;\n\t    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;\n\t    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;\n\t    node.x0 = x0;\n\t    node.y0 = y0;\n\t    node.x1 = x1;\n\t    node.y1 = y1;\n\t    if (node.children) {\n\t      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;\n\t      x0 += paddingLeft(node) - p;\n\t      y0 += paddingTop(node) - p;\n\t      x1 -= paddingRight(node) - p;\n\t      y1 -= paddingBottom(node) - p;\n\t      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;\n\t      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;\n\t      tile(node, x0, y0, x1, y1);\n\t    }\n\t  }\n\t\n\t  treemap.round = function(x) {\n\t    return arguments.length ? (round = !!x, treemap) : round;\n\t  };\n\t\n\t  treemap.size = function(x) {\n\t    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];\n\t  };\n\t\n\t  treemap.tile = function(x) {\n\t    return arguments.length ? (tile = required(x), treemap) : tile;\n\t  };\n\t\n\t  treemap.padding = function(x) {\n\t    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();\n\t  };\n\t\n\t  treemap.paddingInner = function(x) {\n\t    return arguments.length ? (paddingInner = typeof x === \"function\" ? x : constant$6(+x), treemap) : paddingInner;\n\t  };\n\t\n\t  treemap.paddingOuter = function(x) {\n\t    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();\n\t  };\n\t\n\t  treemap.paddingTop = function(x) {\n\t    return arguments.length ? (paddingTop = typeof x === \"function\" ? x : constant$6(+x), treemap) : paddingTop;\n\t  };\n\t\n\t  treemap.paddingRight = function(x) {\n\t    return arguments.length ? (paddingRight = typeof x === \"function\" ? x : constant$6(+x), treemap) : paddingRight;\n\t  };\n\t\n\t  treemap.paddingBottom = function(x) {\n\t    return arguments.length ? (paddingBottom = typeof x === \"function\" ? x : constant$6(+x), treemap) : paddingBottom;\n\t  };\n\t\n\t  treemap.paddingLeft = function(x) {\n\t    return arguments.length ? (paddingLeft = typeof x === \"function\" ? x : constant$6(+x), treemap) : paddingLeft;\n\t  };\n\t\n\t  return treemap;\n\t};\n\t\n\tvar binary = function(parent, x0, y0, x1, y1) {\n\t  var nodes = parent.children,\n\t      i, n = nodes.length,\n\t      sum, sums = new Array(n + 1);\n\t\n\t  for (sums[0] = sum = i = 0; i < n; ++i) {\n\t    sums[i + 1] = sum += nodes[i].value;\n\t  }\n\t\n\t  partition(0, n, parent.value, x0, y0, x1, y1);\n\t\n\t  function partition(i, j, value, x0, y0, x1, y1) {\n\t    if (i >= j - 1) {\n\t      var node = nodes[i];\n\t      node.x0 = x0, node.y0 = y0;\n\t      node.x1 = x1, node.y1 = y1;\n\t      return;\n\t    }\n\t\n\t    var valueOffset = sums[i],\n\t        valueTarget = (value / 2) + valueOffset,\n\t        k = i + 1,\n\t        hi = j - 1;\n\t\n\t    while (k < hi) {\n\t      var mid = k + hi >>> 1;\n\t      if (sums[mid] < valueTarget) k = mid + 1;\n\t      else hi = mid;\n\t    }\n\t\n\t    var valueLeft = sums[k] - valueOffset,\n\t        valueRight = value - valueLeft;\n\t\n\t    if ((y1 - y0) > (x1 - x0)) {\n\t      var yk = (y0 * valueRight + y1 * valueLeft) / value;\n\t      partition(i, k, valueLeft, x0, y0, x1, yk);\n\t      partition(k, j, valueRight, x0, yk, x1, y1);\n\t    } else {\n\t      var xk = (x0 * valueRight + x1 * valueLeft) / value;\n\t      partition(i, k, valueLeft, x0, y0, xk, y1);\n\t      partition(k, j, valueRight, xk, y0, x1, y1);\n\t    }\n\t  }\n\t};\n\t\n\tvar sliceDice = function(parent, x0, y0, x1, y1) {\n\t  (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);\n\t};\n\t\n\tvar resquarify = (function custom(ratio) {\n\t\n\t  function resquarify(parent, x0, y0, x1, y1) {\n\t    if ((rows = parent._squarify) && (rows.ratio === ratio)) {\n\t      var rows,\n\t          row,\n\t          nodes,\n\t          i,\n\t          j = -1,\n\t          n,\n\t          m = rows.length,\n\t          value = parent.value;\n\t\n\t      while (++j < m) {\n\t        row = rows[j], nodes = row.children;\n\t        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;\n\t        if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);\n\t        else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);\n\t        value -= row.value;\n\t      }\n\t    } else {\n\t      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);\n\t      rows.ratio = ratio;\n\t    }\n\t  }\n\t\n\t  resquarify.ratio = function(x) {\n\t    return custom((x = +x) > 1 ? x : 1);\n\t  };\n\t\n\t  return resquarify;\n\t})(phi);\n\t\n\tvar center$1 = function(x, y) {\n\t  var nodes;\n\t\n\t  if (x == null) x = 0;\n\t  if (y == null) y = 0;\n\t\n\t  function force() {\n\t    var i,\n\t        n = nodes.length,\n\t        node,\n\t        sx = 0,\n\t        sy = 0;\n\t\n\t    for (i = 0; i < n; ++i) {\n\t      node = nodes[i], sx += node.x, sy += node.y;\n\t    }\n\t\n\t    for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {\n\t      node = nodes[i], node.x -= sx, node.y -= sy;\n\t    }\n\t  }\n\t\n\t  force.initialize = function(_) {\n\t    nodes = _;\n\t  };\n\t\n\t  force.x = function(_) {\n\t    return arguments.length ? (x = +_, force) : x;\n\t  };\n\t\n\t  force.y = function(_) {\n\t    return arguments.length ? (y = +_, force) : y;\n\t  };\n\t\n\t  return force;\n\t};\n\t\n\tvar constant$7 = function(x) {\n\t  return function() {\n\t    return x;\n\t  };\n\t};\n\t\n\tvar jiggle = function() {\n\t  return (Math.random() - 0.5) * 1e-6;\n\t};\n\t\n\tfunction x$1(d) {\n\t  return d.x + d.vx;\n\t}\n\t\n\tfunction y$1(d) {\n\t  return d.y + d.vy;\n\t}\n\t\n\tvar collide = function(radius) {\n\t  var nodes,\n\t      radii,\n\t      strength = 1,\n\t      iterations = 1;\n\t\n\t  if (typeof radius !== \"function\") radius = constant$7(radius == null ? 1 : +radius);\n\t\n\t  function force() {\n\t    var i, n = nodes.length,\n\t        tree,\n\t        node,\n\t        xi,\n\t        yi,\n\t        ri,\n\t        ri2;\n\t\n\t    for (var k = 0; k < iterations; ++k) {\n\t      tree = quadtree(nodes, x$1, y$1).visitAfter(prepare);\n\t      for (i = 0; i < n; ++i) {\n\t        node = nodes[i];\n\t        ri = radii[i], ri2 = ri * ri;\n\t        xi = node.x + node.vx;\n\t        yi = node.y + node.vy;\n\t        tree.visit(apply);\n\t      }\n\t    }\n\t\n\t    function apply(quad, x0, y0, x1, y1) {\n\t      var data = quad.data, rj = quad.r, r = ri + rj;\n\t      if (data) {\n\t        if (data.index > i) {\n\t          var x = xi - data.x - data.vx,\n\t              y = yi - data.y - data.vy,\n\t              l = x * x + y * y;\n\t          if (l < r * r) {\n\t            if (x === 0) x = jiggle(), l += x * x;\n\t            if (y === 0) y = jiggle(), l += y * y;\n\t            l = (r - (l = Math.sqrt(l))) / l * strength;\n\t            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));\n\t            node.vy += (y *= l) * r;\n\t            data.vx -= x * (r = 1 - r);\n\t            data.vy -= y * r;\n\t          }\n\t        }\n\t        return;\n\t      }\n\t      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;\n\t    }\n\t  }\n\t\n\t  function prepare(quad) {\n\t    if (quad.data) return quad.r = radii[quad.data.index];\n\t    for (var i = quad.r = 0; i < 4; ++i) {\n\t      if (quad[i] && quad[i].r > quad.r) {\n\t        quad.r = quad[i].r;\n\t      }\n\t    }\n\t  }\n\t\n\t  function initialize() {\n\t    if (!nodes) return;\n\t    var i, n = nodes.length;\n\t    radii = new Array(n);\n\t    for (i = 0; i < n; ++i) radii[i] = +radius(nodes[i], i, nodes);\n\t  }\n\t\n\t  force.initialize = function(_) {\n\t    nodes = _;\n\t    initialize();\n\t  };\n\t\n\t  force.iterations = function(_) {\n\t    return arguments.length ? (iterations = +_, force) : iterations;\n\t  };\n\t\n\t  force.strength = function(_) {\n\t    return arguments.length ? (strength = +_, force) : strength;\n\t  };\n\t\n\t  force.radius = function(_) {\n\t    return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant$7(+_), initialize(), force) : radius;\n\t  };\n\t\n\t  return force;\n\t};\n\t\n\tfunction index$2(d, i) {\n\t  return i;\n\t}\n\t\n\tfunction find(nodeById, nodeId) {\n\t  var node = nodeById.get(nodeId);\n\t  if (!node) throw new Error(\"missing: \" + nodeId);\n\t  return node;\n\t}\n\t\n\tvar link = function(links) {\n\t  var id = index$2,\n\t      strength = defaultStrength,\n\t      strengths,\n\t      distance = constant$7(30),\n\t      distances,\n\t      nodes,\n\t      count,\n\t      bias,\n\t      iterations = 1;\n\t\n\t  if (links == null) links = [];\n\t\n\t  function defaultStrength(link) {\n\t    return 1 / Math.min(count[link.source.index], count[link.target.index]);\n\t  }\n\t\n\t  function force(alpha) {\n\t    for (var k = 0, n = links.length; k < iterations; ++k) {\n\t      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {\n\t        link = links[i], source = link.source, target = link.target;\n\t        x = target.x + target.vx - source.x - source.vx || jiggle();\n\t        y = target.y + target.vy - source.y - source.vy || jiggle();\n\t        l = Math.sqrt(x * x + y * y);\n\t        l = (l - distances[i]) / l * alpha * strengths[i];\n\t        x *= l, y *= l;\n\t        target.vx -= x * (b = bias[i]);\n\t        target.vy -= y * b;\n\t        source.vx += x * (b = 1 - b);\n\t        source.vy += y * b;\n\t      }\n\t    }\n\t  }\n\t\n\t  function initialize() {\n\t    if (!nodes) return;\n\t\n\t    var i,\n\t        n = nodes.length,\n\t        m = links.length,\n\t        nodeById = map$1(nodes, id),\n\t        link;\n\t\n\t    for (i = 0, count = new Array(n); i < n; ++i) {\n\t      count[i] = 0;\n\t    }\n\t\n\t    for (i = 0; i < m; ++i) {\n\t      link = links[i], link.index = i;\n\t      if (typeof link.source !== \"object\") link.source = find(nodeById, link.source);\n\t      if (typeof link.target !== \"object\") link.target = find(nodeById, link.target);\n\t      ++count[link.source.index], ++count[link.target.index];\n\t    }\n\t\n\t    for (i = 0, bias = new Array(m); i < m; ++i) {\n\t      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);\n\t    }\n\t\n\t    strengths = new Array(m), initializeStrength();\n\t    distances = new Array(m), initializeDistance();\n\t  }\n\t\n\t  function initializeStrength() {\n\t    if (!nodes) return;\n\t\n\t    for (var i = 0, n = links.length; i < n; ++i) {\n\t      strengths[i] = +strength(links[i], i, links);\n\t    }\n\t  }\n\t\n\t  function initializeDistance() {\n\t    if (!nodes) return;\n\t\n\t    for (var i = 0, n = links.length; i < n; ++i) {\n\t      distances[i] = +distance(links[i], i, links);\n\t    }\n\t  }\n\t\n\t  force.initialize = function(_) {\n\t    nodes = _;\n\t    initialize();\n\t  };\n\t\n\t  force.links = function(_) {\n\t    return arguments.length ? (links = _, initialize(), force) : links;\n\t  };\n\t\n\t  force.id = function(_) {\n\t    return arguments.length ? (id = _, force) : id;\n\t  };\n\t\n\t  force.iterations = function(_) {\n\t    return arguments.length ? (iterations = +_, force) : iterations;\n\t  };\n\t\n\t  force.strength = function(_) {\n\t    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant$7(+_), initializeStrength(), force) : strength;\n\t  };\n\t\n\t  force.distance = function(_) {\n\t    return arguments.length ? (distance = typeof _ === \"function\" ? _ : constant$7(+_), initializeDistance(), force) : distance;\n\t  };\n\t\n\t  return force;\n\t};\n\t\n\tfunction x$2(d) {\n\t  return d.x;\n\t}\n\t\n\tfunction y$2(d) {\n\t  return d.y;\n\t}\n\t\n\tvar initialRadius = 10;\n\tvar initialAngle = Math.PI * (3 - Math.sqrt(5));\n\t\n\tvar simulation = function(nodes) {\n\t  var simulation,\n\t      alpha = 1,\n\t      alphaMin = 0.001,\n\t      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),\n\t      alphaTarget = 0,\n\t      velocityDecay = 0.6,\n\t      forces = map$1(),\n\t      stepper = timer(step),\n\t      event = dispatch(\"tick\", \"end\");\n\t\n\t  if (nodes == null) nodes = [];\n\t\n\t  function step() {\n\t    tick();\n\t    event.call(\"tick\", simulation);\n\t    if (alpha < alphaMin) {\n\t      stepper.stop();\n\t      event.call(\"end\", simulation);\n\t    }\n\t  }\n\t\n\t  function tick() {\n\t    var i, n = nodes.length, node;\n\t\n\t    alpha += (alphaTarget - alpha) * alphaDecay;\n\t\n\t    forces.each(function(force) {\n\t      force(alpha);\n\t    });\n\t\n\t    for (i = 0; i < n; ++i) {\n\t      node = nodes[i];\n\t      if (node.fx == null) node.x += node.vx *= velocityDecay;\n\t      else node.x = node.fx, node.vx = 0;\n\t      if (node.fy == null) node.y += node.vy *= velocityDecay;\n\t      else node.y = node.fy, node.vy = 0;\n\t    }\n\t  }\n\t\n\t  function initializeNodes() {\n\t    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n\t      node = nodes[i], node.index = i;\n\t      if (isNaN(node.x) || isNaN(node.y)) {\n\t        var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;\n\t        node.x = radius * Math.cos(angle);\n\t        node.y = radius * Math.sin(angle);\n\t      }\n\t      if (isNaN(node.vx) || isNaN(node.vy)) {\n\t        node.vx = node.vy = 0;\n\t      }\n\t    }\n\t  }\n\t\n\t  function initializeForce(force) {\n\t    if (force.initialize) force.initialize(nodes);\n\t    return force;\n\t  }\n\t\n\t  initializeNodes();\n\t\n\t  return simulation = {\n\t    tick: tick,\n\t\n\t    restart: function() {\n\t      return stepper.restart(step), simulation;\n\t    },\n\t\n\t    stop: function() {\n\t      return stepper.stop(), simulation;\n\t    },\n\t\n\t    nodes: function(_) {\n\t      return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;\n\t    },\n\t\n\t    alpha: function(_) {\n\t      return arguments.length ? (alpha = +_, simulation) : alpha;\n\t    },\n\t\n\t    alphaMin: function(_) {\n\t      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;\n\t    },\n\t\n\t    alphaDecay: function(_) {\n\t      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;\n\t    },\n\t\n\t    alphaTarget: function(_) {\n\t      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;\n\t    },\n\t\n\t    velocityDecay: function(_) {\n\t      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;\n\t    },\n\t\n\t    force: function(name, _) {\n\t      return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);\n\t    },\n\t\n\t    find: function(x, y, radius) {\n\t      var i = 0,\n\t          n = nodes.length,\n\t          dx,\n\t          dy,\n\t          d2,\n\t          node,\n\t          closest;\n\t\n\t      if (radius == null) radius = Infinity;\n\t      else radius *= radius;\n\t\n\t      for (i = 0; i < n; ++i) {\n\t        node = nodes[i];\n\t        dx = x - node.x;\n\t        dy = y - node.y;\n\t        d2 = dx * dx + dy * dy;\n\t        if (d2 < radius) closest = node, radius = d2;\n\t      }\n\t\n\t      return closest;\n\t    },\n\t\n\t    on: function(name, _) {\n\t      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);\n\t    }\n\t  };\n\t};\n\t\n\tvar manyBody = function() {\n\t  var nodes,\n\t      node,\n\t      alpha,\n\t      strength = constant$7(-30),\n\t      strengths,\n\t      distanceMin2 = 1,\n\t      distanceMax2 = Infinity,\n\t      theta2 = 0.81;\n\t\n\t  function force(_) {\n\t    var i, n = nodes.length, tree = quadtree(nodes, x$2, y$2).visitAfter(accumulate);\n\t    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);\n\t  }\n\t\n\t  function initialize() {\n\t    if (!nodes) return;\n\t    var i, n = nodes.length;\n\t    strengths = new Array(n);\n\t    for (i = 0; i < n; ++i) strengths[i] = +strength(nodes[i], i, nodes);\n\t  }\n\t\n\t  function accumulate(quad) {\n\t    var strength = 0, q, c, x$$1, y$$1, i;\n\t\n\t    // For internal nodes, accumulate forces from child quadrants.\n\t    if (quad.length) {\n\t      for (x$$1 = y$$1 = i = 0; i < 4; ++i) {\n\t        if ((q = quad[i]) && (c = q.value)) {\n\t          strength += c, x$$1 += c * q.x, y$$1 += c * q.y;\n\t        }\n\t      }\n\t      quad.x = x$$1 / strength;\n\t      quad.y = y$$1 / strength;\n\t    }\n\t\n\t    // For leaf nodes, accumulate forces from coincident quadrants.\n\t    else {\n\t      q = quad;\n\t      q.x = q.data.x;\n\t      q.y = q.data.y;\n\t      do strength += strengths[q.data.index];\n\t      while (q = q.next);\n\t    }\n\t\n\t    quad.value = strength;\n\t  }\n\t\n\t  function apply(quad, x1, _, x2) {\n\t    if (!quad.value) return true;\n\t\n\t    var x$$1 = quad.x - node.x,\n\t        y$$1 = quad.y - node.y,\n\t        w = x2 - x1,\n\t        l = x$$1 * x$$1 + y$$1 * y$$1;\n\t\n\t    // Apply the Barnes-Hut approximation if possible.\n\t    // Limit forces for very close nodes; randomize direction if coincident.\n\t    if (w * w / theta2 < l) {\n\t      if (l < distanceMax2) {\n\t        if (x$$1 === 0) x$$1 = jiggle(), l += x$$1 * x$$1;\n\t        if (y$$1 === 0) y$$1 = jiggle(), l += y$$1 * y$$1;\n\t        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n\t        node.vx += x$$1 * quad.value * alpha / l;\n\t        node.vy += y$$1 * quad.value * alpha / l;\n\t      }\n\t      return true;\n\t    }\n\t\n\t    // Otherwise, process points directly.\n\t    else if (quad.length || l >= distanceMax2) return;\n\t\n\t    // Limit forces for very close nodes; randomize direction if coincident.\n\t    if (quad.data !== node || quad.next) {\n\t      if (x$$1 === 0) x$$1 = jiggle(), l += x$$1 * x$$1;\n\t      if (y$$1 === 0) y$$1 = jiggle(), l += y$$1 * y$$1;\n\t      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n\t    }\n\t\n\t    do if (quad.data !== node) {\n\t      w = strengths[quad.data.index] * alpha / l;\n\t      node.vx += x$$1 * w;\n\t      node.vy += y$$1 * w;\n\t    } while (quad = quad.next);\n\t  }\n\t\n\t  force.initialize = function(_) {\n\t    nodes = _;\n\t    initialize();\n\t  };\n\t\n\t  force.strength = function(_) {\n\t    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant$7(+_), initialize(), force) : strength;\n\t  };\n\t\n\t  force.distanceMin = function(_) {\n\t    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);\n\t  };\n\t\n\t  force.distanceMax = function(_) {\n\t    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);\n\t  };\n\t\n\t  force.theta = function(_) {\n\t    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);\n\t  };\n\t\n\t  return force;\n\t};\n\t\n\tvar x$3 = function(x) {\n\t  var strength = constant$7(0.1),\n\t      nodes,\n\t      strengths,\n\t      xz;\n\t\n\t  if (typeof x !== \"function\") x = constant$7(x == null ? 0 : +x);\n\t\n\t  function force(alpha) {\n\t    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n\t      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;\n\t    }\n\t  }\n\t\n\t  function initialize() {\n\t    if (!nodes) return;\n\t    var i, n = nodes.length;\n\t    strengths = new Array(n);\n\t    xz = new Array(n);\n\t    for (i = 0; i < n; ++i) {\n\t      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n\t    }\n\t  }\n\t\n\t  force.initialize = function(_) {\n\t    nodes = _;\n\t    initialize();\n\t  };\n\t\n\t  force.strength = function(_) {\n\t    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant$7(+_), initialize(), force) : strength;\n\t  };\n\t\n\t  force.x = function(_) {\n\t    return arguments.length ? (x = typeof _ === \"function\" ? _ : constant$7(+_), initialize(), force) : x;\n\t  };\n\t\n\t  return force;\n\t};\n\t\n\tvar y$3 = function(y) {\n\t  var strength = constant$7(0.1),\n\t      nodes,\n\t      strengths,\n\t      yz;\n\t\n\t  if (typeof y !== \"function\") y = constant$7(y == null ? 0 : +y);\n\t\n\t  function force(alpha) {\n\t    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n\t      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;\n\t    }\n\t  }\n\t\n\t  function initialize() {\n\t    if (!nodes) return;\n\t    var i, n = nodes.length;\n\t    strengths = new Array(n);\n\t    yz = new Array(n);\n\t    for (i = 0; i < n; ++i) {\n\t      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n\t    }\n\t  }\n\t\n\t  force.initialize = function(_) {\n\t    nodes = _;\n\t    initialize();\n\t  };\n\t\n\t  force.strength = function(_) {\n\t    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant$7(+_), initialize(), force) : strength;\n\t  };\n\t\n\t  force.y = function(_) {\n\t    return arguments.length ? (y = typeof _ === \"function\" ? _ : constant$7(+_), initialize(), force) : y;\n\t  };\n\t\n\t  return force;\n\t};\n\t\n\tfunction nopropagation() {\n\t  exports.event.stopImmediatePropagation();\n\t}\n\t\n\tvar noevent = function() {\n\t  exports.event.preventDefault();\n\t  exports.event.stopImmediatePropagation();\n\t};\n\t\n\tvar dragDisable = function(view) {\n\t  var root = view.document.documentElement,\n\t      selection$$1 = select(view).on(\"dragstart.drag\", noevent, true);\n\t  if (\"onselectstart\" in root) {\n\t    selection$$1.on(\"selectstart.drag\", noevent, true);\n\t  } else {\n\t    root.__noselect = root.style.MozUserSelect;\n\t    root.style.MozUserSelect = \"none\";\n\t  }\n\t};\n\t\n\tfunction yesdrag(view, noclick) {\n\t  var root = view.document.documentElement,\n\t      selection$$1 = select(view).on(\"dragstart.drag\", null);\n\t  if (noclick) {\n\t    selection$$1.on(\"click.drag\", noevent, true);\n\t    setTimeout(function() { selection$$1.on(\"click.drag\", null); }, 0);\n\t  }\n\t  if (\"onselectstart\" in root) {\n\t    selection$$1.on(\"selectstart.drag\", null);\n\t  } else {\n\t    root.style.MozUserSelect = root.__noselect;\n\t    delete root.__noselect;\n\t  }\n\t}\n\t\n\tvar constant$8 = function(x) {\n\t  return function() {\n\t    return x;\n\t  };\n\t};\n\t\n\tfunction DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {\n\t  this.target = target;\n\t  this.type = type;\n\t  this.subject = subject;\n\t  this.identifier = id;\n\t  this.active = active;\n\t  this.x = x;\n\t  this.y = y;\n\t  this.dx = dx;\n\t  this.dy = dy;\n\t  this._ = dispatch;\n\t}\n\t\n\tDragEvent.prototype.on = function() {\n\t  var value = this._.on.apply(this._, arguments);\n\t  return value === this._ ? this : value;\n\t};\n\t\n\t// Ignore right-click, since that should open the context menu.\n\tfunction defaultFilter() {\n\t  return !exports.event.button;\n\t}\n\t\n\tfunction defaultContainer() {\n\t  return this.parentNode;\n\t}\n\t\n\tfunction defaultSubject(d) {\n\t  return d == null ? {x: exports.event.x, y: exports.event.y} : d;\n\t}\n\t\n\tvar drag = function() {\n\t  var filter = defaultFilter,\n\t      container = defaultContainer,\n\t      subject = defaultSubject,\n\t      gestures = {},\n\t      listeners = dispatch(\"start\", \"drag\", \"end\"),\n\t      active = 0,\n\t      mousemoving,\n\t      touchending;\n\t\n\t  function drag(selection$$1) {\n\t    selection$$1\n\t        .on(\"mousedown.drag\", mousedowned)\n\t        .on(\"touchstart.drag\", touchstarted)\n\t        .on(\"touchmove.drag\", touchmoved)\n\t        .on(\"touchend.drag touchcancel.drag\", touchended)\n\t        .style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\");\n\t  }\n\t\n\t  function mousedowned() {\n\t    if (touchending || !filter.apply(this, arguments)) return;\n\t    var gesture = beforestart(\"mouse\", container.apply(this, arguments), mouse, this, arguments);\n\t    if (!gesture) return;\n\t    select(exports.event.view).on(\"mousemove.drag\", mousemoved, true).on(\"mouseup.drag\", mouseupped, true);\n\t    dragDisable(exports.event.view);\n\t    nopropagation();\n\t    mousemoving = false;\n\t    gesture(\"start\");\n\t  }\n\t\n\t  function mousemoved() {\n\t    noevent();\n\t    mousemoving = true;\n\t    gestures.mouse(\"drag\");\n\t  }\n\t\n\t  function mouseupped() {\n\t    select(exports.event.view).on(\"mousemove.drag mouseup.drag\", null);\n\t    yesdrag(exports.event.view, mousemoving);\n\t    noevent();\n\t    gestures.mouse(\"end\");\n\t  }\n\t\n\t  function touchstarted() {\n\t    if (!filter.apply(this, arguments)) return;\n\t    var touches$$1 = exports.event.changedTouches,\n\t        c = container.apply(this, arguments),\n\t        n = touches$$1.length, i, gesture;\n\t\n\t    for (i = 0; i < n; ++i) {\n\t      if (gesture = beforestart(touches$$1[i].identifier, c, touch, this, arguments)) {\n\t        nopropagation();\n\t        gesture(\"start\");\n\t      }\n\t    }\n\t  }\n\t\n\t  function touchmoved() {\n\t    var touches$$1 = exports.event.changedTouches,\n\t        n = touches$$1.length, i, gesture;\n\t\n\t    for (i = 0; i < n; ++i) {\n\t      if (gesture = gestures[touches$$1[i].identifier]) {\n\t        noevent();\n\t        gesture(\"drag\");\n\t      }\n\t    }\n\t  }\n\t\n\t  function touchended() {\n\t    var touches$$1 = exports.event.changedTouches,\n\t        n = touches$$1.length, i, gesture;\n\t\n\t    if (touchending) clearTimeout(touchending);\n\t    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!\n\t    for (i = 0; i < n; ++i) {\n\t      if (gesture = gestures[touches$$1[i].identifier]) {\n\t        nopropagation();\n\t        gesture(\"end\");\n\t      }\n\t    }\n\t  }\n\t\n\t  function beforestart(id, container, point, that, args) {\n\t    var p = point(container, id), s, dx, dy,\n\t        sublisteners = listeners.copy();\n\t\n\t    if (!customEvent(new DragEvent(drag, \"beforestart\", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {\n\t      if ((exports.event.subject = s = subject.apply(that, args)) == null) return false;\n\t      dx = s.x - p[0] || 0;\n\t      dy = s.y - p[1] || 0;\n\t      return true;\n\t    })) return;\n\t\n\t    return function gesture(type) {\n\t      var p0 = p, n;\n\t      switch (type) {\n\t        case \"start\": gestures[id] = gesture, n = active++; break;\n\t        case \"end\": delete gestures[id], --active; // nobreak\n\t        case \"drag\": p = point(container, id), n = active; break;\n\t      }\n\t      customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);\n\t    };\n\t  }\n\t\n\t  drag.filter = function(_) {\n\t    return arguments.length ? (filter = typeof _ === \"function\" ? _ : constant$8(!!_), drag) : filter;\n\t  };\n\t\n\t  drag.container = function(_) {\n\t    return arguments.length ? (container = typeof _ === \"function\" ? _ : constant$8(_), drag) : container;\n\t  };\n\t\n\t  drag.subject = function(_) {\n\t    return arguments.length ? (subject = typeof _ === \"function\" ? _ : constant$8(_), drag) : subject;\n\t  };\n\t\n\t  drag.on = function() {\n\t    var value = listeners.on.apply(listeners, arguments);\n\t    return value === listeners ? drag : value;\n\t  };\n\t\n\t  return drag;\n\t};\n\t\n\tvar constant$9 = function(x) {\n\t  return function() {\n\t    return x;\n\t  };\n\t};\n\t\n\tfunction x$4(d) {\n\t  return d[0];\n\t}\n\t\n\tfunction y$4(d) {\n\t  return d[1];\n\t}\n\t\n\tfunction RedBlackTree() {\n\t  this._ = null; // root node\n\t}\n\t\n\tfunction RedBlackNode(node) {\n\t  node.U = // parent node\n\t  node.C = // color - true for red, false for black\n\t  node.L = // left node\n\t  node.R = // right node\n\t  node.P = // previous node\n\t  node.N = null; // next node\n\t}\n\t\n\tRedBlackTree.prototype = {\n\t  constructor: RedBlackTree,\n\t\n\t  insert: function(after, node) {\n\t    var parent, grandpa, uncle;\n\t\n\t    if (after) {\n\t      node.P = after;\n\t      node.N = after.N;\n\t      if (after.N) after.N.P = node;\n\t      after.N = node;\n\t      if (after.R) {\n\t        after = after.R;\n\t        while (after.L) after = after.L;\n\t        after.L = node;\n\t      } else {\n\t        after.R = node;\n\t      }\n\t      parent = after;\n\t    } else if (this._) {\n\t      after = RedBlackFirst(this._);\n\t      node.P = null;\n\t      node.N = after;\n\t      after.P = after.L = node;\n\t      parent = after;\n\t    } else {\n\t      node.P = node.N = null;\n\t      this._ = node;\n\t      parent = null;\n\t    }\n\t    node.L = node.R = null;\n\t    node.U = parent;\n\t    node.C = true;\n\t\n\t    after = node;\n\t    while (parent && parent.C) {\n\t      grandpa = parent.U;\n\t      if (parent === grandpa.L) {\n\t        uncle = grandpa.R;\n\t        if (uncle && uncle.C) {\n\t          parent.C = uncle.C = false;\n\t          grandpa.C = true;\n\t          after = grandpa;\n\t        } else {\n\t          if (after === parent.R) {\n\t            RedBlackRotateLeft(this, parent);\n\t            after = parent;\n\t            parent = after.U;\n\t          }\n\t          parent.C = false;\n\t          grandpa.C = true;\n\t          RedBlackRotateRight(this, grandpa);\n\t        }\n\t      } else {\n\t        uncle = grandpa.L;\n\t        if (uncle && uncle.C) {\n\t          parent.C = uncle.C = false;\n\t          grandpa.C = true;\n\t          after = grandpa;\n\t        } else {\n\t          if (after === parent.L) {\n\t            RedBlackRotateRight(this, parent);\n\t            after = parent;\n\t            parent = after.U;\n\t          }\n\t          parent.C = false;\n\t          grandpa.C = true;\n\t          RedBlackRotateLeft(this, grandpa);\n\t        }\n\t      }\n\t      parent = after.U;\n\t    }\n\t    this._.C = false;\n\t  },\n\t\n\t  remove: function(node) {\n\t    if (node.N) node.N.P = node.P;\n\t    if (node.P) node.P.N = node.N;\n\t    node.N = node.P = null;\n\t\n\t    var parent = node.U,\n\t        sibling,\n\t        left = node.L,\n\t        right = node.R,\n\t        next,\n\t        red;\n\t\n\t    if (!left) next = right;\n\t    else if (!right) next = left;\n\t    else next = RedBlackFirst(right);\n\t\n\t    if (parent) {\n\t      if (parent.L === node) parent.L = next;\n\t      else parent.R = next;\n\t    } else {\n\t      this._ = next;\n\t    }\n\t\n\t    if (left && right) {\n\t      red = next.C;\n\t      next.C = node.C;\n\t      next.L = left;\n\t      left.U = next;\n\t      if (next !== right) {\n\t        parent = next.U;\n\t        next.U = node.U;\n\t        node = next.R;\n\t        parent.L = node;\n\t        next.R = right;\n\t        right.U = next;\n\t      } else {\n\t        next.U = parent;\n\t        parent = next;\n\t        node = next.R;\n\t      }\n\t    } else {\n\t      red = node.C;\n\t      node = next;\n\t    }\n\t\n\t    if (node) node.U = parent;\n\t    if (red) return;\n\t    if (node && node.C) { node.C = false; return; }\n\t\n\t    do {\n\t      if (node === this._) break;\n\t      if (node === parent.L) {\n\t        sibling = parent.R;\n\t        if (sibling.C) {\n\t          sibling.C = false;\n\t          parent.C = true;\n\t          RedBlackRotateLeft(this, parent);\n\t          sibling = parent.R;\n\t        }\n\t        if ((sibling.L && sibling.L.C)\n\t            || (sibling.R && sibling.R.C)) {\n\t          if (!sibling.R || !sibling.R.C) {\n\t            sibling.L.C = false;\n\t            sibling.C = true;\n\t            RedBlackRotateRight(this, sibling);\n\t            sibling = parent.R;\n\t          }\n\t          sibling.C = parent.C;\n\t          parent.C = sibling.R.C = false;\n\t          RedBlackRotateLeft(this, parent);\n\t          node = this._;\n\t          break;\n\t        }\n\t      } else {\n\t        sibling = parent.L;\n\t        if (sibling.C) {\n\t          sibling.C = false;\n\t          parent.C = true;\n\t          RedBlackRotateRight(this, parent);\n\t          sibling = parent.L;\n\t        }\n\t        if ((sibling.L && sibling.L.C)\n\t          || (sibling.R && sibling.R.C)) {\n\t          if (!sibling.L || !sibling.L.C) {\n\t            sibling.R.C = false;\n\t            sibling.C = true;\n\t            RedBlackRotateLeft(this, sibling);\n\t            sibling = parent.L;\n\t          }\n\t          sibling.C = parent.C;\n\t          parent.C = sibling.L.C = false;\n\t          RedBlackRotateRight(this, parent);\n\t          node = this._;\n\t          break;\n\t        }\n\t      }\n\t      sibling.C = true;\n\t      node = parent;\n\t      parent = parent.U;\n\t    } while (!node.C);\n\t\n\t    if (node) node.C = false;\n\t  }\n\t};\n\t\n\tfunction RedBlackRotateLeft(tree, node) {\n\t  var p = node,\n\t      q = node.R,\n\t      parent = p.U;\n\t\n\t  if (parent) {\n\t    if (parent.L === p) parent.L = q;\n\t    else parent.R = q;\n\t  } else {\n\t    tree._ = q;\n\t  }\n\t\n\t  q.U = parent;\n\t  p.U = q;\n\t  p.R = q.L;\n\t  if (p.R) p.R.U = p;\n\t  q.L = p;\n\t}\n\t\n\tfunction RedBlackRotateRight(tree, node) {\n\t  var p = node,\n\t      q = node.L,\n\t      parent = p.U;\n\t\n\t  if (parent) {\n\t    if (parent.L === p) parent.L = q;\n\t    else parent.R = q;\n\t  } else {\n\t    tree._ = q;\n\t  }\n\t\n\t  q.U = parent;\n\t  p.U = q;\n\t  p.L = q.R;\n\t  if (p.L) p.L.U = p;\n\t  q.R = p;\n\t}\n\t\n\tfunction RedBlackFirst(node) {\n\t  while (node.L) node = node.L;\n\t  return node;\n\t}\n\t\n\tfunction createEdge(left, right, v0, v1) {\n\t  var edge = [null, null],\n\t      index = edges.push(edge) - 1;\n\t  edge.left = left;\n\t  edge.right = right;\n\t  if (v0) setEdgeEnd(edge, left, right, v0);\n\t  if (v1) setEdgeEnd(edge, right, left, v1);\n\t  cells[left.index].halfedges.push(index);\n\t  cells[right.index].halfedges.push(index);\n\t  return edge;\n\t}\n\t\n\tfunction createBorderEdge(left, v0, v1) {\n\t  var edge = [v0, v1];\n\t  edge.left = left;\n\t  return edge;\n\t}\n\t\n\tfunction setEdgeEnd(edge, left, right, vertex) {\n\t  if (!edge[0] && !edge[1]) {\n\t    edge[0] = vertex;\n\t    edge.left = left;\n\t    edge.right = right;\n\t  } else if (edge.left === right) {\n\t    edge[1] = vertex;\n\t  } else {\n\t    edge[0] = vertex;\n\t  }\n\t}\n\t\n\t// Liang–Barsky line clipping.\n\tfunction clipEdge(edge, x0, y0, x1, y1) {\n\t  var a = edge[0],\n\t      b = edge[1],\n\t      ax = a[0],\n\t      ay = a[1],\n\t      bx = b[0],\n\t      by = b[1],\n\t      t0 = 0,\n\t      t1 = 1,\n\t      dx = bx - ax,\n\t      dy = by - ay,\n\t      r;\n\t\n\t  r = x0 - ax;\n\t  if (!dx && r > 0) return;\n\t  r /= dx;\n\t  if (dx < 0) {\n\t    if (r < t0) return;\n\t    if (r < t1) t1 = r;\n\t  } else if (dx > 0) {\n\t    if (r > t1) return;\n\t    if (r > t0) t0 = r;\n\t  }\n\t\n\t  r = x1 - ax;\n\t  if (!dx && r < 0) return;\n\t  r /= dx;\n\t  if (dx < 0) {\n\t    if (r > t1) return;\n\t    if (r > t0) t0 = r;\n\t  } else if (dx > 0) {\n\t    if (r < t0) return;\n\t    if (r < t1) t1 = r;\n\t  }\n\t\n\t  r = y0 - ay;\n\t  if (!dy && r > 0) return;\n\t  r /= dy;\n\t  if (dy < 0) {\n\t    if (r < t0) return;\n\t    if (r < t1) t1 = r;\n\t  } else if (dy > 0) {\n\t    if (r > t1) return;\n\t    if (r > t0) t0 = r;\n\t  }\n\t\n\t  r = y1 - ay;\n\t  if (!dy && r < 0) return;\n\t  r /= dy;\n\t  if (dy < 0) {\n\t    if (r > t1) return;\n\t    if (r > t0) t0 = r;\n\t  } else if (dy > 0) {\n\t    if (r < t0) return;\n\t    if (r < t1) t1 = r;\n\t  }\n\t\n\t  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?\n\t\n\t  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];\n\t  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];\n\t  return true;\n\t}\n\t\n\tfunction connectEdge(edge, x0, y0, x1, y1) {\n\t  var v1 = edge[1];\n\t  if (v1) return true;\n\t\n\t  var v0 = edge[0],\n\t      left = edge.left,\n\t      right = edge.right,\n\t      lx = left[0],\n\t      ly = left[1],\n\t      rx = right[0],\n\t      ry = right[1],\n\t      fx = (lx + rx) / 2,\n\t      fy = (ly + ry) / 2,\n\t      fm,\n\t      fb;\n\t\n\t  if (ry === ly) {\n\t    if (fx < x0 || fx >= x1) return;\n\t    if (lx > rx) {\n\t      if (!v0) v0 = [fx, y0];\n\t      else if (v0[1] >= y1) return;\n\t      v1 = [fx, y1];\n\t    } else {\n\t      if (!v0) v0 = [fx, y1];\n\t      else if (v0[1] < y0) return;\n\t      v1 = [fx, y0];\n\t    }\n\t  } else {\n\t    fm = (lx - rx) / (ry - ly);\n\t    fb = fy - fm * fx;\n\t    if (fm < -1 || fm > 1) {\n\t      if (lx > rx) {\n\t        if (!v0) v0 = [(y0 - fb) / fm, y0];\n\t        else if (v0[1] >= y1) return;\n\t        v1 = [(y1 - fb) / fm, y1];\n\t      } else {\n\t        if (!v0) v0 = [(y1 - fb) / fm, y1];\n\t        else if (v0[1] < y0) return;\n\t        v1 = [(y0 - fb) / fm, y0];\n\t      }\n\t    } else {\n\t      if (ly < ry) {\n\t        if (!v0) v0 = [x0, fm * x0 + fb];\n\t        else if (v0[0] >= x1) return;\n\t        v1 = [x1, fm * x1 + fb];\n\t      } else {\n\t        if (!v0) v0 = [x1, fm * x1 + fb];\n\t        else if (v0[0] < x0) return;\n\t        v1 = [x0, fm * x0 + fb];\n\t      }\n\t    }\n\t  }\n\t\n\t  edge[0] = v0;\n\t  edge[1] = v1;\n\t  return true;\n\t}\n\t\n\tfunction clipEdges(x0, y0, x1, y1) {\n\t  var i = edges.length,\n\t      edge;\n\t\n\t  while (i--) {\n\t    if (!connectEdge(edge = edges[i], x0, y0, x1, y1)\n\t        || !clipEdge(edge, x0, y0, x1, y1)\n\t        || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon$3\n\t            || Math.abs(edge[0][1] - edge[1][1]) > epsilon$3)) {\n\t      delete edges[i];\n\t    }\n\t  }\n\t}\n\t\n\tfunction createCell(site) {\n\t  return cells[site.index] = {\n\t    site: site,\n\t    halfedges: []\n\t  };\n\t}\n\t\n\tfunction cellHalfedgeAngle(cell, edge) {\n\t  var site = cell.site,\n\t      va = edge.left,\n\t      vb = edge.right;\n\t  if (site === vb) vb = va, va = site;\n\t  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);\n\t  if (site === va) va = edge[1], vb = edge[0];\n\t  else va = edge[0], vb = edge[1];\n\t  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);\n\t}\n\t\n\tfunction cellHalfedgeStart(cell, edge) {\n\t  return edge[+(edge.left !== cell.site)];\n\t}\n\t\n\tfunction cellHalfedgeEnd(cell, edge) {\n\t  return edge[+(edge.left === cell.site)];\n\t}\n\t\n\tfunction sortCellHalfedges() {\n\t  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {\n\t    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {\n\t      var index = new Array(m),\n\t          array = new Array(m);\n\t      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);\n\t      index.sort(function(i, j) { return array[j] - array[i]; });\n\t      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];\n\t      for (j = 0; j < m; ++j) halfedges[j] = array[j];\n\t    }\n\t  }\n\t}\n\t\n\tfunction clipCells(x0, y0, x1, y1) {\n\t  var nCells = cells.length,\n\t      iCell,\n\t      cell,\n\t      site,\n\t      iHalfedge,\n\t      halfedges,\n\t      nHalfedges,\n\t      start,\n\t      startX,\n\t      startY,\n\t      end,\n\t      endX,\n\t      endY,\n\t      cover = true;\n\t\n\t  for (iCell = 0; iCell < nCells; ++iCell) {\n\t    if (cell = cells[iCell]) {\n\t      site = cell.site;\n\t      halfedges = cell.halfedges;\n\t      iHalfedge = halfedges.length;\n\t\n\t      // Remove any dangling clipped edges.\n\t      while (iHalfedge--) {\n\t        if (!edges[halfedges[iHalfedge]]) {\n\t          halfedges.splice(iHalfedge, 1);\n\t        }\n\t      }\n\t\n\t      // Insert any border edges as necessary.\n\t      iHalfedge = 0, nHalfedges = halfedges.length;\n\t      while (iHalfedge < nHalfedges) {\n\t        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];\n\t        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];\n\t        if (Math.abs(endX - startX) > epsilon$3 || Math.abs(endY - startY) > epsilon$3) {\n\t          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,\n\t              Math.abs(endX - x0) < epsilon$3 && y1 - endY > epsilon$3 ? [x0, Math.abs(startX - x0) < epsilon$3 ? startY : y1]\n\t              : Math.abs(endY - y1) < epsilon$3 && x1 - endX > epsilon$3 ? [Math.abs(startY - y1) < epsilon$3 ? startX : x1, y1]\n\t              : Math.abs(endX - x1) < epsilon$3 && endY - y0 > epsilon$3 ? [x1, Math.abs(startX - x1) < epsilon$3 ? startY : y0]\n\t              : Math.abs(endY - y0) < epsilon$3 && endX - x0 > epsilon$3 ? [Math.abs(startY - y0) < epsilon$3 ? startX : x0, y0]\n\t              : null)) - 1);\n\t          ++nHalfedges;\n\t        }\n\t      }\n\t\n\t      if (nHalfedges) cover = false;\n\t    }\n\t  }\n\t\n\t  // If there weren’t any edges, have the closest site cover the extent.\n\t  // It doesn’t matter which corner of the extent we measure!\n\t  if (cover) {\n\t    var dx, dy, d2, dc = Infinity;\n\t\n\t    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {\n\t      if (cell = cells[iCell]) {\n\t        site = cell.site;\n\t        dx = site[0] - x0;\n\t        dy = site[1] - y0;\n\t        d2 = dx * dx + dy * dy;\n\t        if (d2 < dc) dc = d2, cover = cell;\n\t      }\n\t    }\n\t\n\t    if (cover) {\n\t      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];\n\t      cover.halfedges.push(\n\t        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,\n\t        edges.push(createBorderEdge(site, v01, v11)) - 1,\n\t        edges.push(createBorderEdge(site, v11, v10)) - 1,\n\t        edges.push(createBorderEdge(site, v10, v00)) - 1\n\t      );\n\t    }\n\t  }\n\t\n\t  // Lastly delete any cells with no edges; these were entirely clipped.\n\t  for (iCell = 0; iCell < nCells; ++iCell) {\n\t    if (cell = cells[iCell]) {\n\t      if (!cell.halfedges.length) {\n\t        delete cells[iCell];\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tvar circlePool = [];\n\t\n\tvar firstCircle;\n\t\n\tfunction Circle() {\n\t  RedBlackNode(this);\n\t  this.x =\n\t  this.y =\n\t  this.arc =\n\t  this.site =\n\t  this.cy = null;\n\t}\n\t\n\tfunction attachCircle(arc) {\n\t  var lArc = arc.P,\n\t      rArc = arc.N;\n\t\n\t  if (!lArc || !rArc) return;\n\t\n\t  var lSite = lArc.site,\n\t      cSite = arc.site,\n\t      rSite = rArc.site;\n\t\n\t  if (lSite === rSite) return;\n\t\n\t  var bx = cSite[0],\n\t      by = cSite[1],\n\t      ax = lSite[0] - bx,\n\t      ay = lSite[1] - by,\n\t      cx = rSite[0] - bx,\n\t      cy = rSite[1] - by;\n\t\n\t  var d = 2 * (ax * cy - ay * cx);\n\t  if (d >= -epsilon2$1) return;\n\t\n\t  var ha = ax * ax + ay * ay,\n\t      hc = cx * cx + cy * cy,\n\t      x = (cy * ha - ay * hc) / d,\n\t      y = (ax * hc - cx * ha) / d;\n\t\n\t  var circle = circlePool.pop() || new Circle;\n\t  circle.arc = arc;\n\t  circle.site = cSite;\n\t  circle.x = x + bx;\n\t  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom\n\t\n\t  arc.circle = circle;\n\t\n\t  var before = null,\n\t      node = circles._;\n\t\n\t  while (node) {\n\t    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {\n\t      if (node.L) node = node.L;\n\t      else { before = node.P; break; }\n\t    } else {\n\t      if (node.R) node = node.R;\n\t      else { before = node; break; }\n\t    }\n\t  }\n\t\n\t  circles.insert(before, circle);\n\t  if (!before) firstCircle = circle;\n\t}\n\t\n\tfunction detachCircle(arc) {\n\t  var circle = arc.circle;\n\t  if (circle) {\n\t    if (!circle.P) firstCircle = circle.N;\n\t    circles.remove(circle);\n\t    circlePool.push(circle);\n\t    RedBlackNode(circle);\n\t    arc.circle = null;\n\t  }\n\t}\n\t\n\tvar beachPool = [];\n\t\n\tfunction Beach() {\n\t  RedBlackNode(this);\n\t  this.edge =\n\t  this.site =\n\t  this.circle = null;\n\t}\n\t\n\tfunction createBeach(site) {\n\t  var beach = beachPool.pop() || new Beach;\n\t  beach.site = site;\n\t  return beach;\n\t}\n\t\n\tfunction detachBeach(beach) {\n\t  detachCircle(beach);\n\t  beaches.remove(beach);\n\t  beachPool.push(beach);\n\t  RedBlackNode(beach);\n\t}\n\t\n\tfunction removeBeach(beach) {\n\t  var circle = beach.circle,\n\t      x = circle.x,\n\t      y = circle.cy,\n\t      vertex = [x, y],\n\t      previous = beach.P,\n\t      next = beach.N,\n\t      disappearing = [beach];\n\t\n\t  detachBeach(beach);\n\t\n\t  var lArc = previous;\n\t  while (lArc.circle\n\t      && Math.abs(x - lArc.circle.x) < epsilon$3\n\t      && Math.abs(y - lArc.circle.cy) < epsilon$3) {\n\t    previous = lArc.P;\n\t    disappearing.unshift(lArc);\n\t    detachBeach(lArc);\n\t    lArc = previous;\n\t  }\n\t\n\t  disappearing.unshift(lArc);\n\t  detachCircle(lArc);\n\t\n\t  var rArc = next;\n\t  while (rArc.circle\n\t      && Math.abs(x - rArc.circle.x) < epsilon$3\n\t      && Math.abs(y - rArc.circle.cy) < epsilon$3) {\n\t    next = rArc.N;\n\t    disappearing.push(rArc);\n\t    detachBeach(rArc);\n\t    rArc = next;\n\t  }\n\t\n\t  disappearing.push(rArc);\n\t  detachCircle(rArc);\n\t\n\t  var nArcs = disappearing.length,\n\t      iArc;\n\t  for (iArc = 1; iArc < nArcs; ++iArc) {\n\t    rArc = disappearing[iArc];\n\t    lArc = disappearing[iArc - 1];\n\t    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);\n\t  }\n\t\n\t  lArc = disappearing[0];\n\t  rArc = disappearing[nArcs - 1];\n\t  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);\n\t\n\t  attachCircle(lArc);\n\t  attachCircle(rArc);\n\t}\n\t\n\tfunction addBeach(site) {\n\t  var x = site[0],\n\t      directrix = site[1],\n\t      lArc,\n\t      rArc,\n\t      dxl,\n\t      dxr,\n\t      node = beaches._;\n\t\n\t  while (node) {\n\t    dxl = leftBreakPoint(node, directrix) - x;\n\t    if (dxl > epsilon$3) node = node.L; else {\n\t      dxr = x - rightBreakPoint(node, directrix);\n\t      if (dxr > epsilon$3) {\n\t        if (!node.R) {\n\t          lArc = node;\n\t          break;\n\t        }\n\t        node = node.R;\n\t      } else {\n\t        if (dxl > -epsilon$3) {\n\t          lArc = node.P;\n\t          rArc = node;\n\t        } else if (dxr > -epsilon$3) {\n\t          lArc = node;\n\t          rArc = node.N;\n\t        } else {\n\t          lArc = rArc = node;\n\t        }\n\t        break;\n\t      }\n\t    }\n\t  }\n\t\n\t  createCell(site);\n\t  var newArc = createBeach(site);\n\t  beaches.insert(lArc, newArc);\n\t\n\t  if (!lArc && !rArc) return;\n\t\n\t  if (lArc === rArc) {\n\t    detachCircle(lArc);\n\t    rArc = createBeach(lArc.site);\n\t    beaches.insert(newArc, rArc);\n\t    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);\n\t    attachCircle(lArc);\n\t    attachCircle(rArc);\n\t    return;\n\t  }\n\t\n\t  if (!rArc) { // && lArc\n\t    newArc.edge = createEdge(lArc.site, newArc.site);\n\t    return;\n\t  }\n\t\n\t  // else lArc !== rArc\n\t  detachCircle(lArc);\n\t  detachCircle(rArc);\n\t\n\t  var lSite = lArc.site,\n\t      ax = lSite[0],\n\t      ay = lSite[1],\n\t      bx = site[0] - ax,\n\t      by = site[1] - ay,\n\t      rSite = rArc.site,\n\t      cx = rSite[0] - ax,\n\t      cy = rSite[1] - ay,\n\t      d = 2 * (bx * cy - by * cx),\n\t      hb = bx * bx + by * by,\n\t      hc = cx * cx + cy * cy,\n\t      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];\n\t\n\t  setEdgeEnd(rArc.edge, lSite, rSite, vertex);\n\t  newArc.edge = createEdge(lSite, site, null, vertex);\n\t  rArc.edge = createEdge(site, rSite, null, vertex);\n\t  attachCircle(lArc);\n\t  attachCircle(rArc);\n\t}\n\t\n\tfunction leftBreakPoint(arc, directrix) {\n\t  var site = arc.site,\n\t      rfocx = site[0],\n\t      rfocy = site[1],\n\t      pby2 = rfocy - directrix;\n\t\n\t  if (!pby2) return rfocx;\n\t\n\t  var lArc = arc.P;\n\t  if (!lArc) return -Infinity;\n\t\n\t  site = lArc.site;\n\t  var lfocx = site[0],\n\t      lfocy = site[1],\n\t      plby2 = lfocy - directrix;\n\t\n\t  if (!plby2) return lfocx;\n\t\n\t  var hl = lfocx - rfocx,\n\t      aby2 = 1 / pby2 - 1 / plby2,\n\t      b = hl / plby2;\n\t\n\t  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;\n\t\n\t  return (rfocx + lfocx) / 2;\n\t}\n\t\n\tfunction rightBreakPoint(arc, directrix) {\n\t  var rArc = arc.N;\n\t  if (rArc) return leftBreakPoint(rArc, directrix);\n\t  var site = arc.site;\n\t  return site[1] === directrix ? site[0] : Infinity;\n\t}\n\t\n\tvar epsilon$3 = 1e-6;\n\tvar epsilon2$1 = 1e-12;\n\tvar beaches;\n\tvar cells;\n\tvar circles;\n\tvar edges;\n\t\n\tfunction triangleArea(a, b, c) {\n\t  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);\n\t}\n\t\n\tfunction lexicographic(a, b) {\n\t  return b[1] - a[1]\n\t      || b[0] - a[0];\n\t}\n\t\n\tfunction Diagram(sites, extent) {\n\t  var site = sites.sort(lexicographic).pop(),\n\t      x,\n\t      y,\n\t      circle;\n\t\n\t  edges = [];\n\t  cells = new Array(sites.length);\n\t  beaches = new RedBlackTree;\n\t  circles = new RedBlackTree;\n\t\n\t  while (true) {\n\t    circle = firstCircle;\n\t    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {\n\t      if (site[0] !== x || site[1] !== y) {\n\t        addBeach(site);\n\t        x = site[0], y = site[1];\n\t      }\n\t      site = sites.pop();\n\t    } else if (circle) {\n\t      removeBeach(circle.arc);\n\t    } else {\n\t      break;\n\t    }\n\t  }\n\t\n\t  sortCellHalfedges();\n\t\n\t  if (extent) {\n\t    var x0 = +extent[0][0],\n\t        y0 = +extent[0][1],\n\t        x1 = +extent[1][0],\n\t        y1 = +extent[1][1];\n\t    clipEdges(x0, y0, x1, y1);\n\t    clipCells(x0, y0, x1, y1);\n\t  }\n\t\n\t  this.edges = edges;\n\t  this.cells = cells;\n\t\n\t  beaches =\n\t  circles =\n\t  edges =\n\t  cells = null;\n\t}\n\t\n\tDiagram.prototype = {\n\t  constructor: Diagram,\n\t\n\t  polygons: function() {\n\t    var edges = this.edges;\n\t\n\t    return this.cells.map(function(cell) {\n\t      var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });\n\t      polygon.data = cell.site.data;\n\t      return polygon;\n\t    });\n\t  },\n\t\n\t  triangles: function() {\n\t    var triangles = [],\n\t        edges = this.edges;\n\t\n\t    this.cells.forEach(function(cell, i) {\n\t      var site = cell.site,\n\t          halfedges = cell.halfedges,\n\t          j = -1,\n\t          m = halfedges.length,\n\t          s0,\n\t          e1 = edges[halfedges[m - 1]],\n\t          s1 = e1.left === site ? e1.right : e1.left;\n\t\n\t      while (++j < m) {\n\t        s0 = s1;\n\t        e1 = edges[halfedges[j]];\n\t        s1 = e1.left === site ? e1.right : e1.left;\n\t        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {\n\t          triangles.push([site.data, s0.data, s1.data]);\n\t        }\n\t      }\n\t    });\n\t\n\t    return triangles;\n\t  },\n\t\n\t  links: function() {\n\t    return this.edges.filter(function(edge) {\n\t      return edge.right;\n\t    }).map(function(edge) {\n\t      return {\n\t        source: edge.left.data,\n\t        target: edge.right.data\n\t      };\n\t    });\n\t  },\n\t\n\t  find: function(x, y, radius) {\n\t    var that = this,\n\t        i0, i1 = that._found || 0,\n\t        cell = that.cells[i1] || that.cells[i1 = 0],\n\t        dx = x - cell.site[0],\n\t        dy = y - cell.site[1],\n\t        d2 = dx * dx + dy * dy;\n\t\n\t    do {\n\t      cell = that.cells[i0 = i1], i1 = null;\n\t      cell.halfedges.forEach(function(e) {\n\t        var edge = that.edges[e], v = edge.left;\n\t        if ((v === cell.site || !v) && !(v = edge.right)) return;\n\t        var vx = x - v[0],\n\t            vy = y - v[1],\n\t            v2 = vx * vx + vy * vy;\n\t        if (v2 < d2) d2 = v2, i1 = v.index;\n\t      });\n\t    } while (i1 !== null);\n\t\n\t    that._found = i0;\n\t\n\t    return radius == null || d2 <= radius * radius ? cell.site : null;\n\t  }\n\t};\n\t\n\tvar voronoi = function() {\n\t  var x$$1 = x$4,\n\t      y$$1 = y$4,\n\t      extent = null;\n\t\n\t  function voronoi(data) {\n\t    return new Diagram(data.map(function(d, i) {\n\t      var s = [Math.round(x$$1(d, i, data) / epsilon$3) * epsilon$3, Math.round(y$$1(d, i, data) / epsilon$3) * epsilon$3];\n\t      s.index = i;\n\t      s.data = d;\n\t      return s;\n\t    }), extent);\n\t  }\n\t\n\t  voronoi.polygons = function(data) {\n\t    return voronoi(data).polygons();\n\t  };\n\t\n\t  voronoi.links = function(data) {\n\t    return voronoi(data).links();\n\t  };\n\t\n\t  voronoi.triangles = function(data) {\n\t    return voronoi(data).triangles();\n\t  };\n\t\n\t  voronoi.x = function(_) {\n\t    return arguments.length ? (x$$1 = typeof _ === \"function\" ? _ : constant$9(+_), voronoi) : x$$1;\n\t  };\n\t\n\t  voronoi.y = function(_) {\n\t    return arguments.length ? (y$$1 = typeof _ === \"function\" ? _ : constant$9(+_), voronoi) : y$$1;\n\t  };\n\t\n\t  voronoi.extent = function(_) {\n\t    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];\n\t  };\n\t\n\t  voronoi.size = function(_) {\n\t    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];\n\t  };\n\t\n\t  return voronoi;\n\t};\n\t\n\tvar constant$10 = function(x) {\n\t  return function() {\n\t    return x;\n\t  };\n\t};\n\t\n\tfunction ZoomEvent(target, type, transform) {\n\t  this.target = target;\n\t  this.type = type;\n\t  this.transform = transform;\n\t}\n\t\n\tfunction Transform(k, x, y) {\n\t  this.k = k;\n\t  this.x = x;\n\t  this.y = y;\n\t}\n\t\n\tTransform.prototype = {\n\t  constructor: Transform,\n\t  scale: function(k) {\n\t    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);\n\t  },\n\t  translate: function(x, y) {\n\t    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);\n\t  },\n\t  apply: function(point) {\n\t    return [point[0] * this.k + this.x, point[1] * this.k + this.y];\n\t  },\n\t  applyX: function(x) {\n\t    return x * this.k + this.x;\n\t  },\n\t  applyY: function(y) {\n\t    return y * this.k + this.y;\n\t  },\n\t  invert: function(location) {\n\t    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];\n\t  },\n\t  invertX: function(x) {\n\t    return (x - this.x) / this.k;\n\t  },\n\t  invertY: function(y) {\n\t    return (y - this.y) / this.k;\n\t  },\n\t  rescaleX: function(x) {\n\t    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));\n\t  },\n\t  rescaleY: function(y) {\n\t    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));\n\t  },\n\t  toString: function() {\n\t    return \"translate(\" + this.x + \",\" + this.y + \") scale(\" + this.k + \")\";\n\t  }\n\t};\n\t\n\tvar identity$6 = new Transform(1, 0, 0);\n\t\n\ttransform.prototype = Transform.prototype;\n\t\n\tfunction transform(node) {\n\t  return node.__zoom || identity$6;\n\t}\n\t\n\tfunction nopropagation$1() {\n\t  exports.event.stopImmediatePropagation();\n\t}\n\t\n\tvar noevent$1 = function() {\n\t  exports.event.preventDefault();\n\t  exports.event.stopImmediatePropagation();\n\t};\n\t\n\t// Ignore right-click, since that should open the context menu.\n\tfunction defaultFilter$1() {\n\t  return !exports.event.button;\n\t}\n\t\n\tfunction defaultExtent() {\n\t  var e = this, w, h;\n\t  if (e instanceof SVGElement) {\n\t    e = e.ownerSVGElement || e;\n\t    w = e.width.baseVal.value;\n\t    h = e.height.baseVal.value;\n\t  } else {\n\t    w = e.clientWidth;\n\t    h = e.clientHeight;\n\t  }\n\t  return [[0, 0], [w, h]];\n\t}\n\t\n\tfunction defaultTransform() {\n\t  return this.__zoom || identity$6;\n\t}\n\t\n\tvar zoom = function() {\n\t  var filter = defaultFilter$1,\n\t      extent = defaultExtent,\n\t      k0 = 0,\n\t      k1 = Infinity,\n\t      x0 = -k1,\n\t      x1 = k1,\n\t      y0 = x0,\n\t      y1 = x1,\n\t      duration = 250,\n\t      gestures = [],\n\t      listeners = dispatch(\"start\", \"zoom\", \"end\"),\n\t      touchstarting,\n\t      touchending,\n\t      touchDelay = 500,\n\t      wheelDelay = 150;\n\t\n\t  function zoom(selection$$1) {\n\t    selection$$1\n\t        .on(\"wheel.zoom\", wheeled)\n\t        .on(\"mousedown.zoom\", mousedowned)\n\t        .on(\"dblclick.zoom\", dblclicked)\n\t        .on(\"touchstart.zoom\", touchstarted)\n\t        .on(\"touchmove.zoom\", touchmoved)\n\t        .on(\"touchend.zoom touchcancel.zoom\", touchended)\n\t        .style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\")\n\t        .property(\"__zoom\", defaultTransform);\n\t  }\n\t\n\t  zoom.transform = function(collection, transform) {\n\t    var selection$$1 = collection.selection ? collection.selection() : collection;\n\t    selection$$1.property(\"__zoom\", defaultTransform);\n\t    if (collection !== selection$$1) {\n\t      schedule(collection, transform);\n\t    } else {\n\t      selection$$1.interrupt().each(function() {\n\t        gesture(this, arguments)\n\t            .start()\n\t            .zoom(null, typeof transform === \"function\" ? transform.apply(this, arguments) : transform)\n\t            .end();\n\t      });\n\t    }\n\t  };\n\t\n\t  zoom.scaleBy = function(selection$$1, k) {\n\t    zoom.scaleTo(selection$$1, function() {\n\t      var k0 = this.__zoom.k,\n\t          k1 = typeof k === \"function\" ? k.apply(this, arguments) : k;\n\t      return k0 * k1;\n\t    });\n\t  };\n\t\n\t  zoom.scaleTo = function(selection$$1, k) {\n\t    zoom.transform(selection$$1, function() {\n\t      var e = extent.apply(this, arguments),\n\t          t0 = this.__zoom,\n\t          p0 = centroid(e),\n\t          p1 = t0.invert(p0),\n\t          k1 = typeof k === \"function\" ? k.apply(this, arguments) : k;\n\t      return constrain(translate(scale(t0, k1), p0, p1), e);\n\t    });\n\t  };\n\t\n\t  zoom.translateBy = function(selection$$1, x, y) {\n\t    zoom.transform(selection$$1, function() {\n\t      return constrain(this.__zoom.translate(\n\t        typeof x === \"function\" ? x.apply(this, arguments) : x,\n\t        typeof y === \"function\" ? y.apply(this, arguments) : y\n\t      ), extent.apply(this, arguments));\n\t    });\n\t  };\n\t\n\t  function scale(transform, k) {\n\t    k = Math.max(k0, Math.min(k1, k));\n\t    return k === transform.k ? transform : new Transform(k, transform.x, transform.y);\n\t  }\n\t\n\t  function translate(transform, p0, p1) {\n\t    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;\n\t    return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);\n\t  }\n\t\n\t  function constrain(transform, extent) {\n\t    var dx = Math.min(0, transform.invertX(extent[0][0]) - x0) || Math.max(0, transform.invertX(extent[1][0]) - x1),\n\t        dy = Math.min(0, transform.invertY(extent[0][1]) - y0) || Math.max(0, transform.invertY(extent[1][1]) - y1);\n\t    return dx || dy ? transform.translate(dx, dy) : transform;\n\t  }\n\t\n\t  function centroid(extent) {\n\t    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];\n\t  }\n\t\n\t  function schedule(transition$$1, transform, center) {\n\t    transition$$1\n\t        .on(\"start.zoom\", function() { gesture(this, arguments).start(); })\n\t        .on(\"interrupt.zoom end.zoom\", function() { gesture(this, arguments).end(); })\n\t        .tween(\"zoom\", function() {\n\t          var that = this,\n\t              args = arguments,\n\t              g = gesture(that, args),\n\t              e = extent.apply(that, args),\n\t              p = center || centroid(e),\n\t              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),\n\t              a = that.__zoom,\n\t              b = typeof transform === \"function\" ? transform.apply(that, args) : transform,\n\t              i = interpolateZoom(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));\n\t          return function(t) {\n\t            if (t === 1) t = b; // Avoid rounding error on end.\n\t            else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }\n\t            g.zoom(null, t);\n\t          };\n\t        });\n\t  }\n\t\n\t  function gesture(that, args) {\n\t    for (var i = 0, n = gestures.length, g; i < n; ++i) {\n\t      if ((g = gestures[i]).that === that) {\n\t        return g;\n\t      }\n\t    }\n\t    return new Gesture(that, args);\n\t  }\n\t\n\t  function Gesture(that, args) {\n\t    this.that = that;\n\t    this.args = args;\n\t    this.index = -1;\n\t    this.active = 0;\n\t    this.extent = extent.apply(that, args);\n\t  }\n\t\n\t  Gesture.prototype = {\n\t    start: function() {\n\t      if (++this.active === 1) {\n\t        this.index = gestures.push(this) - 1;\n\t        this.emit(\"start\");\n\t      }\n\t      return this;\n\t    },\n\t    zoom: function(key, transform) {\n\t      if (this.mouse && key !== \"mouse\") this.mouse[1] = transform.invert(this.mouse[0]);\n\t      if (this.touch0 && key !== \"touch\") this.touch0[1] = transform.invert(this.touch0[0]);\n\t      if (this.touch1 && key !== \"touch\") this.touch1[1] = transform.invert(this.touch1[0]);\n\t      this.that.__zoom = transform;\n\t      this.emit(\"zoom\");\n\t      return this;\n\t    },\n\t    end: function() {\n\t      if (--this.active === 0) {\n\t        gestures.splice(this.index, 1);\n\t        this.index = -1;\n\t        this.emit(\"end\");\n\t      }\n\t      return this;\n\t    },\n\t    emit: function(type) {\n\t      customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);\n\t    }\n\t  };\n\t\n\t  function wheeled() {\n\t    if (!filter.apply(this, arguments)) return;\n\t    var g = gesture(this, arguments),\n\t        t = this.__zoom,\n\t        k = Math.max(k0, Math.min(k1, t.k * Math.pow(2, -exports.event.deltaY * (exports.event.deltaMode ? 120 : 1) / 500))),\n\t        p = mouse(this);\n\t\n\t    // If the mouse is in the same location as before, reuse it.\n\t    // If there were recent wheel events, reset the wheel idle timeout.\n\t    if (g.wheel) {\n\t      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {\n\t        g.mouse[1] = t.invert(g.mouse[0] = p);\n\t      }\n\t      clearTimeout(g.wheel);\n\t    }\n\t\n\t    // If this wheel event won’t trigger a transform change, ignore it.\n\t    else if (t.k === k) return;\n\t\n\t    // Otherwise, capture the mouse point and location at the start.\n\t    else {\n\t      g.mouse = [p, t.invert(p)];\n\t      interrupt(this);\n\t      g.start();\n\t    }\n\t\n\t    noevent$1();\n\t    g.wheel = setTimeout(wheelidled, wheelDelay);\n\t    g.zoom(\"mouse\", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent));\n\t\n\t    function wheelidled() {\n\t      g.wheel = null;\n\t      g.end();\n\t    }\n\t  }\n\t\n\t  function mousedowned() {\n\t    if (touchending || !filter.apply(this, arguments)) return;\n\t    var g = gesture(this, arguments),\n\t        v = select(exports.event.view).on(\"mousemove.zoom\", mousemoved, true).on(\"mouseup.zoom\", mouseupped, true),\n\t        p = mouse(this);\n\t\n\t    dragDisable(exports.event.view);\n\t    nopropagation$1();\n\t    g.mouse = [p, this.__zoom.invert(p)];\n\t    interrupt(this);\n\t    g.start();\n\t\n\t    function mousemoved() {\n\t      noevent$1();\n\t      g.moved = true;\n\t      g.zoom(\"mouse\", constrain(translate(g.that.__zoom, g.mouse[0] = mouse(g.that), g.mouse[1]), g.extent));\n\t    }\n\t\n\t    function mouseupped() {\n\t      v.on(\"mousemove.zoom mouseup.zoom\", null);\n\t      yesdrag(exports.event.view, g.moved);\n\t      noevent$1();\n\t      g.end();\n\t    }\n\t  }\n\t\n\t  function dblclicked() {\n\t    if (!filter.apply(this, arguments)) return;\n\t    var t0 = this.__zoom,\n\t        p0 = mouse(this),\n\t        p1 = t0.invert(p0),\n\t        k1 = t0.k * (exports.event.shiftKey ? 0.5 : 2),\n\t        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments));\n\t\n\t    noevent$1();\n\t    if (duration > 0) select(this).transition().duration(duration).call(schedule, t1, p0);\n\t    else select(this).call(zoom.transform, t1);\n\t  }\n\t\n\t  function touchstarted() {\n\t    if (!filter.apply(this, arguments)) return;\n\t    var g = gesture(this, arguments),\n\t        touches$$1 = exports.event.changedTouches,\n\t        n = touches$$1.length, i, t, p;\n\t\n\t    nopropagation$1();\n\t    for (i = 0; i < n; ++i) {\n\t      t = touches$$1[i], p = touch(this, touches$$1, t.identifier);\n\t      p = [p, this.__zoom.invert(p), t.identifier];\n\t      if (!g.touch0) g.touch0 = p;\n\t      else if (!g.touch1) g.touch1 = p;\n\t    }\n\t    if (touchstarting) {\n\t      touchstarting = clearTimeout(touchstarting);\n\t      if (!g.touch1) return g.end(), dblclicked.apply(this, arguments);\n\t    }\n\t    if (exports.event.touches.length === n) {\n\t      touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);\n\t      interrupt(this);\n\t      g.start();\n\t    }\n\t  }\n\t\n\t  function touchmoved() {\n\t    var g = gesture(this, arguments),\n\t        touches$$1 = exports.event.changedTouches,\n\t        n = touches$$1.length, i, t, p, l;\n\t\n\t    noevent$1();\n\t    if (touchstarting) touchstarting = clearTimeout(touchstarting);\n\t    for (i = 0; i < n; ++i) {\n\t      t = touches$$1[i], p = touch(this, touches$$1, t.identifier);\n\t      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;\n\t      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;\n\t    }\n\t    t = g.that.__zoom;\n\t    if (g.touch1) {\n\t      var p0 = g.touch0[0], l0 = g.touch0[1],\n\t          p1 = g.touch1[0], l1 = g.touch1[1],\n\t          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,\n\t          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;\n\t      t = scale(t, Math.sqrt(dp / dl));\n\t      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];\n\t      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];\n\t    }\n\t    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];\n\t    else return;\n\t    g.zoom(\"touch\", constrain(translate(t, p, l), g.extent));\n\t  }\n\t\n\t  function touchended() {\n\t    var g = gesture(this, arguments),\n\t        touches$$1 = exports.event.changedTouches,\n\t        n = touches$$1.length, i, t;\n\t\n\t    nopropagation$1();\n\t    if (touchending) clearTimeout(touchending);\n\t    touchending = setTimeout(function() { touchending = null; }, touchDelay);\n\t    for (i = 0; i < n; ++i) {\n\t      t = touches$$1[i];\n\t      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;\n\t      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;\n\t    }\n\t    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;\n\t    if (!g.touch0) g.end();\n\t  }\n\t\n\t  zoom.filter = function(_) {\n\t    return arguments.length ? (filter = typeof _ === \"function\" ? _ : constant$10(!!_), zoom) : filter;\n\t  };\n\t\n\t  zoom.extent = function(_) {\n\t    return arguments.length ? (extent = typeof _ === \"function\" ? _ : constant$10([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;\n\t  };\n\t\n\t  zoom.scaleExtent = function(_) {\n\t    return arguments.length ? (k0 = +_[0], k1 = +_[1], zoom) : [k0, k1];\n\t  };\n\t\n\t  zoom.translateExtent = function(_) {\n\t    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], zoom) : [[x0, y0], [x1, y1]];\n\t  };\n\t\n\t  zoom.duration = function(_) {\n\t    return arguments.length ? (duration = +_, zoom) : duration;\n\t  };\n\t\n\t  zoom.on = function() {\n\t    var value = listeners.on.apply(listeners, arguments);\n\t    return value === listeners ? zoom : value;\n\t  };\n\t\n\t  return zoom;\n\t};\n\t\n\tvar constant$11 = function(x) {\n\t  return function() {\n\t    return x;\n\t  };\n\t};\n\t\n\tvar BrushEvent = function(target, type, selection) {\n\t  this.target = target;\n\t  this.type = type;\n\t  this.selection = selection;\n\t};\n\t\n\tfunction nopropagation$2() {\n\t  exports.event.stopImmediatePropagation();\n\t}\n\t\n\tvar noevent$2 = function() {\n\t  exports.event.preventDefault();\n\t  exports.event.stopImmediatePropagation();\n\t};\n\t\n\tvar MODE_DRAG = {name: \"drag\"};\n\tvar MODE_SPACE = {name: \"space\"};\n\tvar MODE_HANDLE = {name: \"handle\"};\n\tvar MODE_CENTER = {name: \"center\"};\n\t\n\tvar X = {\n\t  name: \"x\",\n\t  handles: [\"e\", \"w\"].map(type$1),\n\t  input: function(x, e) { return x && [[x[0], e[0][1]], [x[1], e[1][1]]]; },\n\t  output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }\n\t};\n\t\n\tvar Y = {\n\t  name: \"y\",\n\t  handles: [\"n\", \"s\"].map(type$1),\n\t  input: function(y, e) { return y && [[e[0][0], y[0]], [e[1][0], y[1]]]; },\n\t  output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }\n\t};\n\t\n\tvar XY = {\n\t  name: \"xy\",\n\t  handles: [\"n\", \"e\", \"s\", \"w\", \"nw\", \"ne\", \"se\", \"sw\"].map(type$1),\n\t  input: function(xy) { return xy; },\n\t  output: function(xy) { return xy; }\n\t};\n\t\n\tvar cursors = {\n\t  overlay: \"crosshair\",\n\t  selection: \"move\",\n\t  n: \"ns-resize\",\n\t  e: \"ew-resize\",\n\t  s: \"ns-resize\",\n\t  w: \"ew-resize\",\n\t  nw: \"nwse-resize\",\n\t  ne: \"nesw-resize\",\n\t  se: \"nwse-resize\",\n\t  sw: \"nesw-resize\"\n\t};\n\t\n\tvar flipX = {\n\t  e: \"w\",\n\t  w: \"e\",\n\t  nw: \"ne\",\n\t  ne: \"nw\",\n\t  se: \"sw\",\n\t  sw: \"se\"\n\t};\n\t\n\tvar flipY = {\n\t  n: \"s\",\n\t  s: \"n\",\n\t  nw: \"sw\",\n\t  ne: \"se\",\n\t  se: \"ne\",\n\t  sw: \"nw\"\n\t};\n\t\n\tvar signsX = {\n\t  overlay: +1,\n\t  selection: +1,\n\t  n: null,\n\t  e: +1,\n\t  s: null,\n\t  w: -1,\n\t  nw: -1,\n\t  ne: +1,\n\t  se: +1,\n\t  sw: -1\n\t};\n\t\n\tvar signsY = {\n\t  overlay: +1,\n\t  selection: +1,\n\t  n: -1,\n\t  e: null,\n\t  s: +1,\n\t  w: null,\n\t  nw: -1,\n\t  ne: -1,\n\t  se: +1,\n\t  sw: +1\n\t};\n\t\n\tfunction type$1(t) {\n\t  return {type: t};\n\t}\n\t\n\t// Ignore right-click, since that should open the context menu.\n\tfunction defaultFilter$2() {\n\t  return !exports.event.button;\n\t}\n\t\n\tfunction defaultExtent$1() {\n\t  var svg = this.ownerSVGElement || this;\n\t  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];\n\t}\n\t\n\t// Like d3.local, but with the name “__brush” rather than auto-generated.\n\tfunction local$1(node) {\n\t  while (!node.__brush) if (!(node = node.parentNode)) return;\n\t  return node.__brush;\n\t}\n\t\n\tfunction empty$1(extent) {\n\t  return extent[0][0] === extent[1][0]\n\t      || extent[0][1] === extent[1][1];\n\t}\n\t\n\tfunction brushSelection(node) {\n\t  var state = node.__brush;\n\t  return state ? state.dim.output(state.selection) : null;\n\t}\n\t\n\tfunction brushX() {\n\t  return brush$1(X);\n\t}\n\t\n\tfunction brushY() {\n\t  return brush$1(Y);\n\t}\n\t\n\tvar brush = function() {\n\t  return brush$1(XY);\n\t};\n\t\n\tfunction brush$1(dim) {\n\t  var extent = defaultExtent$1,\n\t      filter = defaultFilter$2,\n\t      listeners = dispatch(brush, \"start\", \"brush\", \"end\"),\n\t      handleSize = 6,\n\t      touchending;\n\t\n\t  function brush(group) {\n\t    var overlay = group\n\t        .property(\"__brush\", initialize)\n\t      .selectAll(\".overlay\")\n\t      .data([type$1(\"overlay\")]);\n\t\n\t    overlay.enter().append(\"rect\")\n\t        .attr(\"class\", \"overlay\")\n\t        .attr(\"pointer-events\", \"all\")\n\t        .attr(\"cursor\", cursors.overlay)\n\t      .merge(overlay)\n\t        .each(function() {\n\t          var extent = local$1(this).extent;\n\t          select(this)\n\t              .attr(\"x\", extent[0][0])\n\t              .attr(\"y\", extent[0][1])\n\t              .attr(\"width\", extent[1][0] - extent[0][0])\n\t              .attr(\"height\", extent[1][1] - extent[0][1]);\n\t        });\n\t\n\t    group.selectAll(\".selection\")\n\t      .data([type$1(\"selection\")])\n\t      .enter().append(\"rect\")\n\t        .attr(\"class\", \"selection\")\n\t        .attr(\"cursor\", cursors.selection)\n\t        .attr(\"fill\", \"#777\")\n\t        .attr(\"fill-opacity\", 0.3)\n\t        .attr(\"stroke\", \"#fff\")\n\t        .attr(\"shape-rendering\", \"crispEdges\");\n\t\n\t    var handle = group.selectAll(\".handle\")\n\t      .data(dim.handles, function(d) { return d.type; });\n\t\n\t    handle.exit().remove();\n\t\n\t    handle.enter().append(\"rect\")\n\t        .attr(\"class\", function(d) { return \"handle handle--\" + d.type; })\n\t        .attr(\"cursor\", function(d) { return cursors[d.type]; });\n\t\n\t    group\n\t        .each(redraw)\n\t        .attr(\"fill\", \"none\")\n\t        .attr(\"pointer-events\", \"all\")\n\t        .style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\")\n\t        .on(\"mousedown.brush touchstart.brush\", started);\n\t  }\n\t\n\t  brush.move = function(group, selection$$1) {\n\t    if (group.selection) {\n\t      group\n\t          .on(\"start.brush\", function() { emitter(this, arguments).beforestart().start(); })\n\t          .on(\"interrupt.brush end.brush\", function() { emitter(this, arguments).end(); })\n\t          .tween(\"brush\", function() {\n\t            var that = this,\n\t                state = that.__brush,\n\t                emit = emitter(that, arguments),\n\t                selection0 = state.selection,\n\t                selection1 = dim.input(typeof selection$$1 === \"function\" ? selection$$1.apply(this, arguments) : selection$$1, state.extent),\n\t                i = interpolate(selection0, selection1);\n\t\n\t            function tween(t) {\n\t              state.selection = t === 1 && empty$1(selection1) ? null : i(t);\n\t              redraw.call(that);\n\t              emit.brush();\n\t            }\n\t\n\t            return selection0 && selection1 ? tween : tween(1);\n\t          });\n\t    } else {\n\t      group\n\t          .each(function() {\n\t            var that = this,\n\t                args = arguments,\n\t                state = that.__brush,\n\t                selection1 = dim.input(typeof selection$$1 === \"function\" ? selection$$1.apply(that, args) : selection$$1, state.extent),\n\t                emit = emitter(that, args).beforestart();\n\t\n\t            interrupt(that);\n\t            state.selection = selection1 == null || empty$1(selection1) ? null : selection1;\n\t            redraw.call(that);\n\t            emit.start().brush().end();\n\t          });\n\t    }\n\t  };\n\t\n\t  function redraw() {\n\t    var group = select(this),\n\t        selection$$1 = local$1(this).selection;\n\t\n\t    if (selection$$1) {\n\t      group.selectAll(\".selection\")\n\t          .style(\"display\", null)\n\t          .attr(\"x\", selection$$1[0][0])\n\t          .attr(\"y\", selection$$1[0][1])\n\t          .attr(\"width\", selection$$1[1][0] - selection$$1[0][0])\n\t          .attr(\"height\", selection$$1[1][1] - selection$$1[0][1]);\n\t\n\t      group.selectAll(\".handle\")\n\t          .style(\"display\", null)\n\t          .attr(\"x\", function(d) { return d.type[d.type.length - 1] === \"e\" ? selection$$1[1][0] - handleSize / 2 : selection$$1[0][0] - handleSize / 2; })\n\t          .attr(\"y\", function(d) { return d.type[0] === \"s\" ? selection$$1[1][1] - handleSize / 2 : selection$$1[0][1] - handleSize / 2; })\n\t          .attr(\"width\", function(d) { return d.type === \"n\" || d.type === \"s\" ? selection$$1[1][0] - selection$$1[0][0] + handleSize : handleSize; })\n\t          .attr(\"height\", function(d) { return d.type === \"e\" || d.type === \"w\" ? selection$$1[1][1] - selection$$1[0][1] + handleSize : handleSize; });\n\t    }\n\t\n\t    else {\n\t      group.selectAll(\".selection,.handle\")\n\t          .style(\"display\", \"none\")\n\t          .attr(\"x\", null)\n\t          .attr(\"y\", null)\n\t          .attr(\"width\", null)\n\t          .attr(\"height\", null);\n\t    }\n\t  }\n\t\n\t  function emitter(that, args) {\n\t    return that.__brush.emitter || new Emitter(that, args);\n\t  }\n\t\n\t  function Emitter(that, args) {\n\t    this.that = that;\n\t    this.args = args;\n\t    this.state = that.__brush;\n\t    this.active = 0;\n\t  }\n\t\n\t  Emitter.prototype = {\n\t    beforestart: function() {\n\t      if (++this.active === 1) this.state.emitter = this, this.starting = true;\n\t      return this;\n\t    },\n\t    start: function() {\n\t      if (this.starting) this.starting = false, this.emit(\"start\");\n\t      return this;\n\t    },\n\t    brush: function() {\n\t      this.emit(\"brush\");\n\t      return this;\n\t    },\n\t    end: function() {\n\t      if (--this.active === 0) delete this.state.emitter, this.emit(\"end\");\n\t      return this;\n\t    },\n\t    emit: function(type) {\n\t      customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);\n\t    }\n\t  };\n\t\n\t  function started() {\n\t    if (exports.event.touches) { if (exports.event.changedTouches.length < exports.event.touches.length) return noevent$2(); }\n\t    else if (touchending) return;\n\t    if (!filter.apply(this, arguments)) return;\n\t\n\t    var that = this,\n\t        type = exports.event.target.__data__.type,\n\t        mode = (exports.event.metaKey ? type = \"overlay\" : type) === \"selection\" ? MODE_DRAG : (exports.event.altKey ? MODE_CENTER : MODE_HANDLE),\n\t        signX = dim === Y ? null : signsX[type],\n\t        signY = dim === X ? null : signsY[type],\n\t        state = local$1(that),\n\t        extent = state.extent,\n\t        selection$$1 = state.selection,\n\t        W = extent[0][0], w0, w1,\n\t        N = extent[0][1], n0, n1,\n\t        E = extent[1][0], e0, e1,\n\t        S = extent[1][1], s0, s1,\n\t        dx,\n\t        dy,\n\t        moving,\n\t        shifting = signX && signY && exports.event.shiftKey,\n\t        lockX,\n\t        lockY,\n\t        point0 = mouse(that),\n\t        point = point0,\n\t        emit = emitter(that, arguments).beforestart();\n\t\n\t    if (type === \"overlay\") {\n\t      state.selection = selection$$1 = [\n\t        [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],\n\t        [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]\n\t      ];\n\t    } else {\n\t      w0 = selection$$1[0][0];\n\t      n0 = selection$$1[0][1];\n\t      e0 = selection$$1[1][0];\n\t      s0 = selection$$1[1][1];\n\t    }\n\t\n\t    w1 = w0;\n\t    n1 = n0;\n\t    e1 = e0;\n\t    s1 = s0;\n\t\n\t    var group = select(that)\n\t        .attr(\"pointer-events\", \"none\");\n\t\n\t    var overlay = group.selectAll(\".overlay\")\n\t        .attr(\"cursor\", cursors[type]);\n\t\n\t    if (exports.event.touches) {\n\t      group\n\t          .on(\"touchmove.brush\", moved, true)\n\t          .on(\"touchend.brush touchcancel.brush\", ended, true);\n\t    } else {\n\t      var view = select(exports.event.view)\n\t          .on(\"keydown.brush\", keydowned, true)\n\t          .on(\"keyup.brush\", keyupped, true)\n\t          .on(\"mousemove.brush\", moved, true)\n\t          .on(\"mouseup.brush\", ended, true);\n\t\n\t      dragDisable(exports.event.view);\n\t    }\n\t\n\t    nopropagation$2();\n\t    interrupt(that);\n\t    redraw.call(that);\n\t    emit.start();\n\t\n\t    function moved() {\n\t      var point1 = mouse(that);\n\t      if (shifting && !lockX && !lockY) {\n\t        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;\n\t        else lockX = true;\n\t      }\n\t      point = point1;\n\t      moving = true;\n\t      noevent$2();\n\t      move();\n\t    }\n\t\n\t    function move() {\n\t      var t;\n\t\n\t      dx = point[0] - point0[0];\n\t      dy = point[1] - point0[1];\n\t\n\t      switch (mode) {\n\t        case MODE_SPACE:\n\t        case MODE_DRAG: {\n\t          if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;\n\t          if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;\n\t          break;\n\t        }\n\t        case MODE_HANDLE: {\n\t          if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;\n\t          else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;\n\t          if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;\n\t          else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;\n\t          break;\n\t        }\n\t        case MODE_CENTER: {\n\t          if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));\n\t          if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));\n\t          break;\n\t        }\n\t      }\n\t\n\t      if (e1 < w1) {\n\t        signX *= -1;\n\t        t = w0, w0 = e0, e0 = t;\n\t        t = w1, w1 = e1, e1 = t;\n\t        if (type in flipX) overlay.attr(\"cursor\", cursors[type = flipX[type]]);\n\t      }\n\t\n\t      if (s1 < n1) {\n\t        signY *= -1;\n\t        t = n0, n0 = s0, s0 = t;\n\t        t = n1, n1 = s1, s1 = t;\n\t        if (type in flipY) overlay.attr(\"cursor\", cursors[type = flipY[type]]);\n\t      }\n\t\n\t      if (state.selection) selection$$1 = state.selection; // May be set by brush.move!\n\t      if (lockX) w1 = selection$$1[0][0], e1 = selection$$1[1][0];\n\t      if (lockY) n1 = selection$$1[0][1], s1 = selection$$1[1][1];\n\t\n\t      if (selection$$1[0][0] !== w1\n\t          || selection$$1[0][1] !== n1\n\t          || selection$$1[1][0] !== e1\n\t          || selection$$1[1][1] !== s1) {\n\t        state.selection = [[w1, n1], [e1, s1]];\n\t        redraw.call(that);\n\t        emit.brush();\n\t      }\n\t    }\n\t\n\t    function ended() {\n\t      nopropagation$2();\n\t      if (exports.event.touches) {\n\t        if (exports.event.touches.length) return;\n\t        if (touchending) clearTimeout(touchending);\n\t        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!\n\t        group.on(\"touchmove.brush touchend.brush touchcancel.brush\", null);\n\t      } else {\n\t        yesdrag(exports.event.view, moving);\n\t        view.on(\"keydown.brush keyup.brush mousemove.brush mouseup.brush\", null);\n\t      }\n\t      group.attr(\"pointer-events\", \"all\");\n\t      overlay.attr(\"cursor\", cursors.overlay);\n\t      if (state.selection) selection$$1 = state.selection; // May be set by brush.move (on start)!\n\t      if (empty$1(selection$$1)) state.selection = null, redraw.call(that);\n\t      emit.end();\n\t    }\n\t\n\t    function keydowned() {\n\t      switch (exports.event.keyCode) {\n\t        case 16: { // SHIFT\n\t          shifting = signX && signY;\n\t          break;\n\t        }\n\t        case 18: { // ALT\n\t          if (mode === MODE_HANDLE) {\n\t            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;\n\t            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;\n\t            mode = MODE_CENTER;\n\t            move();\n\t          }\n\t          break;\n\t        }\n\t        case 32: { // SPACE; takes priority over ALT\n\t          if (mode === MODE_HANDLE || mode === MODE_CENTER) {\n\t            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;\n\t            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;\n\t            mode = MODE_SPACE;\n\t            overlay.attr(\"cursor\", cursors.selection);\n\t            move();\n\t          }\n\t          break;\n\t        }\n\t        default: return;\n\t      }\n\t      noevent$2();\n\t    }\n\t\n\t    function keyupped() {\n\t      switch (exports.event.keyCode) {\n\t        case 16: { // SHIFT\n\t          if (shifting) {\n\t            lockX = lockY = shifting = false;\n\t            move();\n\t          }\n\t          break;\n\t        }\n\t        case 18: { // ALT\n\t          if (mode === MODE_CENTER) {\n\t            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;\n\t            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;\n\t            mode = MODE_HANDLE;\n\t            move();\n\t          }\n\t          break;\n\t        }\n\t        case 32: { // SPACE\n\t          if (mode === MODE_SPACE) {\n\t            if (exports.event.altKey) {\n\t              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;\n\t              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;\n\t              mode = MODE_CENTER;\n\t            } else {\n\t              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;\n\t              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;\n\t              mode = MODE_HANDLE;\n\t            }\n\t            overlay.attr(\"cursor\", cursors[type]);\n\t            move();\n\t          }\n\t          break;\n\t        }\n\t        default: return;\n\t      }\n\t      noevent$2();\n\t    }\n\t  }\n\t\n\t  function initialize() {\n\t    var state = this.__brush || {selection: null};\n\t    state.extent = extent.apply(this, arguments);\n\t    state.dim = dim;\n\t    return state;\n\t  }\n\t\n\t  brush.extent = function(_) {\n\t    return arguments.length ? (extent = typeof _ === \"function\" ? _ : constant$11([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent;\n\t  };\n\t\n\t  brush.filter = function(_) {\n\t    return arguments.length ? (filter = typeof _ === \"function\" ? _ : constant$11(!!_), brush) : filter;\n\t  };\n\t\n\t  brush.handleSize = function(_) {\n\t    return arguments.length ? (handleSize = +_, brush) : handleSize;\n\t  };\n\t\n\t  brush.on = function() {\n\t    var value = listeners.on.apply(listeners, arguments);\n\t    return value === listeners ? brush : value;\n\t  };\n\t\n\t  return brush;\n\t}\n\t\n\tvar cos = Math.cos;\n\tvar sin = Math.sin;\n\tvar pi$3 = Math.PI;\n\tvar halfPi$2 = pi$3 / 2;\n\tvar tau$3 = pi$3 * 2;\n\tvar max$1 = Math.max;\n\t\n\tfunction compareValue(compare) {\n\t  return function(a, b) {\n\t    return compare(\n\t      a.source.value + a.target.value,\n\t      b.source.value + b.target.value\n\t    );\n\t  };\n\t}\n\t\n\tvar chord = function() {\n\t  var padAngle = 0,\n\t      sortGroups = null,\n\t      sortSubgroups = null,\n\t      sortChords = null;\n\t\n\t  function chord(matrix) {\n\t    var n = matrix.length,\n\t        groupSums = [],\n\t        groupIndex = range(n),\n\t        subgroupIndex = [],\n\t        chords = [],\n\t        groups = chords.groups = new Array(n),\n\t        subgroups = new Array(n * n),\n\t        k,\n\t        x,\n\t        x0,\n\t        dx,\n\t        i,\n\t        j;\n\t\n\t    // Compute the sum.\n\t    k = 0, i = -1; while (++i < n) {\n\t      x = 0, j = -1; while (++j < n) {\n\t        x += matrix[i][j];\n\t      }\n\t      groupSums.push(x);\n\t      subgroupIndex.push(range(n));\n\t      k += x;\n\t    }\n\t\n\t    // Sort groups…\n\t    if (sortGroups) groupIndex.sort(function(a, b) {\n\t      return sortGroups(groupSums[a], groupSums[b]);\n\t    });\n\t\n\t    // Sort subgroups…\n\t    if (sortSubgroups) subgroupIndex.forEach(function(d, i) {\n\t      d.sort(function(a, b) {\n\t        return sortSubgroups(matrix[i][a], matrix[i][b]);\n\t      });\n\t    });\n\t\n\t    // Convert the sum to scaling factor for [0, 2pi].\n\t    // TODO Allow start and end angle to be specified?\n\t    // TODO Allow padding to be specified as percentage?\n\t    k = max$1(0, tau$3 - padAngle * n) / k;\n\t    dx = k ? padAngle : tau$3 / n;\n\t\n\t    // Compute the start and end angle for each group and subgroup.\n\t    // Note: Opera has a bug reordering object literal properties!\n\t    x = 0, i = -1; while (++i < n) {\n\t      x0 = x, j = -1; while (++j < n) {\n\t        var di = groupIndex[i],\n\t            dj = subgroupIndex[di][j],\n\t            v = matrix[di][dj],\n\t            a0 = x,\n\t            a1 = x += v * k;\n\t        subgroups[dj * n + di] = {\n\t          index: di,\n\t          subindex: dj,\n\t          startAngle: a0,\n\t          endAngle: a1,\n\t          value: v\n\t        };\n\t      }\n\t      groups[di] = {\n\t        index: di,\n\t        startAngle: x0,\n\t        endAngle: x,\n\t        value: groupSums[di]\n\t      };\n\t      x += dx;\n\t    }\n\t\n\t    // Generate chords for each (non-empty) subgroup-subgroup link.\n\t    i = -1; while (++i < n) {\n\t      j = i - 1; while (++j < n) {\n\t        var source = subgroups[j * n + i],\n\t            target = subgroups[i * n + j];\n\t        if (source.value || target.value) {\n\t          chords.push(source.value < target.value\n\t              ? {source: target, target: source}\n\t              : {source: source, target: target});\n\t        }\n\t      }\n\t    }\n\t\n\t    return sortChords ? chords.sort(sortChords) : chords;\n\t  }\n\t\n\t  chord.padAngle = function(_) {\n\t    return arguments.length ? (padAngle = max$1(0, _), chord) : padAngle;\n\t  };\n\t\n\t  chord.sortGroups = function(_) {\n\t    return arguments.length ? (sortGroups = _, chord) : sortGroups;\n\t  };\n\t\n\t  chord.sortSubgroups = function(_) {\n\t    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;\n\t  };\n\t\n\t  chord.sortChords = function(_) {\n\t    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;\n\t  };\n\t\n\t  return chord;\n\t};\n\t\n\tvar slice$5 = Array.prototype.slice;\n\t\n\tvar constant$12 = function(x) {\n\t  return function() {\n\t    return x;\n\t  };\n\t};\n\t\n\tfunction defaultSource(d) {\n\t  return d.source;\n\t}\n\t\n\tfunction defaultTarget(d) {\n\t  return d.target;\n\t}\n\t\n\tfunction defaultRadius$1(d) {\n\t  return d.radius;\n\t}\n\t\n\tfunction defaultStartAngle(d) {\n\t  return d.startAngle;\n\t}\n\t\n\tfunction defaultEndAngle(d) {\n\t  return d.endAngle;\n\t}\n\t\n\tvar ribbon = function() {\n\t  var source = defaultSource,\n\t      target = defaultTarget,\n\t      radius = defaultRadius$1,\n\t      startAngle = defaultStartAngle,\n\t      endAngle = defaultEndAngle,\n\t      context = null;\n\t\n\t  function ribbon() {\n\t    var buffer,\n\t        argv = slice$5.call(arguments),\n\t        s = source.apply(this, argv),\n\t        t = target.apply(this, argv),\n\t        sr = +radius.apply(this, (argv[0] = s, argv)),\n\t        sa0 = startAngle.apply(this, argv) - halfPi$2,\n\t        sa1 = endAngle.apply(this, argv) - halfPi$2,\n\t        sx0 = sr * cos(sa0),\n\t        sy0 = sr * sin(sa0),\n\t        tr = +radius.apply(this, (argv[0] = t, argv)),\n\t        ta0 = startAngle.apply(this, argv) - halfPi$2,\n\t        ta1 = endAngle.apply(this, argv) - halfPi$2;\n\t\n\t    if (!context) context = buffer = path();\n\t\n\t    context.moveTo(sx0, sy0);\n\t    context.arc(0, 0, sr, sa0, sa1);\n\t    if (sa0 !== ta0 || sa1 !== ta1) { // TODO sr !== tr?\n\t      context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));\n\t      context.arc(0, 0, tr, ta0, ta1);\n\t    }\n\t    context.quadraticCurveTo(0, 0, sx0, sy0);\n\t    context.closePath();\n\t\n\t    if (buffer) return context = null, buffer + \"\" || null;\n\t  }\n\t\n\t  ribbon.radius = function(_) {\n\t    return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant$12(+_), ribbon) : radius;\n\t  };\n\t\n\t  ribbon.startAngle = function(_) {\n\t    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant$12(+_), ribbon) : startAngle;\n\t  };\n\t\n\t  ribbon.endAngle = function(_) {\n\t    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant$12(+_), ribbon) : endAngle;\n\t  };\n\t\n\t  ribbon.source = function(_) {\n\t    return arguments.length ? (source = _, ribbon) : source;\n\t  };\n\t\n\t  ribbon.target = function(_) {\n\t    return arguments.length ? (target = _, ribbon) : target;\n\t  };\n\t\n\t  ribbon.context = function(_) {\n\t    return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;\n\t  };\n\t\n\t  return ribbon;\n\t};\n\t\n\t// Adds floating point numbers with twice the normal precision.\n\t// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and\n\t// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)\n\t// 305–363 (1997).\n\t// Code adapted from GeographicLib by Charles F. F. Karney,\n\t// http://geographiclib.sourceforge.net/\n\t\n\tvar adder = function() {\n\t  return new Adder;\n\t};\n\t\n\tfunction Adder() {\n\t  this.reset();\n\t}\n\t\n\tAdder.prototype = {\n\t  constructor: Adder,\n\t  reset: function() {\n\t    this.s = // rounded value\n\t    this.t = 0; // exact error\n\t  },\n\t  add: function(y) {\n\t    add$1(temp, y, this.t);\n\t    add$1(this, temp.s, this.s);\n\t    if (this.s) this.t += temp.t;\n\t    else this.s = temp.t;\n\t  },\n\t  valueOf: function() {\n\t    return this.s;\n\t  }\n\t};\n\t\n\tvar temp = new Adder;\n\t\n\tfunction add$1(adder, a, b) {\n\t  var x = adder.s = a + b,\n\t      bv = x - a,\n\t      av = x - bv;\n\t  adder.t = (a - av) + (b - bv);\n\t}\n\t\n\tvar epsilon$4 = 1e-6;\n\tvar epsilon2$2 = 1e-12;\n\tvar pi$4 = Math.PI;\n\tvar halfPi$3 = pi$4 / 2;\n\tvar quarterPi = pi$4 / 4;\n\tvar tau$4 = pi$4 * 2;\n\t\n\tvar degrees$1 = 180 / pi$4;\n\tvar radians = pi$4 / 180;\n\t\n\tvar abs = Math.abs;\n\tvar atan = Math.atan;\n\tvar atan2 = Math.atan2;\n\tvar cos$1 = Math.cos;\n\tvar ceil = Math.ceil;\n\tvar exp = Math.exp;\n\t\n\tvar log$1 = Math.log;\n\tvar pow$1 = Math.pow;\n\tvar sin$1 = Math.sin;\n\tvar sign$1 = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };\n\tvar sqrt$1 = Math.sqrt;\n\tvar tan = Math.tan;\n\t\n\tfunction acos(x) {\n\t  return x > 1 ? 0 : x < -1 ? pi$4 : Math.acos(x);\n\t}\n\t\n\tfunction asin$1(x) {\n\t  return x > 1 ? halfPi$3 : x < -1 ? -halfPi$3 : Math.asin(x);\n\t}\n\t\n\tfunction haversin(x) {\n\t  return (x = sin$1(x / 2)) * x;\n\t}\n\t\n\tfunction noop$2() {}\n\t\n\tfunction streamGeometry(geometry, stream) {\n\t  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {\n\t    streamGeometryType[geometry.type](geometry, stream);\n\t  }\n\t}\n\t\n\tvar streamObjectType = {\n\t  Feature: function(feature, stream) {\n\t    streamGeometry(feature.geometry, stream);\n\t  },\n\t  FeatureCollection: function(object, stream) {\n\t    var features = object.features, i = -1, n = features.length;\n\t    while (++i < n) streamGeometry(features[i].geometry, stream);\n\t  }\n\t};\n\t\n\tvar streamGeometryType = {\n\t  Sphere: function(object, stream) {\n\t    stream.sphere();\n\t  },\n\t  Point: function(object, stream) {\n\t    object = object.coordinates;\n\t    stream.point(object[0], object[1], object[2]);\n\t  },\n\t  MultiPoint: function(object, stream) {\n\t    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n\t    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);\n\t  },\n\t  LineString: function(object, stream) {\n\t    streamLine(object.coordinates, stream, 0);\n\t  },\n\t  MultiLineString: function(object, stream) {\n\t    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n\t    while (++i < n) streamLine(coordinates[i], stream, 0);\n\t  },\n\t  Polygon: function(object, stream) {\n\t    streamPolygon(object.coordinates, stream);\n\t  },\n\t  MultiPolygon: function(object, stream) {\n\t    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n\t    while (++i < n) streamPolygon(coordinates[i], stream);\n\t  },\n\t  GeometryCollection: function(object, stream) {\n\t    var geometries = object.geometries, i = -1, n = geometries.length;\n\t    while (++i < n) streamGeometry(geometries[i], stream);\n\t  }\n\t};\n\t\n\tfunction streamLine(coordinates, stream, closed) {\n\t  var i = -1, n = coordinates.length - closed, coordinate;\n\t  stream.lineStart();\n\t  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);\n\t  stream.lineEnd();\n\t}\n\t\n\tfunction streamPolygon(coordinates, stream) {\n\t  var i = -1, n = coordinates.length;\n\t  stream.polygonStart();\n\t  while (++i < n) streamLine(coordinates[i], stream, 1);\n\t  stream.polygonEnd();\n\t}\n\t\n\tvar geoStream = function(object, stream) {\n\t  if (object && streamObjectType.hasOwnProperty(object.type)) {\n\t    streamObjectType[object.type](object, stream);\n\t  } else {\n\t    streamGeometry(object, stream);\n\t  }\n\t};\n\t\n\tvar areaRingSum = adder();\n\t\n\tvar areaSum = adder();\n\tvar lambda00;\n\tvar phi00;\n\tvar lambda0;\n\tvar cosPhi0;\n\tvar sinPhi0;\n\t\n\tvar areaStream = {\n\t  point: noop$2,\n\t  lineStart: noop$2,\n\t  lineEnd: noop$2,\n\t  polygonStart: function() {\n\t    areaRingSum.reset();\n\t    areaStream.lineStart = areaRingStart;\n\t    areaStream.lineEnd = areaRingEnd;\n\t  },\n\t  polygonEnd: function() {\n\t    var areaRing = +areaRingSum;\n\t    areaSum.add(areaRing < 0 ? tau$4 + areaRing : areaRing);\n\t    this.lineStart = this.lineEnd = this.point = noop$2;\n\t  },\n\t  sphere: function() {\n\t    areaSum.add(tau$4);\n\t  }\n\t};\n\t\n\tfunction areaRingStart() {\n\t  areaStream.point = areaPointFirst;\n\t}\n\t\n\tfunction areaRingEnd() {\n\t  areaPoint(lambda00, phi00);\n\t}\n\t\n\tfunction areaPointFirst(lambda, phi) {\n\t  areaStream.point = areaPoint;\n\t  lambda00 = lambda, phi00 = phi;\n\t  lambda *= radians, phi *= radians;\n\t  lambda0 = lambda, cosPhi0 = cos$1(phi = phi / 2 + quarterPi), sinPhi0 = sin$1(phi);\n\t}\n\t\n\tfunction areaPoint(lambda, phi) {\n\t  lambda *= radians, phi *= radians;\n\t  phi = phi / 2 + quarterPi; // half the angular distance from south pole\n\t\n\t  // Spherical excess E for a spherical triangle with vertices: south pole,\n\t  // previous point, current point.  Uses a formula derived from Cagnoli’s\n\t  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n\t  var dLambda = lambda - lambda0,\n\t      sdLambda = dLambda >= 0 ? 1 : -1,\n\t      adLambda = sdLambda * dLambda,\n\t      cosPhi = cos$1(phi),\n\t      sinPhi = sin$1(phi),\n\t      k = sinPhi0 * sinPhi,\n\t      u = cosPhi0 * cosPhi + k * cos$1(adLambda),\n\t      v = k * sdLambda * sin$1(adLambda);\n\t  areaRingSum.add(atan2(v, u));\n\t\n\t  // Advance the previous points.\n\t  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;\n\t}\n\t\n\tvar area$2 = function(object) {\n\t  areaSum.reset();\n\t  geoStream(object, areaStream);\n\t  return areaSum * 2;\n\t};\n\t\n\tfunction spherical(cartesian) {\n\t  return [atan2(cartesian[1], cartesian[0]), asin$1(cartesian[2])];\n\t}\n\t\n\tfunction cartesian(spherical) {\n\t  var lambda = spherical[0], phi = spherical[1], cosPhi = cos$1(phi);\n\t  return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi)];\n\t}\n\t\n\tfunction cartesianDot(a, b) {\n\t  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n\t}\n\t\n\tfunction cartesianCross(a, b) {\n\t  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n\t}\n\t\n\t// TODO return a\n\tfunction cartesianAddInPlace(a, b) {\n\t  a[0] += b[0], a[1] += b[1], a[2] += b[2];\n\t}\n\t\n\tfunction cartesianScale(vector, k) {\n\t  return [vector[0] * k, vector[1] * k, vector[2] * k];\n\t}\n\t\n\t// TODO return d\n\tfunction cartesianNormalizeInPlace(d) {\n\t  var l = sqrt$1(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n\t  d[0] /= l, d[1] /= l, d[2] /= l;\n\t}\n\t\n\tvar lambda0$1;\n\tvar phi0;\n\tvar lambda1;\n\tvar phi1;\n\tvar lambda2;\n\tvar lambda00$1;\n\tvar phi00$1;\n\tvar p0;\n\tvar deltaSum = adder();\n\tvar ranges;\n\tvar range$1;\n\t\n\tvar boundsStream = {\n\t  point: boundsPoint,\n\t  lineStart: boundsLineStart,\n\t  lineEnd: boundsLineEnd,\n\t  polygonStart: function() {\n\t    boundsStream.point = boundsRingPoint;\n\t    boundsStream.lineStart = boundsRingStart;\n\t    boundsStream.lineEnd = boundsRingEnd;\n\t    deltaSum.reset();\n\t    areaStream.polygonStart();\n\t  },\n\t  polygonEnd: function() {\n\t    areaStream.polygonEnd();\n\t    boundsStream.point = boundsPoint;\n\t    boundsStream.lineStart = boundsLineStart;\n\t    boundsStream.lineEnd = boundsLineEnd;\n\t    if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n\t    else if (deltaSum > epsilon$4) phi1 = 90;\n\t    else if (deltaSum < -epsilon$4) phi0 = -90;\n\t    range$1[0] = lambda0$1, range$1[1] = lambda1;\n\t  }\n\t};\n\t\n\tfunction boundsPoint(lambda, phi) {\n\t  ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);\n\t  if (phi < phi0) phi0 = phi;\n\t  if (phi > phi1) phi1 = phi;\n\t}\n\t\n\tfunction linePoint(lambda, phi) {\n\t  var p = cartesian([lambda * radians, phi * radians]);\n\t  if (p0) {\n\t    var normal = cartesianCross(p0, p),\n\t        equatorial = [normal[1], -normal[0], 0],\n\t        inflection = cartesianCross(equatorial, normal);\n\t    cartesianNormalizeInPlace(inflection);\n\t    inflection = spherical(inflection);\n\t    var delta = lambda - lambda2,\n\t        sign$$1 = delta > 0 ? 1 : -1,\n\t        lambdai = inflection[0] * degrees$1 * sign$$1,\n\t        phii,\n\t        antimeridian = abs(delta) > 180;\n\t    if (antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {\n\t      phii = inflection[1] * degrees$1;\n\t      if (phii > phi1) phi1 = phii;\n\t    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {\n\t      phii = -inflection[1] * degrees$1;\n\t      if (phii < phi0) phi0 = phii;\n\t    } else {\n\t      if (phi < phi0) phi0 = phi;\n\t      if (phi > phi1) phi1 = phi;\n\t    }\n\t    if (antimeridian) {\n\t      if (lambda < lambda2) {\n\t        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;\n\t      } else {\n\t        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;\n\t      }\n\t    } else {\n\t      if (lambda1 >= lambda0$1) {\n\t        if (lambda < lambda0$1) lambda0$1 = lambda;\n\t        if (lambda > lambda1) lambda1 = lambda;\n\t      } else {\n\t        if (lambda > lambda2) {\n\t          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;\n\t        } else {\n\t          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;\n\t        }\n\t      }\n\t    }\n\t  } else {\n\t    boundsPoint(lambda, phi);\n\t  }\n\t  p0 = p, lambda2 = lambda;\n\t}\n\t\n\tfunction boundsLineStart() {\n\t  boundsStream.point = linePoint;\n\t}\n\t\n\tfunction boundsLineEnd() {\n\t  range$1[0] = lambda0$1, range$1[1] = lambda1;\n\t  boundsStream.point = boundsPoint;\n\t  p0 = null;\n\t}\n\t\n\tfunction boundsRingPoint(lambda, phi) {\n\t  if (p0) {\n\t    var delta = lambda - lambda2;\n\t    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n\t  } else {\n\t    lambda00$1 = lambda, phi00$1 = phi;\n\t  }\n\t  areaStream.point(lambda, phi);\n\t  linePoint(lambda, phi);\n\t}\n\t\n\tfunction boundsRingStart() {\n\t  areaStream.lineStart();\n\t}\n\t\n\tfunction boundsRingEnd() {\n\t  boundsRingPoint(lambda00$1, phi00$1);\n\t  areaStream.lineEnd();\n\t  if (abs(deltaSum) > epsilon$4) lambda0$1 = -(lambda1 = 180);\n\t  range$1[0] = lambda0$1, range$1[1] = lambda1;\n\t  p0 = null;\n\t}\n\t\n\t// Finds the left-right distance between two longitudes.\n\t// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want\n\t// the distance between ±180° to be 360°.\n\tfunction angle(lambda0, lambda1) {\n\t  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n\t}\n\t\n\tfunction rangeCompare(a, b) {\n\t  return a[0] - b[0];\n\t}\n\t\n\tfunction rangeContains(range, x) {\n\t  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n\t}\n\t\n\tvar bounds = function(feature) {\n\t  var i, n, a, b, merged, deltaMax, delta;\n\t\n\t  phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);\n\t  ranges = [];\n\t  geoStream(feature, boundsStream);\n\t\n\t  // First, sort ranges by their minimum longitudes.\n\t  if (n = ranges.length) {\n\t    ranges.sort(rangeCompare);\n\t\n\t    // Then, merge any ranges that overlap.\n\t    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n\t      b = ranges[i];\n\t      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n\t        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n\t        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n\t      } else {\n\t        merged.push(a = b);\n\t      }\n\t    }\n\t\n\t    // Finally, find the largest gap between the merged ranges.\n\t    // The final bounding box will be the inverse of this gap.\n\t    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n\t      b = merged[i];\n\t      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];\n\t    }\n\t  }\n\t\n\t  ranges = range$1 = null;\n\t\n\t  return lambda0$1 === Infinity || phi0 === Infinity\n\t      ? [[NaN, NaN], [NaN, NaN]]\n\t      : [[lambda0$1, phi0], [lambda1, phi1]];\n\t};\n\t\n\tvar W0;\n\tvar W1;\n\tvar X0;\n\tvar Y0;\n\tvar Z0;\n\tvar X1;\n\tvar Y1;\n\tvar Z1;\n\tvar X2;\n\tvar Y2;\n\tvar Z2;\n\tvar lambda00$2;\n\tvar phi00$2;\n\tvar x0;\n\tvar y0;\n\tvar z0; // previous point\n\t\n\tvar centroidStream = {\n\t  sphere: noop$2,\n\t  point: centroidPoint,\n\t  lineStart: centroidLineStart,\n\t  lineEnd: centroidLineEnd,\n\t  polygonStart: function() {\n\t    centroidStream.lineStart = centroidRingStart;\n\t    centroidStream.lineEnd = centroidRingEnd;\n\t  },\n\t  polygonEnd: function() {\n\t    centroidStream.lineStart = centroidLineStart;\n\t    centroidStream.lineEnd = centroidLineEnd;\n\t  }\n\t};\n\t\n\t// Arithmetic mean of Cartesian vectors.\n\tfunction centroidPoint(lambda, phi) {\n\t  lambda *= radians, phi *= radians;\n\t  var cosPhi = cos$1(phi);\n\t  centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi));\n\t}\n\t\n\tfunction centroidPointCartesian(x, y, z) {\n\t  ++W0;\n\t  X0 += (x - X0) / W0;\n\t  Y0 += (y - Y0) / W0;\n\t  Z0 += (z - Z0) / W0;\n\t}\n\t\n\tfunction centroidLineStart() {\n\t  centroidStream.point = centroidLinePointFirst;\n\t}\n\t\n\tfunction centroidLinePointFirst(lambda, phi) {\n\t  lambda *= radians, phi *= radians;\n\t  var cosPhi = cos$1(phi);\n\t  x0 = cosPhi * cos$1(lambda);\n\t  y0 = cosPhi * sin$1(lambda);\n\t  z0 = sin$1(phi);\n\t  centroidStream.point = centroidLinePoint;\n\t  centroidPointCartesian(x0, y0, z0);\n\t}\n\t\n\tfunction centroidLinePoint(lambda, phi) {\n\t  lambda *= radians, phi *= radians;\n\t  var cosPhi = cos$1(phi),\n\t      x = cosPhi * cos$1(lambda),\n\t      y = cosPhi * sin$1(lambda),\n\t      z = sin$1(phi),\n\t      w = atan2(sqrt$1((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n\t  W1 += w;\n\t  X1 += w * (x0 + (x0 = x));\n\t  Y1 += w * (y0 + (y0 = y));\n\t  Z1 += w * (z0 + (z0 = z));\n\t  centroidPointCartesian(x0, y0, z0);\n\t}\n\t\n\tfunction centroidLineEnd() {\n\t  centroidStream.point = centroidPoint;\n\t}\n\t\n\t// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,\n\t// J. Applied Mechanics 42, 239 (1975).\n\tfunction centroidRingStart() {\n\t  centroidStream.point = centroidRingPointFirst;\n\t}\n\t\n\tfunction centroidRingEnd() {\n\t  centroidRingPoint(lambda00$2, phi00$2);\n\t  centroidStream.point = centroidPoint;\n\t}\n\t\n\tfunction centroidRingPointFirst(lambda, phi) {\n\t  lambda00$2 = lambda, phi00$2 = phi;\n\t  lambda *= radians, phi *= radians;\n\t  centroidStream.point = centroidRingPoint;\n\t  var cosPhi = cos$1(phi);\n\t  x0 = cosPhi * cos$1(lambda);\n\t  y0 = cosPhi * sin$1(lambda);\n\t  z0 = sin$1(phi);\n\t  centroidPointCartesian(x0, y0, z0);\n\t}\n\t\n\tfunction centroidRingPoint(lambda, phi) {\n\t  lambda *= radians, phi *= radians;\n\t  var cosPhi = cos$1(phi),\n\t      x = cosPhi * cos$1(lambda),\n\t      y = cosPhi * sin$1(lambda),\n\t      z = sin$1(phi),\n\t      cx = y0 * z - z0 * y,\n\t      cy = z0 * x - x0 * z,\n\t      cz = x0 * y - y0 * x,\n\t      m = sqrt$1(cx * cx + cy * cy + cz * cz),\n\t      u = x0 * x + y0 * y + z0 * z,\n\t      v = m && -acos(u) / m, // area weight\n\t      w = atan2(m, u); // line weight\n\t  X2 += v * cx;\n\t  Y2 += v * cy;\n\t  Z2 += v * cz;\n\t  W1 += w;\n\t  X1 += w * (x0 + (x0 = x));\n\t  Y1 += w * (y0 + (y0 = y));\n\t  Z1 += w * (z0 + (z0 = z));\n\t  centroidPointCartesian(x0, y0, z0);\n\t}\n\t\n\tvar centroid$1 = function(object) {\n\t  W0 = W1 =\n\t  X0 = Y0 = Z0 =\n\t  X1 = Y1 = Z1 =\n\t  X2 = Y2 = Z2 = 0;\n\t  geoStream(object, centroidStream);\n\t\n\t  var x = X2,\n\t      y = Y2,\n\t      z = Z2,\n\t      m = x * x + y * y + z * z;\n\t\n\t  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.\n\t  if (m < epsilon2$2) {\n\t    x = X1, y = Y1, z = Z1;\n\t    // If the feature has zero length, fall back to arithmetic mean of point vectors.\n\t    if (W1 < epsilon$4) x = X0, y = Y0, z = Z0;\n\t    m = x * x + y * y + z * z;\n\t    // If the feature still has an undefined ccentroid, then return.\n\t    if (m < epsilon2$2) return [NaN, NaN];\n\t  }\n\t\n\t  return [atan2(y, x) * degrees$1, asin$1(z / sqrt$1(m)) * degrees$1];\n\t};\n\t\n\tvar constant$13 = function(x) {\n\t  return function() {\n\t    return x;\n\t  };\n\t};\n\t\n\tvar compose = function(a, b) {\n\t\n\t  function compose(x, y) {\n\t    return x = a(x, y), b(x[0], x[1]);\n\t  }\n\t\n\t  if (a.invert && b.invert) compose.invert = function(x, y) {\n\t    return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n\t  };\n\t\n\t  return compose;\n\t};\n\t\n\tfunction rotationIdentity(lambda, phi) {\n\t  return [lambda > pi$4 ? lambda - tau$4 : lambda < -pi$4 ? lambda + tau$4 : lambda, phi];\n\t}\n\t\n\trotationIdentity.invert = rotationIdentity;\n\t\n\tfunction rotateRadians(deltaLambda, deltaPhi, deltaGamma) {\n\t  return (deltaLambda %= tau$4) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))\n\t    : rotationLambda(deltaLambda))\n\t    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)\n\t    : rotationIdentity);\n\t}\n\t\n\tfunction forwardRotationLambda(deltaLambda) {\n\t  return function(lambda, phi) {\n\t    return lambda += deltaLambda, [lambda > pi$4 ? lambda - tau$4 : lambda < -pi$4 ? lambda + tau$4 : lambda, phi];\n\t  };\n\t}\n\t\n\tfunction rotationLambda(deltaLambda) {\n\t  var rotation = forwardRotationLambda(deltaLambda);\n\t  rotation.invert = forwardRotationLambda(-deltaLambda);\n\t  return rotation;\n\t}\n\t\n\tfunction rotationPhiGamma(deltaPhi, deltaGamma) {\n\t  var cosDeltaPhi = cos$1(deltaPhi),\n\t      sinDeltaPhi = sin$1(deltaPhi),\n\t      cosDeltaGamma = cos$1(deltaGamma),\n\t      sinDeltaGamma = sin$1(deltaGamma);\n\t\n\t  function rotation(lambda, phi) {\n\t    var cosPhi = cos$1(phi),\n\t        x = cos$1(lambda) * cosPhi,\n\t        y = sin$1(lambda) * cosPhi,\n\t        z = sin$1(phi),\n\t        k = z * cosDeltaPhi + x * sinDeltaPhi;\n\t    return [\n\t      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),\n\t      asin$1(k * cosDeltaGamma + y * sinDeltaGamma)\n\t    ];\n\t  }\n\t\n\t  rotation.invert = function(lambda, phi) {\n\t    var cosPhi = cos$1(phi),\n\t        x = cos$1(lambda) * cosPhi,\n\t        y = sin$1(lambda) * cosPhi,\n\t        z = sin$1(phi),\n\t        k = z * cosDeltaGamma - y * sinDeltaGamma;\n\t    return [\n\t      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),\n\t      asin$1(k * cosDeltaPhi - x * sinDeltaPhi)\n\t    ];\n\t  };\n\t\n\t  return rotation;\n\t}\n\t\n\tvar rotation = function(rotate) {\n\t  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);\n\t\n\t  function forward(coordinates) {\n\t    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);\n\t    return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;\n\t  }\n\t\n\t  forward.invert = function(coordinates) {\n\t    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);\n\t    return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;\n\t  };\n\t\n\t  return forward;\n\t};\n\t\n\t// Generates a circle centered at [0°, 0°], with a given radius and precision.\n\tfunction circleStream(stream, radius, delta, direction, t0, t1) {\n\t  if (!delta) return;\n\t  var cosRadius = cos$1(radius),\n\t      sinRadius = sin$1(radius),\n\t      step = direction * delta;\n\t  if (t0 == null) {\n\t    t0 = radius + direction * tau$4;\n\t    t1 = radius - step / 2;\n\t  } else {\n\t    t0 = circleRadius(cosRadius, t0);\n\t    t1 = circleRadius(cosRadius, t1);\n\t    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau$4;\n\t  }\n\t  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {\n\t    point = spherical([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);\n\t    stream.point(point[0], point[1]);\n\t  }\n\t}\n\t\n\t// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].\n\tfunction circleRadius(cosRadius, point) {\n\t  point = cartesian(point), point[0] -= cosRadius;\n\t  cartesianNormalizeInPlace(point);\n\t  var radius = acos(-point[1]);\n\t  return ((-point[2] < 0 ? -radius : radius) + tau$4 - epsilon$4) % tau$4;\n\t}\n\t\n\tvar circle$1 = function() {\n\t  var center = constant$13([0, 0]),\n\t      radius = constant$13(90),\n\t      precision = constant$13(6),\n\t      ring,\n\t      rotate,\n\t      stream = {point: point};\n\t\n\t  function point(x, y) {\n\t    ring.push(x = rotate(x, y));\n\t    x[0] *= degrees$1, x[1] *= degrees$1;\n\t  }\n\t\n\t  function circle() {\n\t    var c = center.apply(this, arguments),\n\t        r = radius.apply(this, arguments) * radians,\n\t        p = precision.apply(this, arguments) * radians;\n\t    ring = [];\n\t    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;\n\t    circleStream(stream, r, p, 1);\n\t    c = {type: \"Polygon\", coordinates: [ring]};\n\t    ring = rotate = null;\n\t    return c;\n\t  }\n\t\n\t  circle.center = function(_) {\n\t    return arguments.length ? (center = typeof _ === \"function\" ? _ : constant$13([+_[0], +_[1]]), circle) : center;\n\t  };\n\t\n\t  circle.radius = function(_) {\n\t    return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant$13(+_), circle) : radius;\n\t  };\n\t\n\t  circle.precision = function(_) {\n\t    return arguments.length ? (precision = typeof _ === \"function\" ? _ : constant$13(+_), circle) : precision;\n\t  };\n\t\n\t  return circle;\n\t};\n\t\n\tvar clipBuffer = function() {\n\t  var lines = [],\n\t      line;\n\t  return {\n\t    point: function(x, y) {\n\t      line.push([x, y]);\n\t    },\n\t    lineStart: function() {\n\t      lines.push(line = []);\n\t    },\n\t    lineEnd: noop$2,\n\t    rejoin: function() {\n\t      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n\t    },\n\t    result: function() {\n\t      var result = lines;\n\t      lines = [];\n\t      line = null;\n\t      return result;\n\t    }\n\t  };\n\t};\n\t\n\tvar clipLine = function(a, b, x0, y0, x1, y1) {\n\t  var ax = a[0],\n\t      ay = a[1],\n\t      bx = b[0],\n\t      by = b[1],\n\t      t0 = 0,\n\t      t1 = 1,\n\t      dx = bx - ax,\n\t      dy = by - ay,\n\t      r;\n\t\n\t  r = x0 - ax;\n\t  if (!dx && r > 0) return;\n\t  r /= dx;\n\t  if (dx < 0) {\n\t    if (r < t0) return;\n\t    if (r < t1) t1 = r;\n\t  } else if (dx > 0) {\n\t    if (r > t1) return;\n\t    if (r > t0) t0 = r;\n\t  }\n\t\n\t  r = x1 - ax;\n\t  if (!dx && r < 0) return;\n\t  r /= dx;\n\t  if (dx < 0) {\n\t    if (r > t1) return;\n\t    if (r > t0) t0 = r;\n\t  } else if (dx > 0) {\n\t    if (r < t0) return;\n\t    if (r < t1) t1 = r;\n\t  }\n\t\n\t  r = y0 - ay;\n\t  if (!dy && r > 0) return;\n\t  r /= dy;\n\t  if (dy < 0) {\n\t    if (r < t0) return;\n\t    if (r < t1) t1 = r;\n\t  } else if (dy > 0) {\n\t    if (r > t1) return;\n\t    if (r > t0) t0 = r;\n\t  }\n\t\n\t  r = y1 - ay;\n\t  if (!dy && r < 0) return;\n\t  r /= dy;\n\t  if (dy < 0) {\n\t    if (r > t1) return;\n\t    if (r > t0) t0 = r;\n\t  } else if (dy > 0) {\n\t    if (r < t0) return;\n\t    if (r < t1) t1 = r;\n\t  }\n\t\n\t  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;\n\t  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;\n\t  return true;\n\t};\n\t\n\tvar pointEqual = function(a, b) {\n\t  return abs(a[0] - b[0]) < epsilon$4 && abs(a[1] - b[1]) < epsilon$4;\n\t};\n\t\n\tfunction Intersection(point, points, other, entry) {\n\t  this.x = point;\n\t  this.z = points;\n\t  this.o = other; // another intersection\n\t  this.e = entry; // is an entry?\n\t  this.v = false; // visited\n\t  this.n = this.p = null; // next & previous\n\t}\n\t\n\t// A generalized polygon clipping algorithm: given a polygon that has been cut\n\t// into its visible line segments, and rejoins the segments by interpolating\n\t// along the clip edge.\n\tvar clipPolygon = function(segments, compareIntersection, startInside, interpolate, stream) {\n\t  var subject = [],\n\t      clip = [],\n\t      i,\n\t      n;\n\t\n\t  segments.forEach(function(segment) {\n\t    if ((n = segment.length - 1) <= 0) return;\n\t    var n, p0 = segment[0], p1 = segment[n], x;\n\t\n\t    // If the first and last points of a segment are coincident, then treat as a\n\t    // closed ring. TODO if all rings are closed, then the winding order of the\n\t    // exterior ring should be checked.\n\t    if (pointEqual(p0, p1)) {\n\t      stream.lineStart();\n\t      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);\n\t      stream.lineEnd();\n\t      return;\n\t    }\n\t\n\t    subject.push(x = new Intersection(p0, segment, null, true));\n\t    clip.push(x.o = new Intersection(p0, null, x, false));\n\t    subject.push(x = new Intersection(p1, segment, null, false));\n\t    clip.push(x.o = new Intersection(p1, null, x, true));\n\t  });\n\t\n\t  if (!subject.length) return;\n\t\n\t  clip.sort(compareIntersection);\n\t  link$1(subject);\n\t  link$1(clip);\n\t\n\t  for (i = 0, n = clip.length; i < n; ++i) {\n\t    clip[i].e = startInside = !startInside;\n\t  }\n\t\n\t  var start = subject[0],\n\t      points,\n\t      point;\n\t\n\t  while (1) {\n\t    // Find first unvisited intersection.\n\t    var current = start,\n\t        isSubject = true;\n\t    while (current.v) if ((current = current.n) === start) return;\n\t    points = current.z;\n\t    stream.lineStart();\n\t    do {\n\t      current.v = current.o.v = true;\n\t      if (current.e) {\n\t        if (isSubject) {\n\t          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);\n\t        } else {\n\t          interpolate(current.x, current.n.x, 1, stream);\n\t        }\n\t        current = current.n;\n\t      } else {\n\t        if (isSubject) {\n\t          points = current.p.z;\n\t          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);\n\t        } else {\n\t          interpolate(current.x, current.p.x, -1, stream);\n\t        }\n\t        current = current.p;\n\t      }\n\t      current = current.o;\n\t      points = current.z;\n\t      isSubject = !isSubject;\n\t    } while (!current.v);\n\t    stream.lineEnd();\n\t  }\n\t};\n\t\n\tfunction link$1(array) {\n\t  if (!(n = array.length)) return;\n\t  var n,\n\t      i = 0,\n\t      a = array[0],\n\t      b;\n\t  while (++i < n) {\n\t    a.n = b = array[i];\n\t    b.p = a;\n\t    a = b;\n\t  }\n\t  a.n = b = array[0];\n\t  b.p = a;\n\t}\n\t\n\tvar clipMax = 1e9;\n\tvar clipMin = -clipMax;\n\t\n\t// TODO Use d3-polygon’s polygonContains here for the ring check?\n\t// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\n\t\n\tfunction clipExtent(x0, y0, x1, y1) {\n\t\n\t  function visible(x, y) {\n\t    return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n\t  }\n\t\n\t  function interpolate(from, to, direction, stream) {\n\t    var a = 0, a1 = 0;\n\t    if (from == null\n\t        || (a = corner(from, direction)) !== (a1 = corner(to, direction))\n\t        || comparePoint(from, to) < 0 ^ direction > 0) {\n\t      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n\t      while ((a = (a + direction + 4) % 4) !== a1);\n\t    } else {\n\t      stream.point(to[0], to[1]);\n\t    }\n\t  }\n\t\n\t  function corner(p, direction) {\n\t    return abs(p[0] - x0) < epsilon$4 ? direction > 0 ? 0 : 3\n\t        : abs(p[0] - x1) < epsilon$4 ? direction > 0 ? 2 : 1\n\t        : abs(p[1] - y0) < epsilon$4 ? direction > 0 ? 1 : 0\n\t        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon\n\t  }\n\t\n\t  function compareIntersection(a, b) {\n\t    return comparePoint(a.x, b.x);\n\t  }\n\t\n\t  function comparePoint(a, b) {\n\t    var ca = corner(a, 1),\n\t        cb = corner(b, 1);\n\t    return ca !== cb ? ca - cb\n\t        : ca === 0 ? b[1] - a[1]\n\t        : ca === 1 ? a[0] - b[0]\n\t        : ca === 2 ? a[1] - b[1]\n\t        : b[0] - a[0];\n\t  }\n\t\n\t  return function(stream) {\n\t    var activeStream = stream,\n\t        bufferStream = clipBuffer(),\n\t        segments,\n\t        polygon,\n\t        ring,\n\t        x__, y__, v__, // first point\n\t        x_, y_, v_, // previous point\n\t        first,\n\t        clean;\n\t\n\t    var clipStream = {\n\t      point: point,\n\t      lineStart: lineStart,\n\t      lineEnd: lineEnd,\n\t      polygonStart: polygonStart,\n\t      polygonEnd: polygonEnd\n\t    };\n\t\n\t    function point(x, y) {\n\t      if (visible(x, y)) activeStream.point(x, y);\n\t    }\n\t\n\t    function polygonInside() {\n\t      var winding = 0;\n\t\n\t      for (var i = 0, n = polygon.length; i < n; ++i) {\n\t        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n\t          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n\t          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }\n\t          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }\n\t        }\n\t      }\n\t\n\t      return winding;\n\t    }\n\t\n\t    // Buffer geometry within a polygon and then clip it en masse.\n\t    function polygonStart() {\n\t      activeStream = bufferStream, segments = [], polygon = [], clean = true;\n\t    }\n\t\n\t    function polygonEnd() {\n\t      var startInside = polygonInside(),\n\t          cleanInside = clean && startInside,\n\t          visible = (segments = merge(segments)).length;\n\t      if (cleanInside || visible) {\n\t        stream.polygonStart();\n\t        if (cleanInside) {\n\t          stream.lineStart();\n\t          interpolate(null, null, 1, stream);\n\t          stream.lineEnd();\n\t        }\n\t        if (visible) {\n\t          clipPolygon(segments, compareIntersection, startInside, interpolate, stream);\n\t        }\n\t        stream.polygonEnd();\n\t      }\n\t      activeStream = stream, segments = polygon = ring = null;\n\t    }\n\t\n\t    function lineStart() {\n\t      clipStream.point = linePoint;\n\t      if (polygon) polygon.push(ring = []);\n\t      first = true;\n\t      v_ = false;\n\t      x_ = y_ = NaN;\n\t    }\n\t\n\t    // TODO rather than special-case polygons, simply handle them separately.\n\t    // Ideally, coincident intersection points should be jittered to avoid\n\t    // clipping issues.\n\t    function lineEnd() {\n\t      if (segments) {\n\t        linePoint(x__, y__);\n\t        if (v__ && v_) bufferStream.rejoin();\n\t        segments.push(bufferStream.result());\n\t      }\n\t      clipStream.point = point;\n\t      if (v_) activeStream.lineEnd();\n\t    }\n\t\n\t    function linePoint(x, y) {\n\t      var v = visible(x, y);\n\t      if (polygon) ring.push([x, y]);\n\t      if (first) {\n\t        x__ = x, y__ = y, v__ = v;\n\t        first = false;\n\t        if (v) {\n\t          activeStream.lineStart();\n\t          activeStream.point(x, y);\n\t        }\n\t      } else {\n\t        if (v && v_) activeStream.point(x, y);\n\t        else {\n\t          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],\n\t              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n\t          if (clipLine(a, b, x0, y0, x1, y1)) {\n\t            if (!v_) {\n\t              activeStream.lineStart();\n\t              activeStream.point(a[0], a[1]);\n\t            }\n\t            activeStream.point(b[0], b[1]);\n\t            if (!v) activeStream.lineEnd();\n\t            clean = false;\n\t          } else if (v) {\n\t            activeStream.lineStart();\n\t            activeStream.point(x, y);\n\t            clean = false;\n\t          }\n\t        }\n\t      }\n\t      x_ = x, y_ = y, v_ = v;\n\t    }\n\t\n\t    return clipStream;\n\t  };\n\t}\n\t\n\tvar extent$1 = function() {\n\t  var x0 = 0,\n\t      y0 = 0,\n\t      x1 = 960,\n\t      y1 = 500,\n\t      cache,\n\t      cacheStream,\n\t      clip;\n\t\n\t  return clip = {\n\t    stream: function(stream) {\n\t      return cache && cacheStream === stream ? cache : cache = clipExtent(x0, y0, x1, y1)(cacheStream = stream);\n\t    },\n\t    extent: function(_) {\n\t      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];\n\t    }\n\t  };\n\t};\n\t\n\tvar lengthSum = adder();\n\tvar lambda0$2;\n\tvar sinPhi0$1;\n\tvar cosPhi0$1;\n\t\n\tvar lengthStream = {\n\t  sphere: noop$2,\n\t  point: noop$2,\n\t  lineStart: lengthLineStart,\n\t  lineEnd: noop$2,\n\t  polygonStart: noop$2,\n\t  polygonEnd: noop$2\n\t};\n\t\n\tfunction lengthLineStart() {\n\t  lengthStream.point = lengthPointFirst;\n\t  lengthStream.lineEnd = lengthLineEnd;\n\t}\n\t\n\tfunction lengthLineEnd() {\n\t  lengthStream.point = lengthStream.lineEnd = noop$2;\n\t}\n\t\n\tfunction lengthPointFirst(lambda, phi) {\n\t  lambda *= radians, phi *= radians;\n\t  lambda0$2 = lambda, sinPhi0$1 = sin$1(phi), cosPhi0$1 = cos$1(phi);\n\t  lengthStream.point = lengthPoint;\n\t}\n\t\n\tfunction lengthPoint(lambda, phi) {\n\t  lambda *= radians, phi *= radians;\n\t  var sinPhi = sin$1(phi),\n\t      cosPhi = cos$1(phi),\n\t      delta = abs(lambda - lambda0$2),\n\t      cosDelta = cos$1(delta),\n\t      sinDelta = sin$1(delta),\n\t      x = cosPhi * sinDelta,\n\t      y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,\n\t      z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;\n\t  lengthSum.add(atan2(sqrt$1(x * x + y * y), z));\n\t  lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;\n\t}\n\t\n\tvar length$2 = function(object) {\n\t  lengthSum.reset();\n\t  geoStream(object, lengthStream);\n\t  return +lengthSum;\n\t};\n\t\n\tvar coordinates = [null, null];\n\tvar object$1 = {type: \"LineString\", coordinates: coordinates};\n\t\n\tvar distance = function(a, b) {\n\t  coordinates[0] = a;\n\t  coordinates[1] = b;\n\t  return length$2(object$1);\n\t};\n\t\n\tfunction graticuleX(y0, y1, dy) {\n\t  var y = range(y0, y1 - epsilon$4, dy).concat(y1);\n\t  return function(x) { return y.map(function(y) { return [x, y]; }); };\n\t}\n\t\n\tfunction graticuleY(x0, x1, dx) {\n\t  var x = range(x0, x1 - epsilon$4, dx).concat(x1);\n\t  return function(y) { return x.map(function(x) { return [x, y]; }); };\n\t}\n\t\n\tfunction graticule() {\n\t  var x1, x0, X1, X0,\n\t      y1, y0, Y1, Y0,\n\t      dx = 10, dy = dx, DX = 90, DY = 360,\n\t      x, y, X, Y,\n\t      precision = 2.5;\n\t\n\t  function graticule() {\n\t    return {type: \"MultiLineString\", coordinates: lines()};\n\t  }\n\t\n\t  function lines() {\n\t    return range(ceil(X0 / DX) * DX, X1, DX).map(X)\n\t        .concat(range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))\n\t        .concat(range(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon$4; }).map(x))\n\t        .concat(range(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon$4; }).map(y));\n\t  }\n\t\n\t  graticule.lines = function() {\n\t    return lines().map(function(coordinates) { return {type: \"LineString\", coordinates: coordinates}; });\n\t  };\n\t\n\t  graticule.outline = function() {\n\t    return {\n\t      type: \"Polygon\",\n\t      coordinates: [\n\t        X(X0).concat(\n\t        Y(Y1).slice(1),\n\t        X(X1).reverse().slice(1),\n\t        Y(Y0).reverse().slice(1))\n\t      ]\n\t    };\n\t  };\n\t\n\t  graticule.extent = function(_) {\n\t    if (!arguments.length) return graticule.extentMinor();\n\t    return graticule.extentMajor(_).extentMinor(_);\n\t  };\n\t\n\t  graticule.extentMajor = function(_) {\n\t    if (!arguments.length) return [[X0, Y0], [X1, Y1]];\n\t    X0 = +_[0][0], X1 = +_[1][0];\n\t    Y0 = +_[0][1], Y1 = +_[1][1];\n\t    if (X0 > X1) _ = X0, X0 = X1, X1 = _;\n\t    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;\n\t    return graticule.precision(precision);\n\t  };\n\t\n\t  graticule.extentMinor = function(_) {\n\t    if (!arguments.length) return [[x0, y0], [x1, y1]];\n\t    x0 = +_[0][0], x1 = +_[1][0];\n\t    y0 = +_[0][1], y1 = +_[1][1];\n\t    if (x0 > x1) _ = x0, x0 = x1, x1 = _;\n\t    if (y0 > y1) _ = y0, y0 = y1, y1 = _;\n\t    return graticule.precision(precision);\n\t  };\n\t\n\t  graticule.step = function(_) {\n\t    if (!arguments.length) return graticule.stepMinor();\n\t    return graticule.stepMajor(_).stepMinor(_);\n\t  };\n\t\n\t  graticule.stepMajor = function(_) {\n\t    if (!arguments.length) return [DX, DY];\n\t    DX = +_[0], DY = +_[1];\n\t    return graticule;\n\t  };\n\t\n\t  graticule.stepMinor = function(_) {\n\t    if (!arguments.length) return [dx, dy];\n\t    dx = +_[0], dy = +_[1];\n\t    return graticule;\n\t  };\n\t\n\t  graticule.precision = function(_) {\n\t    if (!arguments.length) return precision;\n\t    precision = +_;\n\t    x = graticuleX(y0, y1, 90);\n\t    y = graticuleY(x0, x1, precision);\n\t    X = graticuleX(Y0, Y1, 90);\n\t    Y = graticuleY(X0, X1, precision);\n\t    return graticule;\n\t  };\n\t\n\t  return graticule\n\t      .extentMajor([[-180, -90 + epsilon$4], [180, 90 - epsilon$4]])\n\t      .extentMinor([[-180, -80 - epsilon$4], [180, 80 + epsilon$4]]);\n\t}\n\t\n\tfunction graticule10() {\n\t  return graticule()();\n\t}\n\t\n\tvar interpolate$2 = function(a, b) {\n\t  var x0 = a[0] * radians,\n\t      y0 = a[1] * radians,\n\t      x1 = b[0] * radians,\n\t      y1 = b[1] * radians,\n\t      cy0 = cos$1(y0),\n\t      sy0 = sin$1(y0),\n\t      cy1 = cos$1(y1),\n\t      sy1 = sin$1(y1),\n\t      kx0 = cy0 * cos$1(x0),\n\t      ky0 = cy0 * sin$1(x0),\n\t      kx1 = cy1 * cos$1(x1),\n\t      ky1 = cy1 * sin$1(x1),\n\t      d = 2 * asin$1(sqrt$1(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),\n\t      k = sin$1(d);\n\t\n\t  var interpolate = d ? function(t) {\n\t    var B = sin$1(t *= d) / k,\n\t        A = sin$1(d - t) / k,\n\t        x = A * kx0 + B * kx1,\n\t        y = A * ky0 + B * ky1,\n\t        z = A * sy0 + B * sy1;\n\t    return [\n\t      atan2(y, x) * degrees$1,\n\t      atan2(z, sqrt$1(x * x + y * y)) * degrees$1\n\t    ];\n\t  } : function() {\n\t    return [x0 * degrees$1, y0 * degrees$1];\n\t  };\n\t\n\t  interpolate.distance = d;\n\t\n\t  return interpolate;\n\t};\n\t\n\tvar identity$7 = function(x) {\n\t  return x;\n\t};\n\t\n\tvar areaSum$1 = adder();\n\tvar areaRingSum$1 = adder();\n\tvar x00;\n\tvar y00;\n\tvar x0$1;\n\tvar y0$1;\n\t\n\tvar areaStream$1 = {\n\t  point: noop$2,\n\t  lineStart: noop$2,\n\t  lineEnd: noop$2,\n\t  polygonStart: function() {\n\t    areaStream$1.lineStart = areaRingStart$1;\n\t    areaStream$1.lineEnd = areaRingEnd$1;\n\t  },\n\t  polygonEnd: function() {\n\t    areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop$2;\n\t    areaSum$1.add(abs(areaRingSum$1));\n\t    areaRingSum$1.reset();\n\t  },\n\t  result: function() {\n\t    var area = areaSum$1 / 2;\n\t    areaSum$1.reset();\n\t    return area;\n\t  }\n\t};\n\t\n\tfunction areaRingStart$1() {\n\t  areaStream$1.point = areaPointFirst$1;\n\t}\n\t\n\tfunction areaPointFirst$1(x, y) {\n\t  areaStream$1.point = areaPoint$1;\n\t  x00 = x0$1 = x, y00 = y0$1 = y;\n\t}\n\t\n\tfunction areaPoint$1(x, y) {\n\t  areaRingSum$1.add(y0$1 * x - x0$1 * y);\n\t  x0$1 = x, y0$1 = y;\n\t}\n\t\n\tfunction areaRingEnd$1() {\n\t  areaPoint$1(x00, y00);\n\t}\n\t\n\tvar x0$2 = Infinity;\n\tvar y0$2 = x0$2;\n\tvar x1 = -x0$2;\n\tvar y1 = x1;\n\t\n\tvar boundsStream$1 = {\n\t  point: boundsPoint$1,\n\t  lineStart: noop$2,\n\t  lineEnd: noop$2,\n\t  polygonStart: noop$2,\n\t  polygonEnd: noop$2,\n\t  result: function() {\n\t    var bounds = [[x0$2, y0$2], [x1, y1]];\n\t    x1 = y1 = -(y0$2 = x0$2 = Infinity);\n\t    return bounds;\n\t  }\n\t};\n\t\n\tfunction boundsPoint$1(x, y) {\n\t  if (x < x0$2) x0$2 = x;\n\t  if (x > x1) x1 = x;\n\t  if (y < y0$2) y0$2 = y;\n\t  if (y > y1) y1 = y;\n\t}\n\t\n\t// TODO Enforce positive area for exterior, negative area for interior?\n\t\n\tvar X0$1 = 0;\n\tvar Y0$1 = 0;\n\tvar Z0$1 = 0;\n\tvar X1$1 = 0;\n\tvar Y1$1 = 0;\n\tvar Z1$1 = 0;\n\tvar X2$1 = 0;\n\tvar Y2$1 = 0;\n\tvar Z2$1 = 0;\n\tvar x00$1;\n\tvar y00$1;\n\tvar x0$3;\n\tvar y0$3;\n\t\n\tvar centroidStream$1 = {\n\t  point: centroidPoint$1,\n\t  lineStart: centroidLineStart$1,\n\t  lineEnd: centroidLineEnd$1,\n\t  polygonStart: function() {\n\t    centroidStream$1.lineStart = centroidRingStart$1;\n\t    centroidStream$1.lineEnd = centroidRingEnd$1;\n\t  },\n\t  polygonEnd: function() {\n\t    centroidStream$1.point = centroidPoint$1;\n\t    centroidStream$1.lineStart = centroidLineStart$1;\n\t    centroidStream$1.lineEnd = centroidLineEnd$1;\n\t  },\n\t  result: function() {\n\t    var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]\n\t        : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]\n\t        : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]\n\t        : [NaN, NaN];\n\t    X0$1 = Y0$1 = Z0$1 =\n\t    X1$1 = Y1$1 = Z1$1 =\n\t    X2$1 = Y2$1 = Z2$1 = 0;\n\t    return centroid;\n\t  }\n\t};\n\t\n\tfunction centroidPoint$1(x, y) {\n\t  X0$1 += x;\n\t  Y0$1 += y;\n\t  ++Z0$1;\n\t}\n\t\n\tfunction centroidLineStart$1() {\n\t  centroidStream$1.point = centroidPointFirstLine;\n\t}\n\t\n\tfunction centroidPointFirstLine(x, y) {\n\t  centroidStream$1.point = centroidPointLine;\n\t  centroidPoint$1(x0$3 = x, y0$3 = y);\n\t}\n\t\n\tfunction centroidPointLine(x, y) {\n\t  var dx = x - x0$3, dy = y - y0$3, z = sqrt$1(dx * dx + dy * dy);\n\t  X1$1 += z * (x0$3 + x) / 2;\n\t  Y1$1 += z * (y0$3 + y) / 2;\n\t  Z1$1 += z;\n\t  centroidPoint$1(x0$3 = x, y0$3 = y);\n\t}\n\t\n\tfunction centroidLineEnd$1() {\n\t  centroidStream$1.point = centroidPoint$1;\n\t}\n\t\n\tfunction centroidRingStart$1() {\n\t  centroidStream$1.point = centroidPointFirstRing;\n\t}\n\t\n\tfunction centroidRingEnd$1() {\n\t  centroidPointRing(x00$1, y00$1);\n\t}\n\t\n\tfunction centroidPointFirstRing(x, y) {\n\t  centroidStream$1.point = centroidPointRing;\n\t  centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);\n\t}\n\t\n\tfunction centroidPointRing(x, y) {\n\t  var dx = x - x0$3,\n\t      dy = y - y0$3,\n\t      z = sqrt$1(dx * dx + dy * dy);\n\t\n\t  X1$1 += z * (x0$3 + x) / 2;\n\t  Y1$1 += z * (y0$3 + y) / 2;\n\t  Z1$1 += z;\n\t\n\t  z = y0$3 * x - x0$3 * y;\n\t  X2$1 += z * (x0$3 + x);\n\t  Y2$1 += z * (y0$3 + y);\n\t  Z2$1 += z * 3;\n\t  centroidPoint$1(x0$3 = x, y0$3 = y);\n\t}\n\t\n\tfunction PathContext(context) {\n\t  this._context = context;\n\t}\n\t\n\tPathContext.prototype = {\n\t  _radius: 4.5,\n\t  pointRadius: function(_) {\n\t    return this._radius = _, this;\n\t  },\n\t  polygonStart: function() {\n\t    this._line = 0;\n\t  },\n\t  polygonEnd: function() {\n\t    this._line = NaN;\n\t  },\n\t  lineStart: function() {\n\t    this._point = 0;\n\t  },\n\t  lineEnd: function() {\n\t    if (this._line === 0) this._context.closePath();\n\t    this._point = NaN;\n\t  },\n\t  point: function(x, y) {\n\t    switch (this._point) {\n\t      case 0: {\n\t        this._context.moveTo(x, y);\n\t        this._point = 1;\n\t        break;\n\t      }\n\t      case 1: {\n\t        this._context.lineTo(x, y);\n\t        break;\n\t      }\n\t      default: {\n\t        this._context.moveTo(x + this._radius, y);\n\t        this._context.arc(x, y, this._radius, 0, tau$4);\n\t        break;\n\t      }\n\t    }\n\t  },\n\t  result: noop$2\n\t};\n\t\n\tfunction PathString() {\n\t  this._string = [];\n\t}\n\t\n\tPathString.prototype = {\n\t  _circle: circle$2(4.5),\n\t  pointRadius: function(_) {\n\t    return this._circle = circle$2(_), this;\n\t  },\n\t  polygonStart: function() {\n\t    this._line = 0;\n\t  },\n\t  polygonEnd: function() {\n\t    this._line = NaN;\n\t  },\n\t  lineStart: function() {\n\t    this._point = 0;\n\t  },\n\t  lineEnd: function() {\n\t    if (this._line === 0) this._string.push(\"Z\");\n\t    this._point = NaN;\n\t  },\n\t  point: function(x, y) {\n\t    switch (this._point) {\n\t      case 0: {\n\t        this._string.push(\"M\", x, \",\", y);\n\t        this._point = 1;\n\t        break;\n\t      }\n\t      case 1: {\n\t        this._string.push(\"L\", x, \",\", y);\n\t        break;\n\t      }\n\t      default: {\n\t        this._string.push(\"M\", x, \",\", y, this._circle);\n\t        break;\n\t      }\n\t    }\n\t  },\n\t  result: function() {\n\t    if (this._string.length) {\n\t      var result = this._string.join(\"\");\n\t      this._string = [];\n\t      return result;\n\t    }\n\t  }\n\t};\n\t\n\tfunction circle$2(radius) {\n\t  return \"m0,\" + radius\n\t      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius\n\t      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + 2 * radius\n\t      + \"z\";\n\t}\n\t\n\tvar index$3 = function(projection, context) {\n\t  var pointRadius = 4.5,\n\t      projectionStream,\n\t      contextStream;\n\t\n\t  function path(object) {\n\t    if (object) {\n\t      if (typeof pointRadius === \"function\") contextStream.pointRadius(+pointRadius.apply(this, arguments));\n\t      geoStream(object, projectionStream(contextStream));\n\t    }\n\t    return contextStream.result();\n\t  }\n\t\n\t  path.area = function(object) {\n\t    geoStream(object, projectionStream(areaStream$1));\n\t    return areaStream$1.result();\n\t  };\n\t\n\t  path.bounds = function(object) {\n\t    geoStream(object, projectionStream(boundsStream$1));\n\t    return boundsStream$1.result();\n\t  };\n\t\n\t  path.centroid = function(object) {\n\t    geoStream(object, projectionStream(centroidStream$1));\n\t    return centroidStream$1.result();\n\t  };\n\t\n\t  path.projection = function(_) {\n\t    return arguments.length ? (projectionStream = (projection = _) == null ? identity$7 : _.stream, path) : projection;\n\t  };\n\t\n\t  path.context = function(_) {\n\t    if (!arguments.length) return context;\n\t    contextStream = (context = _) == null ? new PathString : new PathContext(_);\n\t    if (typeof pointRadius !== \"function\") contextStream.pointRadius(pointRadius);\n\t    return path;\n\t  };\n\t\n\t  path.pointRadius = function(_) {\n\t    if (!arguments.length) return pointRadius;\n\t    pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n\t    return path;\n\t  };\n\t\n\t  return path.projection(projection).context(context);\n\t};\n\t\n\tvar sum$2 = adder();\n\t\n\tvar polygonContains = function(polygon, point) {\n\t  var lambda = point[0],\n\t      phi = point[1],\n\t      normal = [sin$1(lambda), -cos$1(lambda), 0],\n\t      angle = 0,\n\t      winding = 0;\n\t\n\t  sum$2.reset();\n\t\n\t  for (var i = 0, n = polygon.length; i < n; ++i) {\n\t    if (!(m = (ring = polygon[i]).length)) continue;\n\t    var ring,\n\t        m,\n\t        point0 = ring[m - 1],\n\t        lambda0 = point0[0],\n\t        phi0 = point0[1] / 2 + quarterPi,\n\t        sinPhi0 = sin$1(phi0),\n\t        cosPhi0 = cos$1(phi0);\n\t\n\t    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {\n\t      var point1 = ring[j],\n\t          lambda1 = point1[0],\n\t          phi1 = point1[1] / 2 + quarterPi,\n\t          sinPhi1 = sin$1(phi1),\n\t          cosPhi1 = cos$1(phi1),\n\t          delta = lambda1 - lambda0,\n\t          sign$$1 = delta >= 0 ? 1 : -1,\n\t          absDelta = sign$$1 * delta,\n\t          antimeridian = absDelta > pi$4,\n\t          k = sinPhi0 * sinPhi1;\n\t\n\t      sum$2.add(atan2(k * sign$$1 * sin$1(absDelta), cosPhi0 * cosPhi1 + k * cos$1(absDelta)));\n\t      angle += antimeridian ? delta + sign$$1 * tau$4 : delta;\n\t\n\t      // Are the longitudes either side of the point’s meridian (lambda),\n\t      // and are the latitudes smaller than the parallel (phi)?\n\t      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {\n\t        var arc = cartesianCross(cartesian(point0), cartesian(point1));\n\t        cartesianNormalizeInPlace(arc);\n\t        var intersection = cartesianCross(normal, arc);\n\t        cartesianNormalizeInPlace(intersection);\n\t        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin$1(intersection[2]);\n\t        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {\n\t          winding += antimeridian ^ delta >= 0 ? 1 : -1;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  // First, determine whether the South pole is inside or outside:\n\t  //\n\t  // It is inside if:\n\t  // * the polygon winds around it in a clockwise direction.\n\t  // * the polygon does not (cumulatively) wind around it, but has a negative\n\t  //   (counter-clockwise) area.\n\t  //\n\t  // Second, count the (signed) number of times a segment crosses a lambda\n\t  // from the point to the South pole.  If it is zero, then the point is the\n\t  // same side as the South pole.\n\t\n\t  return (angle < -epsilon$4 || angle < epsilon$4 && sum$2 < -epsilon$4) ^ (winding & 1);\n\t};\n\t\n\tvar clip = function(pointVisible, clipLine, interpolate, start) {\n\t  return function(rotate, sink) {\n\t    var line = clipLine(sink),\n\t        rotatedStart = rotate.invert(start[0], start[1]),\n\t        ringBuffer = clipBuffer(),\n\t        ringSink = clipLine(ringBuffer),\n\t        polygonStarted = false,\n\t        polygon,\n\t        segments,\n\t        ring;\n\t\n\t    var clip = {\n\t      point: point,\n\t      lineStart: lineStart,\n\t      lineEnd: lineEnd,\n\t      polygonStart: function() {\n\t        clip.point = pointRing;\n\t        clip.lineStart = ringStart;\n\t        clip.lineEnd = ringEnd;\n\t        segments = [];\n\t        polygon = [];\n\t      },\n\t      polygonEnd: function() {\n\t        clip.point = point;\n\t        clip.lineStart = lineStart;\n\t        clip.lineEnd = lineEnd;\n\t        segments = merge(segments);\n\t        var startInside = polygonContains(polygon, rotatedStart);\n\t        if (segments.length) {\n\t          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n\t          clipPolygon(segments, compareIntersection, startInside, interpolate, sink);\n\t        } else if (startInside) {\n\t          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n\t          sink.lineStart();\n\t          interpolate(null, null, 1, sink);\n\t          sink.lineEnd();\n\t        }\n\t        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n\t        segments = polygon = null;\n\t      },\n\t      sphere: function() {\n\t        sink.polygonStart();\n\t        sink.lineStart();\n\t        interpolate(null, null, 1, sink);\n\t        sink.lineEnd();\n\t        sink.polygonEnd();\n\t      }\n\t    };\n\t\n\t    function point(lambda, phi) {\n\t      var point = rotate(lambda, phi);\n\t      if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);\n\t    }\n\t\n\t    function pointLine(lambda, phi) {\n\t      var point = rotate(lambda, phi);\n\t      line.point(point[0], point[1]);\n\t    }\n\t\n\t    function lineStart() {\n\t      clip.point = pointLine;\n\t      line.lineStart();\n\t    }\n\t\n\t    function lineEnd() {\n\t      clip.point = point;\n\t      line.lineEnd();\n\t    }\n\t\n\t    function pointRing(lambda, phi) {\n\t      ring.push([lambda, phi]);\n\t      var point = rotate(lambda, phi);\n\t      ringSink.point(point[0], point[1]);\n\t    }\n\t\n\t    function ringStart() {\n\t      ringSink.lineStart();\n\t      ring = [];\n\t    }\n\t\n\t    function ringEnd() {\n\t      pointRing(ring[0][0], ring[0][1]);\n\t      ringSink.lineEnd();\n\t\n\t      var clean = ringSink.clean(),\n\t          ringSegments = ringBuffer.result(),\n\t          i, n = ringSegments.length, m,\n\t          segment,\n\t          point;\n\t\n\t      ring.pop();\n\t      polygon.push(ring);\n\t      ring = null;\n\t\n\t      if (!n) return;\n\t\n\t      // No intersections.\n\t      if (clean & 1) {\n\t        segment = ringSegments[0];\n\t        if ((m = segment.length - 1) > 0) {\n\t          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n\t          sink.lineStart();\n\t          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);\n\t          sink.lineEnd();\n\t        }\n\t        return;\n\t      }\n\t\n\t      // Rejoin connected segments.\n\t      // TODO reuse ringBuffer.rejoin()?\n\t      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n\t\n\t      segments.push(ringSegments.filter(validSegment));\n\t    }\n\t\n\t    return clip;\n\t  };\n\t};\n\t\n\tfunction validSegment(segment) {\n\t  return segment.length > 1;\n\t}\n\t\n\t// Intersections are sorted along the clip edge. For both antimeridian cutting\n\t// and circle clipping, the same comparison is used.\n\tfunction compareIntersection(a, b) {\n\t  return ((a = a.x)[0] < 0 ? a[1] - halfPi$3 - epsilon$4 : halfPi$3 - a[1])\n\t       - ((b = b.x)[0] < 0 ? b[1] - halfPi$3 - epsilon$4 : halfPi$3 - b[1]);\n\t}\n\t\n\tvar clipAntimeridian = clip(\n\t  function() { return true; },\n\t  clipAntimeridianLine,\n\t  clipAntimeridianInterpolate,\n\t  [-pi$4, -halfPi$3]\n\t);\n\t\n\t// Takes a line and cuts into visible segments. Return values: 0 - there were\n\t// intersections or the line was empty; 1 - no intersections; 2 - there were\n\t// intersections, and the first and last segments should be rejoined.\n\tfunction clipAntimeridianLine(stream) {\n\t  var lambda0 = NaN,\n\t      phi0 = NaN,\n\t      sign0 = NaN,\n\t      clean; // no intersections\n\t\n\t  return {\n\t    lineStart: function() {\n\t      stream.lineStart();\n\t      clean = 1;\n\t    },\n\t    point: function(lambda1, phi1) {\n\t      var sign1 = lambda1 > 0 ? pi$4 : -pi$4,\n\t          delta = abs(lambda1 - lambda0);\n\t      if (abs(delta - pi$4) < epsilon$4) { // line crosses a pole\n\t        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi$3 : -halfPi$3);\n\t        stream.point(sign0, phi0);\n\t        stream.lineEnd();\n\t        stream.lineStart();\n\t        stream.point(sign1, phi0);\n\t        stream.point(lambda1, phi0);\n\t        clean = 0;\n\t      } else if (sign0 !== sign1 && delta >= pi$4) { // line crosses antimeridian\n\t        if (abs(lambda0 - sign0) < epsilon$4) lambda0 -= sign0 * epsilon$4; // handle degeneracies\n\t        if (abs(lambda1 - sign1) < epsilon$4) lambda1 -= sign1 * epsilon$4;\n\t        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);\n\t        stream.point(sign0, phi0);\n\t        stream.lineEnd();\n\t        stream.lineStart();\n\t        stream.point(sign1, phi0);\n\t        clean = 0;\n\t      }\n\t      stream.point(lambda0 = lambda1, phi0 = phi1);\n\t      sign0 = sign1;\n\t    },\n\t    lineEnd: function() {\n\t      stream.lineEnd();\n\t      lambda0 = phi0 = NaN;\n\t    },\n\t    clean: function() {\n\t      return 2 - clean; // if intersections, rejoin first and last segments\n\t    }\n\t  };\n\t}\n\t\n\tfunction clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {\n\t  var cosPhi0,\n\t      cosPhi1,\n\t      sinLambda0Lambda1 = sin$1(lambda0 - lambda1);\n\t  return abs(sinLambda0Lambda1) > epsilon$4\n\t      ? atan((sin$1(phi0) * (cosPhi1 = cos$1(phi1)) * sin$1(lambda1)\n\t          - sin$1(phi1) * (cosPhi0 = cos$1(phi0)) * sin$1(lambda0))\n\t          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))\n\t      : (phi0 + phi1) / 2;\n\t}\n\t\n\tfunction clipAntimeridianInterpolate(from, to, direction, stream) {\n\t  var phi;\n\t  if (from == null) {\n\t    phi = direction * halfPi$3;\n\t    stream.point(-pi$4, phi);\n\t    stream.point(0, phi);\n\t    stream.point(pi$4, phi);\n\t    stream.point(pi$4, 0);\n\t    stream.point(pi$4, -phi);\n\t    stream.point(0, -phi);\n\t    stream.point(-pi$4, -phi);\n\t    stream.point(-pi$4, 0);\n\t    stream.point(-pi$4, phi);\n\t  } else if (abs(from[0] - to[0]) > epsilon$4) {\n\t    var lambda = from[0] < to[0] ? pi$4 : -pi$4;\n\t    phi = direction * lambda / 2;\n\t    stream.point(-lambda, phi);\n\t    stream.point(0, phi);\n\t    stream.point(lambda, phi);\n\t  } else {\n\t    stream.point(to[0], to[1]);\n\t  }\n\t}\n\t\n\tvar clipCircle = function(radius, delta) {\n\t  var cr = cos$1(radius),\n\t      smallRadius = cr > 0,\n\t      notHemisphere = abs(cr) > epsilon$4; // TODO optimise for this common case\n\t\n\t  function interpolate(from, to, direction, stream) {\n\t    circleStream(stream, radius, delta, direction, from, to);\n\t  }\n\t\n\t  function visible(lambda, phi) {\n\t    return cos$1(lambda) * cos$1(phi) > cr;\n\t  }\n\t\n\t  // Takes a line and cuts into visible segments. Return values used for polygon\n\t  // clipping: 0 - there were intersections or the line was empty; 1 - no\n\t  // intersections 2 - there were intersections, and the first and last segments\n\t  // should be rejoined.\n\t  function clipLine(stream) {\n\t    var point0, // previous point\n\t        c0, // code for previous point\n\t        v0, // visibility of previous point\n\t        v00, // visibility of first point\n\t        clean; // no intersections\n\t    return {\n\t      lineStart: function() {\n\t        v00 = v0 = false;\n\t        clean = 1;\n\t      },\n\t      point: function(lambda, phi) {\n\t        var point1 = [lambda, phi],\n\t            point2,\n\t            v = visible(lambda, phi),\n\t            c = smallRadius\n\t              ? v ? 0 : code(lambda, phi)\n\t              : v ? code(lambda + (lambda < 0 ? pi$4 : -pi$4), phi) : 0;\n\t        if (!point0 && (v00 = v0 = v)) stream.lineStart();\n\t        // Handle degeneracies.\n\t        // TODO ignore if not clipping polygons.\n\t        if (v !== v0) {\n\t          point2 = intersect(point0, point1);\n\t          if (pointEqual(point0, point2) || pointEqual(point1, point2)) {\n\t            point1[0] += epsilon$4;\n\t            point1[1] += epsilon$4;\n\t            v = visible(point1[0], point1[1]);\n\t          }\n\t        }\n\t        if (v !== v0) {\n\t          clean = 0;\n\t          if (v) {\n\t            // outside going in\n\t            stream.lineStart();\n\t            point2 = intersect(point1, point0);\n\t            stream.point(point2[0], point2[1]);\n\t          } else {\n\t            // inside going out\n\t            point2 = intersect(point0, point1);\n\t            stream.point(point2[0], point2[1]);\n\t            stream.lineEnd();\n\t          }\n\t          point0 = point2;\n\t        } else if (notHemisphere && point0 && smallRadius ^ v) {\n\t          var t;\n\t          // If the codes for two points are different, or are both zero,\n\t          // and there this segment intersects with the small circle.\n\t          if (!(c & c0) && (t = intersect(point1, point0, true))) {\n\t            clean = 0;\n\t            if (smallRadius) {\n\t              stream.lineStart();\n\t              stream.point(t[0][0], t[0][1]);\n\t              stream.point(t[1][0], t[1][1]);\n\t              stream.lineEnd();\n\t            } else {\n\t              stream.point(t[1][0], t[1][1]);\n\t              stream.lineEnd();\n\t              stream.lineStart();\n\t              stream.point(t[0][0], t[0][1]);\n\t            }\n\t          }\n\t        }\n\t        if (v && (!point0 || !pointEqual(point0, point1))) {\n\t          stream.point(point1[0], point1[1]);\n\t        }\n\t        point0 = point1, v0 = v, c0 = c;\n\t      },\n\t      lineEnd: function() {\n\t        if (v0) stream.lineEnd();\n\t        point0 = null;\n\t      },\n\t      // Rejoin first and last segments if there were intersections and the first\n\t      // and last points were visible.\n\t      clean: function() {\n\t        return clean | ((v00 && v0) << 1);\n\t      }\n\t    };\n\t  }\n\t\n\t  // Intersects the great circle between a and b with the clip circle.\n\t  function intersect(a, b, two) {\n\t    var pa = cartesian(a),\n\t        pb = cartesian(b);\n\t\n\t    // We have two planes, n1.p = d1 and n2.p = d2.\n\t    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).\n\t    var n1 = [1, 0, 0], // normal\n\t        n2 = cartesianCross(pa, pb),\n\t        n2n2 = cartesianDot(n2, n2),\n\t        n1n2 = n2[0], // cartesianDot(n1, n2),\n\t        determinant = n2n2 - n1n2 * n1n2;\n\t\n\t    // Two polar points.\n\t    if (!determinant) return !two && a;\n\t\n\t    var c1 =  cr * n2n2 / determinant,\n\t        c2 = -cr * n1n2 / determinant,\n\t        n1xn2 = cartesianCross(n1, n2),\n\t        A = cartesianScale(n1, c1),\n\t        B = cartesianScale(n2, c2);\n\t    cartesianAddInPlace(A, B);\n\t\n\t    // Solve |p(t)|^2 = 1.\n\t    var u = n1xn2,\n\t        w = cartesianDot(A, u),\n\t        uu = cartesianDot(u, u),\n\t        t2 = w * w - uu * (cartesianDot(A, A) - 1);\n\t\n\t    if (t2 < 0) return;\n\t\n\t    var t = sqrt$1(t2),\n\t        q = cartesianScale(u, (-w - t) / uu);\n\t    cartesianAddInPlace(q, A);\n\t    q = spherical(q);\n\t\n\t    if (!two) return q;\n\t\n\t    // Two intersection points.\n\t    var lambda0 = a[0],\n\t        lambda1 = b[0],\n\t        phi0 = a[1],\n\t        phi1 = b[1],\n\t        z;\n\t\n\t    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\n\t\n\t    var delta = lambda1 - lambda0,\n\t        polar = abs(delta - pi$4) < epsilon$4,\n\t        meridian = polar || delta < epsilon$4;\n\t\n\t    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;\n\t\n\t    // Check that the first point is between a and b.\n\t    if (meridian\n\t        ? polar\n\t          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon$4 ? phi0 : phi1)\n\t          : phi0 <= q[1] && q[1] <= phi1\n\t        : delta > pi$4 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n\t      var q1 = cartesianScale(u, (-w + t) / uu);\n\t      cartesianAddInPlace(q1, A);\n\t      return [q, spherical(q1)];\n\t    }\n\t  }\n\t\n\t  // Generates a 4-bit vector representing the location of a point relative to\n\t  // the small circle's bounding box.\n\t  function code(lambda, phi) {\n\t    var r = smallRadius ? radius : pi$4 - radius,\n\t        code = 0;\n\t    if (lambda < -r) code |= 1; // left\n\t    else if (lambda > r) code |= 2; // right\n\t    if (phi < -r) code |= 4; // below\n\t    else if (phi > r) code |= 8; // above\n\t    return code;\n\t  }\n\t\n\t  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$4, radius - pi$4]);\n\t};\n\t\n\tvar transform$1 = function(methods) {\n\t  return {\n\t    stream: transformer(methods)\n\t  };\n\t};\n\t\n\tfunction transformer(methods) {\n\t  return function(stream) {\n\t    var s = new TransformStream;\n\t    for (var key in methods) s[key] = methods[key];\n\t    s.stream = stream;\n\t    return s;\n\t  };\n\t}\n\t\n\tfunction TransformStream() {}\n\t\n\tTransformStream.prototype = {\n\t  constructor: TransformStream,\n\t  point: function(x, y) { this.stream.point(x, y); },\n\t  sphere: function() { this.stream.sphere(); },\n\t  lineStart: function() { this.stream.lineStart(); },\n\t  lineEnd: function() { this.stream.lineEnd(); },\n\t  polygonStart: function() { this.stream.polygonStart(); },\n\t  polygonEnd: function() { this.stream.polygonEnd(); }\n\t};\n\t\n\tfunction fitExtent(projection, extent, object) {\n\t  var w = extent[1][0] - extent[0][0],\n\t      h = extent[1][1] - extent[0][1],\n\t      clip = projection.clipExtent && projection.clipExtent();\n\t\n\t  projection\n\t      .scale(150)\n\t      .translate([0, 0]);\n\t\n\t  if (clip != null) projection.clipExtent(null);\n\t\n\t  geoStream(object, projection.stream(boundsStream$1));\n\t\n\t  var b = boundsStream$1.result(),\n\t      k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),\n\t      x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,\n\t      y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;\n\t\n\t  if (clip != null) projection.clipExtent(clip);\n\t\n\t  return projection\n\t      .scale(k * 150)\n\t      .translate([x, y]);\n\t}\n\t\n\tfunction fitSize(projection, size, object) {\n\t  return fitExtent(projection, [[0, 0], size], object);\n\t}\n\t\n\tvar maxDepth = 16;\n\tvar cosMinDistance = cos$1(30 * radians); // cos(minimum angular distance)\n\t\n\tvar resample = function(project, delta2) {\n\t  return +delta2 ? resample$1(project, delta2) : resampleNone(project);\n\t};\n\t\n\tfunction resampleNone(project) {\n\t  return transformer({\n\t    point: function(x, y) {\n\t      x = project(x, y);\n\t      this.stream.point(x[0], x[1]);\n\t    }\n\t  });\n\t}\n\t\n\tfunction resample$1(project, delta2) {\n\t\n\t  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {\n\t    var dx = x1 - x0,\n\t        dy = y1 - y0,\n\t        d2 = dx * dx + dy * dy;\n\t    if (d2 > 4 * delta2 && depth--) {\n\t      var a = a0 + a1,\n\t          b = b0 + b1,\n\t          c = c0 + c1,\n\t          m = sqrt$1(a * a + b * b + c * c),\n\t          phi2 = asin$1(c /= m),\n\t          lambda2 = abs(abs(c) - 1) < epsilon$4 || abs(lambda0 - lambda1) < epsilon$4 ? (lambda0 + lambda1) / 2 : atan2(b, a),\n\t          p = project(lambda2, phi2),\n\t          x2 = p[0],\n\t          y2 = p[1],\n\t          dx2 = x2 - x0,\n\t          dy2 = y2 - y0,\n\t          dz = dy * dx2 - dx * dy2;\n\t      if (dz * dz / d2 > delta2 // perpendicular projected distance\n\t          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end\n\t          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance\n\t        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);\n\t        stream.point(x2, y2);\n\t        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);\n\t      }\n\t    }\n\t  }\n\t  return function(stream) {\n\t    var lambda00, x00, y00, a00, b00, c00, // first point\n\t        lambda0, x0, y0, a0, b0, c0; // previous point\n\t\n\t    var resampleStream = {\n\t      point: point,\n\t      lineStart: lineStart,\n\t      lineEnd: lineEnd,\n\t      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },\n\t      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }\n\t    };\n\t\n\t    function point(x, y) {\n\t      x = project(x, y);\n\t      stream.point(x[0], x[1]);\n\t    }\n\t\n\t    function lineStart() {\n\t      x0 = NaN;\n\t      resampleStream.point = linePoint;\n\t      stream.lineStart();\n\t    }\n\t\n\t    function linePoint(lambda, phi) {\n\t      var c = cartesian([lambda, phi]), p = project(lambda, phi);\n\t      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n\t      stream.point(x0, y0);\n\t    }\n\t\n\t    function lineEnd() {\n\t      resampleStream.point = point;\n\t      stream.lineEnd();\n\t    }\n\t\n\t    function ringStart() {\n\t      lineStart();\n\t      resampleStream.point = ringPoint;\n\t      resampleStream.lineEnd = ringEnd;\n\t    }\n\t\n\t    function ringPoint(lambda, phi) {\n\t      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n\t      resampleStream.point = linePoint;\n\t    }\n\t\n\t    function ringEnd() {\n\t      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);\n\t      resampleStream.lineEnd = lineEnd;\n\t      lineEnd();\n\t    }\n\t\n\t    return resampleStream;\n\t  };\n\t}\n\t\n\tvar transformRadians = transformer({\n\t  point: function(x, y) {\n\t    this.stream.point(x * radians, y * radians);\n\t  }\n\t});\n\t\n\tfunction projection(project) {\n\t  return projectionMutator(function() { return project; })();\n\t}\n\t\n\tfunction projectionMutator(projectAt) {\n\t  var project,\n\t      k = 150, // scale\n\t      x = 480, y = 250, // translate\n\t      dx, dy, lambda = 0, phi = 0, // center\n\t      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, projectRotate, // rotate\n\t      theta = null, preclip = clipAntimeridian, // clip angle\n\t      x0 = null, y0, x1, y1, postclip = identity$7, // clip extent\n\t      delta2 = 0.5, projectResample = resample(projectTransform, delta2), // precision\n\t      cache,\n\t      cacheStream;\n\t\n\t  function projection(point) {\n\t    point = projectRotate(point[0] * radians, point[1] * radians);\n\t    return [point[0] * k + dx, dy - point[1] * k];\n\t  }\n\t\n\t  function invert(point) {\n\t    point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);\n\t    return point && [point[0] * degrees$1, point[1] * degrees$1];\n\t  }\n\t\n\t  function projectTransform(x, y) {\n\t    return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];\n\t  }\n\t\n\t  projection.stream = function(stream) {\n\t    return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));\n\t  };\n\t\n\t  projection.clipAngle = function(_) {\n\t    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians, 6 * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees$1;\n\t  };\n\t\n\t  projection.clipExtent = function(_) {\n\t    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$7) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n\t  };\n\t\n\t  projection.scale = function(_) {\n\t    return arguments.length ? (k = +_, recenter()) : k;\n\t  };\n\t\n\t  projection.translate = function(_) {\n\t    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];\n\t  };\n\t\n\t  projection.center = function(_) {\n\t    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees$1, phi * degrees$1];\n\t  };\n\t\n\t  projection.rotate = function(_) {\n\t    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees$1, deltaPhi * degrees$1, deltaGamma * degrees$1];\n\t  };\n\t\n\t  projection.precision = function(_) {\n\t    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt$1(delta2);\n\t  };\n\t\n\t  projection.fitExtent = function(extent, object) {\n\t    return fitExtent(projection, extent, object);\n\t  };\n\t\n\t  projection.fitSize = function(size, object) {\n\t    return fitSize(projection, size, object);\n\t  };\n\t\n\t  function recenter() {\n\t    projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);\n\t    var center = project(lambda, phi);\n\t    dx = x - center[0] * k;\n\t    dy = y + center[1] * k;\n\t    return reset();\n\t  }\n\t\n\t  function reset() {\n\t    cache = cacheStream = null;\n\t    return projection;\n\t  }\n\t\n\t  return function() {\n\t    project = projectAt.apply(this, arguments);\n\t    projection.invert = project.invert && invert;\n\t    return recenter();\n\t  };\n\t}\n\t\n\tfunction conicProjection(projectAt) {\n\t  var phi0 = 0,\n\t      phi1 = pi$4 / 3,\n\t      m = projectionMutator(projectAt),\n\t      p = m(phi0, phi1);\n\t\n\t  p.parallels = function(_) {\n\t    return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees$1, phi1 * degrees$1];\n\t  };\n\t\n\t  return p;\n\t}\n\t\n\tfunction cylindricalEqualAreaRaw(phi0) {\n\t  var cosPhi0 = cos$1(phi0);\n\t\n\t  function forward(lambda, phi) {\n\t    return [lambda * cosPhi0, sin$1(phi) / cosPhi0];\n\t  }\n\t\n\t  forward.invert = function(x, y) {\n\t    return [x / cosPhi0, asin$1(y * cosPhi0)];\n\t  };\n\t\n\t  return forward;\n\t}\n\t\n\tfunction conicEqualAreaRaw(y0, y1) {\n\t  var sy0 = sin$1(y0), n = (sy0 + sin$1(y1)) / 2;\n\t\n\t  // Are the parallels symmetrical around the Equator?\n\t  if (abs(n) < epsilon$4) return cylindricalEqualAreaRaw(y0);\n\t\n\t  var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt$1(c) / n;\n\t\n\t  function project(x, y) {\n\t    var r = sqrt$1(c - 2 * n * sin$1(y)) / n;\n\t    return [r * sin$1(x *= n), r0 - r * cos$1(x)];\n\t  }\n\t\n\t  project.invert = function(x, y) {\n\t    var r0y = r0 - y;\n\t    return [atan2(x, abs(r0y)) / n * sign$1(r0y), asin$1((c - (x * x + r0y * r0y) * n * n) / (2 * n))];\n\t  };\n\t\n\t  return project;\n\t}\n\t\n\tvar conicEqualArea = function() {\n\t  return conicProjection(conicEqualAreaRaw)\n\t      .scale(155.424)\n\t      .center([0, 33.6442]);\n\t};\n\t\n\tvar albers = function() {\n\t  return conicEqualArea()\n\t      .parallels([29.5, 45.5])\n\t      .scale(1070)\n\t      .translate([480, 250])\n\t      .rotate([96, 0])\n\t      .center([-0.6, 38.7]);\n\t};\n\t\n\t// The projections must have mutually exclusive clip regions on the sphere,\n\t// as this will avoid emitting interleaving lines and polygons.\n\tfunction multiplex(streams) {\n\t  var n = streams.length;\n\t  return {\n\t    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },\n\t    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },\n\t    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },\n\t    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },\n\t    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },\n\t    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }\n\t  };\n\t}\n\t\n\t// A composite projection for the United States, configured by default for\n\t// 960×500. The projection also works quite well at 960×600 if you change the\n\t// scale to 1285 and adjust the translate accordingly. The set of standard\n\t// parallels for each region comes from USGS, which is published here:\n\t// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers\n\tvar albersUsa = function() {\n\t  var cache,\n\t      cacheStream,\n\t      lower48 = albers(), lower48Point,\n\t      alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338\n\t      hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007\n\t      point, pointStream = {point: function(x, y) { point = [x, y]; }};\n\t\n\t  function albersUsa(coordinates) {\n\t    var x = coordinates[0], y = coordinates[1];\n\t    return point = null,\n\t        (lower48Point.point(x, y), point)\n\t        || (alaskaPoint.point(x, y), point)\n\t        || (hawaiiPoint.point(x, y), point);\n\t  }\n\t\n\t  albersUsa.invert = function(coordinates) {\n\t    var k = lower48.scale(),\n\t        t = lower48.translate(),\n\t        x = (coordinates[0] - t[0]) / k,\n\t        y = (coordinates[1] - t[1]) / k;\n\t    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska\n\t        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii\n\t        : lower48).invert(coordinates);\n\t  };\n\t\n\t  albersUsa.stream = function(stream) {\n\t    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);\n\t  };\n\t\n\t  albersUsa.precision = function(_) {\n\t    if (!arguments.length) return lower48.precision();\n\t    lower48.precision(_), alaska.precision(_), hawaii.precision(_);\n\t    return reset();\n\t  };\n\t\n\t  albersUsa.scale = function(_) {\n\t    if (!arguments.length) return lower48.scale();\n\t    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);\n\t    return albersUsa.translate(lower48.translate());\n\t  };\n\t\n\t  albersUsa.translate = function(_) {\n\t    if (!arguments.length) return lower48.translate();\n\t    var k = lower48.scale(), x = +_[0], y = +_[1];\n\t\n\t    lower48Point = lower48\n\t        .translate(_)\n\t        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])\n\t        .stream(pointStream);\n\t\n\t    alaskaPoint = alaska\n\t        .translate([x - 0.307 * k, y + 0.201 * k])\n\t        .clipExtent([[x - 0.425 * k + epsilon$4, y + 0.120 * k + epsilon$4], [x - 0.214 * k - epsilon$4, y + 0.234 * k - epsilon$4]])\n\t        .stream(pointStream);\n\t\n\t    hawaiiPoint = hawaii\n\t        .translate([x - 0.205 * k, y + 0.212 * k])\n\t        .clipExtent([[x - 0.214 * k + epsilon$4, y + 0.166 * k + epsilon$4], [x - 0.115 * k - epsilon$4, y + 0.234 * k - epsilon$4]])\n\t        .stream(pointStream);\n\t\n\t    return reset();\n\t  };\n\t\n\t  albersUsa.fitExtent = function(extent, object) {\n\t    return fitExtent(albersUsa, extent, object);\n\t  };\n\t\n\t  albersUsa.fitSize = function(size, object) {\n\t    return fitSize(albersUsa, size, object);\n\t  };\n\t\n\t  function reset() {\n\t    cache = cacheStream = null;\n\t    return albersUsa;\n\t  }\n\t\n\t  return albersUsa.scale(1070);\n\t};\n\t\n\tfunction azimuthalRaw(scale) {\n\t  return function(x, y) {\n\t    var cx = cos$1(x),\n\t        cy = cos$1(y),\n\t        k = scale(cx * cy);\n\t    return [\n\t      k * cy * sin$1(x),\n\t      k * sin$1(y)\n\t    ];\n\t  }\n\t}\n\t\n\tfunction azimuthalInvert(angle) {\n\t  return function(x, y) {\n\t    var z = sqrt$1(x * x + y * y),\n\t        c = angle(z),\n\t        sc = sin$1(c),\n\t        cc = cos$1(c);\n\t    return [\n\t      atan2(x * sc, z * cc),\n\t      asin$1(z && y * sc / z)\n\t    ];\n\t  }\n\t}\n\t\n\tvar azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {\n\t  return sqrt$1(2 / (1 + cxcy));\n\t});\n\t\n\tazimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {\n\t  return 2 * asin$1(z / 2);\n\t});\n\t\n\tvar azimuthalEqualArea = function() {\n\t  return projection(azimuthalEqualAreaRaw)\n\t      .scale(124.75)\n\t      .clipAngle(180 - 1e-3);\n\t};\n\t\n\tvar azimuthalEquidistantRaw = azimuthalRaw(function(c) {\n\t  return (c = acos(c)) && c / sin$1(c);\n\t});\n\t\n\tazimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {\n\t  return z;\n\t});\n\t\n\tvar azimuthalEquidistant = function() {\n\t  return projection(azimuthalEquidistantRaw)\n\t      .scale(79.4188)\n\t      .clipAngle(180 - 1e-3);\n\t};\n\t\n\tfunction mercatorRaw(lambda, phi) {\n\t  return [lambda, log$1(tan((halfPi$3 + phi) / 2))];\n\t}\n\t\n\tmercatorRaw.invert = function(x, y) {\n\t  return [x, 2 * atan(exp(y)) - halfPi$3];\n\t};\n\t\n\tvar mercator = function() {\n\t  return mercatorProjection(mercatorRaw)\n\t      .scale(961 / tau$4);\n\t};\n\t\n\tfunction mercatorProjection(project) {\n\t  var m = projection(project),\n\t      scale = m.scale,\n\t      translate = m.translate,\n\t      clipExtent = m.clipExtent,\n\t      clipAuto;\n\t\n\t  m.scale = function(_) {\n\t    return arguments.length ? (scale(_), clipAuto && m.clipExtent(null), m) : scale();\n\t  };\n\t\n\t  m.translate = function(_) {\n\t    return arguments.length ? (translate(_), clipAuto && m.clipExtent(null), m) : translate();\n\t  };\n\t\n\t  m.clipExtent = function(_) {\n\t    if (!arguments.length) return clipAuto ? null : clipExtent();\n\t    if (clipAuto = _ == null) {\n\t      var k = pi$4 * scale(),\n\t          t = translate();\n\t      _ = [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]];\n\t    }\n\t    clipExtent(_);\n\t    return m;\n\t  };\n\t\n\t  return m.clipExtent(null);\n\t}\n\t\n\tfunction tany(y) {\n\t  return tan((halfPi$3 + y) / 2);\n\t}\n\t\n\tfunction conicConformalRaw(y0, y1) {\n\t  var cy0 = cos$1(y0),\n\t      n = y0 === y1 ? sin$1(y0) : log$1(cy0 / cos$1(y1)) / log$1(tany(y1) / tany(y0)),\n\t      f = cy0 * pow$1(tany(y0), n) / n;\n\t\n\t  if (!n) return mercatorRaw;\n\t\n\t  function project(x, y) {\n\t    if (f > 0) { if (y < -halfPi$3 + epsilon$4) y = -halfPi$3 + epsilon$4; }\n\t    else { if (y > halfPi$3 - epsilon$4) y = halfPi$3 - epsilon$4; }\n\t    var r = f / pow$1(tany(y), n);\n\t    return [r * sin$1(n * x), f - r * cos$1(n * x)];\n\t  }\n\t\n\t  project.invert = function(x, y) {\n\t    var fy = f - y, r = sign$1(n) * sqrt$1(x * x + fy * fy);\n\t    return [atan2(x, abs(fy)) / n * sign$1(fy), 2 * atan(pow$1(f / r, 1 / n)) - halfPi$3];\n\t  };\n\t\n\t  return project;\n\t}\n\t\n\tvar conicConformal = function() {\n\t  return conicProjection(conicConformalRaw)\n\t      .scale(109.5)\n\t      .parallels([30, 30]);\n\t};\n\t\n\tfunction equirectangularRaw(lambda, phi) {\n\t  return [lambda, phi];\n\t}\n\t\n\tequirectangularRaw.invert = equirectangularRaw;\n\t\n\tvar equirectangular = function() {\n\t  return projection(equirectangularRaw)\n\t      .scale(152.63);\n\t};\n\t\n\tfunction conicEquidistantRaw(y0, y1) {\n\t  var cy0 = cos$1(y0),\n\t      n = y0 === y1 ? sin$1(y0) : (cy0 - cos$1(y1)) / (y1 - y0),\n\t      g = cy0 / n + y0;\n\t\n\t  if (abs(n) < epsilon$4) return equirectangularRaw;\n\t\n\t  function project(x, y) {\n\t    var gy = g - y, nx = n * x;\n\t    return [gy * sin$1(nx), g - gy * cos$1(nx)];\n\t  }\n\t\n\t  project.invert = function(x, y) {\n\t    var gy = g - y;\n\t    return [atan2(x, abs(gy)) / n * sign$1(gy), g - sign$1(n) * sqrt$1(x * x + gy * gy)];\n\t  };\n\t\n\t  return project;\n\t}\n\t\n\tvar conicEquidistant = function() {\n\t  return conicProjection(conicEquidistantRaw)\n\t      .scale(131.154)\n\t      .center([0, 13.9389]);\n\t};\n\t\n\tfunction gnomonicRaw(x, y) {\n\t  var cy = cos$1(y), k = cos$1(x) * cy;\n\t  return [cy * sin$1(x) / k, sin$1(y) / k];\n\t}\n\t\n\tgnomonicRaw.invert = azimuthalInvert(atan);\n\t\n\tvar gnomonic = function() {\n\t  return projection(gnomonicRaw)\n\t      .scale(144.049)\n\t      .clipAngle(60);\n\t};\n\t\n\tfunction scaleTranslate(k, tx, ty) {\n\t  return k === 1 && tx === 0 && ty === 0 ? identity$7 : transformer({\n\t    point: function(x, y) {\n\t      this.stream.point(x * k + tx, y * k + ty);\n\t    }\n\t  });\n\t}\n\t\n\tvar identity$8 = function() {\n\t  var k = 1, tx = 0, ty = 0, transform = identity$7, // scale and translate\n\t      x0 = null, y0, x1, y1, clip = identity$7, // clip extent\n\t      cache,\n\t      cacheStream,\n\t      projection;\n\t\n\t  function reset() {\n\t    cache = cacheStream = null;\n\t    return projection;\n\t  }\n\t\n\t  return projection = {\n\t    stream: function(stream) {\n\t      return cache && cacheStream === stream ? cache : cache = transform(clip(cacheStream = stream));\n\t    },\n\t    clipExtent: function(_) {\n\t      return arguments.length ? (clip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$7) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n\t    },\n\t    scale: function(_) {\n\t      return arguments.length ? (transform = scaleTranslate(k = +_, tx, ty), reset()) : k;\n\t    },\n\t    translate: function(_) {\n\t      return arguments.length ? (transform = scaleTranslate(k, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];\n\t    },\n\t    fitExtent: function(extent, object) {\n\t      return fitExtent(projection, extent, object);\n\t    },\n\t    fitSize: function(size, object) {\n\t      return fitSize(projection, size, object);\n\t    }\n\t  };\n\t};\n\t\n\tfunction orthographicRaw(x, y) {\n\t  return [cos$1(y) * sin$1(x), sin$1(y)];\n\t}\n\t\n\torthographicRaw.invert = azimuthalInvert(asin$1);\n\t\n\tvar orthographic = function() {\n\t  return projection(orthographicRaw)\n\t      .scale(249.5)\n\t      .clipAngle(90 + epsilon$4);\n\t};\n\t\n\tfunction stereographicRaw(x, y) {\n\t  var cy = cos$1(y), k = 1 + cos$1(x) * cy;\n\t  return [cy * sin$1(x) / k, sin$1(y) / k];\n\t}\n\t\n\tstereographicRaw.invert = azimuthalInvert(function(z) {\n\t  return 2 * atan(z);\n\t});\n\t\n\tvar stereographic = function() {\n\t  return projection(stereographicRaw)\n\t      .scale(250)\n\t      .clipAngle(142);\n\t};\n\t\n\tfunction transverseMercatorRaw(lambda, phi) {\n\t  return [log$1(tan((halfPi$3 + phi) / 2)), -lambda];\n\t}\n\t\n\ttransverseMercatorRaw.invert = function(x, y) {\n\t  return [-y, 2 * atan(exp(x)) - halfPi$3];\n\t};\n\t\n\tvar transverseMercator = function() {\n\t  var m = mercatorProjection(transverseMercatorRaw),\n\t      center = m.center,\n\t      rotate = m.rotate;\n\t\n\t  m.center = function(_) {\n\t    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);\n\t  };\n\t\n\t  m.rotate = function(_) {\n\t    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);\n\t  };\n\t\n\t  return rotate([0, 0, 90])\n\t      .scale(159.155);\n\t};\n\t\n\texports.version = version;\n\texports.bisect = bisectRight;\n\texports.bisectRight = bisectRight;\n\texports.bisectLeft = bisectLeft;\n\texports.ascending = ascending;\n\texports.bisector = bisector;\n\texports.descending = descending;\n\texports.deviation = deviation;\n\texports.extent = extent;\n\texports.histogram = histogram;\n\texports.thresholdFreedmanDiaconis = freedmanDiaconis;\n\texports.thresholdScott = scott;\n\texports.thresholdSturges = sturges;\n\texports.max = max;\n\texports.mean = mean;\n\texports.median = median;\n\texports.merge = merge;\n\texports.min = min;\n\texports.pairs = pairs;\n\texports.permute = permute;\n\texports.quantile = threshold;\n\texports.range = range;\n\texports.scan = scan;\n\texports.shuffle = shuffle;\n\texports.sum = sum;\n\texports.ticks = ticks;\n\texports.tickStep = tickStep;\n\texports.transpose = transpose;\n\texports.variance = variance;\n\texports.zip = zip;\n\texports.entries = entries;\n\texports.keys = keys;\n\texports.values = values;\n\texports.map = map$1;\n\texports.set = set;\n\texports.nest = nest;\n\texports.randomUniform = uniform;\n\texports.randomNormal = normal;\n\texports.randomLogNormal = logNormal;\n\texports.randomBates = bates;\n\texports.randomIrwinHall = irwinHall;\n\texports.randomExponential = exponential;\n\texports.easeLinear = linear;\n\texports.easeQuad = quadInOut;\n\texports.easeQuadIn = quadIn;\n\texports.easeQuadOut = quadOut;\n\texports.easeQuadInOut = quadInOut;\n\texports.easeCubic = cubicInOut;\n\texports.easeCubicIn = cubicIn;\n\texports.easeCubicOut = cubicOut;\n\texports.easeCubicInOut = cubicInOut;\n\texports.easePoly = polyInOut;\n\texports.easePolyIn = polyIn;\n\texports.easePolyOut = polyOut;\n\texports.easePolyInOut = polyInOut;\n\texports.easeSin = sinInOut;\n\texports.easeSinIn = sinIn;\n\texports.easeSinOut = sinOut;\n\texports.easeSinInOut = sinInOut;\n\texports.easeExp = expInOut;\n\texports.easeExpIn = expIn;\n\texports.easeExpOut = expOut;\n\texports.easeExpInOut = expInOut;\n\texports.easeCircle = circleInOut;\n\texports.easeCircleIn = circleIn;\n\texports.easeCircleOut = circleOut;\n\texports.easeCircleInOut = circleInOut;\n\texports.easeBounce = bounceOut;\n\texports.easeBounceIn = bounceIn;\n\texports.easeBounceOut = bounceOut;\n\texports.easeBounceInOut = bounceInOut;\n\texports.easeBack = backInOut;\n\texports.easeBackIn = backIn;\n\texports.easeBackOut = backOut;\n\texports.easeBackInOut = backInOut;\n\texports.easeElastic = elasticOut;\n\texports.easeElasticIn = elasticIn;\n\texports.easeElasticOut = elasticOut;\n\texports.easeElasticInOut = elasticInOut;\n\texports.polygonArea = area;\n\texports.polygonCentroid = centroid;\n\texports.polygonHull = hull;\n\texports.polygonContains = contains;\n\texports.polygonLength = length$1;\n\texports.path = path;\n\texports.quadtree = quadtree;\n\texports.queue = queue;\n\texports.arc = arc;\n\texports.area = area$1;\n\texports.line = line;\n\texports.pie = pie;\n\texports.radialArea = radialArea;\n\texports.radialLine = radialLine$1;\n\texports.symbol = symbol;\n\texports.symbols = symbols;\n\texports.symbolCircle = circle;\n\texports.symbolCross = cross$1;\n\texports.symbolDiamond = diamond;\n\texports.symbolSquare = square;\n\texports.symbolStar = star;\n\texports.symbolTriangle = triangle;\n\texports.symbolWye = wye;\n\texports.curveBasisClosed = basisClosed;\n\texports.curveBasisOpen = basisOpen;\n\texports.curveBasis = basis;\n\texports.curveBundle = bundle;\n\texports.curveCardinalClosed = cardinalClosed;\n\texports.curveCardinalOpen = cardinalOpen;\n\texports.curveCardinal = cardinal;\n\texports.curveCatmullRomClosed = catmullRomClosed;\n\texports.curveCatmullRomOpen = catmullRomOpen;\n\texports.curveCatmullRom = catmullRom;\n\texports.curveLinearClosed = linearClosed;\n\texports.curveLinear = curveLinear;\n\texports.curveMonotoneX = monotoneX;\n\texports.curveMonotoneY = monotoneY;\n\texports.curveNatural = natural;\n\texports.curveStep = step;\n\texports.curveStepAfter = stepAfter;\n\texports.curveStepBefore = stepBefore;\n\texports.stack = stack;\n\texports.stackOffsetExpand = expand;\n\texports.stackOffsetNone = none;\n\texports.stackOffsetSilhouette = silhouette;\n\texports.stackOffsetWiggle = wiggle;\n\texports.stackOrderAscending = ascending$1;\n\texports.stackOrderDescending = descending$2;\n\texports.stackOrderInsideOut = insideOut;\n\texports.stackOrderNone = none$1;\n\texports.stackOrderReverse = reverse;\n\texports.color = color;\n\texports.rgb = rgb;\n\texports.hsl = hsl;\n\texports.lab = lab;\n\texports.hcl = hcl;\n\texports.cubehelix = cubehelix;\n\texports.interpolate = interpolate;\n\texports.interpolateArray = array$1;\n\texports.interpolateDate = date;\n\texports.interpolateNumber = interpolateNumber;\n\texports.interpolateObject = object;\n\texports.interpolateRound = interpolateRound;\n\texports.interpolateString = interpolateString;\n\texports.interpolateTransformCss = interpolateTransformCss;\n\texports.interpolateTransformSvg = interpolateTransformSvg;\n\texports.interpolateZoom = interpolateZoom;\n\texports.interpolateRgb = interpolateRgb;\n\texports.interpolateRgbBasis = rgbBasis;\n\texports.interpolateRgbBasisClosed = rgbBasisClosed;\n\texports.interpolateHsl = hsl$2;\n\texports.interpolateHslLong = hslLong;\n\texports.interpolateLab = lab$1;\n\texports.interpolateHcl = hcl$2;\n\texports.interpolateHclLong = hclLong;\n\texports.interpolateCubehelix = cubehelix$2;\n\texports.interpolateCubehelixLong = cubehelixLong;\n\texports.interpolateBasis = basis$2;\n\texports.interpolateBasisClosed = basisClosed$1;\n\texports.quantize = quantize;\n\texports.dispatch = dispatch;\n\texports.dsvFormat = dsv;\n\texports.csvParse = csvParse;\n\texports.csvParseRows = csvParseRows;\n\texports.csvFormat = csvFormat;\n\texports.csvFormatRows = csvFormatRows;\n\texports.tsvParse = tsvParse;\n\texports.tsvParseRows = tsvParseRows;\n\texports.tsvFormat = tsvFormat;\n\texports.tsvFormatRows = tsvFormatRows;\n\texports.request = request;\n\texports.html = html;\n\texports.json = json;\n\texports.text = text;\n\texports.xml = xml;\n\texports.csv = csv$1;\n\texports.tsv = tsv$1;\n\texports.now = now;\n\texports.timer = timer;\n\texports.timerFlush = timerFlush;\n\texports.timeout = timeout$1;\n\texports.interval = interval$1;\n\texports.timeInterval = newInterval;\n\texports.timeMillisecond = millisecond;\n\texports.timeMilliseconds = milliseconds;\n\texports.timeSecond = second;\n\texports.timeSeconds = seconds;\n\texports.timeMinute = minute;\n\texports.timeMinutes = minutes;\n\texports.timeHour = hour;\n\texports.timeHours = hours;\n\texports.timeDay = day;\n\texports.timeDays = days;\n\texports.timeWeek = sunday;\n\texports.timeWeeks = sundays;\n\texports.timeSunday = sunday;\n\texports.timeSundays = sundays;\n\texports.timeMonday = monday;\n\texports.timeMondays = mondays;\n\texports.timeTuesday = tuesday;\n\texports.timeTuesdays = tuesdays;\n\texports.timeWednesday = wednesday;\n\texports.timeWednesdays = wednesdays;\n\texports.timeThursday = thursday;\n\texports.timeThursdays = thursdays;\n\texports.timeFriday = friday;\n\texports.timeFridays = fridays;\n\texports.timeSaturday = saturday;\n\texports.timeSaturdays = saturdays;\n\texports.timeMonth = month;\n\texports.timeMonths = months;\n\texports.timeYear = year;\n\texports.timeYears = years;\n\texports.utcMillisecond = millisecond;\n\texports.utcMilliseconds = milliseconds;\n\texports.utcSecond = second;\n\texports.utcSeconds = seconds;\n\texports.utcMinute = utcMinute;\n\texports.utcMinutes = utcMinutes;\n\texports.utcHour = utcHour;\n\texports.utcHours = utcHours;\n\texports.utcDay = utcDay;\n\texports.utcDays = utcDays;\n\texports.utcWeek = utcSunday;\n\texports.utcWeeks = utcSundays;\n\texports.utcSunday = utcSunday;\n\texports.utcSundays = utcSundays;\n\texports.utcMonday = utcMonday;\n\texports.utcMondays = utcMondays;\n\texports.utcTuesday = utcTuesday;\n\texports.utcTuesdays = utcTuesdays;\n\texports.utcWednesday = utcWednesday;\n\texports.utcWednesdays = utcWednesdays;\n\texports.utcThursday = utcThursday;\n\texports.utcThursdays = utcThursdays;\n\texports.utcFriday = utcFriday;\n\texports.utcFridays = utcFridays;\n\texports.utcSaturday = utcSaturday;\n\texports.utcSaturdays = utcSaturdays;\n\texports.utcMonth = utcMonth;\n\texports.utcMonths = utcMonths;\n\texports.utcYear = utcYear;\n\texports.utcYears = utcYears;\n\texports.formatLocale = formatLocale;\n\texports.formatDefaultLocale = defaultLocale;\n\texports.formatSpecifier = formatSpecifier;\n\texports.precisionFixed = precisionFixed;\n\texports.precisionPrefix = precisionPrefix;\n\texports.precisionRound = precisionRound;\n\texports.isoFormat = formatIso;\n\texports.isoParse = parseIso;\n\texports.timeFormatLocale = formatLocale$1;\n\texports.timeFormatDefaultLocale = defaultLocale$1;\n\texports.scaleBand = band;\n\texports.scalePoint = point$4;\n\texports.scaleIdentity = identity$4;\n\texports.scaleLinear = linear$2;\n\texports.scaleLog = log;\n\texports.scaleOrdinal = ordinal;\n\texports.scaleImplicit = implicit;\n\texports.scalePow = pow;\n\texports.scaleSqrt = sqrt;\n\texports.scaleQuantile = quantile$$1;\n\texports.scaleQuantize = quantize$1;\n\texports.scaleThreshold = threshold$1;\n\texports.scaleTime = time;\n\texports.scaleUtc = utcTime;\n\texports.schemeCategory10 = category10;\n\texports.schemeCategory20b = category20b;\n\texports.schemeCategory20c = category20c;\n\texports.schemeCategory20 = category20;\n\texports.scaleSequential = sequential;\n\texports.interpolateCubehelixDefault = cubehelix$3;\n\texports.interpolateRainbow = rainbow$1;\n\texports.interpolateWarm = warm;\n\texports.interpolateCool = cool;\n\texports.interpolateViridis = viridis;\n\texports.interpolateMagma = magma;\n\texports.interpolateInferno = inferno;\n\texports.interpolatePlasma = plasma;\n\texports.creator = creator;\n\texports.customEvent = customEvent;\n\texports.local = local;\n\texports.matcher = matcher$1;\n\texports.mouse = mouse;\n\texports.namespace = namespace;\n\texports.namespaces = namespaces;\n\texports.select = select;\n\texports.selectAll = selectAll;\n\texports.selection = selection;\n\texports.selector = selector;\n\texports.selectorAll = selectorAll;\n\texports.touch = touch;\n\texports.touches = touches;\n\texports.window = window;\n\texports.active = active;\n\texports.interrupt = interrupt;\n\texports.transition = transition;\n\texports.axisTop = axisTop;\n\texports.axisRight = axisRight;\n\texports.axisBottom = axisBottom;\n\texports.axisLeft = axisLeft;\n\texports.cluster = cluster;\n\texports.hierarchy = hierarchy;\n\texports.pack = index;\n\texports.packSiblings = siblings;\n\texports.packEnclose = enclose;\n\texports.partition = partition;\n\texports.stratify = stratify;\n\texports.tree = tree;\n\texports.treemap = index$1;\n\texports.treemapBinary = binary;\n\texports.treemapDice = treemapDice;\n\texports.treemapSlice = treemapSlice;\n\texports.treemapSliceDice = sliceDice;\n\texports.treemapSquarify = squarify;\n\texports.treemapResquarify = resquarify;\n\texports.forceCenter = center$1;\n\texports.forceCollide = collide;\n\texports.forceLink = link;\n\texports.forceManyBody = manyBody;\n\texports.forceSimulation = simulation;\n\texports.forceX = x$3;\n\texports.forceY = y$3;\n\texports.drag = drag;\n\texports.dragDisable = dragDisable;\n\texports.dragEnable = yesdrag;\n\texports.voronoi = voronoi;\n\texports.zoom = zoom;\n\texports.zoomIdentity = identity$6;\n\texports.zoomTransform = transform;\n\texports.brush = brush;\n\texports.brushX = brushX;\n\texports.brushY = brushY;\n\texports.brushSelection = brushSelection;\n\texports.chord = chord;\n\texports.ribbon = ribbon;\n\texports.geoAlbers = albers;\n\texports.geoAlbersUsa = albersUsa;\n\texports.geoArea = area$2;\n\texports.geoAzimuthalEqualArea = azimuthalEqualArea;\n\texports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;\n\texports.geoAzimuthalEquidistant = azimuthalEquidistant;\n\texports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;\n\texports.geoBounds = bounds;\n\texports.geoCentroid = centroid$1;\n\texports.geoCircle = circle$1;\n\texports.geoClipExtent = extent$1;\n\texports.geoConicConformal = conicConformal;\n\texports.geoConicConformalRaw = conicConformalRaw;\n\texports.geoConicEqualArea = conicEqualArea;\n\texports.geoConicEqualAreaRaw = conicEqualAreaRaw;\n\texports.geoConicEquidistant = conicEquidistant;\n\texports.geoConicEquidistantRaw = conicEquidistantRaw;\n\texports.geoDistance = distance;\n\texports.geoEquirectangular = equirectangular;\n\texports.geoEquirectangularRaw = equirectangularRaw;\n\texports.geoGnomonic = gnomonic;\n\texports.geoGnomonicRaw = gnomonicRaw;\n\texports.geoGraticule = graticule;\n\texports.geoGraticule10 = graticule10;\n\texports.geoIdentity = identity$8;\n\texports.geoInterpolate = interpolate$2;\n\texports.geoLength = length$2;\n\texports.geoMercator = mercator;\n\texports.geoMercatorRaw = mercatorRaw;\n\texports.geoOrthographic = orthographic;\n\texports.geoOrthographicRaw = orthographicRaw;\n\texports.geoPath = index$3;\n\texports.geoProjection = projection;\n\texports.geoProjectionMutator = projectionMutator;\n\texports.geoRotation = rotation;\n\texports.geoStereographic = stereographic;\n\texports.geoStereographicRaw = stereographicRaw;\n\texports.geoStream = geoStream;\n\texports.geoTransform = transform$1;\n\texports.geoTransverseMercator = transverseMercator;\n\texports.geoTransverseMercatorRaw = transverseMercatorRaw;\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\n\n/***/ },\n/* 136 */,\n/* 137 */,\n/* 138 */,\n/* 139 */,\n/* 140 */,\n/* 141 */\n/***/ function(module, exports) {\n\n\texports.read = function (buffer, offset, isLE, mLen, nBytes) {\n\t  var e, m\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var nBits = -7\n\t  var i = isLE ? (nBytes - 1) : 0\n\t  var d = isLE ? -1 : 1\n\t  var s = buffer[offset + i]\n\t\n\t  i += d\n\t\n\t  e = s & ((1 << (-nBits)) - 1)\n\t  s >>= (-nBits)\n\t  nBits += eLen\n\t  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  m = e & ((1 << (-nBits)) - 1)\n\t  e >>= (-nBits)\n\t  nBits += mLen\n\t  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  if (e === 0) {\n\t    e = 1 - eBias\n\t  } else if (e === eMax) {\n\t    return m ? NaN : ((s ? -1 : 1) * Infinity)\n\t  } else {\n\t    m = m + Math.pow(2, mLen)\n\t    e = e - eBias\n\t  }\n\t  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n\t}\n\t\n\texports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n\t  var e, m, c\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n\t  var i = isLE ? 0 : (nBytes - 1)\n\t  var d = isLE ? 1 : -1\n\t  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\t\n\t  value = Math.abs(value)\n\t\n\t  if (isNaN(value) || value === Infinity) {\n\t    m = isNaN(value) ? 1 : 0\n\t    e = eMax\n\t  } else {\n\t    e = Math.floor(Math.log(value) / Math.LN2)\n\t    if (value * (c = Math.pow(2, -e)) < 1) {\n\t      e--\n\t      c *= 2\n\t    }\n\t    if (e + eBias >= 1) {\n\t      value += rt / c\n\t    } else {\n\t      value += rt * Math.pow(2, 1 - eBias)\n\t    }\n\t    if (value * c >= 2) {\n\t      e++\n\t      c /= 2\n\t    }\n\t\n\t    if (e + eBias >= eMax) {\n\t      m = 0\n\t      e = eMax\n\t    } else if (e + eBias >= 1) {\n\t      m = (value * c - 1) * Math.pow(2, mLen)\n\t      e = e + eBias\n\t    } else {\n\t      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n\t      e = 0\n\t    }\n\t  }\n\t\n\t  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\t\n\t  e = (e << mLen) | m\n\t  eLen += mLen\n\t  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\t\n\t  buffer[offset + i - d] |= s * 128\n\t}\n\n\n/***/ },\n/* 142 */\n/***/ function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = Array.isArray || function (arr) {\n\t  return toString.call(arr) == '[object Array]';\n\t};\n\n\n/***/ },\n/* 143 */\n/***/ function(module, exports) {\n\n\tmodule.exports = Array.isArray || function (arr) {\n\t  return Object.prototype.toString.call(arr) == '[object Array]';\n\t};\n\n\n/***/ },\n/* 144 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(12)\n\n\n/***/ },\n/* 145 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(65)\n\n\n/***/ },\n/* 146 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {exports = module.exports = __webpack_require__(66);\n\texports.Stream = __webpack_require__(22);\n\texports.Readable = exports;\n\texports.Writable = __webpack_require__(42);\n\texports.Duplex = __webpack_require__(12);\n\texports.Transform = __webpack_require__(41);\n\texports.PassThrough = __webpack_require__(65);\n\tif (!process.browser && ({\"NODE_ENV\":\"production\"}).READABLE_STREAM === 'disable') {\n\t  module.exports = __webpack_require__(22);\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))\n\n/***/ },\n/* 147 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(41)\n\n\n/***/ },\n/* 148 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(42)\n\n\n/***/ },\n/* 149 */,\n/* 150 */,\n/* 151 */,\n/* 152 */,\n/* 153 */,\n/* 154 */,\n/* 155 */,\n/* 156 */,\n/* 157 */,\n/* 158 */,\n/* 159 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * Vue.js v2.0.3\n\t * (c) 2014-2016 Evan You\n\t * Released under the MIT License.\n\t */\n\t(function (global, factory) {\n\t   true ? module.exports = factory() :\n\t  typeof define === 'function' && define.amd ? define(factory) :\n\t  (global.Vue = factory());\n\t}(this, (function () { 'use strict';\n\t\n\t/*  */\n\t\n\t/**\n\t * Convert a value to a string that is actually rendered.\n\t */\n\tfunction _toString (val) {\n\t  return val == null\n\t    ? ''\n\t    : typeof val === 'object'\n\t      ? JSON.stringify(val, null, 2)\n\t      : String(val)\n\t}\n\t\n\t/**\n\t * Convert a input value to a number for persistence.\n\t * If the conversion fails, return original string.\n\t */\n\tfunction toNumber (val) {\n\t  var n = parseFloat(val, 10);\n\t  return (n || n === 0) ? n : val\n\t}\n\t\n\t/**\n\t * Make a map and return a function for checking if a key\n\t * is in that map.\n\t */\n\tfunction makeMap (\n\t  str,\n\t  expectsLowerCase\n\t) {\n\t  var map = Object.create(null);\n\t  var list = str.split(',');\n\t  for (var i = 0; i < list.length; i++) {\n\t    map[list[i]] = true;\n\t  }\n\t  return expectsLowerCase\n\t    ? function (val) { return map[val.toLowerCase()]; }\n\t    : function (val) { return map[val]; }\n\t}\n\t\n\t/**\n\t * Check if a tag is a built-in tag.\n\t */\n\tvar isBuiltInTag = makeMap('slot,component', true);\n\t\n\t/**\n\t * Remove an item from an array\n\t */\n\tfunction remove$1 (arr, item) {\n\t  if (arr.length) {\n\t    var index = arr.indexOf(item);\n\t    if (index > -1) {\n\t      return arr.splice(index, 1)\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Check whether the object has the property.\n\t */\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\tfunction hasOwn (obj, key) {\n\t  return hasOwnProperty.call(obj, key)\n\t}\n\t\n\t/**\n\t * Check if value is primitive\n\t */\n\tfunction isPrimitive (value) {\n\t  return typeof value === 'string' || typeof value === 'number'\n\t}\n\t\n\t/**\n\t * Create a cached version of a pure function.\n\t */\n\tfunction cached (fn) {\n\t  var cache = Object.create(null);\n\t  return function cachedFn (str) {\n\t    var hit = cache[str];\n\t    return hit || (cache[str] = fn(str))\n\t  }\n\t}\n\t\n\t/**\n\t * Camelize a hyphen-delmited string.\n\t */\n\tvar camelizeRE = /-(\\w)/g;\n\tvar camelize = cached(function (str) {\n\t  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n\t});\n\t\n\t/**\n\t * Capitalize a string.\n\t */\n\tvar capitalize = cached(function (str) {\n\t  return str.charAt(0).toUpperCase() + str.slice(1)\n\t});\n\t\n\t/**\n\t * Hyphenate a camelCase string.\n\t */\n\tvar hyphenateRE = /([^-])([A-Z])/g;\n\tvar hyphenate = cached(function (str) {\n\t  return str\n\t    .replace(hyphenateRE, '$1-$2')\n\t    .replace(hyphenateRE, '$1-$2')\n\t    .toLowerCase()\n\t});\n\t\n\t/**\n\t * Simple bind, faster than native\n\t */\n\tfunction bind$1 (fn, ctx) {\n\t  function boundFn (a) {\n\t    var l = arguments.length;\n\t    return l\n\t      ? l > 1\n\t        ? fn.apply(ctx, arguments)\n\t        : fn.call(ctx, a)\n\t      : fn.call(ctx)\n\t  }\n\t  // record original fn length\n\t  boundFn._length = fn.length;\n\t  return boundFn\n\t}\n\t\n\t/**\n\t * Convert an Array-like object to a real Array.\n\t */\n\tfunction toArray (list, start) {\n\t  start = start || 0;\n\t  var i = list.length - start;\n\t  var ret = new Array(i);\n\t  while (i--) {\n\t    ret[i] = list[i + start];\n\t  }\n\t  return ret\n\t}\n\t\n\t/**\n\t * Mix properties into target object.\n\t */\n\tfunction extend (to, _from) {\n\t  for (var key in _from) {\n\t    to[key] = _from[key];\n\t  }\n\t  return to\n\t}\n\t\n\t/**\n\t * Quick object check - this is primarily used to tell\n\t * Objects from primitive values when we know the value\n\t * is a JSON-compliant type.\n\t */\n\tfunction isObject (obj) {\n\t  return obj !== null && typeof obj === 'object'\n\t}\n\t\n\t/**\n\t * Strict object type check. Only returns true\n\t * for plain JavaScript objects.\n\t */\n\tvar toString = Object.prototype.toString;\n\tvar OBJECT_STRING = '[object Object]';\n\tfunction isPlainObject (obj) {\n\t  return toString.call(obj) === OBJECT_STRING\n\t}\n\t\n\t/**\n\t * Merge an Array of Objects into a single Object.\n\t */\n\tfunction toObject (arr) {\n\t  var res = {};\n\t  for (var i = 0; i < arr.length; i++) {\n\t    if (arr[i]) {\n\t      extend(res, arr[i]);\n\t    }\n\t  }\n\t  return res\n\t}\n\t\n\t/**\n\t * Perform no operation.\n\t */\n\tfunction noop () {}\n\t\n\t/**\n\t * Always return false.\n\t */\n\tvar no = function () { return false; };\n\t\n\t/**\n\t * Generate a static keys string from compiler modules.\n\t */\n\tfunction genStaticKeys (modules) {\n\t  return modules.reduce(function (keys, m) {\n\t    return keys.concat(m.staticKeys || [])\n\t  }, []).join(',')\n\t}\n\t\n\t/**\n\t * Check if two values are loosely equal - that is,\n\t * if they are plain objects, do they have the same shape?\n\t */\n\tfunction looseEqual (a, b) {\n\t  /* eslint-disable eqeqeq */\n\t  return a == b || (\n\t    isObject(a) && isObject(b)\n\t      ? JSON.stringify(a) === JSON.stringify(b)\n\t      : false\n\t  )\n\t  /* eslint-enable eqeqeq */\n\t}\n\t\n\tfunction looseIndexOf (arr, val) {\n\t  for (var i = 0; i < arr.length; i++) {\n\t    if (looseEqual(arr[i], val)) { return i }\n\t  }\n\t  return -1\n\t}\n\t\n\t/*  */\n\t\n\tvar config = {\n\t  /**\n\t   * Option merge strategies (used in core/util/options)\n\t   */\n\t  optionMergeStrategies: Object.create(null),\n\t\n\t  /**\n\t   * Whether to suppress warnings.\n\t   */\n\t  silent: false,\n\t\n\t  /**\n\t   * Whether to enable devtools\n\t   */\n\t  devtools: \"development\" !== 'production',\n\t\n\t  /**\n\t   * Error handler for watcher errors\n\t   */\n\t  errorHandler: null,\n\t\n\t  /**\n\t   * Ignore certain custom elements\n\t   */\n\t  ignoredElements: null,\n\t\n\t  /**\n\t   * Custom user key aliases for v-on\n\t   */\n\t  keyCodes: Object.create(null),\n\t\n\t  /**\n\t   * Check if a tag is reserved so that it cannot be registered as a\n\t   * component. This is platform-dependent and may be overwritten.\n\t   */\n\t  isReservedTag: no,\n\t\n\t  /**\n\t   * Check if a tag is an unknown element.\n\t   * Platform-dependent.\n\t   */\n\t  isUnknownElement: no,\n\t\n\t  /**\n\t   * Get the namespace of an element\n\t   */\n\t  getTagNamespace: noop,\n\t\n\t  /**\n\t   * Check if an attribute must be bound using property, e.g. value\n\t   * Platform-dependent.\n\t   */\n\t  mustUseProp: no,\n\t\n\t  /**\n\t   * List of asset types that a component can own.\n\t   */\n\t  _assetTypes: [\n\t    'component',\n\t    'directive',\n\t    'filter'\n\t  ],\n\t\n\t  /**\n\t   * List of lifecycle hooks.\n\t   */\n\t  _lifecycleHooks: [\n\t    'beforeCreate',\n\t    'created',\n\t    'beforeMount',\n\t    'mounted',\n\t    'beforeUpdate',\n\t    'updated',\n\t    'beforeDestroy',\n\t    'destroyed',\n\t    'activated',\n\t    'deactivated'\n\t  ],\n\t\n\t  /**\n\t   * Max circular updates allowed in a scheduler flush cycle.\n\t   */\n\t  _maxUpdateCount: 100,\n\t\n\t  /**\n\t   * Server rendering?\n\t   */\n\t  _isServer: \"client\" === 'server'\n\t};\n\t\n\t/*  */\n\t\n\t/**\n\t * Check if a string starts with $ or _\n\t */\n\tfunction isReserved (str) {\n\t  var c = (str + '').charCodeAt(0);\n\t  return c === 0x24 || c === 0x5F\n\t}\n\t\n\t/**\n\t * Define a property.\n\t */\n\tfunction def (obj, key, val, enumerable) {\n\t  Object.defineProperty(obj, key, {\n\t    value: val,\n\t    enumerable: !!enumerable,\n\t    writable: true,\n\t    configurable: true\n\t  });\n\t}\n\t\n\t/**\n\t * Parse simple path.\n\t */\n\tvar bailRE = /[^\\w\\.\\$]/;\n\tfunction parsePath (path) {\n\t  if (bailRE.test(path)) {\n\t    return\n\t  } else {\n\t    var segments = path.split('.');\n\t    return function (obj) {\n\t      for (var i = 0; i < segments.length; i++) {\n\t        if (!obj) { return }\n\t        obj = obj[segments[i]];\n\t      }\n\t      return obj\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t/* globals MutationObserver */\n\t\n\t// can we use __proto__?\n\tvar hasProto = '__proto__' in {};\n\t\n\t// Browser environment sniffing\n\tvar inBrowser =\n\t  typeof window !== 'undefined' &&\n\t  Object.prototype.toString.call(window) !== '[object Object]';\n\t\n\tvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\n\tvar isIE = UA && /msie|trident/.test(UA);\n\tvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n\tvar isEdge = UA && UA.indexOf('edge/') > 0;\n\tvar isAndroid = UA && UA.indexOf('android') > 0;\n\tvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\n\t\n\t// detect devtools\n\tvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\t\n\t/* istanbul ignore next */\n\tfunction isNative (Ctor) {\n\t  return /native code/.test(Ctor.toString())\n\t}\n\t\n\t/**\n\t * Defer a task to execute it asynchronously.\n\t */\n\tvar nextTick = (function () {\n\t  var callbacks = [];\n\t  var pending = false;\n\t  var timerFunc;\n\t\n\t  function nextTickHandler () {\n\t    pending = false;\n\t    var copies = callbacks.slice(0);\n\t    callbacks.length = 0;\n\t    for (var i = 0; i < copies.length; i++) {\n\t      copies[i]();\n\t    }\n\t  }\n\t\n\t  // the nextTick behavior leverages the microtask queue, which can be accessed\n\t  // via either native Promise.then or MutationObserver.\n\t  // MutationObserver has wider support, however it is seriously bugged in\n\t  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n\t  // completely stops working after triggering a few times... so, if native\n\t  // Promise is available, we will use it:\n\t  /* istanbul ignore if */\n\t  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n\t    var p = Promise.resolve();\n\t    timerFunc = function () {\n\t      p.then(nextTickHandler);\n\t      // in problematic UIWebViews, Promise.then doesn't completely break, but\n\t      // it can get stuck in a weird state where callbacks are pushed into the\n\t      // microtask queue but the queue isn't being flushed, until the browser\n\t      // needs to do some other work, e.g. handle a timer. Therefore we can\n\t      // \"force\" the microtask queue to be flushed by adding an empty timer.\n\t      if (isIOS) { setTimeout(noop); }\n\t    };\n\t  } else if (typeof MutationObserver !== 'undefined' && (\n\t    isNative(MutationObserver) ||\n\t    // PhantomJS and iOS 7.x\n\t    MutationObserver.toString() === '[object MutationObserverConstructor]'\n\t  )) {\n\t    // use MutationObserver where native Promise is not available,\n\t    // e.g. PhantomJS IE11, iOS7, Android 4.4\n\t    var counter = 1;\n\t    var observer = new MutationObserver(nextTickHandler);\n\t    var textNode = document.createTextNode(String(counter));\n\t    observer.observe(textNode, {\n\t      characterData: true\n\t    });\n\t    timerFunc = function () {\n\t      counter = (counter + 1) % 2;\n\t      textNode.data = String(counter);\n\t    };\n\t  } else {\n\t    // fallback to setTimeout\n\t    /* istanbul ignore next */\n\t    timerFunc = function () {\n\t      setTimeout(nextTickHandler, 0);\n\t    };\n\t  }\n\t\n\t  return function queueNextTick (cb, ctx) {\n\t    var func = ctx\n\t      ? function () { cb.call(ctx); }\n\t      : cb;\n\t    callbacks.push(func);\n\t    if (!pending) {\n\t      pending = true;\n\t      timerFunc();\n\t    }\n\t  }\n\t})();\n\t\n\tvar _Set;\n\t/* istanbul ignore if */\n\tif (typeof Set !== 'undefined' && isNative(Set)) {\n\t  // use native Set when available.\n\t  _Set = Set;\n\t} else {\n\t  // a non-standard Set polyfill that only works with primitive keys.\n\t  _Set = (function () {\n\t    function Set () {\n\t      this.set = Object.create(null);\n\t    }\n\t    Set.prototype.has = function has (key) {\n\t      return this.set[key] !== undefined\n\t    };\n\t    Set.prototype.add = function add (key) {\n\t      this.set[key] = 1;\n\t    };\n\t    Set.prototype.clear = function clear () {\n\t      this.set = Object.create(null);\n\t    };\n\t\n\t    return Set;\n\t  }());\n\t}\n\t\n\t/* not type checking this file because flow doesn't play well with Proxy */\n\t\n\tvar hasProxy;\n\tvar proxyHandlers;\n\tvar initProxy;\n\t\n\t{\n\t  var allowedGlobals = makeMap(\n\t    'Infinity,undefined,NaN,isFinite,isNaN,' +\n\t    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n\t    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n\t    'require' // for Webpack/Browserify\n\t  );\n\t\n\t  hasProxy =\n\t    typeof Proxy !== 'undefined' &&\n\t    Proxy.toString().match(/native code/);\n\t\n\t  proxyHandlers = {\n\t    has: function has (target, key) {\n\t      var has = key in target;\n\t      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n\t      if (!has && !isAllowed) {\n\t        warn(\n\t          \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n\t          \"referenced during render. Make sure to declare reactive data \" +\n\t          \"properties in the data option.\",\n\t          target\n\t        );\n\t      }\n\t      return has || !isAllowed\n\t    }\n\t  };\n\t\n\t  initProxy = function initProxy (vm) {\n\t    if (hasProxy) {\n\t      vm._renderProxy = new Proxy(vm, proxyHandlers);\n\t    } else {\n\t      vm._renderProxy = vm;\n\t    }\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\t\n\tvar uid$2 = 0;\n\t\n\t/**\n\t * A dep is an observable that can have multiple\n\t * directives subscribing to it.\n\t */\n\tvar Dep = function Dep () {\n\t  this.id = uid$2++;\n\t  this.subs = [];\n\t};\n\t\n\tDep.prototype.addSub = function addSub (sub) {\n\t  this.subs.push(sub);\n\t};\n\t\n\tDep.prototype.removeSub = function removeSub (sub) {\n\t  remove$1(this.subs, sub);\n\t};\n\t\n\tDep.prototype.depend = function depend () {\n\t  if (Dep.target) {\n\t    Dep.target.addDep(this);\n\t  }\n\t};\n\t\n\tDep.prototype.notify = function notify () {\n\t  // stablize the subscriber list first\n\t  var subs = this.subs.slice();\n\t  for (var i = 0, l = subs.length; i < l; i++) {\n\t    subs[i].update();\n\t  }\n\t};\n\t\n\t// the current target watcher being evaluated.\n\t// this is globally unique because there could be only one\n\t// watcher being evaluated at any time.\n\tDep.target = null;\n\tvar targetStack = [];\n\t\n\tfunction pushTarget (_target) {\n\t  if (Dep.target) { targetStack.push(Dep.target); }\n\t  Dep.target = _target;\n\t}\n\t\n\tfunction popTarget () {\n\t  Dep.target = targetStack.pop();\n\t}\n\t\n\t/*  */\n\t\n\t\n\tvar queue = [];\n\tvar has$1 = {};\n\tvar circular = {};\n\tvar waiting = false;\n\tvar flushing = false;\n\tvar index = 0;\n\t\n\t/**\n\t * Reset the scheduler's state.\n\t */\n\tfunction resetSchedulerState () {\n\t  queue.length = 0;\n\t  has$1 = {};\n\t  {\n\t    circular = {};\n\t  }\n\t  waiting = flushing = false;\n\t}\n\t\n\t/**\n\t * Flush both queues and run the watchers.\n\t */\n\tfunction flushSchedulerQueue () {\n\t  flushing = true;\n\t\n\t  // Sort queue before flush.\n\t  // This ensures that:\n\t  // 1. Components are updated from parent to child. (because parent is always\n\t  //    created before the child)\n\t  // 2. A component's user watchers are run before its render watcher (because\n\t  //    user watchers are created before the render watcher)\n\t  // 3. If a component is destroyed during a parent component's watcher run,\n\t  //    its watchers can be skipped.\n\t  queue.sort(function (a, b) { return a.id - b.id; });\n\t\n\t  // do not cache length because more watchers might be pushed\n\t  // as we run existing watchers\n\t  for (index = 0; index < queue.length; index++) {\n\t    var watcher = queue[index];\n\t    var id = watcher.id;\n\t    has$1[id] = null;\n\t    watcher.run();\n\t    // in dev build, check and stop circular updates.\n\t    if (\"development\" !== 'production' && has$1[id] != null) {\n\t      circular[id] = (circular[id] || 0) + 1;\n\t      if (circular[id] > config._maxUpdateCount) {\n\t        warn(\n\t          'You may have an infinite update loop ' + (\n\t            watcher.user\n\t              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n\t              : \"in a component render function.\"\n\t          ),\n\t          watcher.vm\n\t        );\n\t        break\n\t      }\n\t    }\n\t  }\n\t\n\t  // devtool hook\n\t  /* istanbul ignore if */\n\t  if (devtools && config.devtools) {\n\t    devtools.emit('flush');\n\t  }\n\t\n\t  resetSchedulerState();\n\t}\n\t\n\t/**\n\t * Push a watcher into the watcher queue.\n\t * Jobs with duplicate IDs will be skipped unless it's\n\t * pushed when the queue is being flushed.\n\t */\n\tfunction queueWatcher (watcher) {\n\t  var id = watcher.id;\n\t  if (has$1[id] == null) {\n\t    has$1[id] = true;\n\t    if (!flushing) {\n\t      queue.push(watcher);\n\t    } else {\n\t      // if already flushing, splice the watcher based on its id\n\t      // if already past its id, it will be run next immediately.\n\t      var i = queue.length - 1;\n\t      while (i >= 0 && queue[i].id > watcher.id) {\n\t        i--;\n\t      }\n\t      queue.splice(Math.max(i, index) + 1, 0, watcher);\n\t    }\n\t    // queue the flush\n\t    if (!waiting) {\n\t      waiting = true;\n\t      nextTick(flushSchedulerQueue);\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar uid$1 = 0;\n\t\n\t/**\n\t * A watcher parses an expression, collects dependencies,\n\t * and fires callback when the expression value changes.\n\t * This is used for both the $watch() api and directives.\n\t */\n\tvar Watcher = function Watcher (\n\t  vm,\n\t  expOrFn,\n\t  cb,\n\t  options\n\t) {\n\t  if ( options === void 0 ) options = {};\n\t\n\t  this.vm = vm;\n\t  vm._watchers.push(this);\n\t  // options\n\t  this.deep = !!options.deep;\n\t  this.user = !!options.user;\n\t  this.lazy = !!options.lazy;\n\t  this.sync = !!options.sync;\n\t  this.expression = expOrFn.toString();\n\t  this.cb = cb;\n\t  this.id = ++uid$1; // uid for batching\n\t  this.active = true;\n\t  this.dirty = this.lazy; // for lazy watchers\n\t  this.deps = [];\n\t  this.newDeps = [];\n\t  this.depIds = new _Set();\n\t  this.newDepIds = new _Set();\n\t  // parse expression for getter\n\t  if (typeof expOrFn === 'function') {\n\t    this.getter = expOrFn;\n\t  } else {\n\t    this.getter = parsePath(expOrFn);\n\t    if (!this.getter) {\n\t      this.getter = function () {};\n\t      \"development\" !== 'production' && warn(\n\t        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n\t        'Watcher only accepts simple dot-delimited paths. ' +\n\t        'For full control, use a function instead.',\n\t        vm\n\t      );\n\t    }\n\t  }\n\t  this.value = this.lazy\n\t    ? undefined\n\t    : this.get();\n\t};\n\t\n\t/**\n\t * Evaluate the getter, and re-collect dependencies.\n\t */\n\tWatcher.prototype.get = function get () {\n\t  pushTarget(this);\n\t  var value = this.getter.call(this.vm, this.vm);\n\t  // \"touch\" every property so they are all tracked as\n\t  // dependencies for deep watching\n\t  if (this.deep) {\n\t    traverse(value);\n\t  }\n\t  popTarget();\n\t  this.cleanupDeps();\n\t  return value\n\t};\n\t\n\t/**\n\t * Add a dependency to this directive.\n\t */\n\tWatcher.prototype.addDep = function addDep (dep) {\n\t  var id = dep.id;\n\t  if (!this.newDepIds.has(id)) {\n\t    this.newDepIds.add(id);\n\t    this.newDeps.push(dep);\n\t    if (!this.depIds.has(id)) {\n\t      dep.addSub(this);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Clean up for dependency collection.\n\t */\n\tWatcher.prototype.cleanupDeps = function cleanupDeps () {\n\t    var this$1 = this;\n\t\n\t  var i = this.deps.length;\n\t  while (i--) {\n\t    var dep = this$1.deps[i];\n\t    if (!this$1.newDepIds.has(dep.id)) {\n\t      dep.removeSub(this$1);\n\t    }\n\t  }\n\t  var tmp = this.depIds;\n\t  this.depIds = this.newDepIds;\n\t  this.newDepIds = tmp;\n\t  this.newDepIds.clear();\n\t  tmp = this.deps;\n\t  this.deps = this.newDeps;\n\t  this.newDeps = tmp;\n\t  this.newDeps.length = 0;\n\t};\n\t\n\t/**\n\t * Subscriber interface.\n\t * Will be called when a dependency changes.\n\t */\n\tWatcher.prototype.update = function update () {\n\t  /* istanbul ignore else */\n\t  if (this.lazy) {\n\t    this.dirty = true;\n\t  } else if (this.sync) {\n\t    this.run();\n\t  } else {\n\t    queueWatcher(this);\n\t  }\n\t};\n\t\n\t/**\n\t * Scheduler job interface.\n\t * Will be called by the scheduler.\n\t */\n\tWatcher.prototype.run = function run () {\n\t  if (this.active) {\n\t    var value = this.get();\n\t      if (\n\t        value !== this.value ||\n\t      // Deep watchers and watchers on Object/Arrays should fire even\n\t      // when the value is the same, because the value may\n\t      // have mutated.\n\t      isObject(value) ||\n\t      this.deep\n\t    ) {\n\t      // set new value\n\t      var oldValue = this.value;\n\t      this.value = value;\n\t      if (this.user) {\n\t        try {\n\t          this.cb.call(this.vm, value, oldValue);\n\t        } catch (e) {\n\t          \"development\" !== 'production' && warn(\n\t            (\"Error in watcher \\\"\" + (this.expression) + \"\\\"\"),\n\t            this.vm\n\t          );\n\t          /* istanbul ignore else */\n\t          if (config.errorHandler) {\n\t            config.errorHandler.call(null, e, this.vm);\n\t          } else {\n\t            throw e\n\t          }\n\t        }\n\t      } else {\n\t        this.cb.call(this.vm, value, oldValue);\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Evaluate the value of the watcher.\n\t * This only gets called for lazy watchers.\n\t */\n\tWatcher.prototype.evaluate = function evaluate () {\n\t  this.value = this.get();\n\t  this.dirty = false;\n\t};\n\t\n\t/**\n\t * Depend on all deps collected by this watcher.\n\t */\n\tWatcher.prototype.depend = function depend () {\n\t    var this$1 = this;\n\t\n\t  var i = this.deps.length;\n\t  while (i--) {\n\t    this$1.deps[i].depend();\n\t  }\n\t};\n\t\n\t/**\n\t * Remove self from all dependencies' subcriber list.\n\t */\n\tWatcher.prototype.teardown = function teardown () {\n\t    var this$1 = this;\n\t\n\t  if (this.active) {\n\t    // remove self from vm's watcher list\n\t    // this is a somewhat expensive operation so we skip it\n\t    // if the vm is being destroyed or is performing a v-for\n\t    // re-render (the watcher list is then filtered by v-for).\n\t    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {\n\t      remove$1(this.vm._watchers, this);\n\t    }\n\t    var i = this.deps.length;\n\t    while (i--) {\n\t      this$1.deps[i].removeSub(this$1);\n\t    }\n\t    this.active = false;\n\t  }\n\t};\n\t\n\t/**\n\t * Recursively traverse an object to evoke all converted\n\t * getters, so that every nested property inside the object\n\t * is collected as a \"deep\" dependency.\n\t */\n\tvar seenObjects = new _Set();\n\tfunction traverse (val, seen) {\n\t  var i, keys;\n\t  if (!seen) {\n\t    seen = seenObjects;\n\t    seen.clear();\n\t  }\n\t  var isA = Array.isArray(val);\n\t  var isO = isObject(val);\n\t  if ((isA || isO) && Object.isExtensible(val)) {\n\t    if (val.__ob__) {\n\t      var depId = val.__ob__.dep.id;\n\t      if (seen.has(depId)) {\n\t        return\n\t      } else {\n\t        seen.add(depId);\n\t      }\n\t    }\n\t    if (isA) {\n\t      i = val.length;\n\t      while (i--) { traverse(val[i], seen); }\n\t    } else if (isO) {\n\t      keys = Object.keys(val);\n\t      i = keys.length;\n\t      while (i--) { traverse(val[keys[i]], seen); }\n\t    }\n\t  }\n\t}\n\t\n\t/*\n\t * not type checking this file because flow doesn't play well with\n\t * dynamically accessing methods on Array prototype\n\t */\n\t\n\tvar arrayProto = Array.prototype;\n\tvar arrayMethods = Object.create(arrayProto);[\n\t  'push',\n\t  'pop',\n\t  'shift',\n\t  'unshift',\n\t  'splice',\n\t  'sort',\n\t  'reverse'\n\t]\n\t.forEach(function (method) {\n\t  // cache original method\n\t  var original = arrayProto[method];\n\t  def(arrayMethods, method, function mutator () {\n\t    var arguments$1 = arguments;\n\t\n\t    // avoid leaking arguments:\n\t    // http://jsperf.com/closure-with-arguments\n\t    var i = arguments.length;\n\t    var args = new Array(i);\n\t    while (i--) {\n\t      args[i] = arguments$1[i];\n\t    }\n\t    var result = original.apply(this, args);\n\t    var ob = this.__ob__;\n\t    var inserted;\n\t    switch (method) {\n\t      case 'push':\n\t        inserted = args;\n\t        break\n\t      case 'unshift':\n\t        inserted = args;\n\t        break\n\t      case 'splice':\n\t        inserted = args.slice(2);\n\t        break\n\t    }\n\t    if (inserted) { ob.observeArray(inserted); }\n\t    // notify change\n\t    ob.dep.notify();\n\t    return result\n\t  });\n\t});\n\t\n\t/*  */\n\t\n\tvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\t\n\t/**\n\t * By default, when a reactive property is set, the new value is\n\t * also converted to become reactive. However when passing down props,\n\t * we don't want to force conversion because the value may be a nested value\n\t * under a frozen data structure. Converting it would defeat the optimization.\n\t */\n\tvar observerState = {\n\t  shouldConvert: true,\n\t  isSettingProps: false\n\t};\n\t\n\t/**\n\t * Observer class that are attached to each observed\n\t * object. Once attached, the observer converts target\n\t * object's property keys into getter/setters that\n\t * collect dependencies and dispatches updates.\n\t */\n\tvar Observer = function Observer (value) {\n\t  this.value = value;\n\t  this.dep = new Dep();\n\t  this.vmCount = 0;\n\t  def(value, '__ob__', this);\n\t  if (Array.isArray(value)) {\n\t    var augment = hasProto\n\t      ? protoAugment\n\t      : copyAugment;\n\t    augment(value, arrayMethods, arrayKeys);\n\t    this.observeArray(value);\n\t  } else {\n\t    this.walk(value);\n\t  }\n\t};\n\t\n\t/**\n\t * Walk through each property and convert them into\n\t * getter/setters. This method should only be called when\n\t * value type is Object.\n\t */\n\tObserver.prototype.walk = function walk (obj) {\n\t  var keys = Object.keys(obj);\n\t  for (var i = 0; i < keys.length; i++) {\n\t    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n\t  }\n\t};\n\t\n\t/**\n\t * Observe a list of Array items.\n\t */\n\tObserver.prototype.observeArray = function observeArray (items) {\n\t  for (var i = 0, l = items.length; i < l; i++) {\n\t    observe(items[i]);\n\t  }\n\t};\n\t\n\t// helpers\n\t\n\t/**\n\t * Augment an target Object or Array by intercepting\n\t * the prototype chain using __proto__\n\t */\n\tfunction protoAugment (target, src) {\n\t  /* eslint-disable no-proto */\n\t  target.__proto__ = src;\n\t  /* eslint-enable no-proto */\n\t}\n\t\n\t/**\n\t * Augment an target Object or Array by defining\n\t * hidden properties.\n\t *\n\t * istanbul ignore next\n\t */\n\tfunction copyAugment (target, src, keys) {\n\t  for (var i = 0, l = keys.length; i < l; i++) {\n\t    var key = keys[i];\n\t    def(target, key, src[key]);\n\t  }\n\t}\n\t\n\t/**\n\t * Attempt to create an observer instance for a value,\n\t * returns the new observer if successfully observed,\n\t * or the existing observer if the value already has one.\n\t */\n\tfunction observe (value) {\n\t  if (!isObject(value)) {\n\t    return\n\t  }\n\t  var ob;\n\t  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n\t    ob = value.__ob__;\n\t  } else if (\n\t    observerState.shouldConvert &&\n\t    !config._isServer &&\n\t    (Array.isArray(value) || isPlainObject(value)) &&\n\t    Object.isExtensible(value) &&\n\t    !value._isVue\n\t  ) {\n\t    ob = new Observer(value);\n\t  }\n\t  return ob\n\t}\n\t\n\t/**\n\t * Define a reactive property on an Object.\n\t */\n\tfunction defineReactive$$1 (\n\t  obj,\n\t  key,\n\t  val,\n\t  customSetter\n\t) {\n\t  var dep = new Dep();\n\t\n\t  var property = Object.getOwnPropertyDescriptor(obj, key);\n\t  if (property && property.configurable === false) {\n\t    return\n\t  }\n\t\n\t  // cater for pre-defined getter/setters\n\t  var getter = property && property.get;\n\t  var setter = property && property.set;\n\t\n\t  var childOb = observe(val);\n\t  Object.defineProperty(obj, key, {\n\t    enumerable: true,\n\t    configurable: true,\n\t    get: function reactiveGetter () {\n\t      var value = getter ? getter.call(obj) : val;\n\t      if (Dep.target) {\n\t        dep.depend();\n\t        if (childOb) {\n\t          childOb.dep.depend();\n\t        }\n\t        if (Array.isArray(value)) {\n\t          dependArray(value);\n\t        }\n\t      }\n\t      return value\n\t    },\n\t    set: function reactiveSetter (newVal) {\n\t      var value = getter ? getter.call(obj) : val;\n\t      if (newVal === value) {\n\t        return\n\t      }\n\t      if (\"development\" !== 'production' && customSetter) {\n\t        customSetter();\n\t      }\n\t      if (setter) {\n\t        setter.call(obj, newVal);\n\t      } else {\n\t        val = newVal;\n\t      }\n\t      childOb = observe(newVal);\n\t      dep.notify();\n\t    }\n\t  });\n\t}\n\t\n\t/**\n\t * Set a property on an object. Adds the new property and\n\t * triggers change notification if the property doesn't\n\t * already exist.\n\t */\n\tfunction set (obj, key, val) {\n\t  if (Array.isArray(obj)) {\n\t    obj.splice(key, 1, val);\n\t    return val\n\t  }\n\t  if (hasOwn(obj, key)) {\n\t    obj[key] = val;\n\t    return\n\t  }\n\t  var ob = obj.__ob__;\n\t  if (obj._isVue || (ob && ob.vmCount)) {\n\t    \"development\" !== 'production' && warn(\n\t      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n\t      'at runtime - declare it upfront in the data option.'\n\t    );\n\t    return\n\t  }\n\t  if (!ob) {\n\t    obj[key] = val;\n\t    return\n\t  }\n\t  defineReactive$$1(ob.value, key, val);\n\t  ob.dep.notify();\n\t  return val\n\t}\n\t\n\t/**\n\t * Delete a property and trigger change if necessary.\n\t */\n\tfunction del (obj, key) {\n\t  var ob = obj.__ob__;\n\t  if (obj._isVue || (ob && ob.vmCount)) {\n\t    \"development\" !== 'production' && warn(\n\t      'Avoid deleting properties on a Vue instance or its root $data ' +\n\t      '- just set it to null.'\n\t    );\n\t    return\n\t  }\n\t  if (!hasOwn(obj, key)) {\n\t    return\n\t  }\n\t  delete obj[key];\n\t  if (!ob) {\n\t    return\n\t  }\n\t  ob.dep.notify();\n\t}\n\t\n\t/**\n\t * Collect dependencies on array elements when the array is touched, since\n\t * we cannot intercept array element access like property getters.\n\t */\n\tfunction dependArray (value) {\n\t  for (var e = void 0, i = 0, l = value.length; i < l; i++) {\n\t    e = value[i];\n\t    e && e.__ob__ && e.__ob__.dep.depend();\n\t    if (Array.isArray(e)) {\n\t      dependArray(e);\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction initState (vm) {\n\t  vm._watchers = [];\n\t  initProps(vm);\n\t  initData(vm);\n\t  initComputed(vm);\n\t  initMethods(vm);\n\t  initWatch(vm);\n\t}\n\t\n\tfunction initProps (vm) {\n\t  var props = vm.$options.props;\n\t  if (props) {\n\t    var propsData = vm.$options.propsData || {};\n\t    var keys = vm.$options._propKeys = Object.keys(props);\n\t    var isRoot = !vm.$parent;\n\t    // root instance props should be converted\n\t    observerState.shouldConvert = isRoot;\n\t    var loop = function ( i ) {\n\t      var key = keys[i];\n\t      /* istanbul ignore else */\n\t      {\n\t        defineReactive$$1(vm, key, validateProp(key, props, propsData, vm), function () {\n\t          if (vm.$parent && !observerState.isSettingProps) {\n\t            warn(\n\t              \"Avoid mutating a prop directly since the value will be \" +\n\t              \"overwritten whenever the parent component re-renders. \" +\n\t              \"Instead, use a data or computed property based on the prop's \" +\n\t              \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n\t              vm\n\t            );\n\t          }\n\t        });\n\t      }\n\t    };\n\t\n\t    for (var i = 0; i < keys.length; i++) loop( i );\n\t    observerState.shouldConvert = true;\n\t  }\n\t}\n\t\n\tfunction initData (vm) {\n\t  var data = vm.$options.data;\n\t  data = vm._data = typeof data === 'function'\n\t    ? data.call(vm)\n\t    : data || {};\n\t  if (!isPlainObject(data)) {\n\t    data = {};\n\t    \"development\" !== 'production' && warn(\n\t      'data functions should return an object.',\n\t      vm\n\t    );\n\t  }\n\t  // proxy data on instance\n\t  var keys = Object.keys(data);\n\t  var props = vm.$options.props;\n\t  var i = keys.length;\n\t  while (i--) {\n\t    if (props && hasOwn(props, keys[i])) {\n\t      \"development\" !== 'production' && warn(\n\t        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n\t        \"Use prop default value instead.\",\n\t        vm\n\t      );\n\t    } else {\n\t      proxy(vm, keys[i]);\n\t    }\n\t  }\n\t  // observe data\n\t  observe(data);\n\t  data.__ob__ && data.__ob__.vmCount++;\n\t}\n\t\n\tvar computedSharedDefinition = {\n\t  enumerable: true,\n\t  configurable: true,\n\t  get: noop,\n\t  set: noop\n\t};\n\t\n\tfunction initComputed (vm) {\n\t  var computed = vm.$options.computed;\n\t  if (computed) {\n\t    for (var key in computed) {\n\t      var userDef = computed[key];\n\t      if (typeof userDef === 'function') {\n\t        computedSharedDefinition.get = makeComputedGetter(userDef, vm);\n\t        computedSharedDefinition.set = noop;\n\t      } else {\n\t        computedSharedDefinition.get = userDef.get\n\t          ? userDef.cache !== false\n\t            ? makeComputedGetter(userDef.get, vm)\n\t            : bind$1(userDef.get, vm)\n\t          : noop;\n\t        computedSharedDefinition.set = userDef.set\n\t          ? bind$1(userDef.set, vm)\n\t          : noop;\n\t      }\n\t      Object.defineProperty(vm, key, computedSharedDefinition);\n\t    }\n\t  }\n\t}\n\t\n\tfunction makeComputedGetter (getter, owner) {\n\t  var watcher = new Watcher(owner, getter, noop, {\n\t    lazy: true\n\t  });\n\t  return function computedGetter () {\n\t    if (watcher.dirty) {\n\t      watcher.evaluate();\n\t    }\n\t    if (Dep.target) {\n\t      watcher.depend();\n\t    }\n\t    return watcher.value\n\t  }\n\t}\n\t\n\tfunction initMethods (vm) {\n\t  var methods = vm.$options.methods;\n\t  if (methods) {\n\t    for (var key in methods) {\n\t      vm[key] = methods[key] == null ? noop : bind$1(methods[key], vm);\n\t      if (\"development\" !== 'production' && methods[key] == null) {\n\t        warn(\n\t          \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n\t          \"Did you reference the function correctly?\",\n\t          vm\n\t        );\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction initWatch (vm) {\n\t  var watch = vm.$options.watch;\n\t  if (watch) {\n\t    for (var key in watch) {\n\t      var handler = watch[key];\n\t      if (Array.isArray(handler)) {\n\t        for (var i = 0; i < handler.length; i++) {\n\t          createWatcher(vm, key, handler[i]);\n\t        }\n\t      } else {\n\t        createWatcher(vm, key, handler);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction createWatcher (vm, key, handler) {\n\t  var options;\n\t  if (isPlainObject(handler)) {\n\t    options = handler;\n\t    handler = handler.handler;\n\t  }\n\t  if (typeof handler === 'string') {\n\t    handler = vm[handler];\n\t  }\n\t  vm.$watch(key, handler, options);\n\t}\n\t\n\tfunction stateMixin (Vue) {\n\t  // flow somehow has problems with directly declared definition object\n\t  // when using Object.defineProperty, so we have to procedurally build up\n\t  // the object here.\n\t  var dataDef = {};\n\t  dataDef.get = function () {\n\t    return this._data\n\t  };\n\t  {\n\t    dataDef.set = function (newData) {\n\t      warn(\n\t        'Avoid replacing instance root $data. ' +\n\t        'Use nested data properties instead.',\n\t        this\n\t      );\n\t    };\n\t  }\n\t  Object.defineProperty(Vue.prototype, '$data', dataDef);\n\t\n\t  Vue.prototype.$set = set;\n\t  Vue.prototype.$delete = del;\n\t\n\t  Vue.prototype.$watch = function (\n\t    expOrFn,\n\t    cb,\n\t    options\n\t  ) {\n\t    var vm = this;\n\t    options = options || {};\n\t    options.user = true;\n\t    var watcher = new Watcher(vm, expOrFn, cb, options);\n\t    if (options.immediate) {\n\t      cb.call(vm, watcher.value);\n\t    }\n\t    return function unwatchFn () {\n\t      watcher.teardown();\n\t    }\n\t  };\n\t}\n\t\n\tfunction proxy (vm, key) {\n\t  if (!isReserved(key)) {\n\t    Object.defineProperty(vm, key, {\n\t      configurable: true,\n\t      enumerable: true,\n\t      get: function proxyGetter () {\n\t        return vm._data[key]\n\t      },\n\t      set: function proxySetter (val) {\n\t        vm._data[key] = val;\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar VNode = function VNode (\n\t  tag,\n\t  data,\n\t  children,\n\t  text,\n\t  elm,\n\t  ns,\n\t  context,\n\t  componentOptions\n\t) {\n\t  this.tag = tag;\n\t  this.data = data;\n\t  this.children = children;\n\t  this.text = text;\n\t  this.elm = elm;\n\t  this.ns = ns;\n\t  this.context = context;\n\t  this.functionalContext = undefined;\n\t  this.key = data && data.key;\n\t  this.componentOptions = componentOptions;\n\t  this.child = undefined;\n\t  this.parent = undefined;\n\t  this.raw = false;\n\t  this.isStatic = false;\n\t  this.isRootInsert = true;\n\t  this.isComment = false;\n\t  this.isCloned = false;\n\t};\n\t\n\tvar emptyVNode = function () {\n\t  var node = new VNode();\n\t  node.text = '';\n\t  node.isComment = true;\n\t  return node\n\t};\n\t\n\t// optimized shallow clone\n\t// used for static nodes and slot nodes because they may be reused across\n\t// multiple renders, cloning them avoids errors when DOM manipulations rely\n\t// on their elm reference.\n\tfunction cloneVNode (vnode) {\n\t  var cloned = new VNode(\n\t    vnode.tag,\n\t    vnode.data,\n\t    vnode.children,\n\t    vnode.text,\n\t    vnode.elm,\n\t    vnode.ns,\n\t    vnode.context,\n\t    vnode.componentOptions\n\t  );\n\t  cloned.isStatic = vnode.isStatic;\n\t  cloned.key = vnode.key;\n\t  cloned.isCloned = true;\n\t  return cloned\n\t}\n\t\n\tfunction cloneVNodes (vnodes) {\n\t  var res = new Array(vnodes.length);\n\t  for (var i = 0; i < vnodes.length; i++) {\n\t    res[i] = cloneVNode(vnodes[i]);\n\t  }\n\t  return res\n\t}\n\t\n\t/*  */\n\t\n\tfunction mergeVNodeHook (def, hookKey, hook, key) {\n\t  key = key + hookKey;\n\t  var injectedHash = def.__injected || (def.__injected = {});\n\t  if (!injectedHash[key]) {\n\t    injectedHash[key] = true;\n\t    var oldHook = def[hookKey];\n\t    if (oldHook) {\n\t      def[hookKey] = function () {\n\t        oldHook.apply(this, arguments);\n\t        hook.apply(this, arguments);\n\t      };\n\t    } else {\n\t      def[hookKey] = hook;\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction updateListeners (\n\t  on,\n\t  oldOn,\n\t  add,\n\t  remove$$1,\n\t  vm\n\t) {\n\t  var name, cur, old, fn, event, capture;\n\t  for (name in on) {\n\t    cur = on[name];\n\t    old = oldOn[name];\n\t    if (!cur) {\n\t      \"development\" !== 'production' && warn(\n\t        \"Invalid handler for event \\\"\" + name + \"\\\": got \" + String(cur),\n\t        vm\n\t      );\n\t    } else if (!old) {\n\t      capture = name.charAt(0) === '!';\n\t      event = capture ? name.slice(1) : name;\n\t      if (Array.isArray(cur)) {\n\t        add(event, (cur.invoker = arrInvoker(cur)), capture);\n\t      } else {\n\t        if (!cur.invoker) {\n\t          fn = cur;\n\t          cur = on[name] = {};\n\t          cur.fn = fn;\n\t          cur.invoker = fnInvoker(cur);\n\t        }\n\t        add(event, cur.invoker, capture);\n\t      }\n\t    } else if (cur !== old) {\n\t      if (Array.isArray(old)) {\n\t        old.length = cur.length;\n\t        for (var i = 0; i < old.length; i++) { old[i] = cur[i]; }\n\t        on[name] = old;\n\t      } else {\n\t        old.fn = cur;\n\t        on[name] = old;\n\t      }\n\t    }\n\t  }\n\t  for (name in oldOn) {\n\t    if (!on[name]) {\n\t      event = name.charAt(0) === '!' ? name.slice(1) : name;\n\t      remove$$1(event, oldOn[name].invoker);\n\t    }\n\t  }\n\t}\n\t\n\tfunction arrInvoker (arr) {\n\t  return function (ev) {\n\t    var arguments$1 = arguments;\n\t\n\t    var single = arguments.length === 1;\n\t    for (var i = 0; i < arr.length; i++) {\n\t      single ? arr[i](ev) : arr[i].apply(null, arguments$1);\n\t    }\n\t  }\n\t}\n\t\n\tfunction fnInvoker (o) {\n\t  return function (ev) {\n\t    var single = arguments.length === 1;\n\t    single ? o.fn(ev) : o.fn.apply(null, arguments);\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction normalizeChildren (\n\t  children,\n\t  ns,\n\t  nestedIndex\n\t) {\n\t  if (isPrimitive(children)) {\n\t    return [createTextVNode(children)]\n\t  }\n\t  if (Array.isArray(children)) {\n\t    var res = [];\n\t    for (var i = 0, l = children.length; i < l; i++) {\n\t      var c = children[i];\n\t      var last = res[res.length - 1];\n\t      //  nested\n\t      if (Array.isArray(c)) {\n\t        res.push.apply(res, normalizeChildren(c, ns, ((nestedIndex || '') + \"_\" + i)));\n\t      } else if (isPrimitive(c)) {\n\t        if (last && last.text) {\n\t          last.text += String(c);\n\t        } else if (c !== '') {\n\t          // convert primitive to vnode\n\t          res.push(createTextVNode(c));\n\t        }\n\t      } else if (c instanceof VNode) {\n\t        if (c.text && last && last.text) {\n\t          last.text += c.text;\n\t        } else {\n\t          // inherit parent namespace\n\t          if (ns) {\n\t            applyNS(c, ns);\n\t          }\n\t          // default key for nested array children (likely generated by v-for)\n\t          if (c.tag && c.key == null && nestedIndex != null) {\n\t            c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n\t          }\n\t          res.push(c);\n\t        }\n\t      }\n\t    }\n\t    return res\n\t  }\n\t}\n\t\n\tfunction createTextVNode (val) {\n\t  return new VNode(undefined, undefined, undefined, String(val))\n\t}\n\t\n\tfunction applyNS (vnode, ns) {\n\t  if (vnode.tag && !vnode.ns) {\n\t    vnode.ns = ns;\n\t    if (vnode.children) {\n\t      for (var i = 0, l = vnode.children.length; i < l; i++) {\n\t        applyNS(vnode.children[i], ns);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction getFirstComponentChild (children) {\n\t  return children && children.filter(function (c) { return c && c.componentOptions; })[0]\n\t}\n\t\n\t/*  */\n\t\n\tvar activeInstance = null;\n\t\n\tfunction initLifecycle (vm) {\n\t  var options = vm.$options;\n\t\n\t  // locate first non-abstract parent\n\t  var parent = options.parent;\n\t  if (parent && !options.abstract) {\n\t    while (parent.$options.abstract && parent.$parent) {\n\t      parent = parent.$parent;\n\t    }\n\t    parent.$children.push(vm);\n\t  }\n\t\n\t  vm.$parent = parent;\n\t  vm.$root = parent ? parent.$root : vm;\n\t\n\t  vm.$children = [];\n\t  vm.$refs = {};\n\t\n\t  vm._watcher = null;\n\t  vm._inactive = false;\n\t  vm._isMounted = false;\n\t  vm._isDestroyed = false;\n\t  vm._isBeingDestroyed = false;\n\t}\n\t\n\tfunction lifecycleMixin (Vue) {\n\t  Vue.prototype._mount = function (\n\t    el,\n\t    hydrating\n\t  ) {\n\t    var vm = this;\n\t    vm.$el = el;\n\t    if (!vm.$options.render) {\n\t      vm.$options.render = emptyVNode;\n\t      {\n\t        /* istanbul ignore if */\n\t        if (vm.$options.template) {\n\t          warn(\n\t            'You are using the runtime-only build of Vue where the template ' +\n\t            'option is not available. Either pre-compile the templates into ' +\n\t            'render functions, or use the compiler-included build.',\n\t            vm\n\t          );\n\t        } else {\n\t          warn(\n\t            'Failed to mount component: template or render function not defined.',\n\t            vm\n\t          );\n\t        }\n\t      }\n\t    }\n\t    callHook(vm, 'beforeMount');\n\t    vm._watcher = new Watcher(vm, function () {\n\t      vm._update(vm._render(), hydrating);\n\t    }, noop);\n\t    hydrating = false;\n\t    // manually mounted instance, call mounted on self\n\t    // mounted is called for render-created child components in its inserted hook\n\t    if (vm.$vnode == null) {\n\t      vm._isMounted = true;\n\t      callHook(vm, 'mounted');\n\t    }\n\t    return vm\n\t  };\n\t\n\t  Vue.prototype._update = function (vnode, hydrating) {\n\t    var vm = this;\n\t    if (vm._isMounted) {\n\t      callHook(vm, 'beforeUpdate');\n\t    }\n\t    var prevEl = vm.$el;\n\t    var prevActiveInstance = activeInstance;\n\t    activeInstance = vm;\n\t    var prevVnode = vm._vnode;\n\t    vm._vnode = vnode;\n\t    if (!prevVnode) {\n\t      // Vue.prototype.__patch__ is injected in entry points\n\t      // based on the rendering backend used.\n\t      vm.$el = vm.__patch__(vm.$el, vnode, hydrating);\n\t    } else {\n\t      vm.$el = vm.__patch__(prevVnode, vnode);\n\t    }\n\t    activeInstance = prevActiveInstance;\n\t    // update __vue__ reference\n\t    if (prevEl) {\n\t      prevEl.__vue__ = null;\n\t    }\n\t    if (vm.$el) {\n\t      vm.$el.__vue__ = vm;\n\t    }\n\t    // if parent is an HOC, update its $el as well\n\t    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n\t      vm.$parent.$el = vm.$el;\n\t    }\n\t    if (vm._isMounted) {\n\t      callHook(vm, 'updated');\n\t    }\n\t  };\n\t\n\t  Vue.prototype._updateFromParent = function (\n\t    propsData,\n\t    listeners,\n\t    parentVnode,\n\t    renderChildren\n\t  ) {\n\t    var vm = this;\n\t    var hasChildren = !!(vm.$options._renderChildren || renderChildren);\n\t    vm.$options._parentVnode = parentVnode;\n\t    vm.$options._renderChildren = renderChildren;\n\t    // update props\n\t    if (propsData && vm.$options.props) {\n\t      observerState.shouldConvert = false;\n\t      {\n\t        observerState.isSettingProps = true;\n\t      }\n\t      var propKeys = vm.$options._propKeys || [];\n\t      for (var i = 0; i < propKeys.length; i++) {\n\t        var key = propKeys[i];\n\t        vm[key] = validateProp(key, vm.$options.props, propsData, vm);\n\t      }\n\t      observerState.shouldConvert = true;\n\t      {\n\t        observerState.isSettingProps = false;\n\t      }\n\t    }\n\t    // update listeners\n\t    if (listeners) {\n\t      var oldListeners = vm.$options._parentListeners;\n\t      vm.$options._parentListeners = listeners;\n\t      vm._updateListeners(listeners, oldListeners);\n\t    }\n\t    // resolve slots + force update if has children\n\t    if (hasChildren) {\n\t      vm.$slots = resolveSlots(renderChildren, vm._renderContext);\n\t      vm.$forceUpdate();\n\t    }\n\t  };\n\t\n\t  Vue.prototype.$forceUpdate = function () {\n\t    var vm = this;\n\t    if (vm._watcher) {\n\t      vm._watcher.update();\n\t    }\n\t  };\n\t\n\t  Vue.prototype.$destroy = function () {\n\t    var vm = this;\n\t    if (vm._isBeingDestroyed) {\n\t      return\n\t    }\n\t    callHook(vm, 'beforeDestroy');\n\t    vm._isBeingDestroyed = true;\n\t    // remove self from parent\n\t    var parent = vm.$parent;\n\t    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n\t      remove$1(parent.$children, vm);\n\t    }\n\t    // teardown watchers\n\t    if (vm._watcher) {\n\t      vm._watcher.teardown();\n\t    }\n\t    var i = vm._watchers.length;\n\t    while (i--) {\n\t      vm._watchers[i].teardown();\n\t    }\n\t    // remove reference from data ob\n\t    // frozen object may not have observer.\n\t    if (vm._data.__ob__) {\n\t      vm._data.__ob__.vmCount--;\n\t    }\n\t    // call the last hook...\n\t    vm._isDestroyed = true;\n\t    callHook(vm, 'destroyed');\n\t    // turn off all instance listeners.\n\t    vm.$off();\n\t    // remove __vue__ reference\n\t    if (vm.$el) {\n\t      vm.$el.__vue__ = null;\n\t    }\n\t    // invoke destroy hooks on current rendered tree\n\t    vm.__patch__(vm._vnode, null);\n\t  };\n\t}\n\t\n\tfunction callHook (vm, hook) {\n\t  var handlers = vm.$options[hook];\n\t  if (handlers) {\n\t    for (var i = 0, j = handlers.length; i < j; i++) {\n\t      handlers[i].call(vm);\n\t    }\n\t  }\n\t  vm.$emit('hook:' + hook);\n\t}\n\t\n\t/*  */\n\t\n\tvar hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy$1 };\n\tvar hooksToMerge = Object.keys(hooks);\n\t\n\tfunction createComponent (\n\t  Ctor,\n\t  data,\n\t  context,\n\t  children,\n\t  tag\n\t) {\n\t  if (!Ctor) {\n\t    return\n\t  }\n\t\n\t  if (isObject(Ctor)) {\n\t    Ctor = Vue$3.extend(Ctor);\n\t  }\n\t\n\t  if (typeof Ctor !== 'function') {\n\t    {\n\t      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n\t    }\n\t    return\n\t  }\n\t\n\t  // async component\n\t  if (!Ctor.cid) {\n\t    if (Ctor.resolved) {\n\t      Ctor = Ctor.resolved;\n\t    } else {\n\t      Ctor = resolveAsyncComponent(Ctor, function () {\n\t        // it's ok to queue this on every render because\n\t        // $forceUpdate is buffered by the scheduler.\n\t        context.$forceUpdate();\n\t      });\n\t      if (!Ctor) {\n\t        // return nothing if this is indeed an async component\n\t        // wait for the callback to trigger parent update.\n\t        return\n\t      }\n\t    }\n\t  }\n\t\n\t  data = data || {};\n\t\n\t  // extract props\n\t  var propsData = extractProps(data, Ctor);\n\t\n\t  // functional component\n\t  if (Ctor.options.functional) {\n\t    return createFunctionalComponent(Ctor, propsData, data, context, children)\n\t  }\n\t\n\t  // extract listeners, since these needs to be treated as\n\t  // child component listeners instead of DOM listeners\n\t  var listeners = data.on;\n\t  // replace with listeners with .native modifier\n\t  data.on = data.nativeOn;\n\t\n\t  if (Ctor.options.abstract) {\n\t    // abstract components do not keep anything\n\t    // other than props & listeners\n\t    data = {};\n\t  }\n\t\n\t  // merge component management hooks onto the placeholder node\n\t  mergeHooks(data);\n\t\n\t  // return a placeholder vnode\n\t  var name = Ctor.options.name || tag;\n\t  var vnode = new VNode(\n\t    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n\t    data, undefined, undefined, undefined, undefined, context,\n\t    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n\t  );\n\t  return vnode\n\t}\n\t\n\tfunction createFunctionalComponent (\n\t  Ctor,\n\t  propsData,\n\t  data,\n\t  context,\n\t  children\n\t) {\n\t  var props = {};\n\t  var propOptions = Ctor.options.props;\n\t  if (propOptions) {\n\t    for (var key in propOptions) {\n\t      props[key] = validateProp(key, propOptions, propsData);\n\t    }\n\t  }\n\t  var vnode = Ctor.options.render.call(\n\t    null,\n\t    // ensure the createElement function in functional components\n\t    // gets a unique context - this is necessary for correct named slot check\n\t    bind$1(createElement, { _self: Object.create(context) }),\n\t    {\n\t      props: props,\n\t      data: data,\n\t      parent: context,\n\t      children: normalizeChildren(children),\n\t      slots: function () { return resolveSlots(children, context); }\n\t    }\n\t  );\n\t  if (vnode instanceof VNode) {\n\t    vnode.functionalContext = context;\n\t    if (data.slot) {\n\t      (vnode.data || (vnode.data = {})).slot = data.slot;\n\t    }\n\t  }\n\t  return vnode\n\t}\n\t\n\tfunction createComponentInstanceForVnode (\n\t  vnode, // we know it's MountedComponentVNode but flow doesn't\n\t  parent // activeInstance in lifecycle state\n\t) {\n\t  var vnodeComponentOptions = vnode.componentOptions;\n\t  var options = {\n\t    _isComponent: true,\n\t    parent: parent,\n\t    propsData: vnodeComponentOptions.propsData,\n\t    _componentTag: vnodeComponentOptions.tag,\n\t    _parentVnode: vnode,\n\t    _parentListeners: vnodeComponentOptions.listeners,\n\t    _renderChildren: vnodeComponentOptions.children\n\t  };\n\t  // check inline-template render functions\n\t  var inlineTemplate = vnode.data.inlineTemplate;\n\t  if (inlineTemplate) {\n\t    options.render = inlineTemplate.render;\n\t    options.staticRenderFns = inlineTemplate.staticRenderFns;\n\t  }\n\t  return new vnodeComponentOptions.Ctor(options)\n\t}\n\t\n\tfunction init (vnode, hydrating) {\n\t  if (!vnode.child || vnode.child._isDestroyed) {\n\t    var child = vnode.child = createComponentInstanceForVnode(vnode, activeInstance);\n\t    child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n\t  }\n\t}\n\t\n\tfunction prepatch (\n\t  oldVnode,\n\t  vnode\n\t) {\n\t  var options = vnode.componentOptions;\n\t  var child = vnode.child = oldVnode.child;\n\t  child._updateFromParent(\n\t    options.propsData, // updated props\n\t    options.listeners, // updated listeners\n\t    vnode, // new parent vnode\n\t    options.children // new children\n\t  );\n\t}\n\t\n\tfunction insert (vnode) {\n\t  if (!vnode.child._isMounted) {\n\t    vnode.child._isMounted = true;\n\t    callHook(vnode.child, 'mounted');\n\t  }\n\t  if (vnode.data.keepAlive) {\n\t    vnode.child._inactive = false;\n\t    callHook(vnode.child, 'activated');\n\t  }\n\t}\n\t\n\tfunction destroy$1 (vnode) {\n\t  if (!vnode.child._isDestroyed) {\n\t    if (!vnode.data.keepAlive) {\n\t      vnode.child.$destroy();\n\t    } else {\n\t      vnode.child._inactive = true;\n\t      callHook(vnode.child, 'deactivated');\n\t    }\n\t  }\n\t}\n\t\n\tfunction resolveAsyncComponent (\n\t  factory,\n\t  cb\n\t) {\n\t  if (factory.requested) {\n\t    // pool callbacks\n\t    factory.pendingCallbacks.push(cb);\n\t  } else {\n\t    factory.requested = true;\n\t    var cbs = factory.pendingCallbacks = [cb];\n\t    var sync = true;\n\t\n\t    var resolve = function (res) {\n\t      if (isObject(res)) {\n\t        res = Vue$3.extend(res);\n\t      }\n\t      // cache resolved\n\t      factory.resolved = res;\n\t      // invoke callbacks only if this is not a synchronous resolve\n\t      // (async resolves are shimmed as synchronous during SSR)\n\t      if (!sync) {\n\t        for (var i = 0, l = cbs.length; i < l; i++) {\n\t          cbs[i](res);\n\t        }\n\t      }\n\t    };\n\t\n\t    var reject = function (reason) {\n\t      \"development\" !== 'production' && warn(\n\t        \"Failed to resolve async component: \" + (String(factory)) +\n\t        (reason ? (\"\\nReason: \" + reason) : '')\n\t      );\n\t    };\n\t\n\t    var res = factory(resolve, reject);\n\t\n\t    // handle promise\n\t    if (res && typeof res.then === 'function' && !factory.resolved) {\n\t      res.then(resolve, reject);\n\t    }\n\t\n\t    sync = false;\n\t    // return in case resolved synchronously\n\t    return factory.resolved\n\t  }\n\t}\n\t\n\tfunction extractProps (data, Ctor) {\n\t  // we are only extrating raw values here.\n\t  // validation and default values are handled in the child\n\t  // component itself.\n\t  var propOptions = Ctor.options.props;\n\t  if (!propOptions) {\n\t    return\n\t  }\n\t  var res = {};\n\t  var attrs = data.attrs;\n\t  var props = data.props;\n\t  var domProps = data.domProps;\n\t  if (attrs || props || domProps) {\n\t    for (var key in propOptions) {\n\t      var altKey = hyphenate(key);\n\t      checkProp(res, props, key, altKey, true) ||\n\t      checkProp(res, attrs, key, altKey) ||\n\t      checkProp(res, domProps, key, altKey);\n\t    }\n\t  }\n\t  return res\n\t}\n\t\n\tfunction checkProp (\n\t  res,\n\t  hash,\n\t  key,\n\t  altKey,\n\t  preserve\n\t) {\n\t  if (hash) {\n\t    if (hasOwn(hash, key)) {\n\t      res[key] = hash[key];\n\t      if (!preserve) {\n\t        delete hash[key];\n\t      }\n\t      return true\n\t    } else if (hasOwn(hash, altKey)) {\n\t      res[key] = hash[altKey];\n\t      if (!preserve) {\n\t        delete hash[altKey];\n\t      }\n\t      return true\n\t    }\n\t  }\n\t  return false\n\t}\n\t\n\tfunction mergeHooks (data) {\n\t  if (!data.hook) {\n\t    data.hook = {};\n\t  }\n\t  for (var i = 0; i < hooksToMerge.length; i++) {\n\t    var key = hooksToMerge[i];\n\t    var fromParent = data.hook[key];\n\t    var ours = hooks[key];\n\t    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n\t  }\n\t}\n\t\n\tfunction mergeHook$1 (a, b) {\n\t  // since all hooks have at most two args, use fixed args\n\t  // to avoid having to use fn.apply().\n\t  return function (_, __) {\n\t    a(_, __);\n\t    b(_, __);\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\t// wrapper function for providing a more flexible interface\n\t// without getting yelled at by flow\n\tfunction createElement (\n\t  tag,\n\t  data,\n\t  children\n\t) {\n\t  if (data && (Array.isArray(data) || typeof data !== 'object')) {\n\t    children = data;\n\t    data = undefined;\n\t  }\n\t  // make sure to use real instance instead of proxy as context\n\t  return _createElement(this._self, tag, data, children)\n\t}\n\t\n\tfunction _createElement (\n\t  context,\n\t  tag,\n\t  data,\n\t  children\n\t) {\n\t  if (data && data.__ob__) {\n\t    \"development\" !== 'production' && warn(\n\t      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n\t      'Always create fresh vnode data objects in each render!',\n\t      context\n\t    );\n\t    return\n\t  }\n\t  if (!tag) {\n\t    // in case of component :is set to falsy value\n\t    return emptyVNode()\n\t  }\n\t  if (typeof tag === 'string') {\n\t    var Ctor;\n\t    var ns = config.getTagNamespace(tag);\n\t    if (config.isReservedTag(tag)) {\n\t      // platform built-in elements\n\t      return new VNode(\n\t        tag, data, normalizeChildren(children, ns),\n\t        undefined, undefined, ns, context\n\t      )\n\t    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {\n\t      // component\n\t      return createComponent(Ctor, data, context, children, tag)\n\t    } else {\n\t      // unknown or unlisted namespaced elements\n\t      // check at runtime because it may get assigned a namespace when its\n\t      // parent normalizes children\n\t      return new VNode(\n\t        tag, data, normalizeChildren(children, ns),\n\t        undefined, undefined, ns, context\n\t      )\n\t    }\n\t  } else {\n\t    // direct component options / constructor\n\t    return createComponent(tag, data, context, children)\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction initRender (vm) {\n\t  vm.$vnode = null; // the placeholder node in parent tree\n\t  vm._vnode = null; // the root of the child tree\n\t  vm._staticTrees = null;\n\t  vm._renderContext = vm.$options._parentVnode && vm.$options._parentVnode.context;\n\t  vm.$slots = resolveSlots(vm.$options._renderChildren, vm._renderContext);\n\t  // bind the public createElement fn to this instance\n\t  // so that we get proper render context inside it.\n\t  vm.$createElement = bind$1(createElement, vm);\n\t  if (vm.$options.el) {\n\t    vm.$mount(vm.$options.el);\n\t  }\n\t}\n\t\n\tfunction renderMixin (Vue) {\n\t  Vue.prototype.$nextTick = function (fn) {\n\t    nextTick(fn, this);\n\t  };\n\t\n\t  Vue.prototype._render = function () {\n\t    var vm = this;\n\t    var ref = vm.$options;\n\t    var render = ref.render;\n\t    var staticRenderFns = ref.staticRenderFns;\n\t    var _parentVnode = ref._parentVnode;\n\t\n\t    if (vm._isMounted) {\n\t      // clone slot nodes on re-renders\n\t      for (var key in vm.$slots) {\n\t        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n\t      }\n\t    }\n\t\n\t    if (staticRenderFns && !vm._staticTrees) {\n\t      vm._staticTrees = [];\n\t    }\n\t    // set parent vnode. this allows render functions to have access\n\t    // to the data on the placeholder node.\n\t    vm.$vnode = _parentVnode;\n\t    // render self\n\t    var vnode;\n\t    try {\n\t      vnode = render.call(vm._renderProxy, vm.$createElement);\n\t    } catch (e) {\n\t      {\n\t        warn((\"Error when rendering \" + (formatComponentName(vm)) + \":\"));\n\t      }\n\t      /* istanbul ignore else */\n\t      if (config.errorHandler) {\n\t        config.errorHandler.call(null, e, vm);\n\t      } else {\n\t        if (config._isServer) {\n\t          throw e\n\t        } else {\n\t          setTimeout(function () { throw e }, 0);\n\t        }\n\t      }\n\t      // return previous vnode to prevent render error causing blank component\n\t      vnode = vm._vnode;\n\t    }\n\t    // return empty vnode in case the render function errored out\n\t    if (!(vnode instanceof VNode)) {\n\t      if (\"development\" !== 'production' && Array.isArray(vnode)) {\n\t        warn(\n\t          'Multiple root nodes returned from render function. Render function ' +\n\t          'should return a single root node.',\n\t          vm\n\t        );\n\t      }\n\t      vnode = emptyVNode();\n\t    }\n\t    // set parent\n\t    vnode.parent = _parentVnode;\n\t    return vnode\n\t  };\n\t\n\t  // shorthands used in render functions\n\t  Vue.prototype._h = createElement;\n\t  // toString for mustaches\n\t  Vue.prototype._s = _toString;\n\t  // number conversion\n\t  Vue.prototype._n = toNumber;\n\t  // empty vnode\n\t  Vue.prototype._e = emptyVNode;\n\t  // loose equal\n\t  Vue.prototype._q = looseEqual;\n\t  // loose indexOf\n\t  Vue.prototype._i = looseIndexOf;\n\t\n\t  // render static tree by index\n\t  Vue.prototype._m = function renderStatic (\n\t    index,\n\t    isInFor\n\t  ) {\n\t    var tree = this._staticTrees[index];\n\t    // if has already-rendered static tree and not inside v-for,\n\t    // we can reuse the same tree by doing a shallow clone.\n\t    if (tree && !isInFor) {\n\t      return Array.isArray(tree)\n\t        ? cloneVNodes(tree)\n\t        : cloneVNode(tree)\n\t    }\n\t    // otherwise, render a fresh tree.\n\t    tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);\n\t    if (Array.isArray(tree)) {\n\t      for (var i = 0; i < tree.length; i++) {\n\t        if (typeof tree[i] !== 'string') {\n\t          tree[i].isStatic = true;\n\t          tree[i].key = \"__static__\" + index + \"_\" + i;\n\t        }\n\t      }\n\t    } else {\n\t      tree.isStatic = true;\n\t      tree.key = \"__static__\" + index;\n\t    }\n\t    return tree\n\t  };\n\t\n\t  // filter resolution helper\n\t  var identity = function (_) { return _; };\n\t  Vue.prototype._f = function resolveFilter (id) {\n\t    return resolveAsset(this.$options, 'filters', id, true) || identity\n\t  };\n\t\n\t  // render v-for\n\t  Vue.prototype._l = function renderList (\n\t    val,\n\t    render\n\t  ) {\n\t    var ret, i, l, keys, key;\n\t    if (Array.isArray(val)) {\n\t      ret = new Array(val.length);\n\t      for (i = 0, l = val.length; i < l; i++) {\n\t        ret[i] = render(val[i], i);\n\t      }\n\t    } else if (typeof val === 'number') {\n\t      ret = new Array(val);\n\t      for (i = 0; i < val; i++) {\n\t        ret[i] = render(i + 1, i);\n\t      }\n\t    } else if (isObject(val)) {\n\t      keys = Object.keys(val);\n\t      ret = new Array(keys.length);\n\t      for (i = 0, l = keys.length; i < l; i++) {\n\t        key = keys[i];\n\t        ret[i] = render(val[key], key, i);\n\t      }\n\t    }\n\t    return ret\n\t  };\n\t\n\t  // renderSlot\n\t  Vue.prototype._t = function (\n\t    name,\n\t    fallback\n\t  ) {\n\t    var slotNodes = this.$slots[name];\n\t    // warn duplicate slot usage\n\t    if (slotNodes && \"development\" !== 'production') {\n\t      slotNodes._rendered && warn(\n\t        \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n\t        \"- this will likely cause render errors.\",\n\t        this\n\t      );\n\t      slotNodes._rendered = true;\n\t    }\n\t    return slotNodes || fallback\n\t  };\n\t\n\t  // apply v-bind object\n\t  Vue.prototype._b = function bindProps (\n\t    data,\n\t    value,\n\t    asProp\n\t  ) {\n\t    if (value) {\n\t      if (!isObject(value)) {\n\t        \"development\" !== 'production' && warn(\n\t          'v-bind without argument expects an Object or Array value',\n\t          this\n\t        );\n\t      } else {\n\t        if (Array.isArray(value)) {\n\t          value = toObject(value);\n\t        }\n\t        for (var key in value) {\n\t          if (key === 'class' || key === 'style') {\n\t            data[key] = value[key];\n\t          } else {\n\t            var hash = asProp || config.mustUseProp(key)\n\t              ? data.domProps || (data.domProps = {})\n\t              : data.attrs || (data.attrs = {});\n\t            hash[key] = value[key];\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return data\n\t  };\n\t\n\t  // expose v-on keyCodes\n\t  Vue.prototype._k = function getKeyCodes (key) {\n\t    return config.keyCodes[key]\n\t  };\n\t}\n\t\n\tfunction resolveSlots (\n\t  renderChildren,\n\t  context\n\t) {\n\t  var slots = {};\n\t  if (!renderChildren) {\n\t    return slots\n\t  }\n\t  var children = normalizeChildren(renderChildren) || [];\n\t  var defaultSlot = [];\n\t  var name, child;\n\t  for (var i = 0, l = children.length; i < l; i++) {\n\t    child = children[i];\n\t    // named slots should only be respected if the vnode was rendered in the\n\t    // same context.\n\t    if ((child.context === context || child.functionalContext === context) &&\n\t        child.data && (name = child.data.slot)) {\n\t      var slot = (slots[name] || (slots[name] = []));\n\t      if (child.tag === 'template') {\n\t        slot.push.apply(slot, child.children);\n\t      } else {\n\t        slot.push(child);\n\t      }\n\t    } else {\n\t      defaultSlot.push(child);\n\t    }\n\t  }\n\t  // ignore single whitespace\n\t  if (defaultSlot.length && !(\n\t    defaultSlot.length === 1 &&\n\t    (defaultSlot[0].text === ' ' || defaultSlot[0].isComment)\n\t  )) {\n\t    slots.default = defaultSlot;\n\t  }\n\t  return slots\n\t}\n\t\n\t/*  */\n\t\n\tfunction initEvents (vm) {\n\t  vm._events = Object.create(null);\n\t  // init parent attached events\n\t  var listeners = vm.$options._parentListeners;\n\t  var on = bind$1(vm.$on, vm);\n\t  var off = bind$1(vm.$off, vm);\n\t  vm._updateListeners = function (listeners, oldListeners) {\n\t    updateListeners(listeners, oldListeners || {}, on, off, vm);\n\t  };\n\t  if (listeners) {\n\t    vm._updateListeners(listeners);\n\t  }\n\t}\n\t\n\tfunction eventsMixin (Vue) {\n\t  Vue.prototype.$on = function (event, fn) {\n\t    var vm = this;(vm._events[event] || (vm._events[event] = [])).push(fn);\n\t    return vm\n\t  };\n\t\n\t  Vue.prototype.$once = function (event, fn) {\n\t    var vm = this;\n\t    function on () {\n\t      vm.$off(event, on);\n\t      fn.apply(vm, arguments);\n\t    }\n\t    on.fn = fn;\n\t    vm.$on(event, on);\n\t    return vm\n\t  };\n\t\n\t  Vue.prototype.$off = function (event, fn) {\n\t    var vm = this;\n\t    // all\n\t    if (!arguments.length) {\n\t      vm._events = Object.create(null);\n\t      return vm\n\t    }\n\t    // specific event\n\t    var cbs = vm._events[event];\n\t    if (!cbs) {\n\t      return vm\n\t    }\n\t    if (arguments.length === 1) {\n\t      vm._events[event] = null;\n\t      return vm\n\t    }\n\t    // specific handler\n\t    var cb;\n\t    var i = cbs.length;\n\t    while (i--) {\n\t      cb = cbs[i];\n\t      if (cb === fn || cb.fn === fn) {\n\t        cbs.splice(i, 1);\n\t        break\n\t      }\n\t    }\n\t    return vm\n\t  };\n\t\n\t  Vue.prototype.$emit = function (event) {\n\t    var vm = this;\n\t    var cbs = vm._events[event];\n\t    if (cbs) {\n\t      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n\t      var args = toArray(arguments, 1);\n\t      for (var i = 0, l = cbs.length; i < l; i++) {\n\t        cbs[i].apply(vm, args);\n\t      }\n\t    }\n\t    return vm\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\tvar uid = 0;\n\t\n\tfunction initMixin (Vue) {\n\t  Vue.prototype._init = function (options) {\n\t    var vm = this;\n\t    // a uid\n\t    vm._uid = uid++;\n\t    // a flag to avoid this being observed\n\t    vm._isVue = true;\n\t    // merge options\n\t    if (options && options._isComponent) {\n\t      // optimize internal component instantiation\n\t      // since dynamic options merging is pretty slow, and none of the\n\t      // internal component options needs special treatment.\n\t      initInternalComponent(vm, options);\n\t    } else {\n\t      vm.$options = mergeOptions(\n\t        resolveConstructorOptions(vm),\n\t        options || {},\n\t        vm\n\t      );\n\t    }\n\t    /* istanbul ignore else */\n\t    {\n\t      initProxy(vm);\n\t    }\n\t    // expose real self\n\t    vm._self = vm;\n\t    initLifecycle(vm);\n\t    initEvents(vm);\n\t    callHook(vm, 'beforeCreate');\n\t    initState(vm);\n\t    callHook(vm, 'created');\n\t    initRender(vm);\n\t  };\n\t\n\t  function initInternalComponent (vm, options) {\n\t    var opts = vm.$options = Object.create(resolveConstructorOptions(vm));\n\t    // doing this because it's faster than dynamic enumeration.\n\t    opts.parent = options.parent;\n\t    opts.propsData = options.propsData;\n\t    opts._parentVnode = options._parentVnode;\n\t    opts._parentListeners = options._parentListeners;\n\t    opts._renderChildren = options._renderChildren;\n\t    opts._componentTag = options._componentTag;\n\t    if (options.render) {\n\t      opts.render = options.render;\n\t      opts.staticRenderFns = options.staticRenderFns;\n\t    }\n\t  }\n\t\n\t  function resolveConstructorOptions (vm) {\n\t    var Ctor = vm.constructor;\n\t    var options = Ctor.options;\n\t    if (Ctor.super) {\n\t      var superOptions = Ctor.super.options;\n\t      var cachedSuperOptions = Ctor.superOptions;\n\t      if (superOptions !== cachedSuperOptions) {\n\t        // super option changed\n\t        Ctor.superOptions = superOptions;\n\t        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n\t        if (options.name) {\n\t          options.components[options.name] = Ctor;\n\t        }\n\t      }\n\t    }\n\t    return options\n\t  }\n\t}\n\t\n\tfunction Vue$3 (options) {\n\t  if (\"development\" !== 'production' &&\n\t    !(this instanceof Vue$3)) {\n\t    warn('Vue is a constructor and should be called with the `new` keyword');\n\t  }\n\t  this._init(options);\n\t}\n\t\n\tinitMixin(Vue$3);\n\tstateMixin(Vue$3);\n\teventsMixin(Vue$3);\n\tlifecycleMixin(Vue$3);\n\trenderMixin(Vue$3);\n\t\n\tvar warn = noop;\n\tvar formatComponentName;\n\t\n\t{\n\t  var hasConsole = typeof console !== 'undefined';\n\t\n\t  warn = function (msg, vm) {\n\t    if (hasConsole && (!config.silent)) {\n\t      console.error(\"[Vue warn]: \" + msg + \" \" + (\n\t        vm ? formatLocation(formatComponentName(vm)) : ''\n\t      ));\n\t    }\n\t  };\n\t\n\t  formatComponentName = function (vm) {\n\t    if (vm.$root === vm) {\n\t      return 'root instance'\n\t    }\n\t    var name = vm._isVue\n\t      ? vm.$options.name || vm.$options._componentTag\n\t      : vm.name;\n\t    return (\n\t      (name ? (\"component <\" + name + \">\") : \"anonymous component\") +\n\t      (vm._isVue && vm.$options.__file ? (\" at \" + (vm.$options.__file)) : '')\n\t    )\n\t  };\n\t\n\t  var formatLocation = function (str) {\n\t    if (str === 'anonymous component') {\n\t      str += \" - use the \\\"name\\\" option for better debugging messages.\";\n\t    }\n\t    return (\"\\n(found in \" + str + \")\")\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\t/**\n\t * Option overwriting strategies are functions that handle\n\t * how to merge a parent option value and a child option\n\t * value into the final value.\n\t */\n\tvar strats = config.optionMergeStrategies;\n\t\n\t/**\n\t * Options with restrictions\n\t */\n\t{\n\t  strats.el = strats.propsData = function (parent, child, vm, key) {\n\t    if (!vm) {\n\t      warn(\n\t        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n\t        'creation with the `new` keyword.'\n\t      );\n\t    }\n\t    return defaultStrat(parent, child)\n\t  };\n\t}\n\t\n\t/**\n\t * Helper that recursively merges two data objects together.\n\t */\n\tfunction mergeData (to, from) {\n\t  var key, toVal, fromVal;\n\t  for (key in from) {\n\t    toVal = to[key];\n\t    fromVal = from[key];\n\t    if (!hasOwn(to, key)) {\n\t      set(to, key, fromVal);\n\t    } else if (isObject(toVal) && isObject(fromVal)) {\n\t      mergeData(toVal, fromVal);\n\t    }\n\t  }\n\t  return to\n\t}\n\t\n\t/**\n\t * Data\n\t */\n\tstrats.data = function (\n\t  parentVal,\n\t  childVal,\n\t  vm\n\t) {\n\t  if (!vm) {\n\t    // in a Vue.extend merge, both should be functions\n\t    if (!childVal) {\n\t      return parentVal\n\t    }\n\t    if (typeof childVal !== 'function') {\n\t      \"development\" !== 'production' && warn(\n\t        'The \"data\" option should be a function ' +\n\t        'that returns a per-instance value in component ' +\n\t        'definitions.',\n\t        vm\n\t      );\n\t      return parentVal\n\t    }\n\t    if (!parentVal) {\n\t      return childVal\n\t    }\n\t    // when parentVal & childVal are both present,\n\t    // we need to return a function that returns the\n\t    // merged result of both functions... no need to\n\t    // check if parentVal is a function here because\n\t    // it has to be a function to pass previous merges.\n\t    return function mergedDataFn () {\n\t      return mergeData(\n\t        childVal.call(this),\n\t        parentVal.call(this)\n\t      )\n\t    }\n\t  } else if (parentVal || childVal) {\n\t    return function mergedInstanceDataFn () {\n\t      // instance merge\n\t      var instanceData = typeof childVal === 'function'\n\t        ? childVal.call(vm)\n\t        : childVal;\n\t      var defaultData = typeof parentVal === 'function'\n\t        ? parentVal.call(vm)\n\t        : undefined;\n\t      if (instanceData) {\n\t        return mergeData(instanceData, defaultData)\n\t      } else {\n\t        return defaultData\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Hooks and param attributes are merged as arrays.\n\t */\n\tfunction mergeHook (\n\t  parentVal,\n\t  childVal\n\t) {\n\t  return childVal\n\t    ? parentVal\n\t      ? parentVal.concat(childVal)\n\t      : Array.isArray(childVal)\n\t        ? childVal\n\t        : [childVal]\n\t    : parentVal\n\t}\n\t\n\tconfig._lifecycleHooks.forEach(function (hook) {\n\t  strats[hook] = mergeHook;\n\t});\n\t\n\t/**\n\t * Assets\n\t *\n\t * When a vm is present (instance creation), we need to do\n\t * a three-way merge between constructor options, instance\n\t * options and parent options.\n\t */\n\tfunction mergeAssets (parentVal, childVal) {\n\t  var res = Object.create(parentVal || null);\n\t  return childVal\n\t    ? extend(res, childVal)\n\t    : res\n\t}\n\t\n\tconfig._assetTypes.forEach(function (type) {\n\t  strats[type + 's'] = mergeAssets;\n\t});\n\t\n\t/**\n\t * Watchers.\n\t *\n\t * Watchers hashes should not overwrite one\n\t * another, so we merge them as arrays.\n\t */\n\tstrats.watch = function (parentVal, childVal) {\n\t  /* istanbul ignore if */\n\t  if (!childVal) { return parentVal }\n\t  if (!parentVal) { return childVal }\n\t  var ret = {};\n\t  extend(ret, parentVal);\n\t  for (var key in childVal) {\n\t    var parent = ret[key];\n\t    var child = childVal[key];\n\t    if (parent && !Array.isArray(parent)) {\n\t      parent = [parent];\n\t    }\n\t    ret[key] = parent\n\t      ? parent.concat(child)\n\t      : [child];\n\t  }\n\t  return ret\n\t};\n\t\n\t/**\n\t * Other object hashes.\n\t */\n\tstrats.props =\n\tstrats.methods =\n\tstrats.computed = function (parentVal, childVal) {\n\t  if (!childVal) { return parentVal }\n\t  if (!parentVal) { return childVal }\n\t  var ret = Object.create(null);\n\t  extend(ret, parentVal);\n\t  extend(ret, childVal);\n\t  return ret\n\t};\n\t\n\t/**\n\t * Default strategy.\n\t */\n\tvar defaultStrat = function (parentVal, childVal) {\n\t  return childVal === undefined\n\t    ? parentVal\n\t    : childVal\n\t};\n\t\n\t/**\n\t * Make sure component options get converted to actual\n\t * constructors.\n\t */\n\tfunction normalizeComponents (options) {\n\t  if (options.components) {\n\t    var components = options.components;\n\t    var def;\n\t    for (var key in components) {\n\t      var lower = key.toLowerCase();\n\t      if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n\t        \"development\" !== 'production' && warn(\n\t          'Do not use built-in or reserved HTML elements as component ' +\n\t          'id: ' + key\n\t        );\n\t        continue\n\t      }\n\t      def = components[key];\n\t      if (isPlainObject(def)) {\n\t        components[key] = Vue$3.extend(def);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Ensure all props option syntax are normalized into the\n\t * Object-based format.\n\t */\n\tfunction normalizeProps (options) {\n\t  var props = options.props;\n\t  if (!props) { return }\n\t  var res = {};\n\t  var i, val, name;\n\t  if (Array.isArray(props)) {\n\t    i = props.length;\n\t    while (i--) {\n\t      val = props[i];\n\t      if (typeof val === 'string') {\n\t        name = camelize(val);\n\t        res[name] = { type: null };\n\t      } else {\n\t        warn('props must be strings when using array syntax.');\n\t      }\n\t    }\n\t  } else if (isPlainObject(props)) {\n\t    for (var key in props) {\n\t      val = props[key];\n\t      name = camelize(key);\n\t      res[name] = isPlainObject(val)\n\t        ? val\n\t        : { type: val };\n\t    }\n\t  }\n\t  options.props = res;\n\t}\n\t\n\t/**\n\t * Normalize raw function directives into object format.\n\t */\n\tfunction normalizeDirectives (options) {\n\t  var dirs = options.directives;\n\t  if (dirs) {\n\t    for (var key in dirs) {\n\t      var def = dirs[key];\n\t      if (typeof def === 'function') {\n\t        dirs[key] = { bind: def, update: def };\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Merge two option objects into a new one.\n\t * Core utility used in both instantiation and inheritance.\n\t */\n\tfunction mergeOptions (\n\t  parent,\n\t  child,\n\t  vm\n\t) {\n\t  normalizeComponents(child);\n\t  normalizeProps(child);\n\t  normalizeDirectives(child);\n\t  var extendsFrom = child.extends;\n\t  if (extendsFrom) {\n\t    parent = typeof extendsFrom === 'function'\n\t      ? mergeOptions(parent, extendsFrom.options, vm)\n\t      : mergeOptions(parent, extendsFrom, vm);\n\t  }\n\t  if (child.mixins) {\n\t    for (var i = 0, l = child.mixins.length; i < l; i++) {\n\t      var mixin = child.mixins[i];\n\t      if (mixin.prototype instanceof Vue$3) {\n\t        mixin = mixin.options;\n\t      }\n\t      parent = mergeOptions(parent, mixin, vm);\n\t    }\n\t  }\n\t  var options = {};\n\t  var key;\n\t  for (key in parent) {\n\t    mergeField(key);\n\t  }\n\t  for (key in child) {\n\t    if (!hasOwn(parent, key)) {\n\t      mergeField(key);\n\t    }\n\t  }\n\t  function mergeField (key) {\n\t    var strat = strats[key] || defaultStrat;\n\t    options[key] = strat(parent[key], child[key], vm, key);\n\t  }\n\t  return options\n\t}\n\t\n\t/**\n\t * Resolve an asset.\n\t * This function is used because child instances need access\n\t * to assets defined in its ancestor chain.\n\t */\n\tfunction resolveAsset (\n\t  options,\n\t  type,\n\t  id,\n\t  warnMissing\n\t) {\n\t  /* istanbul ignore if */\n\t  if (typeof id !== 'string') {\n\t    return\n\t  }\n\t  var assets = options[type];\n\t  var res = assets[id] ||\n\t    // camelCase ID\n\t    assets[camelize(id)] ||\n\t    // Pascal Case ID\n\t    assets[capitalize(camelize(id))];\n\t  if (\"development\" !== 'production' && warnMissing && !res) {\n\t    warn(\n\t      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n\t      options\n\t    );\n\t  }\n\t  return res\n\t}\n\t\n\t/*  */\n\t\n\tfunction validateProp (\n\t  key,\n\t  propOptions,\n\t  propsData,\n\t  vm\n\t) {\n\t  var prop = propOptions[key];\n\t  var absent = !hasOwn(propsData, key);\n\t  var value = propsData[key];\n\t  // handle boolean props\n\t  if (isBooleanType(prop.type)) {\n\t    if (absent && !hasOwn(prop, 'default')) {\n\t      value = false;\n\t    } else if (value === '' || value === hyphenate(key)) {\n\t      value = true;\n\t    }\n\t  }\n\t  // check default value\n\t  if (value === undefined) {\n\t    value = getPropDefaultValue(vm, prop, key);\n\t    // since the default value is a fresh copy,\n\t    // make sure to observe it.\n\t    var prevShouldConvert = observerState.shouldConvert;\n\t    observerState.shouldConvert = true;\n\t    observe(value);\n\t    observerState.shouldConvert = prevShouldConvert;\n\t  }\n\t  {\n\t    assertProp(prop, key, value, vm, absent);\n\t  }\n\t  return value\n\t}\n\t\n\t/**\n\t * Get the default value of a prop.\n\t */\n\tfunction getPropDefaultValue (vm, prop, name) {\n\t  // no default, return undefined\n\t  if (!hasOwn(prop, 'default')) {\n\t    return undefined\n\t  }\n\t  var def = prop.default;\n\t  // warn against non-factory defaults for Object & Array\n\t  if (isObject(def)) {\n\t    \"development\" !== 'production' && warn(\n\t      'Invalid default value for prop \"' + name + '\": ' +\n\t      'Props with type Object/Array must use a factory function ' +\n\t      'to return the default value.',\n\t      vm\n\t    );\n\t  }\n\t  // call factory function for non-Function types\n\t  return typeof def === 'function' && prop.type !== Function\n\t    ? def.call(vm)\n\t    : def\n\t}\n\t\n\t/**\n\t * Assert whether a prop is valid.\n\t */\n\tfunction assertProp (\n\t  prop,\n\t  name,\n\t  value,\n\t  vm,\n\t  absent\n\t) {\n\t  if (prop.required && absent) {\n\t    warn(\n\t      'Missing required prop: \"' + name + '\"',\n\t      vm\n\t    );\n\t    return\n\t  }\n\t  if (value == null && !prop.required) {\n\t    return\n\t  }\n\t  var type = prop.type;\n\t  var valid = !type || type === true;\n\t  var expectedTypes = [];\n\t  if (type) {\n\t    if (!Array.isArray(type)) {\n\t      type = [type];\n\t    }\n\t    for (var i = 0; i < type.length && !valid; i++) {\n\t      var assertedType = assertType(value, type[i]);\n\t      expectedTypes.push(assertedType.expectedType);\n\t      valid = assertedType.valid;\n\t    }\n\t  }\n\t  if (!valid) {\n\t    warn(\n\t      'Invalid prop: type check failed for prop \"' + name + '\".' +\n\t      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n\t      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n\t      vm\n\t    );\n\t    return\n\t  }\n\t  var validator = prop.validator;\n\t  if (validator) {\n\t    if (!validator(value)) {\n\t      warn(\n\t        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n\t        vm\n\t      );\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Assert the type of a value\n\t */\n\tfunction assertType (value, type) {\n\t  var valid;\n\t  var expectedType = getType(type);\n\t  if (expectedType === 'String') {\n\t    valid = typeof value === (expectedType = 'string');\n\t  } else if (expectedType === 'Number') {\n\t    valid = typeof value === (expectedType = 'number');\n\t  } else if (expectedType === 'Boolean') {\n\t    valid = typeof value === (expectedType = 'boolean');\n\t  } else if (expectedType === 'Function') {\n\t    valid = typeof value === (expectedType = 'function');\n\t  } else if (expectedType === 'Object') {\n\t    valid = isPlainObject(value);\n\t  } else if (expectedType === 'Array') {\n\t    valid = Array.isArray(value);\n\t  } else {\n\t    valid = value instanceof type;\n\t  }\n\t  return {\n\t    valid: valid,\n\t    expectedType: expectedType\n\t  }\n\t}\n\t\n\t/**\n\t * Use function string name to check built-in types,\n\t * because a simple equality check will fail when running\n\t * across different vms / iframes.\n\t */\n\tfunction getType (fn) {\n\t  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n\t  return match && match[1]\n\t}\n\t\n\tfunction isBooleanType (fn) {\n\t  if (!Array.isArray(fn)) {\n\t    return getType(fn) === 'Boolean'\n\t  }\n\t  for (var i = 0, len = fn.length; i < len; i++) {\n\t    if (getType(fn[i]) === 'Boolean') {\n\t      return true\n\t    }\n\t  }\n\t  /* istanbul ignore next */\n\t  return false\n\t}\n\t\n\t\n\t\n\tvar util = Object.freeze({\n\t\tdefineReactive: defineReactive$$1,\n\t\t_toString: _toString,\n\t\ttoNumber: toNumber,\n\t\tmakeMap: makeMap,\n\t\tisBuiltInTag: isBuiltInTag,\n\t\tremove: remove$1,\n\t\thasOwn: hasOwn,\n\t\tisPrimitive: isPrimitive,\n\t\tcached: cached,\n\t\tcamelize: camelize,\n\t\tcapitalize: capitalize,\n\t\thyphenate: hyphenate,\n\t\tbind: bind$1,\n\t\ttoArray: toArray,\n\t\textend: extend,\n\t\tisObject: isObject,\n\t\tisPlainObject: isPlainObject,\n\t\ttoObject: toObject,\n\t\tnoop: noop,\n\t\tno: no,\n\t\tgenStaticKeys: genStaticKeys,\n\t\tlooseEqual: looseEqual,\n\t\tlooseIndexOf: looseIndexOf,\n\t\tisReserved: isReserved,\n\t\tdef: def,\n\t\tparsePath: parsePath,\n\t\thasProto: hasProto,\n\t\tinBrowser: inBrowser,\n\t\tUA: UA,\n\t\tisIE: isIE,\n\t\tisIE9: isIE9,\n\t\tisEdge: isEdge,\n\t\tisAndroid: isAndroid,\n\t\tisIOS: isIOS,\n\t\tdevtools: devtools,\n\t\tnextTick: nextTick,\n\t\tget _Set () { return _Set; },\n\t\tmergeOptions: mergeOptions,\n\t\tresolveAsset: resolveAsset,\n\t\tget warn () { return warn; },\n\t\tget formatComponentName () { return formatComponentName; },\n\t\tvalidateProp: validateProp\n\t});\n\t\n\t/*  */\n\t\n\tfunction initUse (Vue) {\n\t  Vue.use = function (plugin) {\n\t    /* istanbul ignore if */\n\t    if (plugin.installed) {\n\t      return\n\t    }\n\t    // additional parameters\n\t    var args = toArray(arguments, 1);\n\t    args.unshift(this);\n\t    if (typeof plugin.install === 'function') {\n\t      plugin.install.apply(plugin, args);\n\t    } else {\n\t      plugin.apply(null, args);\n\t    }\n\t    plugin.installed = true;\n\t    return this\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\tfunction initMixin$1 (Vue) {\n\t  Vue.mixin = function (mixin) {\n\t    Vue.options = mergeOptions(Vue.options, mixin);\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\tfunction initExtend (Vue) {\n\t  /**\n\t   * Each instance constructor, including Vue, has a unique\n\t   * cid. This enables us to create wrapped \"child\n\t   * constructors\" for prototypal inheritance and cache them.\n\t   */\n\t  Vue.cid = 0;\n\t  var cid = 1;\n\t\n\t  /**\n\t   * Class inheritance\n\t   */\n\t  Vue.extend = function (extendOptions) {\n\t    extendOptions = extendOptions || {};\n\t    var Super = this;\n\t    var isFirstExtend = Super.cid === 0;\n\t    if (isFirstExtend && extendOptions._Ctor) {\n\t      return extendOptions._Ctor\n\t    }\n\t    var name = extendOptions.name || Super.options.name;\n\t    {\n\t      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n\t        warn(\n\t          'Invalid component name: \"' + name + '\". Component names ' +\n\t          'can only contain alphanumeric characaters and the hyphen.'\n\t        );\n\t        name = null;\n\t      }\n\t    }\n\t    var Sub = function VueComponent (options) {\n\t      this._init(options);\n\t    };\n\t    Sub.prototype = Object.create(Super.prototype);\n\t    Sub.prototype.constructor = Sub;\n\t    Sub.cid = cid++;\n\t    Sub.options = mergeOptions(\n\t      Super.options,\n\t      extendOptions\n\t    );\n\t    Sub['super'] = Super;\n\t    // allow further extension\n\t    Sub.extend = Super.extend;\n\t    // create asset registers, so extended classes\n\t    // can have their private assets too.\n\t    config._assetTypes.forEach(function (type) {\n\t      Sub[type] = Super[type];\n\t    });\n\t    // enable recursive self-lookup\n\t    if (name) {\n\t      Sub.options.components[name] = Sub;\n\t    }\n\t    // keep a reference to the super options at extension time.\n\t    // later at instantiation we can check if Super's options have\n\t    // been updated.\n\t    Sub.superOptions = Super.options;\n\t    Sub.extendOptions = extendOptions;\n\t    // cache constructor\n\t    if (isFirstExtend) {\n\t      extendOptions._Ctor = Sub;\n\t    }\n\t    return Sub\n\t  };\n\t}\n\t\n\t/*  */\n\t\n\tfunction initAssetRegisters (Vue) {\n\t  /**\n\t   * Create asset registration methods.\n\t   */\n\t  config._assetTypes.forEach(function (type) {\n\t    Vue[type] = function (\n\t      id,\n\t      definition\n\t    ) {\n\t      if (!definition) {\n\t        return this.options[type + 's'][id]\n\t      } else {\n\t        /* istanbul ignore if */\n\t        {\n\t          if (type === 'component' && config.isReservedTag(id)) {\n\t            warn(\n\t              'Do not use built-in or reserved HTML elements as component ' +\n\t              'id: ' + id\n\t            );\n\t          }\n\t        }\n\t        if (type === 'component' && isPlainObject(definition)) {\n\t          definition.name = definition.name || id;\n\t          definition = Vue.extend(definition);\n\t        }\n\t        if (type === 'directive' && typeof definition === 'function') {\n\t          definition = { bind: definition, update: definition };\n\t        }\n\t        this.options[type + 's'][id] = definition;\n\t        return definition\n\t      }\n\t    };\n\t  });\n\t}\n\t\n\tvar KeepAlive = {\n\t  name: 'keep-alive',\n\t  abstract: true,\n\t  created: function created () {\n\t    this.cache = Object.create(null);\n\t  },\n\t  render: function render () {\n\t    var vnode = getFirstComponentChild(this.$slots.default);\n\t    if (vnode && vnode.componentOptions) {\n\t      var opts = vnode.componentOptions;\n\t      var key = vnode.key == null\n\t        // same constructor may get registered as different local components\n\t        // so cid alone is not enough (#3269)\n\t        ? opts.Ctor.cid + '::' + opts.tag\n\t        : vnode.key;\n\t      if (this.cache[key]) {\n\t        vnode.child = this.cache[key].child;\n\t      } else {\n\t        this.cache[key] = vnode;\n\t      }\n\t      vnode.data.keepAlive = true;\n\t    }\n\t    return vnode\n\t  },\n\t  destroyed: function destroyed () {\n\t    var this$1 = this;\n\t\n\t    for (var key in this.cache) {\n\t      var vnode = this$1.cache[key];\n\t      callHook(vnode.child, 'deactivated');\n\t      vnode.child.$destroy();\n\t    }\n\t  }\n\t};\n\t\n\tvar builtInComponents = {\n\t  KeepAlive: KeepAlive\n\t};\n\t\n\t/*  */\n\t\n\tfunction initGlobalAPI (Vue) {\n\t  // config\n\t  var configDef = {};\n\t  configDef.get = function () { return config; };\n\t  {\n\t    configDef.set = function () {\n\t      warn(\n\t        'Do not replace the Vue.config object, set individual fields instead.'\n\t      );\n\t    };\n\t  }\n\t  Object.defineProperty(Vue, 'config', configDef);\n\t  Vue.util = util;\n\t  Vue.set = set;\n\t  Vue.delete = del;\n\t  Vue.nextTick = nextTick;\n\t\n\t  Vue.options = Object.create(null);\n\t  config._assetTypes.forEach(function (type) {\n\t    Vue.options[type + 's'] = Object.create(null);\n\t  });\n\t\n\t  extend(Vue.options.components, builtInComponents);\n\t\n\t  initUse(Vue);\n\t  initMixin$1(Vue);\n\t  initExtend(Vue);\n\t  initAssetRegisters(Vue);\n\t}\n\t\n\tinitGlobalAPI(Vue$3);\n\t\n\tObject.defineProperty(Vue$3.prototype, '$isServer', {\n\t  get: function () { return config._isServer; }\n\t});\n\t\n\tVue$3.version = '2.0.3';\n\t\n\t/*  */\n\t\n\t// attributes that should be using props for binding\n\tvar mustUseProp = makeMap('value,selected,checked,muted');\n\t\n\tvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\t\n\tvar isBooleanAttr = makeMap(\n\t  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n\t  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n\t  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n\t  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n\t  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n\t  'truespeed,typemustmatch,visible'\n\t);\n\t\n\tvar isAttr = makeMap(\n\t  'accept,accept-charset,accesskey,action,align,alt,async,autocomplete,' +\n\t  'autofocus,autoplay,autosave,bgcolor,border,buffered,challenge,charset,' +\n\t  'checked,cite,class,code,codebase,color,cols,colspan,content,http-equiv,' +\n\t  'name,contenteditable,contextmenu,controls,coords,data,datetime,default,' +\n\t  'defer,dir,dirname,disabled,download,draggable,dropzone,enctype,method,for,' +\n\t  'form,formaction,headers,<th>,height,hidden,high,href,hreflang,http-equiv,' +\n\t  'icon,id,ismap,itemprop,keytype,kind,label,lang,language,list,loop,low,' +\n\t  'manifest,max,maxlength,media,method,GET,POST,min,multiple,email,file,' +\n\t  'muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,' +\n\t  'preload,radiogroup,readonly,rel,required,reversed,rows,rowspan,sandbox,' +\n\t  'scope,scoped,seamless,selected,shape,size,type,text,password,sizes,span,' +\n\t  'spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,' +\n\t  'target,title,type,usemap,value,width,wrap'\n\t);\n\t\n\t\n\t\n\tvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\t\n\tvar isXlink = function (name) {\n\t  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n\t};\n\t\n\tvar getXlinkProp = function (name) {\n\t  return isXlink(name) ? name.slice(6, name.length) : ''\n\t};\n\t\n\tvar isFalsyAttrValue = function (val) {\n\t  return val == null || val === false\n\t};\n\t\n\t/*  */\n\t\n\tfunction genClassForVnode (vnode) {\n\t  var data = vnode.data;\n\t  var parentNode = vnode;\n\t  var childNode = vnode;\n\t  while (childNode.child) {\n\t    childNode = childNode.child._vnode;\n\t    if (childNode.data) {\n\t      data = mergeClassData(childNode.data, data);\n\t    }\n\t  }\n\t  while ((parentNode = parentNode.parent)) {\n\t    if (parentNode.data) {\n\t      data = mergeClassData(data, parentNode.data);\n\t    }\n\t  }\n\t  return genClassFromData(data)\n\t}\n\t\n\tfunction mergeClassData (child, parent) {\n\t  return {\n\t    staticClass: concat(child.staticClass, parent.staticClass),\n\t    class: child.class\n\t      ? [child.class, parent.class]\n\t      : parent.class\n\t  }\n\t}\n\t\n\tfunction genClassFromData (data) {\n\t  var dynamicClass = data.class;\n\t  var staticClass = data.staticClass;\n\t  if (staticClass || dynamicClass) {\n\t    return concat(staticClass, stringifyClass(dynamicClass))\n\t  }\n\t  /* istanbul ignore next */\n\t  return ''\n\t}\n\t\n\tfunction concat (a, b) {\n\t  return a ? b ? (a + ' ' + b) : a : (b || '')\n\t}\n\t\n\tfunction stringifyClass (value) {\n\t  var res = '';\n\t  if (!value) {\n\t    return res\n\t  }\n\t  if (typeof value === 'string') {\n\t    return value\n\t  }\n\t  if (Array.isArray(value)) {\n\t    var stringified;\n\t    for (var i = 0, l = value.length; i < l; i++) {\n\t      if (value[i]) {\n\t        if ((stringified = stringifyClass(value[i]))) {\n\t          res += stringified + ' ';\n\t        }\n\t      }\n\t    }\n\t    return res.slice(0, -1)\n\t  }\n\t  if (isObject(value)) {\n\t    for (var key in value) {\n\t      if (value[key]) { res += key + ' '; }\n\t    }\n\t    return res.slice(0, -1)\n\t  }\n\t  /* istanbul ignore next */\n\t  return res\n\t}\n\t\n\t/*  */\n\t\n\tvar namespaceMap = {\n\t  svg: 'http://www.w3.org/2000/svg',\n\t  math: 'http://www.w3.org/1998/Math/MathML'\n\t};\n\t\n\tvar isHTMLTag = makeMap(\n\t  'html,body,base,head,link,meta,style,title,' +\n\t  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n\t  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n\t  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n\t  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n\t  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n\t  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n\t  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n\t  'output,progress,select,textarea,' +\n\t  'details,dialog,menu,menuitem,summary,' +\n\t  'content,element,shadow,template'\n\t);\n\t\n\tvar isUnaryTag = makeMap(\n\t  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n\t  'link,meta,param,source,track,wbr',\n\t  true\n\t);\n\t\n\t// Elements that you can, intentionally, leave open\n\t// (and which close themselves)\n\tvar canBeLeftOpenTag = makeMap(\n\t  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source',\n\t  true\n\t);\n\t\n\t// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n\t// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n\tvar isNonPhrasingTag = makeMap(\n\t  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n\t  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n\t  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n\t  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n\t  'title,tr,track',\n\t  true\n\t);\n\t\n\t// this map is intentionally selective, only covering SVG elements that may\n\t// contain child elements.\n\tvar isSVG = makeMap(\n\t  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font,' +\n\t  'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n\t  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n\t  true\n\t);\n\t\n\tvar isPreTag = function (tag) { return tag === 'pre'; };\n\t\n\tvar isReservedTag = function (tag) {\n\t  return isHTMLTag(tag) || isSVG(tag)\n\t};\n\t\n\tfunction getTagNamespace (tag) {\n\t  if (isSVG(tag)) {\n\t    return 'svg'\n\t  }\n\t  // basic support for MathML\n\t  // note it doesn't support other MathML elements being component roots\n\t  if (tag === 'math') {\n\t    return 'math'\n\t  }\n\t}\n\t\n\tvar unknownElementCache = Object.create(null);\n\tfunction isUnknownElement (tag) {\n\t  /* istanbul ignore if */\n\t  if (!inBrowser) {\n\t    return true\n\t  }\n\t  if (isReservedTag(tag)) {\n\t    return false\n\t  }\n\t  tag = tag.toLowerCase();\n\t  /* istanbul ignore if */\n\t  if (unknownElementCache[tag] != null) {\n\t    return unknownElementCache[tag]\n\t  }\n\t  var el = document.createElement(tag);\n\t  if (tag.indexOf('-') > -1) {\n\t    // http://stackoverflow.com/a/28210364/1070244\n\t    return (unknownElementCache[tag] = (\n\t      el.constructor === window.HTMLUnknownElement ||\n\t      el.constructor === window.HTMLElement\n\t    ))\n\t  } else {\n\t    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\t/**\n\t * Query an element selector if it's not an element already.\n\t */\n\tfunction query (el) {\n\t  if (typeof el === 'string') {\n\t    var selector = el;\n\t    el = document.querySelector(el);\n\t    if (!el) {\n\t      \"development\" !== 'production' && warn(\n\t        'Cannot find element: ' + selector\n\t      );\n\t      return document.createElement('div')\n\t    }\n\t  }\n\t  return el\n\t}\n\t\n\t/*  */\n\t\n\tfunction createElement$1 (tagName, vnode) {\n\t  var elm = document.createElement(tagName);\n\t  if (tagName !== 'select') {\n\t    return elm\n\t  }\n\t  if (vnode.data && vnode.data.attrs && 'multiple' in vnode.data.attrs) {\n\t    elm.setAttribute('multiple', 'multiple');\n\t  }\n\t  return elm\n\t}\n\t\n\tfunction createElementNS (namespace, tagName) {\n\t  return document.createElementNS(namespaceMap[namespace], tagName)\n\t}\n\t\n\tfunction createTextNode (text) {\n\t  return document.createTextNode(text)\n\t}\n\t\n\tfunction createComment (text) {\n\t  return document.createComment(text)\n\t}\n\t\n\tfunction insertBefore (parentNode, newNode, referenceNode) {\n\t  parentNode.insertBefore(newNode, referenceNode);\n\t}\n\t\n\tfunction removeChild (node, child) {\n\t  node.removeChild(child);\n\t}\n\t\n\tfunction appendChild (node, child) {\n\t  node.appendChild(child);\n\t}\n\t\n\tfunction parentNode (node) {\n\t  return node.parentNode\n\t}\n\t\n\tfunction nextSibling (node) {\n\t  return node.nextSibling\n\t}\n\t\n\tfunction tagName (node) {\n\t  return node.tagName\n\t}\n\t\n\tfunction setTextContent (node, text) {\n\t  node.textContent = text;\n\t}\n\t\n\tfunction childNodes (node) {\n\t  return node.childNodes\n\t}\n\t\n\tfunction setAttribute (node, key, val) {\n\t  node.setAttribute(key, val);\n\t}\n\t\n\t\n\tvar nodeOps = Object.freeze({\n\t\tcreateElement: createElement$1,\n\t\tcreateElementNS: createElementNS,\n\t\tcreateTextNode: createTextNode,\n\t\tcreateComment: createComment,\n\t\tinsertBefore: insertBefore,\n\t\tremoveChild: removeChild,\n\t\tappendChild: appendChild,\n\t\tparentNode: parentNode,\n\t\tnextSibling: nextSibling,\n\t\ttagName: tagName,\n\t\tsetTextContent: setTextContent,\n\t\tchildNodes: childNodes,\n\t\tsetAttribute: setAttribute\n\t});\n\t\n\t/*  */\n\t\n\tvar ref = {\n\t  create: function create (_, vnode) {\n\t    registerRef(vnode);\n\t  },\n\t  update: function update (oldVnode, vnode) {\n\t    if (oldVnode.data.ref !== vnode.data.ref) {\n\t      registerRef(oldVnode, true);\n\t      registerRef(vnode);\n\t    }\n\t  },\n\t  destroy: function destroy (vnode) {\n\t    registerRef(vnode, true);\n\t  }\n\t};\n\t\n\tfunction registerRef (vnode, isRemoval) {\n\t  var key = vnode.data.ref;\n\t  if (!key) { return }\n\t\n\t  var vm = vnode.context;\n\t  var ref = vnode.child || vnode.elm;\n\t  var refs = vm.$refs;\n\t  if (isRemoval) {\n\t    if (Array.isArray(refs[key])) {\n\t      remove$1(refs[key], ref);\n\t    } else if (refs[key] === ref) {\n\t      refs[key] = undefined;\n\t    }\n\t  } else {\n\t    if (vnode.data.refInFor) {\n\t      if (Array.isArray(refs[key])) {\n\t        refs[key].push(ref);\n\t      } else {\n\t        refs[key] = [ref];\n\t      }\n\t    } else {\n\t      refs[key] = ref;\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Virtual DOM patching algorithm based on Snabbdom by\n\t * Simon Friis Vindum (@paldepind)\n\t * Licensed under the MIT License\n\t * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n\t *\n\t * modified by Evan You (@yyx990803)\n\t *\n\t\n\t/*\n\t * Not type-checking this because this file is perf-critical and the cost\n\t * of making flow understand it is not worth it.\n\t */\n\t\n\tvar emptyNode = new VNode('', {}, []);\n\t\n\tvar hooks$1 = ['create', 'update', 'remove', 'destroy'];\n\t\n\tfunction isUndef (s) {\n\t  return s == null\n\t}\n\t\n\tfunction isDef (s) {\n\t  return s != null\n\t}\n\t\n\tfunction sameVnode (vnode1, vnode2) {\n\t  return (\n\t    vnode1.key === vnode2.key &&\n\t    vnode1.tag === vnode2.tag &&\n\t    vnode1.isComment === vnode2.isComment &&\n\t    !vnode1.data === !vnode2.data\n\t  )\n\t}\n\t\n\tfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n\t  var i, key;\n\t  var map = {};\n\t  for (i = beginIdx; i <= endIdx; ++i) {\n\t    key = children[i].key;\n\t    if (isDef(key)) { map[key] = i; }\n\t  }\n\t  return map\n\t}\n\t\n\tfunction createPatchFunction (backend) {\n\t  var i, j;\n\t  var cbs = {};\n\t\n\t  var modules = backend.modules;\n\t  var nodeOps = backend.nodeOps;\n\t\n\t  for (i = 0; i < hooks$1.length; ++i) {\n\t    cbs[hooks$1[i]] = [];\n\t    for (j = 0; j < modules.length; ++j) {\n\t      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }\n\t    }\n\t  }\n\t\n\t  function emptyNodeAt (elm) {\n\t    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n\t  }\n\t\n\t  function createRmCb (childElm, listeners) {\n\t    function remove$$1 () {\n\t      if (--remove$$1.listeners === 0) {\n\t        removeElement(childElm);\n\t      }\n\t    }\n\t    remove$$1.listeners = listeners;\n\t    return remove$$1\n\t  }\n\t\n\t  function removeElement (el) {\n\t    var parent = nodeOps.parentNode(el);\n\t    nodeOps.removeChild(parent, el);\n\t  }\n\t\n\t  function createElm (vnode, insertedVnodeQueue, nested) {\n\t    var i;\n\t    var data = vnode.data;\n\t    vnode.isRootInsert = !nested;\n\t    if (isDef(data)) {\n\t      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode); }\n\t      // after calling the init hook, if the vnode is a child component\n\t      // it should've created a child instance and mounted it. the child\n\t      // component also has set the placeholder vnode's elm.\n\t      // in that case we can just return the element and be done.\n\t      if (isDef(i = vnode.child)) {\n\t        initComponent(vnode, insertedVnodeQueue);\n\t        return vnode.elm\n\t      }\n\t    }\n\t    var children = vnode.children;\n\t    var tag = vnode.tag;\n\t    if (isDef(tag)) {\n\t      {\n\t        if (\n\t          !vnode.ns &&\n\t          !(config.ignoredElements && config.ignoredElements.indexOf(tag) > -1) &&\n\t          config.isUnknownElement(tag)\n\t        ) {\n\t          warn(\n\t            'Unknown custom element: <' + tag + '> - did you ' +\n\t            'register the component correctly? For recursive components, ' +\n\t            'make sure to provide the \"name\" option.',\n\t            vnode.context\n\t          );\n\t        }\n\t      }\n\t      vnode.elm = vnode.ns\n\t        ? nodeOps.createElementNS(vnode.ns, tag)\n\t        : nodeOps.createElement(tag, vnode);\n\t      setScope(vnode);\n\t      createChildren(vnode, children, insertedVnodeQueue);\n\t      if (isDef(data)) {\n\t        invokeCreateHooks(vnode, insertedVnodeQueue);\n\t      }\n\t    } else if (vnode.isComment) {\n\t      vnode.elm = nodeOps.createComment(vnode.text);\n\t    } else {\n\t      vnode.elm = nodeOps.createTextNode(vnode.text);\n\t    }\n\t    return vnode.elm\n\t  }\n\t\n\t  function createChildren (vnode, children, insertedVnodeQueue) {\n\t    if (Array.isArray(children)) {\n\t      for (var i = 0; i < children.length; ++i) {\n\t        nodeOps.appendChild(vnode.elm, createElm(children[i], insertedVnodeQueue, true));\n\t      }\n\t    } else if (isPrimitive(vnode.text)) {\n\t      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n\t    }\n\t  }\n\t\n\t  function isPatchable (vnode) {\n\t    while (vnode.child) {\n\t      vnode = vnode.child._vnode;\n\t    }\n\t    return isDef(vnode.tag)\n\t  }\n\t\n\t  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n\t    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n\t      cbs.create[i$1](emptyNode, vnode);\n\t    }\n\t    i = vnode.data.hook; // Reuse variable\n\t    if (isDef(i)) {\n\t      if (i.create) { i.create(emptyNode, vnode); }\n\t      if (i.insert) { insertedVnodeQueue.push(vnode); }\n\t    }\n\t  }\n\t\n\t  function initComponent (vnode, insertedVnodeQueue) {\n\t    if (vnode.data.pendingInsert) {\n\t      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n\t    }\n\t    vnode.elm = vnode.child.$el;\n\t    if (isPatchable(vnode)) {\n\t      invokeCreateHooks(vnode, insertedVnodeQueue);\n\t      setScope(vnode);\n\t    } else {\n\t      // empty component root.\n\t      // skip all element-related modules except for ref (#3455)\n\t      registerRef(vnode);\n\t      // make sure to invoke the insert hook\n\t      insertedVnodeQueue.push(vnode);\n\t    }\n\t  }\n\t\n\t  // set scope id attribute for scoped CSS.\n\t  // this is implemented as a special case to avoid the overhead\n\t  // of going through the normal attribute patching process.\n\t  function setScope (vnode) {\n\t    var i;\n\t    if (isDef(i = vnode.context) && isDef(i = i.$options._scopeId)) {\n\t      nodeOps.setAttribute(vnode.elm, i, '');\n\t    }\n\t    if (isDef(i = activeInstance) &&\n\t        i !== vnode.context &&\n\t        isDef(i = i.$options._scopeId)) {\n\t      nodeOps.setAttribute(vnode.elm, i, '');\n\t    }\n\t  }\n\t\n\t  function addVnodes (parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n\t    for (; startIdx <= endIdx; ++startIdx) {\n\t      nodeOps.insertBefore(parentElm, createElm(vnodes[startIdx], insertedVnodeQueue), before);\n\t    }\n\t  }\n\t\n\t  function invokeDestroyHook (vnode) {\n\t    var i, j;\n\t    var data = vnode.data;\n\t    if (isDef(data)) {\n\t      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n\t      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n\t    }\n\t    if (isDef(i = vnode.children)) {\n\t      for (j = 0; j < vnode.children.length; ++j) {\n\t        invokeDestroyHook(vnode.children[j]);\n\t      }\n\t    }\n\t  }\n\t\n\t  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n\t    for (; startIdx <= endIdx; ++startIdx) {\n\t      var ch = vnodes[startIdx];\n\t      if (isDef(ch)) {\n\t        if (isDef(ch.tag)) {\n\t          removeAndInvokeRemoveHook(ch);\n\t          invokeDestroyHook(ch);\n\t        } else { // Text node\n\t          nodeOps.removeChild(parentElm, ch.elm);\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  function removeAndInvokeRemoveHook (vnode, rm) {\n\t    if (rm || isDef(vnode.data)) {\n\t      var listeners = cbs.remove.length + 1;\n\t      if (!rm) {\n\t        // directly removing\n\t        rm = createRmCb(vnode.elm, listeners);\n\t      } else {\n\t        // we have a recursively passed down rm callback\n\t        // increase the listeners count\n\t        rm.listeners += listeners;\n\t      }\n\t      // recursively invoke hooks on child component root node\n\t      if (isDef(i = vnode.child) && isDef(i = i._vnode) && isDef(i.data)) {\n\t        removeAndInvokeRemoveHook(i, rm);\n\t      }\n\t      for (i = 0; i < cbs.remove.length; ++i) {\n\t        cbs.remove[i](vnode, rm);\n\t      }\n\t      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n\t        i(vnode, rm);\n\t      } else {\n\t        rm();\n\t      }\n\t    } else {\n\t      removeElement(vnode.elm);\n\t    }\n\t  }\n\t\n\t  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n\t    var oldStartIdx = 0;\n\t    var newStartIdx = 0;\n\t    var oldEndIdx = oldCh.length - 1;\n\t    var oldStartVnode = oldCh[0];\n\t    var oldEndVnode = oldCh[oldEndIdx];\n\t    var newEndIdx = newCh.length - 1;\n\t    var newStartVnode = newCh[0];\n\t    var newEndVnode = newCh[newEndIdx];\n\t    var oldKeyToIdx, idxInOld, elmToMove, before;\n\t\n\t    // removeOnly is a special flag used only by <transition-group>\n\t    // to ensure removed elements stay in correct relative positions\n\t    // during leaving transitions\n\t    var canMove = !removeOnly;\n\t\n\t    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n\t      if (isUndef(oldStartVnode)) {\n\t        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n\t      } else if (isUndef(oldEndVnode)) {\n\t        oldEndVnode = oldCh[--oldEndIdx];\n\t      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n\t        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n\t        oldStartVnode = oldCh[++oldStartIdx];\n\t        newStartVnode = newCh[++newStartIdx];\n\t      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n\t        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n\t        oldEndVnode = oldCh[--oldEndIdx];\n\t        newEndVnode = newCh[--newEndIdx];\n\t      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n\t        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n\t        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n\t        oldStartVnode = oldCh[++oldStartIdx];\n\t        newEndVnode = newCh[--newEndIdx];\n\t      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n\t        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n\t        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n\t        oldEndVnode = oldCh[--oldEndIdx];\n\t        newStartVnode = newCh[++newStartIdx];\n\t      } else {\n\t        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n\t        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n\t        if (isUndef(idxInOld)) { // New element\n\t          nodeOps.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n\t          newStartVnode = newCh[++newStartIdx];\n\t        } else {\n\t          elmToMove = oldCh[idxInOld];\n\t          /* istanbul ignore if */\n\t          if (\"development\" !== 'production' && !elmToMove) {\n\t            warn(\n\t              'It seems there are duplicate keys that is causing an update error. ' +\n\t              'Make sure each v-for item has a unique key.'\n\t            );\n\t          }\n\t          if (elmToMove.tag !== newStartVnode.tag) {\n\t            // same key but different element. treat as new element\n\t            nodeOps.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n\t            newStartVnode = newCh[++newStartIdx];\n\t          } else {\n\t            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n\t            oldCh[idxInOld] = undefined;\n\t            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n\t            newStartVnode = newCh[++newStartIdx];\n\t          }\n\t        }\n\t      }\n\t    }\n\t    if (oldStartIdx > oldEndIdx) {\n\t      before = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n\t      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n\t    } else if (newStartIdx > newEndIdx) {\n\t      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n\t    }\n\t  }\n\t\n\t  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n\t    if (oldVnode === vnode) {\n\t      return\n\t    }\n\t    // reuse element for static trees.\n\t    // note we only do this if the vnode is cloned -\n\t    // if the new node is not cloned it means the render functions have been\n\t    // reset by the hot-reload-api and we need to do a proper re-render.\n\t    if (vnode.isStatic &&\n\t        oldVnode.isStatic &&\n\t        vnode.key === oldVnode.key &&\n\t        vnode.isCloned) {\n\t      vnode.elm = oldVnode.elm;\n\t      return\n\t    }\n\t    var i;\n\t    var data = vnode.data;\n\t    var hasData = isDef(data);\n\t    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n\t      i(oldVnode, vnode);\n\t    }\n\t    var elm = vnode.elm = oldVnode.elm;\n\t    var oldCh = oldVnode.children;\n\t    var ch = vnode.children;\n\t    if (hasData && isPatchable(vnode)) {\n\t      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n\t      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n\t    }\n\t    if (isUndef(vnode.text)) {\n\t      if (isDef(oldCh) && isDef(ch)) {\n\t        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n\t      } else if (isDef(ch)) {\n\t        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n\t        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n\t      } else if (isDef(oldCh)) {\n\t        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n\t      } else if (isDef(oldVnode.text)) {\n\t        nodeOps.setTextContent(elm, '');\n\t      }\n\t    } else if (oldVnode.text !== vnode.text) {\n\t      nodeOps.setTextContent(elm, vnode.text);\n\t    }\n\t    if (hasData) {\n\t      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n\t    }\n\t  }\n\t\n\t  function invokeInsertHook (vnode, queue, initial) {\n\t    // delay insert hooks for component root nodes, invoke them after the\n\t    // element is really inserted\n\t    if (initial && vnode.parent) {\n\t      vnode.parent.data.pendingInsert = queue;\n\t    } else {\n\t      for (var i = 0; i < queue.length; ++i) {\n\t        queue[i].data.hook.insert(queue[i]);\n\t      }\n\t    }\n\t  }\n\t\n\t  var bailed = false;\n\t  function hydrate (elm, vnode, insertedVnodeQueue) {\n\t    {\n\t      if (!assertNodeMatch(elm, vnode)) {\n\t        return false\n\t      }\n\t    }\n\t    vnode.elm = elm;\n\t    var tag = vnode.tag;\n\t    var data = vnode.data;\n\t    var children = vnode.children;\n\t    if (isDef(data)) {\n\t      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n\t      if (isDef(i = vnode.child)) {\n\t        // child component. it should have hydrated its own tree.\n\t        initComponent(vnode, insertedVnodeQueue);\n\t        return true\n\t      }\n\t    }\n\t    if (isDef(tag)) {\n\t      if (isDef(children)) {\n\t        var childNodes = nodeOps.childNodes(elm);\n\t        // empty element, allow client to pick up and populate children\n\t        if (!childNodes.length) {\n\t          createChildren(vnode, children, insertedVnodeQueue);\n\t        } else {\n\t          var childrenMatch = true;\n\t          if (childNodes.length !== children.length) {\n\t            childrenMatch = false;\n\t          } else {\n\t            for (var i$1 = 0; i$1 < children.length; i$1++) {\n\t              if (!hydrate(childNodes[i$1], children[i$1], insertedVnodeQueue)) {\n\t                childrenMatch = false;\n\t                break\n\t              }\n\t            }\n\t          }\n\t          if (!childrenMatch) {\n\t            if (\"development\" !== 'production' &&\n\t                typeof console !== 'undefined' &&\n\t                !bailed) {\n\t              bailed = true;\n\t              console.warn('Parent: ', elm);\n\t              console.warn('Mismatching childNodes vs. VNodes: ', childNodes, children);\n\t            }\n\t            return false\n\t          }\n\t        }\n\t      }\n\t      if (isDef(data)) {\n\t        invokeCreateHooks(vnode, insertedVnodeQueue);\n\t      }\n\t    }\n\t    return true\n\t  }\n\t\n\t  function assertNodeMatch (node, vnode) {\n\t    if (vnode.tag) {\n\t      return (\n\t        vnode.tag.indexOf('vue-component') === 0 ||\n\t        vnode.tag === nodeOps.tagName(node).toLowerCase()\n\t      )\n\t    } else {\n\t      return _toString(vnode.text) === node.data\n\t    }\n\t  }\n\t\n\t  return function patch (oldVnode, vnode, hydrating, removeOnly) {\n\t    if (!vnode) {\n\t      if (oldVnode) { invokeDestroyHook(oldVnode); }\n\t      return\n\t    }\n\t\n\t    var elm, parent;\n\t    var isInitialPatch = false;\n\t    var insertedVnodeQueue = [];\n\t\n\t    if (!oldVnode) {\n\t      // empty mount, create new root element\n\t      isInitialPatch = true;\n\t      createElm(vnode, insertedVnodeQueue);\n\t    } else {\n\t      var isRealElement = isDef(oldVnode.nodeType);\n\t      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n\t        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n\t      } else {\n\t        if (isRealElement) {\n\t          // mounting to a real element\n\t          // check if this is server-rendered content and if we can perform\n\t          // a successful hydration.\n\t          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {\n\t            oldVnode.removeAttribute('server-rendered');\n\t            hydrating = true;\n\t          }\n\t          if (hydrating) {\n\t            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n\t              invokeInsertHook(vnode, insertedVnodeQueue, true);\n\t              return oldVnode\n\t            } else {\n\t              warn(\n\t                'The client-side rendered virtual DOM tree is not matching ' +\n\t                'server-rendered content. This is likely caused by incorrect ' +\n\t                'HTML markup, for example nesting block-level elements inside ' +\n\t                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n\t                'full client-side render.'\n\t              );\n\t            }\n\t          }\n\t          // either not server-rendered, or hydration failed.\n\t          // create an empty node and replace it\n\t          oldVnode = emptyNodeAt(oldVnode);\n\t        }\n\t        elm = oldVnode.elm;\n\t        parent = nodeOps.parentNode(elm);\n\t\n\t        createElm(vnode, insertedVnodeQueue);\n\t\n\t        // component root element replaced.\n\t        // update parent placeholder node element.\n\t        if (vnode.parent) {\n\t          vnode.parent.elm = vnode.elm;\n\t          if (isPatchable(vnode)) {\n\t            for (var i = 0; i < cbs.create.length; ++i) {\n\t              cbs.create[i](emptyNode, vnode.parent);\n\t            }\n\t          }\n\t        }\n\t\n\t        if (parent !== null) {\n\t          nodeOps.insertBefore(parent, vnode.elm, nodeOps.nextSibling(elm));\n\t          removeVnodes(parent, [oldVnode], 0, 0);\n\t        } else if (isDef(oldVnode.tag)) {\n\t          invokeDestroyHook(oldVnode);\n\t        }\n\t      }\n\t    }\n\t\n\t    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n\t    return vnode.elm\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar directives = {\n\t  create: updateDirectives,\n\t  update: updateDirectives,\n\t  destroy: function unbindDirectives (vnode) {\n\t    updateDirectives(vnode, emptyNode);\n\t  }\n\t};\n\t\n\tfunction updateDirectives (\n\t  oldVnode,\n\t  vnode\n\t) {\n\t  if (!oldVnode.data.directives && !vnode.data.directives) {\n\t    return\n\t  }\n\t  var isCreate = oldVnode === emptyNode;\n\t  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n\t  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\t\n\t  var dirsWithInsert = [];\n\t  var dirsWithPostpatch = [];\n\t\n\t  var key, oldDir, dir;\n\t  for (key in newDirs) {\n\t    oldDir = oldDirs[key];\n\t    dir = newDirs[key];\n\t    if (!oldDir) {\n\t      // new directive, bind\n\t      callHook$1(dir, 'bind', vnode, oldVnode);\n\t      if (dir.def && dir.def.inserted) {\n\t        dirsWithInsert.push(dir);\n\t      }\n\t    } else {\n\t      // existing directive, update\n\t      dir.oldValue = oldDir.value;\n\t      callHook$1(dir, 'update', vnode, oldVnode);\n\t      if (dir.def && dir.def.componentUpdated) {\n\t        dirsWithPostpatch.push(dir);\n\t      }\n\t    }\n\t  }\n\t\n\t  if (dirsWithInsert.length) {\n\t    var callInsert = function () {\n\t      dirsWithInsert.forEach(function (dir) {\n\t        callHook$1(dir, 'inserted', vnode, oldVnode);\n\t      });\n\t    };\n\t    if (isCreate) {\n\t      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert, 'dir-insert');\n\t    } else {\n\t      callInsert();\n\t    }\n\t  }\n\t\n\t  if (dirsWithPostpatch.length) {\n\t    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n\t      dirsWithPostpatch.forEach(function (dir) {\n\t        callHook$1(dir, 'componentUpdated', vnode, oldVnode);\n\t      });\n\t    }, 'dir-postpatch');\n\t  }\n\t\n\t  if (!isCreate) {\n\t    for (key in oldDirs) {\n\t      if (!newDirs[key]) {\n\t        // no longer present, unbind\n\t        callHook$1(oldDirs[key], 'unbind', oldVnode);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tvar emptyModifiers = Object.create(null);\n\t\n\tfunction normalizeDirectives$1 (\n\t  dirs,\n\t  vm\n\t) {\n\t  var res = Object.create(null);\n\t  if (!dirs) {\n\t    return res\n\t  }\n\t  var i, dir;\n\t  for (i = 0; i < dirs.length; i++) {\n\t    dir = dirs[i];\n\t    if (!dir.modifiers) {\n\t      dir.modifiers = emptyModifiers;\n\t    }\n\t    res[getRawDirName(dir)] = dir;\n\t    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n\t  }\n\t  return res\n\t}\n\t\n\tfunction getRawDirName (dir) {\n\t  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n\t}\n\t\n\tfunction callHook$1 (dir, hook, vnode, oldVnode) {\n\t  var fn = dir.def && dir.def[hook];\n\t  if (fn) {\n\t    fn(vnode.elm, dir, vnode, oldVnode);\n\t  }\n\t}\n\t\n\tvar baseModules = [\n\t  ref,\n\t  directives\n\t];\n\t\n\t/*  */\n\t\n\tfunction updateAttrs (oldVnode, vnode) {\n\t  if (!oldVnode.data.attrs && !vnode.data.attrs) {\n\t    return\n\t  }\n\t  var key, cur, old;\n\t  var elm = vnode.elm;\n\t  var oldAttrs = oldVnode.data.attrs || {};\n\t  var attrs = vnode.data.attrs || {};\n\t  // clone observed objects, as the user probably wants to mutate it\n\t  if (attrs.__ob__) {\n\t    attrs = vnode.data.attrs = extend({}, attrs);\n\t  }\n\t\n\t  for (key in attrs) {\n\t    cur = attrs[key];\n\t    old = oldAttrs[key];\n\t    if (old !== cur) {\n\t      setAttr(elm, key, cur);\n\t    }\n\t  }\n\t  for (key in oldAttrs) {\n\t    if (attrs[key] == null) {\n\t      if (isXlink(key)) {\n\t        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n\t      } else if (!isEnumeratedAttr(key)) {\n\t        elm.removeAttribute(key);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction setAttr (el, key, value) {\n\t  if (isBooleanAttr(key)) {\n\t    // set attribute for blank value\n\t    // e.g. <option disabled>Select one</option>\n\t    if (isFalsyAttrValue(value)) {\n\t      el.removeAttribute(key);\n\t    } else {\n\t      el.setAttribute(key, key);\n\t    }\n\t  } else if (isEnumeratedAttr(key)) {\n\t    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n\t  } else if (isXlink(key)) {\n\t    if (isFalsyAttrValue(value)) {\n\t      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n\t    } else {\n\t      el.setAttributeNS(xlinkNS, key, value);\n\t    }\n\t  } else {\n\t    if (isFalsyAttrValue(value)) {\n\t      el.removeAttribute(key);\n\t    } else {\n\t      el.setAttribute(key, value);\n\t    }\n\t  }\n\t}\n\t\n\tvar attrs = {\n\t  create: updateAttrs,\n\t  update: updateAttrs\n\t};\n\t\n\t/*  */\n\t\n\tfunction updateClass (oldVnode, vnode) {\n\t  var el = vnode.elm;\n\t  var data = vnode.data;\n\t  var oldData = oldVnode.data;\n\t  if (!data.staticClass && !data.class &&\n\t      (!oldData || (!oldData.staticClass && !oldData.class))) {\n\t    return\n\t  }\n\t\n\t  var cls = genClassForVnode(vnode);\n\t\n\t  // handle transition classes\n\t  var transitionClass = el._transitionClasses;\n\t  if (transitionClass) {\n\t    cls = concat(cls, stringifyClass(transitionClass));\n\t  }\n\t\n\t  // set the class\n\t  if (cls !== el._prevClass) {\n\t    el.setAttribute('class', cls);\n\t    el._prevClass = cls;\n\t  }\n\t}\n\t\n\tvar klass = {\n\t  create: updateClass,\n\t  update: updateClass\n\t};\n\t\n\t// skip type checking this file because we need to attach private properties\n\t// to elements\n\t\n\tfunction updateDOMListeners (oldVnode, vnode) {\n\t  if (!oldVnode.data.on && !vnode.data.on) {\n\t    return\n\t  }\n\t  var on = vnode.data.on || {};\n\t  var oldOn = oldVnode.data.on || {};\n\t  var add = vnode.elm._v_add || (vnode.elm._v_add = function (event, handler, capture) {\n\t    vnode.elm.addEventListener(event, handler, capture);\n\t  });\n\t  var remove = vnode.elm._v_remove || (vnode.elm._v_remove = function (event, handler) {\n\t    vnode.elm.removeEventListener(event, handler);\n\t  });\n\t  updateListeners(on, oldOn, add, remove, vnode.context);\n\t}\n\t\n\tvar events = {\n\t  create: updateDOMListeners,\n\t  update: updateDOMListeners\n\t};\n\t\n\t/*  */\n\t\n\tfunction updateDOMProps (oldVnode, vnode) {\n\t  if (!oldVnode.data.domProps && !vnode.data.domProps) {\n\t    return\n\t  }\n\t  var key, cur;\n\t  var elm = vnode.elm;\n\t  var oldProps = oldVnode.data.domProps || {};\n\t  var props = vnode.data.domProps || {};\n\t  // clone observed objects, as the user probably wants to mutate it\n\t  if (props.__ob__) {\n\t    props = vnode.data.domProps = extend({}, props);\n\t  }\n\t\n\t  for (key in oldProps) {\n\t    if (props[key] == null) {\n\t      elm[key] = undefined;\n\t    }\n\t  }\n\t  for (key in props) {\n\t    // ignore children if the node has textContent or innerHTML,\n\t    // as these will throw away existing DOM nodes and cause removal errors\n\t    // on subsequent patches (#3360)\n\t    if ((key === 'textContent' || key === 'innerHTML') && vnode.children) {\n\t      vnode.children.length = 0;\n\t    }\n\t    cur = props[key];\n\t    if (key === 'value') {\n\t      // store value as _value as well since\n\t      // non-string values will be stringified\n\t      elm._value = cur;\n\t      // avoid resetting cursor position when value is the same\n\t      var strCur = cur == null ? '' : String(cur);\n\t      if (elm.value !== strCur && !elm.composing) {\n\t        elm.value = strCur;\n\t      }\n\t    } else {\n\t      elm[key] = cur;\n\t    }\n\t  }\n\t}\n\t\n\tvar domProps = {\n\t  create: updateDOMProps,\n\t  update: updateDOMProps\n\t};\n\t\n\t/*  */\n\t\n\tvar prefixes = ['Webkit', 'Moz', 'ms'];\n\t\n\tvar testEl;\n\tvar normalize = cached(function (prop) {\n\t  testEl = testEl || document.createElement('div');\n\t  prop = camelize(prop);\n\t  if (prop !== 'filter' && (prop in testEl.style)) {\n\t    return prop\n\t  }\n\t  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n\t  for (var i = 0; i < prefixes.length; i++) {\n\t    var prefixed = prefixes[i] + upper;\n\t    if (prefixed in testEl.style) {\n\t      return prefixed\n\t    }\n\t  }\n\t});\n\t\n\tfunction updateStyle (oldVnode, vnode) {\n\t  if ((!oldVnode.data || !oldVnode.data.style) && !vnode.data.style) {\n\t    return\n\t  }\n\t  var cur, name;\n\t  var el = vnode.elm;\n\t  var oldStyle = oldVnode.data.style || {};\n\t  var style = vnode.data.style || {};\n\t\n\t  // handle string\n\t  if (typeof style === 'string') {\n\t    el.style.cssText = style;\n\t    return\n\t  }\n\t\n\t  var needClone = style.__ob__;\n\t\n\t  // handle array syntax\n\t  if (Array.isArray(style)) {\n\t    style = vnode.data.style = toObject(style);\n\t  }\n\t\n\t  // clone the style for future updates,\n\t  // in case the user mutates the style object in-place.\n\t  if (needClone) {\n\t    style = vnode.data.style = extend({}, style);\n\t  }\n\t\n\t  for (name in oldStyle) {\n\t    if (style[name] == null) {\n\t      el.style[normalize(name)] = '';\n\t    }\n\t  }\n\t  for (name in style) {\n\t    cur = style[name];\n\t    if (cur !== oldStyle[name]) {\n\t      // ie9 setting to null has no effect, must use empty string\n\t      el.style[normalize(name)] = cur == null ? '' : cur;\n\t    }\n\t  }\n\t}\n\t\n\tvar style = {\n\t  create: updateStyle,\n\t  update: updateStyle\n\t};\n\t\n\t/*  */\n\t\n\t/**\n\t * Add class with compatibility for SVG since classList is not supported on\n\t * SVG elements in IE\n\t */\n\tfunction addClass (el, cls) {\n\t  /* istanbul ignore else */\n\t  if (el.classList) {\n\t    if (cls.indexOf(' ') > -1) {\n\t      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n\t    } else {\n\t      el.classList.add(cls);\n\t    }\n\t  } else {\n\t    var cur = ' ' + el.getAttribute('class') + ' ';\n\t    if (cur.indexOf(' ' + cls + ' ') < 0) {\n\t      el.setAttribute('class', (cur + cls).trim());\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Remove class with compatibility for SVG since classList is not supported on\n\t * SVG elements in IE\n\t */\n\tfunction removeClass (el, cls) {\n\t  /* istanbul ignore else */\n\t  if (el.classList) {\n\t    if (cls.indexOf(' ') > -1) {\n\t      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n\t    } else {\n\t      el.classList.remove(cls);\n\t    }\n\t  } else {\n\t    var cur = ' ' + el.getAttribute('class') + ' ';\n\t    var tar = ' ' + cls + ' ';\n\t    while (cur.indexOf(tar) >= 0) {\n\t      cur = cur.replace(tar, ' ');\n\t    }\n\t    el.setAttribute('class', cur.trim());\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar hasTransition = inBrowser && !isIE9;\n\tvar TRANSITION = 'transition';\n\tvar ANIMATION = 'animation';\n\t\n\t// Transition property/event sniffing\n\tvar transitionProp = 'transition';\n\tvar transitionEndEvent = 'transitionend';\n\tvar animationProp = 'animation';\n\tvar animationEndEvent = 'animationend';\n\tif (hasTransition) {\n\t  /* istanbul ignore if */\n\t  if (window.ontransitionend === undefined &&\n\t    window.onwebkittransitionend !== undefined) {\n\t    transitionProp = 'WebkitTransition';\n\t    transitionEndEvent = 'webkitTransitionEnd';\n\t  }\n\t  if (window.onanimationend === undefined &&\n\t    window.onwebkitanimationend !== undefined) {\n\t    animationProp = 'WebkitAnimation';\n\t    animationEndEvent = 'webkitAnimationEnd';\n\t  }\n\t}\n\t\n\tvar raf = (inBrowser && window.requestAnimationFrame) || setTimeout;\n\tfunction nextFrame (fn) {\n\t  raf(function () {\n\t    raf(fn);\n\t  });\n\t}\n\t\n\tfunction addTransitionClass (el, cls) {\n\t  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n\t  addClass(el, cls);\n\t}\n\t\n\tfunction removeTransitionClass (el, cls) {\n\t  if (el._transitionClasses) {\n\t    remove$1(el._transitionClasses, cls);\n\t  }\n\t  removeClass(el, cls);\n\t}\n\t\n\tfunction whenTransitionEnds (\n\t  el,\n\t  expectedType,\n\t  cb\n\t) {\n\t  var ref = getTransitionInfo(el, expectedType);\n\t  var type = ref.type;\n\t  var timeout = ref.timeout;\n\t  var propCount = ref.propCount;\n\t  if (!type) { return cb() }\n\t  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n\t  var ended = 0;\n\t  var end = function () {\n\t    el.removeEventListener(event, onEnd);\n\t    cb();\n\t  };\n\t  var onEnd = function (e) {\n\t    if (e.target === el) {\n\t      if (++ended >= propCount) {\n\t        end();\n\t      }\n\t    }\n\t  };\n\t  setTimeout(function () {\n\t    if (ended < propCount) {\n\t      end();\n\t    }\n\t  }, timeout + 1);\n\t  el.addEventListener(event, onEnd);\n\t}\n\t\n\tvar transformRE = /\\b(transform|all)(,|$)/;\n\t\n\tfunction getTransitionInfo (el, expectedType) {\n\t  var styles = window.getComputedStyle(el);\n\t  var transitioneDelays = styles[transitionProp + 'Delay'].split(', ');\n\t  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n\t  var transitionTimeout = getTimeout(transitioneDelays, transitionDurations);\n\t  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n\t  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n\t  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\t\n\t  var type;\n\t  var timeout = 0;\n\t  var propCount = 0;\n\t  /* istanbul ignore if */\n\t  if (expectedType === TRANSITION) {\n\t    if (transitionTimeout > 0) {\n\t      type = TRANSITION;\n\t      timeout = transitionTimeout;\n\t      propCount = transitionDurations.length;\n\t    }\n\t  } else if (expectedType === ANIMATION) {\n\t    if (animationTimeout > 0) {\n\t      type = ANIMATION;\n\t      timeout = animationTimeout;\n\t      propCount = animationDurations.length;\n\t    }\n\t  } else {\n\t    timeout = Math.max(transitionTimeout, animationTimeout);\n\t    type = timeout > 0\n\t      ? transitionTimeout > animationTimeout\n\t        ? TRANSITION\n\t        : ANIMATION\n\t      : null;\n\t    propCount = type\n\t      ? type === TRANSITION\n\t        ? transitionDurations.length\n\t        : animationDurations.length\n\t      : 0;\n\t  }\n\t  var hasTransform =\n\t    type === TRANSITION &&\n\t    transformRE.test(styles[transitionProp + 'Property']);\n\t  return {\n\t    type: type,\n\t    timeout: timeout,\n\t    propCount: propCount,\n\t    hasTransform: hasTransform\n\t  }\n\t}\n\t\n\tfunction getTimeout (delays, durations) {\n\t  return Math.max.apply(null, durations.map(function (d, i) {\n\t    return toMs(d) + toMs(delays[i])\n\t  }))\n\t}\n\t\n\tfunction toMs (s) {\n\t  return Number(s.slice(0, -1)) * 1000\n\t}\n\t\n\t/*  */\n\t\n\tfunction enter (vnode) {\n\t  var el = vnode.elm;\n\t\n\t  // call leave callback now\n\t  if (el._leaveCb) {\n\t    el._leaveCb.cancelled = true;\n\t    el._leaveCb();\n\t  }\n\t\n\t  var data = resolveTransition(vnode.data.transition);\n\t  if (!data) {\n\t    return\n\t  }\n\t\n\t  /* istanbul ignore if */\n\t  if (el._enterCb || el.nodeType !== 1) {\n\t    return\n\t  }\n\t\n\t  var css = data.css;\n\t  var type = data.type;\n\t  var enterClass = data.enterClass;\n\t  var enterActiveClass = data.enterActiveClass;\n\t  var appearClass = data.appearClass;\n\t  var appearActiveClass = data.appearActiveClass;\n\t  var beforeEnter = data.beforeEnter;\n\t  var enter = data.enter;\n\t  var afterEnter = data.afterEnter;\n\t  var enterCancelled = data.enterCancelled;\n\t  var beforeAppear = data.beforeAppear;\n\t  var appear = data.appear;\n\t  var afterAppear = data.afterAppear;\n\t  var appearCancelled = data.appearCancelled;\n\t\n\t  // activeInstance will always be the <transition> component managing this\n\t  // transition. One edge case to check is when the <transition> is placed\n\t  // as the root node of a child component. In that case we need to check\n\t  // <transition>'s parent for appear check.\n\t  var transitionNode = activeInstance.$vnode;\n\t  var context = transitionNode && transitionNode.parent\n\t    ? transitionNode.parent.context\n\t    : activeInstance;\n\t\n\t  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\t\n\t  if (isAppear && !appear && appear !== '') {\n\t    return\n\t  }\n\t\n\t  var startClass = isAppear ? appearClass : enterClass;\n\t  var activeClass = isAppear ? appearActiveClass : enterActiveClass;\n\t  var beforeEnterHook = isAppear ? (beforeAppear || beforeEnter) : beforeEnter;\n\t  var enterHook = isAppear ? (typeof appear === 'function' ? appear : enter) : enter;\n\t  var afterEnterHook = isAppear ? (afterAppear || afterEnter) : afterEnter;\n\t  var enterCancelledHook = isAppear ? (appearCancelled || enterCancelled) : enterCancelled;\n\t\n\t  var expectsCSS = css !== false && !isIE9;\n\t  var userWantsControl =\n\t    enterHook &&\n\t    // enterHook may be a bound method which exposes\n\t    // the length of original fn as _length\n\t    (enterHook._length || enterHook.length) > 1;\n\t\n\t  var cb = el._enterCb = once(function () {\n\t    if (expectsCSS) {\n\t      removeTransitionClass(el, activeClass);\n\t    }\n\t    if (cb.cancelled) {\n\t      if (expectsCSS) {\n\t        removeTransitionClass(el, startClass);\n\t      }\n\t      enterCancelledHook && enterCancelledHook(el);\n\t    } else {\n\t      afterEnterHook && afterEnterHook(el);\n\t    }\n\t    el._enterCb = null;\n\t  });\n\t\n\t  if (!vnode.data.show) {\n\t    // remove pending leave element on enter by injecting an insert hook\n\t    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n\t      var parent = el.parentNode;\n\t      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n\t      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n\t        pendingNode.elm._leaveCb();\n\t      }\n\t      enterHook && enterHook(el, cb);\n\t    }, 'transition-insert');\n\t  }\n\t\n\t  // start enter transition\n\t  beforeEnterHook && beforeEnterHook(el);\n\t  if (expectsCSS) {\n\t    addTransitionClass(el, startClass);\n\t    addTransitionClass(el, activeClass);\n\t    nextFrame(function () {\n\t      removeTransitionClass(el, startClass);\n\t      if (!cb.cancelled && !userWantsControl) {\n\t        whenTransitionEnds(el, type, cb);\n\t      }\n\t    });\n\t  }\n\t\n\t  if (vnode.data.show) {\n\t    enterHook && enterHook(el, cb);\n\t  }\n\t\n\t  if (!expectsCSS && !userWantsControl) {\n\t    cb();\n\t  }\n\t}\n\t\n\tfunction leave (vnode, rm) {\n\t  var el = vnode.elm;\n\t\n\t  // call enter callback now\n\t  if (el._enterCb) {\n\t    el._enterCb.cancelled = true;\n\t    el._enterCb();\n\t  }\n\t\n\t  var data = resolveTransition(vnode.data.transition);\n\t  if (!data) {\n\t    return rm()\n\t  }\n\t\n\t  /* istanbul ignore if */\n\t  if (el._leaveCb || el.nodeType !== 1) {\n\t    return\n\t  }\n\t\n\t  var css = data.css;\n\t  var type = data.type;\n\t  var leaveClass = data.leaveClass;\n\t  var leaveActiveClass = data.leaveActiveClass;\n\t  var beforeLeave = data.beforeLeave;\n\t  var leave = data.leave;\n\t  var afterLeave = data.afterLeave;\n\t  var leaveCancelled = data.leaveCancelled;\n\t  var delayLeave = data.delayLeave;\n\t\n\t  var expectsCSS = css !== false && !isIE9;\n\t  var userWantsControl =\n\t    leave &&\n\t    // leave hook may be a bound method which exposes\n\t    // the length of original fn as _length\n\t    (leave._length || leave.length) > 1;\n\t\n\t  var cb = el._leaveCb = once(function () {\n\t    if (el.parentNode && el.parentNode._pending) {\n\t      el.parentNode._pending[vnode.key] = null;\n\t    }\n\t    if (expectsCSS) {\n\t      removeTransitionClass(el, leaveActiveClass);\n\t    }\n\t    if (cb.cancelled) {\n\t      if (expectsCSS) {\n\t        removeTransitionClass(el, leaveClass);\n\t      }\n\t      leaveCancelled && leaveCancelled(el);\n\t    } else {\n\t      rm();\n\t      afterLeave && afterLeave(el);\n\t    }\n\t    el._leaveCb = null;\n\t  });\n\t\n\t  if (delayLeave) {\n\t    delayLeave(performLeave);\n\t  } else {\n\t    performLeave();\n\t  }\n\t\n\t  function performLeave () {\n\t    // the delayed leave may have already been cancelled\n\t    if (cb.cancelled) {\n\t      return\n\t    }\n\t    // record leaving element\n\t    if (!vnode.data.show) {\n\t      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n\t    }\n\t    beforeLeave && beforeLeave(el);\n\t    if (expectsCSS) {\n\t      addTransitionClass(el, leaveClass);\n\t      addTransitionClass(el, leaveActiveClass);\n\t      nextFrame(function () {\n\t        removeTransitionClass(el, leaveClass);\n\t        if (!cb.cancelled && !userWantsControl) {\n\t          whenTransitionEnds(el, type, cb);\n\t        }\n\t      });\n\t    }\n\t    leave && leave(el, cb);\n\t    if (!expectsCSS && !userWantsControl) {\n\t      cb();\n\t    }\n\t  }\n\t}\n\t\n\tfunction resolveTransition (def$$1) {\n\t  if (!def$$1) {\n\t    return\n\t  }\n\t  /* istanbul ignore else */\n\t  if (typeof def$$1 === 'object') {\n\t    var res = {};\n\t    if (def$$1.css !== false) {\n\t      extend(res, autoCssTransition(def$$1.name || 'v'));\n\t    }\n\t    extend(res, def$$1);\n\t    return res\n\t  } else if (typeof def$$1 === 'string') {\n\t    return autoCssTransition(def$$1)\n\t  }\n\t}\n\t\n\tvar autoCssTransition = cached(function (name) {\n\t  return {\n\t    enterClass: (name + \"-enter\"),\n\t    leaveClass: (name + \"-leave\"),\n\t    appearClass: (name + \"-enter\"),\n\t    enterActiveClass: (name + \"-enter-active\"),\n\t    leaveActiveClass: (name + \"-leave-active\"),\n\t    appearActiveClass: (name + \"-enter-active\")\n\t  }\n\t});\n\t\n\tfunction once (fn) {\n\t  var called = false;\n\t  return function () {\n\t    if (!called) {\n\t      called = true;\n\t      fn();\n\t    }\n\t  }\n\t}\n\t\n\tvar transition = inBrowser ? {\n\t  create: function create (_, vnode) {\n\t    if (!vnode.data.show) {\n\t      enter(vnode);\n\t    }\n\t  },\n\t  remove: function remove (vnode, rm) {\n\t    /* istanbul ignore else */\n\t    if (!vnode.data.show) {\n\t      leave(vnode, rm);\n\t    } else {\n\t      rm();\n\t    }\n\t  }\n\t} : {};\n\t\n\tvar platformModules = [\n\t  attrs,\n\t  klass,\n\t  events,\n\t  domProps,\n\t  style,\n\t  transition\n\t];\n\t\n\t/*  */\n\t\n\t// the directive module should be applied last, after all\n\t// built-in modules have been applied.\n\tvar modules = platformModules.concat(baseModules);\n\t\n\tvar patch$1 = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\t\n\t/**\n\t * Not type checking this file because flow doesn't like attaching\n\t * properties to Elements.\n\t */\n\t\n\tvar modelableTagRE = /^input|select|textarea|vue-component-[0-9]+(-[0-9a-zA-Z_\\-]*)?$/;\n\t\n\t/* istanbul ignore if */\n\tif (isIE9) {\n\t  // http://www.matts411.com/post/internet-explorer-9-oninput/\n\t  document.addEventListener('selectionchange', function () {\n\t    var el = document.activeElement;\n\t    if (el && el.vmodel) {\n\t      trigger(el, 'input');\n\t    }\n\t  });\n\t}\n\t\n\tvar model = {\n\t  inserted: function inserted (el, binding, vnode) {\n\t    {\n\t      if (!modelableTagRE.test(vnode.tag)) {\n\t        warn(\n\t          \"v-model is not supported on element type: <\" + (vnode.tag) + \">. \" +\n\t          'If you are working with contenteditable, it\\'s recommended to ' +\n\t          'wrap a library dedicated for that purpose inside a custom component.',\n\t          vnode.context\n\t        );\n\t      }\n\t    }\n\t    if (vnode.tag === 'select') {\n\t      var cb = function () {\n\t        setSelected(el, binding, vnode.context);\n\t      };\n\t      cb();\n\t      /* istanbul ignore if */\n\t      if (isIE || isEdge) {\n\t        setTimeout(cb, 0);\n\t      }\n\t    } else if (\n\t      (vnode.tag === 'textarea' || el.type === 'text') &&\n\t      !binding.modifiers.lazy\n\t    ) {\n\t      if (!isAndroid) {\n\t        el.addEventListener('compositionstart', onCompositionStart);\n\t        el.addEventListener('compositionend', onCompositionEnd);\n\t      }\n\t      /* istanbul ignore if */\n\t      if (isIE9) {\n\t        el.vmodel = true;\n\t      }\n\t    }\n\t  },\n\t  componentUpdated: function componentUpdated (el, binding, vnode) {\n\t    if (vnode.tag === 'select') {\n\t      setSelected(el, binding, vnode.context);\n\t      // in case the options rendered by v-for have changed,\n\t      // it's possible that the value is out-of-sync with the rendered options.\n\t      // detect such cases and filter out values that no longer has a matchig\n\t      // option in the DOM.\n\t      var needReset = el.multiple\n\t        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n\t        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n\t      if (needReset) {\n\t        trigger(el, 'change');\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\tfunction setSelected (el, binding, vm) {\n\t  var value = binding.value;\n\t  var isMultiple = el.multiple;\n\t  if (isMultiple && !Array.isArray(value)) {\n\t    \"development\" !== 'production' && warn(\n\t      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n\t      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n\t      vm\n\t    );\n\t    return\n\t  }\n\t  var selected, option;\n\t  for (var i = 0, l = el.options.length; i < l; i++) {\n\t    option = el.options[i];\n\t    if (isMultiple) {\n\t      selected = looseIndexOf(value, getValue(option)) > -1;\n\t      if (option.selected !== selected) {\n\t        option.selected = selected;\n\t      }\n\t    } else {\n\t      if (looseEqual(getValue(option), value)) {\n\t        if (el.selectedIndex !== i) {\n\t          el.selectedIndex = i;\n\t        }\n\t        return\n\t      }\n\t    }\n\t  }\n\t  if (!isMultiple) {\n\t    el.selectedIndex = -1;\n\t  }\n\t}\n\t\n\tfunction hasNoMatchingOption (value, options) {\n\t  for (var i = 0, l = options.length; i < l; i++) {\n\t    if (looseEqual(getValue(options[i]), value)) {\n\t      return false\n\t    }\n\t  }\n\t  return true\n\t}\n\t\n\tfunction getValue (option) {\n\t  return '_value' in option\n\t    ? option._value\n\t    : option.value\n\t}\n\t\n\tfunction onCompositionStart (e) {\n\t  e.target.composing = true;\n\t}\n\t\n\tfunction onCompositionEnd (e) {\n\t  e.target.composing = false;\n\t  trigger(e.target, 'input');\n\t}\n\t\n\tfunction trigger (el, type) {\n\t  var e = document.createEvent('HTMLEvents');\n\t  e.initEvent(type, true, true);\n\t  el.dispatchEvent(e);\n\t}\n\t\n\t/*  */\n\t\n\t// recursively search for possible transition defined inside the component root\n\tfunction locateNode (vnode) {\n\t  return vnode.child && (!vnode.data || !vnode.data.transition)\n\t    ? locateNode(vnode.child._vnode)\n\t    : vnode\n\t}\n\t\n\tvar show = {\n\t  bind: function bind (el, ref, vnode) {\n\t    var value = ref.value;\n\t\n\t    vnode = locateNode(vnode);\n\t    var transition = vnode.data && vnode.data.transition;\n\t    if (value && transition && !isIE9) {\n\t      enter(vnode);\n\t    }\n\t    var originalDisplay = el.style.display === 'none' ? '' : el.style.display;\n\t    el.style.display = value ? originalDisplay : 'none';\n\t    el.__vOriginalDisplay = originalDisplay;\n\t  },\n\t  update: function update (el, ref, vnode) {\n\t    var value = ref.value;\n\t    var oldValue = ref.oldValue;\n\t\n\t    /* istanbul ignore if */\n\t    if (value === oldValue) { return }\n\t    vnode = locateNode(vnode);\n\t    var transition = vnode.data && vnode.data.transition;\n\t    if (transition && !isIE9) {\n\t      if (value) {\n\t        enter(vnode);\n\t        el.style.display = el.__vOriginalDisplay;\n\t      } else {\n\t        leave(vnode, function () {\n\t          el.style.display = 'none';\n\t        });\n\t      }\n\t    } else {\n\t      el.style.display = value ? el.__vOriginalDisplay : 'none';\n\t    }\n\t  }\n\t};\n\t\n\tvar platformDirectives = {\n\t  model: model,\n\t  show: show\n\t};\n\t\n\t/*  */\n\t\n\t// Provides transition support for a single element/component.\n\t// supports transition mode (out-in / in-out)\n\t\n\tvar transitionProps = {\n\t  name: String,\n\t  appear: Boolean,\n\t  css: Boolean,\n\t  mode: String,\n\t  type: String,\n\t  enterClass: String,\n\t  leaveClass: String,\n\t  enterActiveClass: String,\n\t  leaveActiveClass: String,\n\t  appearClass: String,\n\t  appearActiveClass: String\n\t};\n\t\n\t// in case the child is also an abstract component, e.g. <keep-alive>\n\t// we want to recrusively retrieve the real component to be rendered\n\tfunction getRealChild (vnode) {\n\t  var compOptions = vnode && vnode.componentOptions;\n\t  if (compOptions && compOptions.Ctor.options.abstract) {\n\t    return getRealChild(getFirstComponentChild(compOptions.children))\n\t  } else {\n\t    return vnode\n\t  }\n\t}\n\t\n\tfunction extractTransitionData (comp) {\n\t  var data = {};\n\t  var options = comp.$options;\n\t  // props\n\t  for (var key in options.propsData) {\n\t    data[key] = comp[key];\n\t  }\n\t  // events.\n\t  // extract listeners and pass them directly to the transition methods\n\t  var listeners = options._parentListeners;\n\t  for (var key$1 in listeners) {\n\t    data[camelize(key$1)] = listeners[key$1].fn;\n\t  }\n\t  return data\n\t}\n\t\n\tfunction placeholder (h, rawChild) {\n\t  return /\\d-keep-alive$/.test(rawChild.tag)\n\t    ? h('keep-alive')\n\t    : null\n\t}\n\t\n\tfunction hasParentTransition (vnode) {\n\t  while ((vnode = vnode.parent)) {\n\t    if (vnode.data.transition) {\n\t      return true\n\t    }\n\t  }\n\t}\n\t\n\tvar Transition = {\n\t  name: 'transition',\n\t  props: transitionProps,\n\t  abstract: true,\n\t  render: function render (h) {\n\t    var this$1 = this;\n\t\n\t    var children = this.$slots.default;\n\t    if (!children) {\n\t      return\n\t    }\n\t\n\t    // filter out text nodes (possible whitespaces)\n\t    children = children.filter(function (c) { return c.tag; });\n\t    /* istanbul ignore if */\n\t    if (!children.length) {\n\t      return\n\t    }\n\t\n\t    // warn multiple elements\n\t    if (\"development\" !== 'production' && children.length > 1) {\n\t      warn(\n\t        '<transition> can only be used on a single element. Use ' +\n\t        '<transition-group> for lists.',\n\t        this.$parent\n\t      );\n\t    }\n\t\n\t    var mode = this.mode;\n\t\n\t    // warn invalid mode\n\t    if (\"development\" !== 'production' &&\n\t        mode && mode !== 'in-out' && mode !== 'out-in') {\n\t      warn(\n\t        'invalid <transition> mode: ' + mode,\n\t        this.$parent\n\t      );\n\t    }\n\t\n\t    var rawChild = children[0];\n\t\n\t    // if this is a component root node and the component's\n\t    // parent container node also has transition, skip.\n\t    if (hasParentTransition(this.$vnode)) {\n\t      return rawChild\n\t    }\n\t\n\t    // apply transition data to child\n\t    // use getRealChild() to ignore abstract components e.g. keep-alive\n\t    var child = getRealChild(rawChild);\n\t    /* istanbul ignore if */\n\t    if (!child) {\n\t      return rawChild\n\t    }\n\t\n\t    if (this._leaving) {\n\t      return placeholder(h, rawChild)\n\t    }\n\t\n\t    var key = child.key = child.key == null || child.isStatic\n\t      ? (\"__v\" + (child.tag + this._uid) + \"__\")\n\t      : child.key;\n\t    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n\t    var oldRawChild = this._vnode;\n\t    var oldChild = getRealChild(oldRawChild);\n\t\n\t    // mark v-show\n\t    // so that the transition module can hand over the control to the directive\n\t    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n\t      child.data.show = true;\n\t    }\n\t\n\t    if (oldChild && oldChild.data && oldChild.key !== key) {\n\t      // replace old child transition data with fresh one\n\t      // important for dynamic transitions!\n\t      var oldData = oldChild.data.transition = extend({}, data);\n\t\n\t      // handle transition mode\n\t      if (mode === 'out-in') {\n\t        // return placeholder node and queue update when leave finishes\n\t        this._leaving = true;\n\t        mergeVNodeHook(oldData, 'afterLeave', function () {\n\t          this$1._leaving = false;\n\t          this$1.$forceUpdate();\n\t        }, key);\n\t        return placeholder(h, rawChild)\n\t      } else if (mode === 'in-out') {\n\t        var delayedLeave;\n\t        var performLeave = function () { delayedLeave(); };\n\t        mergeVNodeHook(data, 'afterEnter', performLeave, key);\n\t        mergeVNodeHook(data, 'enterCancelled', performLeave, key);\n\t        mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n\t          delayedLeave = leave;\n\t        }, key);\n\t      }\n\t    }\n\t\n\t    return rawChild\n\t  }\n\t};\n\t\n\t/*  */\n\t\n\t// Provides transition support for list items.\n\t// supports move transitions using the FLIP technique.\n\t\n\t// Because the vdom's children update algorithm is \"unstable\" - i.e.\n\t// it doesn't guarantee the relative positioning of removed elements,\n\t// we force transition-group to update its children into two passes:\n\t// in the first pass, we remove all nodes that need to be removed,\n\t// triggering their leaving transition; in the second pass, we insert/move\n\t// into the final disired state. This way in the second pass removed\n\t// nodes will remain where they should be.\n\t\n\tvar props = extend({\n\t  tag: String,\n\t  moveClass: String\n\t}, transitionProps);\n\t\n\tdelete props.mode;\n\t\n\tvar TransitionGroup = {\n\t  props: props,\n\t\n\t  render: function render (h) {\n\t    var tag = this.tag || this.$vnode.data.tag || 'span';\n\t    var map = Object.create(null);\n\t    var prevChildren = this.prevChildren = this.children;\n\t    var rawChildren = this.$slots.default || [];\n\t    var children = this.children = [];\n\t    var transitionData = extractTransitionData(this);\n\t\n\t    for (var i = 0; i < rawChildren.length; i++) {\n\t      var c = rawChildren[i];\n\t      if (c.tag) {\n\t        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n\t          children.push(c);\n\t          map[c.key] = c\n\t          ;(c.data || (c.data = {})).transition = transitionData;\n\t        } else {\n\t          var opts = c.componentOptions;\n\t          var name = opts\n\t            ? (opts.Ctor.options.name || opts.tag)\n\t            : c.tag;\n\t          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n\t        }\n\t      }\n\t    }\n\t\n\t    if (prevChildren) {\n\t      var kept = [];\n\t      var removed = [];\n\t      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n\t        var c$1 = prevChildren[i$1];\n\t        c$1.data.transition = transitionData;\n\t        c$1.data.pos = c$1.elm.getBoundingClientRect();\n\t        if (map[c$1.key]) {\n\t          kept.push(c$1);\n\t        } else {\n\t          removed.push(c$1);\n\t        }\n\t      }\n\t      this.kept = h(tag, null, kept);\n\t      this.removed = removed;\n\t    }\n\t\n\t    return h(tag, null, children)\n\t  },\n\t\n\t  beforeUpdate: function beforeUpdate () {\n\t    // force removing pass\n\t    this.__patch__(\n\t      this._vnode,\n\t      this.kept,\n\t      false, // hydrating\n\t      true // removeOnly (!important, avoids unnecessary moves)\n\t    );\n\t    this._vnode = this.kept;\n\t  },\n\t\n\t  updated: function updated () {\n\t    var children = this.prevChildren;\n\t    var moveClass = this.moveClass || (this.name + '-move');\n\t    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n\t      return\n\t    }\n\t\n\t    // we divide the work into three loops to avoid mixing DOM reads and writes\n\t    // in each iteration - which helps prevent layout thrashing.\n\t    children.forEach(callPendingCbs);\n\t    children.forEach(recordPosition);\n\t    children.forEach(applyTranslation);\n\t\n\t    // force reflow to put everything in position\n\t    var f = document.body.offsetHeight; // eslint-disable-line\n\t\n\t    children.forEach(function (c) {\n\t      if (c.data.moved) {\n\t        var el = c.elm;\n\t        var s = el.style;\n\t        addTransitionClass(el, moveClass);\n\t        s.transform = s.WebkitTransform = s.transitionDuration = '';\n\t        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n\t          if (!e || /transform$/.test(e.propertyName)) {\n\t            el.removeEventListener(transitionEndEvent, cb);\n\t            el._moveCb = null;\n\t            removeTransitionClass(el, moveClass);\n\t          }\n\t        });\n\t      }\n\t    });\n\t  },\n\t\n\t  methods: {\n\t    hasMove: function hasMove (el, moveClass) {\n\t      /* istanbul ignore if */\n\t      if (!hasTransition) {\n\t        return false\n\t      }\n\t      if (this._hasMove != null) {\n\t        return this._hasMove\n\t      }\n\t      addTransitionClass(el, moveClass);\n\t      var info = getTransitionInfo(el);\n\t      removeTransitionClass(el, moveClass);\n\t      return (this._hasMove = info.hasTransform)\n\t    }\n\t  }\n\t};\n\t\n\tfunction callPendingCbs (c) {\n\t  /* istanbul ignore if */\n\t  if (c.elm._moveCb) {\n\t    c.elm._moveCb();\n\t  }\n\t  /* istanbul ignore if */\n\t  if (c.elm._enterCb) {\n\t    c.elm._enterCb();\n\t  }\n\t}\n\t\n\tfunction recordPosition (c) {\n\t  c.data.newPos = c.elm.getBoundingClientRect();\n\t}\n\t\n\tfunction applyTranslation (c) {\n\t  var oldPos = c.data.pos;\n\t  var newPos = c.data.newPos;\n\t  var dx = oldPos.left - newPos.left;\n\t  var dy = oldPos.top - newPos.top;\n\t  if (dx || dy) {\n\t    c.data.moved = true;\n\t    var s = c.elm.style;\n\t    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n\t    s.transitionDuration = '0s';\n\t  }\n\t}\n\t\n\tvar platformComponents = {\n\t  Transition: Transition,\n\t  TransitionGroup: TransitionGroup\n\t};\n\t\n\t/*  */\n\t\n\t// install platform specific utils\n\tVue$3.config.isUnknownElement = isUnknownElement;\n\tVue$3.config.isReservedTag = isReservedTag;\n\tVue$3.config.getTagNamespace = getTagNamespace;\n\tVue$3.config.mustUseProp = mustUseProp;\n\t\n\t// install platform runtime directives & components\n\textend(Vue$3.options.directives, platformDirectives);\n\textend(Vue$3.options.components, platformComponents);\n\t\n\t// install platform patch function\n\tVue$3.prototype.__patch__ = config._isServer ? noop : patch$1;\n\t\n\t// wrap mount\n\tVue$3.prototype.$mount = function (\n\t  el,\n\t  hydrating\n\t) {\n\t  el = el && !config._isServer ? query(el) : undefined;\n\t  return this._mount(el, hydrating)\n\t};\n\t\n\t// devtools global hook\n\t/* istanbul ignore next */\n\tsetTimeout(function () {\n\t  if (config.devtools) {\n\t    if (devtools) {\n\t      devtools.emit('init', Vue$3);\n\t    } else if (\n\t      \"development\" !== 'production' &&\n\t      inBrowser && /Chrome\\/\\d+/.test(window.navigator.userAgent)\n\t    ) {\n\t      console.log(\n\t        'Download the Vue Devtools for a better development experience:\\n' +\n\t        'https://github.com/vuejs/vue-devtools'\n\t      );\n\t    }\n\t  }\n\t}, 0);\n\t\n\t/*  */\n\t\n\t// check whether current browser encodes a char inside attribute values\n\tfunction shouldDecode (content, encoded) {\n\t  var div = document.createElement('div');\n\t  div.innerHTML = \"<div a=\\\"\" + content + \"\\\">\";\n\t  return div.innerHTML.indexOf(encoded) > 0\n\t}\n\t\n\t// #3663\n\t// IE encodes newlines inside attribute values while other browsers don't\n\tvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\t\n\t/*  */\n\t\n\tvar decoder = document.createElement('div');\n\t\n\tfunction decode (html) {\n\t  decoder.innerHTML = html;\n\t  return decoder.textContent\n\t}\n\t\n\t/**\n\t * Not type-checking this file because it's mostly vendor code.\n\t */\n\t\n\t/*!\n\t * HTML Parser By John Resig (ejohn.org)\n\t * Modified by Juriy \"kangax\" Zaytsev\n\t * Original code by Erik Arvidsson, Mozilla Public License\n\t * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n\t */\n\t\n\t// Regular Expressions for parsing tags and attributes\n\tvar singleAttrIdentifier = /([^\\s\"'<>\\/=]+)/;\n\tvar singleAttrAssign = /(?:=)/;\n\tvar singleAttrValues = [\n\t  // attr value double quotes\n\t  /\"([^\"]*)\"+/.source,\n\t  // attr value, single quotes\n\t  /'([^']*)'+/.source,\n\t  // attr value, no quotes\n\t  /([^\\s\"'=<>`]+)/.source\n\t];\n\tvar attribute = new RegExp(\n\t  '^\\\\s*' + singleAttrIdentifier.source +\n\t  '(?:\\\\s*(' + singleAttrAssign.source + ')' +\n\t  '\\\\s*(?:' + singleAttrValues.join('|') + '))?'\n\t);\n\t\n\t// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n\t// but for Vue templates we can enforce a simple charset\n\tvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\n\tvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\n\tvar startTagOpen = new RegExp('^<' + qnameCapture);\n\tvar startTagClose = /^\\s*(\\/?)>/;\n\tvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\n\tvar doctype = /^<!DOCTYPE [^>]+>/i;\n\t\n\tvar IS_REGEX_CAPTURING_BROKEN = false;\n\t'x'.replace(/x(.)?/g, function (m, g) {\n\t  IS_REGEX_CAPTURING_BROKEN = g === '';\n\t});\n\t\n\t// Special Elements (can contain anything)\n\tvar isSpecialTag = makeMap('script,style', true);\n\t\n\tvar reCache = {};\n\t\n\tvar ltRE = /&lt;/g;\n\tvar gtRE = /&gt;/g;\n\tvar nlRE = /&#10;/g;\n\tvar ampRE = /&amp;/g;\n\tvar quoteRE = /&quot;/g;\n\t\n\tfunction decodeAttr (value, shouldDecodeNewlines) {\n\t  if (shouldDecodeNewlines) {\n\t    value = value.replace(nlRE, '\\n');\n\t  }\n\t  return value\n\t    .replace(ltRE, '<')\n\t    .replace(gtRE, '>')\n\t    .replace(ampRE, '&')\n\t    .replace(quoteRE, '\"')\n\t}\n\t\n\tfunction parseHTML (html, options) {\n\t  var stack = [];\n\t  var expectHTML = options.expectHTML;\n\t  var isUnaryTag$$1 = options.isUnaryTag || no;\n\t  var index = 0;\n\t  var last, lastTag;\n\t  while (html) {\n\t    last = html;\n\t    // Make sure we're not in a script or style element\n\t    if (!lastTag || !isSpecialTag(lastTag)) {\n\t      var textEnd = html.indexOf('<');\n\t      if (textEnd === 0) {\n\t        // Comment:\n\t        if (/^<!--/.test(html)) {\n\t          var commentEnd = html.indexOf('-->');\n\t\n\t          if (commentEnd >= 0) {\n\t            advance(commentEnd + 3);\n\t            continue\n\t          }\n\t        }\n\t\n\t        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n\t        if (/^<!\\[/.test(html)) {\n\t          var conditionalEnd = html.indexOf(']>');\n\t\n\t          if (conditionalEnd >= 0) {\n\t            advance(conditionalEnd + 2);\n\t            continue\n\t          }\n\t        }\n\t\n\t        // Doctype:\n\t        var doctypeMatch = html.match(doctype);\n\t        if (doctypeMatch) {\n\t          advance(doctypeMatch[0].length);\n\t          continue\n\t        }\n\t\n\t        // End tag:\n\t        var endTagMatch = html.match(endTag);\n\t        if (endTagMatch) {\n\t          var curIndex = index;\n\t          advance(endTagMatch[0].length);\n\t          parseEndTag(endTagMatch[0], endTagMatch[1], curIndex, index);\n\t          continue\n\t        }\n\t\n\t        // Start tag:\n\t        var startTagMatch = parseStartTag();\n\t        if (startTagMatch) {\n\t          handleStartTag(startTagMatch);\n\t          continue\n\t        }\n\t      }\n\t\n\t      var text = void 0;\n\t      if (textEnd >= 0) {\n\t        text = html.substring(0, textEnd);\n\t        advance(textEnd);\n\t      } else {\n\t        text = html;\n\t        html = '';\n\t      }\n\t\n\t      if (options.chars) {\n\t        options.chars(text);\n\t      }\n\t    } else {\n\t      var stackedTag = lastTag.toLowerCase();\n\t      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n\t      var endTagLength = 0;\n\t      var rest = html.replace(reStackedTag, function (all, text, endTag) {\n\t        endTagLength = endTag.length;\n\t        if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {\n\t          text = text\n\t            .replace(/<!--([\\s\\S]*?)-->/g, '$1')\n\t            .replace(/<!\\[CDATA\\[([\\s\\S]*?)\\]\\]>/g, '$1');\n\t        }\n\t        if (options.chars) {\n\t          options.chars(text);\n\t        }\n\t        return ''\n\t      });\n\t      index += html.length - rest.length;\n\t      html = rest;\n\t      parseEndTag('</' + stackedTag + '>', stackedTag, index - endTagLength, index);\n\t    }\n\t\n\t    if (html === last) {\n\t      throw new Error('Error parsing template:\\n\\n' + html)\n\t    }\n\t  }\n\t\n\t  // Clean up any remaining tags\n\t  parseEndTag();\n\t\n\t  function advance (n) {\n\t    index += n;\n\t    html = html.substring(n);\n\t  }\n\t\n\t  function parseStartTag () {\n\t    var start = html.match(startTagOpen);\n\t    if (start) {\n\t      var match = {\n\t        tagName: start[1],\n\t        attrs: [],\n\t        start: index\n\t      };\n\t      advance(start[0].length);\n\t      var end, attr;\n\t      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n\t        advance(attr[0].length);\n\t        match.attrs.push(attr);\n\t      }\n\t      if (end) {\n\t        match.unarySlash = end[1];\n\t        advance(end[0].length);\n\t        match.end = index;\n\t        return match\n\t      }\n\t    }\n\t  }\n\t\n\t  function handleStartTag (match) {\n\t    var tagName = match.tagName;\n\t    var unarySlash = match.unarySlash;\n\t\n\t    if (expectHTML) {\n\t      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n\t        parseEndTag('', lastTag);\n\t      }\n\t      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {\n\t        parseEndTag('', tagName);\n\t      }\n\t    }\n\t\n\t    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\t\n\t    var l = match.attrs.length;\n\t    var attrs = new Array(l);\n\t    for (var i = 0; i < l; i++) {\n\t      var args = match.attrs[i];\n\t      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n\t      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n\t        if (args[3] === '') { delete args[3]; }\n\t        if (args[4] === '') { delete args[4]; }\n\t        if (args[5] === '') { delete args[5]; }\n\t      }\n\t      var value = args[3] || args[4] || args[5] || '';\n\t      attrs[i] = {\n\t        name: args[1],\n\t        value: decodeAttr(\n\t          value,\n\t          options.shouldDecodeNewlines\n\t        )\n\t      };\n\t    }\n\t\n\t    if (!unary) {\n\t      stack.push({ tag: tagName, attrs: attrs });\n\t      lastTag = tagName;\n\t      unarySlash = '';\n\t    }\n\t\n\t    if (options.start) {\n\t      options.start(tagName, attrs, unary, match.start, match.end);\n\t    }\n\t  }\n\t\n\t  function parseEndTag (tag, tagName, start, end) {\n\t    var pos;\n\t    if (start == null) { start = index; }\n\t    if (end == null) { end = index; }\n\t\n\t    // Find the closest opened tag of the same type\n\t    if (tagName) {\n\t      var needle = tagName.toLowerCase();\n\t      for (pos = stack.length - 1; pos >= 0; pos--) {\n\t        if (stack[pos].tag.toLowerCase() === needle) {\n\t          break\n\t        }\n\t      }\n\t    } else {\n\t      // If no tag name is provided, clean shop\n\t      pos = 0;\n\t    }\n\t\n\t    if (pos >= 0) {\n\t      // Close all the open elements, up the stack\n\t      for (var i = stack.length - 1; i >= pos; i--) {\n\t        if (options.end) {\n\t          options.end(stack[i].tag, start, end);\n\t        }\n\t      }\n\t\n\t      // Remove the open elements from the stack\n\t      stack.length = pos;\n\t      lastTag = pos && stack[pos - 1].tag;\n\t    } else if (tagName.toLowerCase() === 'br') {\n\t      if (options.start) {\n\t        options.start(tagName, [], true, start, end);\n\t      }\n\t    } else if (tagName.toLowerCase() === 'p') {\n\t      if (options.start) {\n\t        options.start(tagName, [], false, start, end);\n\t      }\n\t      if (options.end) {\n\t        options.end(tagName, start, end);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction parseFilters (exp) {\n\t  var inSingle = false;\n\t  var inDouble = false;\n\t  var curly = 0;\n\t  var square = 0;\n\t  var paren = 0;\n\t  var lastFilterIndex = 0;\n\t  var c, prev, i, expression, filters;\n\t\n\t  for (i = 0; i < exp.length; i++) {\n\t    prev = c;\n\t    c = exp.charCodeAt(i);\n\t    if (inSingle) {\n\t      // check single quote\n\t      if (c === 0x27 && prev !== 0x5C) { inSingle = !inSingle; }\n\t    } else if (inDouble) {\n\t      // check double quote\n\t      if (c === 0x22 && prev !== 0x5C) { inDouble = !inDouble; }\n\t    } else if (\n\t      c === 0x7C && // pipe\n\t      exp.charCodeAt(i + 1) !== 0x7C &&\n\t      exp.charCodeAt(i - 1) !== 0x7C &&\n\t      !curly && !square && !paren\n\t    ) {\n\t      if (expression === undefined) {\n\t        // first filter, end of expression\n\t        lastFilterIndex = i + 1;\n\t        expression = exp.slice(0, i).trim();\n\t      } else {\n\t        pushFilter();\n\t      }\n\t    } else {\n\t      switch (c) {\n\t        case 0x22: inDouble = true; break // \"\n\t        case 0x27: inSingle = true; break // '\n\t        case 0x28: paren++; break         // (\n\t        case 0x29: paren--; break         // )\n\t        case 0x5B: square++; break        // [\n\t        case 0x5D: square--; break        // ]\n\t        case 0x7B: curly++; break         // {\n\t        case 0x7D: curly--; break         // }\n\t      }\n\t    }\n\t  }\n\t\n\t  if (expression === undefined) {\n\t    expression = exp.slice(0, i).trim();\n\t  } else if (lastFilterIndex !== 0) {\n\t    pushFilter();\n\t  }\n\t\n\t  function pushFilter () {\n\t    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n\t    lastFilterIndex = i + 1;\n\t  }\n\t\n\t  if (filters) {\n\t    for (i = 0; i < filters.length; i++) {\n\t      expression = wrapFilter(expression, filters[i]);\n\t    }\n\t  }\n\t\n\t  return expression\n\t}\n\t\n\tfunction wrapFilter (exp, filter) {\n\t  var i = filter.indexOf('(');\n\t  if (i < 0) {\n\t    // _f: resolveFilter\n\t    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n\t  } else {\n\t    var name = filter.slice(0, i);\n\t    var args = filter.slice(i + 1);\n\t    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\n\tvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\t\n\tvar buildRegex = cached(function (delimiters) {\n\t  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n\t  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n\t  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n\t});\n\t\n\tfunction parseText (\n\t  text,\n\t  delimiters\n\t) {\n\t  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n\t  if (!tagRE.test(text)) {\n\t    return\n\t  }\n\t  var tokens = [];\n\t  var lastIndex = tagRE.lastIndex = 0;\n\t  var match, index;\n\t  while ((match = tagRE.exec(text))) {\n\t    index = match.index;\n\t    // push text token\n\t    if (index > lastIndex) {\n\t      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n\t    }\n\t    // tag token\n\t    var exp = parseFilters(match[1].trim());\n\t    tokens.push((\"_s(\" + exp + \")\"));\n\t    lastIndex = index + match[0].length;\n\t  }\n\t  if (lastIndex < text.length) {\n\t    tokens.push(JSON.stringify(text.slice(lastIndex)));\n\t  }\n\t  return tokens.join('+')\n\t}\n\t\n\t/*  */\n\t\n\tfunction baseWarn (msg) {\n\t  console.error((\"[Vue parser]: \" + msg));\n\t}\n\t\n\tfunction pluckModuleFunction (\n\t  modules,\n\t  key\n\t) {\n\t  return modules\n\t    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n\t    : []\n\t}\n\t\n\tfunction addProp (el, name, value) {\n\t  (el.props || (el.props = [])).push({ name: name, value: value });\n\t}\n\t\n\tfunction addAttr (el, name, value) {\n\t  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n\t}\n\t\n\tfunction addDirective (\n\t  el,\n\t  name,\n\t  rawName,\n\t  value,\n\t  arg,\n\t  modifiers\n\t) {\n\t  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n\t}\n\t\n\tfunction addHandler (\n\t  el,\n\t  name,\n\t  value,\n\t  modifiers,\n\t  important\n\t) {\n\t  // check capture modifier\n\t  if (modifiers && modifiers.capture) {\n\t    delete modifiers.capture;\n\t    name = '!' + name; // mark the event as captured\n\t  }\n\t  var events;\n\t  if (modifiers && modifiers.native) {\n\t    delete modifiers.native;\n\t    events = el.nativeEvents || (el.nativeEvents = {});\n\t  } else {\n\t    events = el.events || (el.events = {});\n\t  }\n\t  var newHandler = { value: value, modifiers: modifiers };\n\t  var handlers = events[name];\n\t  /* istanbul ignore if */\n\t  if (Array.isArray(handlers)) {\n\t    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n\t  } else if (handlers) {\n\t    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n\t  } else {\n\t    events[name] = newHandler;\n\t  }\n\t}\n\t\n\tfunction getBindingAttr (\n\t  el,\n\t  name,\n\t  getStatic\n\t) {\n\t  var dynamicValue =\n\t    getAndRemoveAttr(el, ':' + name) ||\n\t    getAndRemoveAttr(el, 'v-bind:' + name);\n\t  if (dynamicValue != null) {\n\t    return dynamicValue\n\t  } else if (getStatic !== false) {\n\t    var staticValue = getAndRemoveAttr(el, name);\n\t    if (staticValue != null) {\n\t      return JSON.stringify(staticValue)\n\t    }\n\t  }\n\t}\n\t\n\tfunction getAndRemoveAttr (el, name) {\n\t  var val;\n\t  if ((val = el.attrsMap[name]) != null) {\n\t    var list = el.attrsList;\n\t    for (var i = 0, l = list.length; i < l; i++) {\n\t      if (list[i].name === name) {\n\t        list.splice(i, 1);\n\t        break\n\t      }\n\t    }\n\t  }\n\t  return val\n\t}\n\t\n\t/*  */\n\t\n\tvar dirRE = /^v-|^@|^:/;\n\tvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\n\tvar forIteratorRE = /\\(([^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\tvar bindRE = /^:|^v-bind:/;\n\tvar onRE = /^@|^v-on:/;\n\tvar argRE = /:(.*)$/;\n\tvar modifierRE = /\\.[^\\.]+/g;\n\tvar specialNewlineRE = /\\u2028|\\u2029/g;\n\t\n\tvar decodeHTMLCached = cached(decode);\n\t\n\t// configurable state\n\tvar warn$1;\n\tvar platformGetTagNamespace;\n\tvar platformMustUseProp;\n\tvar platformIsPreTag;\n\tvar preTransforms;\n\tvar transforms;\n\tvar postTransforms;\n\tvar delimiters;\n\t\n\t/**\n\t * Convert HTML string to AST.\n\t */\n\tfunction parse (\n\t  template,\n\t  options\n\t) {\n\t  warn$1 = options.warn || baseWarn;\n\t  platformGetTagNamespace = options.getTagNamespace || no;\n\t  platformMustUseProp = options.mustUseProp || no;\n\t  platformIsPreTag = options.isPreTag || no;\n\t  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n\t  transforms = pluckModuleFunction(options.modules, 'transformNode');\n\t  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\t  delimiters = options.delimiters;\n\t  var stack = [];\n\t  var preserveWhitespace = options.preserveWhitespace !== false;\n\t  var root;\n\t  var currentParent;\n\t  var inVPre = false;\n\t  var inPre = false;\n\t  var warned = false;\n\t  parseHTML(template, {\n\t    expectHTML: options.expectHTML,\n\t    isUnaryTag: options.isUnaryTag,\n\t    shouldDecodeNewlines: options.shouldDecodeNewlines,\n\t    start: function start (tag, attrs, unary) {\n\t      // check namespace.\n\t      // inherit parent ns if there is one\n\t      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\t\n\t      // handle IE svg bug\n\t      /* istanbul ignore if */\n\t      if (options.isIE && ns === 'svg') {\n\t        attrs = guardIESVGBug(attrs);\n\t      }\n\t\n\t      var element = {\n\t        type: 1,\n\t        tag: tag,\n\t        attrsList: attrs,\n\t        attrsMap: makeAttrsMap(attrs, options.isIE),\n\t        parent: currentParent,\n\t        children: []\n\t      };\n\t      if (ns) {\n\t        element.ns = ns;\n\t      }\n\t\n\t      if (\"client\" !== 'server' && isForbiddenTag(element)) {\n\t        element.forbidden = true;\n\t        \"development\" !== 'production' && warn$1(\n\t          'Templates should only be responsible for mapping the state to the ' +\n\t          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n\t          \"<\" + tag + \">.\"\n\t        );\n\t      }\n\t\n\t      // apply pre-transforms\n\t      for (var i = 0; i < preTransforms.length; i++) {\n\t        preTransforms[i](element, options);\n\t      }\n\t\n\t      if (!inVPre) {\n\t        processPre(element);\n\t        if (element.pre) {\n\t          inVPre = true;\n\t        }\n\t      }\n\t      if (platformIsPreTag(element.tag)) {\n\t        inPre = true;\n\t      }\n\t      if (inVPre) {\n\t        processRawAttrs(element);\n\t      } else {\n\t        processFor(element);\n\t        processIf(element);\n\t        processOnce(element);\n\t        processKey(element);\n\t\n\t        // determine whether this is a plain element after\n\t        // removing structural attributes\n\t        element.plain = !element.key && !attrs.length;\n\t\n\t        processRef(element);\n\t        processSlot(element);\n\t        processComponent(element);\n\t        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n\t          transforms[i$1](element, options);\n\t        }\n\t        processAttrs(element);\n\t      }\n\t\n\t      function checkRootConstraints (el) {\n\t        {\n\t          if (el.tag === 'slot' || el.tag === 'template') {\n\t            warn$1(\n\t              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n\t              'contain multiple nodes:\\n' + template\n\t            );\n\t          }\n\t          if (el.attrsMap.hasOwnProperty('v-for')) {\n\t            warn$1(\n\t              'Cannot use v-for on stateful component root element because ' +\n\t              'it renders multiple elements:\\n' + template\n\t            );\n\t          }\n\t        }\n\t      }\n\t\n\t      // tree management\n\t      if (!root) {\n\t        root = element;\n\t        checkRootConstraints(root);\n\t      } else if (\"development\" !== 'production' && !stack.length && !warned) {\n\t        // allow 2 root elements with v-if and v-else\n\t        if (root.if && element.else) {\n\t          checkRootConstraints(element);\n\t          root.elseBlock = element;\n\t        } else {\n\t          warned = true;\n\t          warn$1(\n\t            (\"Component template should contain exactly one root element:\\n\\n\" + template)\n\t          );\n\t        }\n\t      }\n\t      if (currentParent && !element.forbidden) {\n\t        if (element.else) {\n\t          processElse(element, currentParent);\n\t        } else {\n\t          currentParent.children.push(element);\n\t          element.parent = currentParent;\n\t        }\n\t      }\n\t      if (!unary) {\n\t        currentParent = element;\n\t        stack.push(element);\n\t      }\n\t      // apply post-transforms\n\t      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n\t        postTransforms[i$2](element, options);\n\t      }\n\t    },\n\t\n\t    end: function end () {\n\t      // remove trailing whitespace\n\t      var element = stack[stack.length - 1];\n\t      var lastNode = element.children[element.children.length - 1];\n\t      if (lastNode && lastNode.type === 3 && lastNode.text === ' ') {\n\t        element.children.pop();\n\t      }\n\t      // pop stack\n\t      stack.length -= 1;\n\t      currentParent = stack[stack.length - 1];\n\t      // check pre state\n\t      if (element.pre) {\n\t        inVPre = false;\n\t      }\n\t      if (platformIsPreTag(element.tag)) {\n\t        inPre = false;\n\t      }\n\t    },\n\t\n\t    chars: function chars (text) {\n\t      if (!currentParent) {\n\t        if (\"development\" !== 'production' && !warned && text === template) {\n\t          warned = true;\n\t          warn$1(\n\t            'Component template requires a root element, rather than just text:\\n\\n' + template\n\t          );\n\t        }\n\t        return\n\t      }\n\t      text = inPre || text.trim()\n\t        ? decodeHTMLCached(text)\n\t        // only preserve whitespace if its not right after a starting tag\n\t        : preserveWhitespace && currentParent.children.length ? ' ' : '';\n\t      if (text) {\n\t        var expression;\n\t        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n\t          currentParent.children.push({\n\t            type: 2,\n\t            expression: expression,\n\t            text: text\n\t          });\n\t        } else {\n\t          // #3895 special character\n\t          text = text.replace(specialNewlineRE, '');\n\t          currentParent.children.push({\n\t            type: 3,\n\t            text: text\n\t          });\n\t        }\n\t      }\n\t    }\n\t  });\n\t  return root\n\t}\n\t\n\tfunction processPre (el) {\n\t  if (getAndRemoveAttr(el, 'v-pre') != null) {\n\t    el.pre = true;\n\t  }\n\t}\n\t\n\tfunction processRawAttrs (el) {\n\t  var l = el.attrsList.length;\n\t  if (l) {\n\t    var attrs = el.attrs = new Array(l);\n\t    for (var i = 0; i < l; i++) {\n\t      attrs[i] = {\n\t        name: el.attrsList[i].name,\n\t        value: JSON.stringify(el.attrsList[i].value)\n\t      };\n\t    }\n\t  } else if (!el.pre) {\n\t    // non root node in pre blocks with no attributes\n\t    el.plain = true;\n\t  }\n\t}\n\t\n\tfunction processKey (el) {\n\t  var exp = getBindingAttr(el, 'key');\n\t  if (exp) {\n\t    if (\"development\" !== 'production' && el.tag === 'template') {\n\t      warn$1(\"<template> cannot be keyed. Place the key on real elements instead.\");\n\t    }\n\t    el.key = exp;\n\t  }\n\t}\n\t\n\tfunction processRef (el) {\n\t  var ref = getBindingAttr(el, 'ref');\n\t  if (ref) {\n\t    el.ref = ref;\n\t    el.refInFor = checkInFor(el);\n\t  }\n\t}\n\t\n\tfunction processFor (el) {\n\t  var exp;\n\t  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n\t    var inMatch = exp.match(forAliasRE);\n\t    if (!inMatch) {\n\t      \"development\" !== 'production' && warn$1(\n\t        (\"Invalid v-for expression: \" + exp)\n\t      );\n\t      return\n\t    }\n\t    el.for = inMatch[2].trim();\n\t    var alias = inMatch[1].trim();\n\t    var iteratorMatch = alias.match(forIteratorRE);\n\t    if (iteratorMatch) {\n\t      el.alias = iteratorMatch[1].trim();\n\t      el.iterator1 = iteratorMatch[2].trim();\n\t      if (iteratorMatch[3]) {\n\t        el.iterator2 = iteratorMatch[3].trim();\n\t      }\n\t    } else {\n\t      el.alias = alias;\n\t    }\n\t  }\n\t}\n\t\n\tfunction processIf (el) {\n\t  var exp = getAndRemoveAttr(el, 'v-if');\n\t  if (exp) {\n\t    el.if = exp;\n\t  }\n\t  if (getAndRemoveAttr(el, 'v-else') != null) {\n\t    el.else = true;\n\t  }\n\t}\n\t\n\tfunction processElse (el, parent) {\n\t  var prev = findPrevElement(parent.children);\n\t  if (prev && prev.if) {\n\t    prev.elseBlock = el;\n\t  } else {\n\t    warn$1(\n\t      (\"v-else used on element <\" + (el.tag) + \"> without corresponding v-if.\")\n\t    );\n\t  }\n\t}\n\t\n\tfunction processOnce (el) {\n\t  var once = getAndRemoveAttr(el, 'v-once');\n\t  if (once != null) {\n\t    el.once = true;\n\t  }\n\t}\n\t\n\tfunction processSlot (el) {\n\t  if (el.tag === 'slot') {\n\t    el.slotName = getBindingAttr(el, 'name');\n\t  } else {\n\t    var slotTarget = getBindingAttr(el, 'slot');\n\t    if (slotTarget) {\n\t      el.slotTarget = slotTarget;\n\t    }\n\t  }\n\t}\n\t\n\tfunction processComponent (el) {\n\t  var binding;\n\t  if ((binding = getBindingAttr(el, 'is'))) {\n\t    el.component = binding;\n\t  }\n\t  if (getAndRemoveAttr(el, 'inline-template') != null) {\n\t    el.inlineTemplate = true;\n\t  }\n\t}\n\t\n\tfunction processAttrs (el) {\n\t  var list = el.attrsList;\n\t  var i, l, name, rawName, value, arg, modifiers, isProp;\n\t  for (i = 0, l = list.length; i < l; i++) {\n\t    name = rawName = list[i].name;\n\t    value = list[i].value;\n\t    if (dirRE.test(name)) {\n\t      // mark element as dynamic\n\t      el.hasBindings = true;\n\t      // modifiers\n\t      modifiers = parseModifiers(name);\n\t      if (modifiers) {\n\t        name = name.replace(modifierRE, '');\n\t      }\n\t      if (bindRE.test(name)) { // v-bind\n\t        name = name.replace(bindRE, '');\n\t        if (modifiers && modifiers.prop) {\n\t          isProp = true;\n\t          name = camelize(name);\n\t          if (name === 'innerHtml') { name = 'innerHTML'; }\n\t        }\n\t        if (isProp || platformMustUseProp(name)) {\n\t          addProp(el, name, value);\n\t        } else {\n\t          addAttr(el, name, value);\n\t        }\n\t      } else if (onRE.test(name)) { // v-on\n\t        name = name.replace(onRE, '');\n\t        addHandler(el, name, value, modifiers);\n\t      } else { // normal directives\n\t        name = name.replace(dirRE, '');\n\t        // parse arg\n\t        var argMatch = name.match(argRE);\n\t        if (argMatch && (arg = argMatch[1])) {\n\t          name = name.slice(0, -(arg.length + 1));\n\t        }\n\t        addDirective(el, name, rawName, value, arg, modifiers);\n\t        if (\"development\" !== 'production' && name === 'model') {\n\t          checkForAliasModel(el, value);\n\t        }\n\t      }\n\t    } else {\n\t      // literal attribute\n\t      {\n\t        var expression = parseText(value, delimiters);\n\t        if (expression) {\n\t          warn$1(\n\t            name + \"=\\\"\" + value + \"\\\": \" +\n\t            'Interpolation inside attributes has been deprecated. ' +\n\t            'Use v-bind or the colon shorthand instead.'\n\t          );\n\t        }\n\t      }\n\t      addAttr(el, name, JSON.stringify(value));\n\t    }\n\t  }\n\t}\n\t\n\tfunction checkInFor (el) {\n\t  var parent = el;\n\t  while (parent) {\n\t    if (parent.for !== undefined) {\n\t      return true\n\t    }\n\t    parent = parent.parent;\n\t  }\n\t  return false\n\t}\n\t\n\tfunction parseModifiers (name) {\n\t  var match = name.match(modifierRE);\n\t  if (match) {\n\t    var ret = {};\n\t    match.forEach(function (m) { ret[m.slice(1)] = true; });\n\t    return ret\n\t  }\n\t}\n\t\n\tfunction makeAttrsMap (attrs, isIE) {\n\t  var map = {};\n\t  for (var i = 0, l = attrs.length; i < l; i++) {\n\t    if (\"development\" !== 'production' && map[attrs[i].name] && !isIE) {\n\t      warn$1('duplicate attribute: ' + attrs[i].name);\n\t    }\n\t    map[attrs[i].name] = attrs[i].value;\n\t  }\n\t  return map\n\t}\n\t\n\tfunction findPrevElement (children) {\n\t  var i = children.length;\n\t  while (i--) {\n\t    if (children[i].tag) { return children[i] }\n\t  }\n\t}\n\t\n\tfunction isForbiddenTag (el) {\n\t  return (\n\t    el.tag === 'style' ||\n\t    (el.tag === 'script' && (\n\t      !el.attrsMap.type ||\n\t      el.attrsMap.type === 'text/javascript'\n\t    ))\n\t  )\n\t}\n\t\n\tvar ieNSBug = /^xmlns:NS\\d+/;\n\tvar ieNSPrefix = /^NS\\d+:/;\n\t\n\t/* istanbul ignore next */\n\tfunction guardIESVGBug (attrs) {\n\t  var res = [];\n\t  for (var i = 0; i < attrs.length; i++) {\n\t    var attr = attrs[i];\n\t    if (!ieNSBug.test(attr.name)) {\n\t      attr.name = attr.name.replace(ieNSPrefix, '');\n\t      res.push(attr);\n\t    }\n\t  }\n\t  return res\n\t}\n\t\n\tfunction checkForAliasModel (el, value) {\n\t  var _el = el;\n\t  while (_el) {\n\t    if (_el.for && _el.alias === value) {\n\t      warn$1(\n\t        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n\t        \"You are binding v-model directly to a v-for iteration alias. \" +\n\t        \"This will not be able to modify the v-for source array because \" +\n\t        \"writing to the alias is like modifying a function local variable. \" +\n\t        \"Consider using an array of objects and use v-model on an object property instead.\"\n\t      );\n\t    }\n\t    _el = _el.parent;\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar isStaticKey;\n\tvar isPlatformReservedTag;\n\t\n\tvar genStaticKeysCached = cached(genStaticKeys$1);\n\t\n\t/**\n\t * Goal of the optimizier: walk the generated template AST tree\n\t * and detect sub-trees that are purely static, i.e. parts of\n\t * the DOM that never needs to change.\n\t *\n\t * Once we detect these sub-trees, we can:\n\t *\n\t * 1. Hoist them into constants, so that we no longer need to\n\t *    create fresh nodes for them on each re-render;\n\t * 2. Completely skip them in the patching process.\n\t */\n\tfunction optimize (root, options) {\n\t  if (!root) { return }\n\t  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n\t  isPlatformReservedTag = options.isReservedTag || (function () { return false; });\n\t  // first pass: mark all non-static nodes.\n\t  markStatic(root);\n\t  // second pass: mark static roots.\n\t  markStaticRoots(root, false);\n\t}\n\t\n\tfunction genStaticKeys$1 (keys) {\n\t  return makeMap(\n\t    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n\t    (keys ? ',' + keys : '')\n\t  )\n\t}\n\t\n\tfunction markStatic (node) {\n\t  node.static = isStatic(node);\n\t  if (node.type === 1) {\n\t    for (var i = 0, l = node.children.length; i < l; i++) {\n\t      var child = node.children[i];\n\t      markStatic(child);\n\t      if (!child.static) {\n\t        node.static = false;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction markStaticRoots (node, isInFor) {\n\t  if (node.type === 1) {\n\t    if (node.once || node.static) {\n\t      node.staticRoot = true;\n\t      node.staticInFor = isInFor;\n\t      return\n\t    }\n\t    if (node.children) {\n\t      for (var i = 0, l = node.children.length; i < l; i++) {\n\t        markStaticRoots(node.children[i], isInFor || !!node.for);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction isStatic (node) {\n\t  if (node.type === 2) { // expression\n\t    return false\n\t  }\n\t  if (node.type === 3) { // text\n\t    return true\n\t  }\n\t  return !!(node.pre || (\n\t    !node.hasBindings && // no dynamic bindings\n\t    !node.if && !node.for && // not v-if or v-for or v-else\n\t    !isBuiltInTag(node.tag) && // not a built-in\n\t    isPlatformReservedTag(node.tag) && // not a component\n\t    !isDirectChildOfTemplateFor(node) &&\n\t    Object.keys(node).every(isStaticKey)\n\t  ))\n\t}\n\t\n\tfunction isDirectChildOfTemplateFor (node) {\n\t  while (node.parent) {\n\t    node = node.parent;\n\t    if (node.tag !== 'template') {\n\t      return false\n\t    }\n\t    if (node.for) {\n\t      return true\n\t    }\n\t  }\n\t  return false\n\t}\n\t\n\t/*  */\n\t\n\tvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\]|\\[\\d+\\]|\\[[A-Za-z_$][\\w$]*\\])*\\s*$/;\n\t\n\t// keyCode aliases\n\tvar keyCodes = {\n\t  esc: 27,\n\t  tab: 9,\n\t  enter: 13,\n\t  space: 32,\n\t  up: 38,\n\t  left: 37,\n\t  right: 39,\n\t  down: 40,\n\t  'delete': [8, 46]\n\t};\n\t\n\tvar modifierCode = {\n\t  stop: '$event.stopPropagation();',\n\t  prevent: '$event.preventDefault();',\n\t  self: 'if($event.target !== $event.currentTarget)return;'\n\t};\n\t\n\tfunction genHandlers (events, native) {\n\t  var res = native ? 'nativeOn:{' : 'on:{';\n\t  for (var name in events) {\n\t    res += \"\\\"\" + name + \"\\\":\" + (genHandler(events[name])) + \",\";\n\t  }\n\t  return res.slice(0, -1) + '}'\n\t}\n\t\n\tfunction genHandler (\n\t  handler\n\t) {\n\t  if (!handler) {\n\t    return 'function(){}'\n\t  } else if (Array.isArray(handler)) {\n\t    return (\"[\" + (handler.map(genHandler).join(',')) + \"]\")\n\t  } else if (!handler.modifiers) {\n\t    return simplePathRE.test(handler.value)\n\t      ? handler.value\n\t      : (\"function($event){\" + (handler.value) + \"}\")\n\t  } else {\n\t    var code = '';\n\t    var keys = [];\n\t    for (var key in handler.modifiers) {\n\t      if (modifierCode[key]) {\n\t        code += modifierCode[key];\n\t      } else {\n\t        keys.push(key);\n\t      }\n\t    }\n\t    if (keys.length) {\n\t      code = genKeyFilter(keys) + code;\n\t    }\n\t    var handlerCode = simplePathRE.test(handler.value)\n\t      ? handler.value + '($event)'\n\t      : handler.value;\n\t    return 'function($event){' + code + handlerCode + '}'\n\t  }\n\t}\n\t\n\tfunction genKeyFilter (keys) {\n\t  var code = keys.length === 1\n\t    ? normalizeKeyCode(keys[0])\n\t    : Array.prototype.concat.apply([], keys.map(normalizeKeyCode));\n\t  if (Array.isArray(code)) {\n\t    return (\"if(\" + (code.map(function (c) { return (\"$event.keyCode!==\" + c); }).join('&&')) + \")return;\")\n\t  } else {\n\t    return (\"if($event.keyCode!==\" + code + \")return;\")\n\t  }\n\t}\n\t\n\tfunction normalizeKeyCode (key) {\n\t  return (\n\t    parseInt(key, 10) || // number keyCode\n\t    keyCodes[key] || // built-in alias\n\t    (\"_k(\" + (JSON.stringify(key)) + \")\") // custom alias\n\t  )\n\t}\n\t\n\t/*  */\n\t\n\tfunction bind$2 (el, dir) {\n\t  el.wrapData = function (code) {\n\t    return (\"_b(\" + code + \",\" + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + \")\")\n\t  };\n\t}\n\t\n\tvar baseDirectives = {\n\t  bind: bind$2,\n\t  cloak: noop\n\t};\n\t\n\t/*  */\n\t\n\t// configurable state\n\tvar warn$2;\n\tvar transforms$1;\n\tvar dataGenFns;\n\tvar platformDirectives$1;\n\tvar staticRenderFns;\n\tvar currentOptions;\n\t\n\tfunction generate (\n\t  ast,\n\t  options\n\t) {\n\t  // save previous staticRenderFns so generate calls can be nested\n\t  var prevStaticRenderFns = staticRenderFns;\n\t  var currentStaticRenderFns = staticRenderFns = [];\n\t  currentOptions = options;\n\t  warn$2 = options.warn || baseWarn;\n\t  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n\t  dataGenFns = pluckModuleFunction(options.modules, 'genData');\n\t  platformDirectives$1 = options.directives || {};\n\t  var code = ast ? genElement(ast) : '_h(\"div\")';\n\t  staticRenderFns = prevStaticRenderFns;\n\t  return {\n\t    render: (\"with(this){return \" + code + \"}\"),\n\t    staticRenderFns: currentStaticRenderFns\n\t  }\n\t}\n\t\n\tfunction genElement (el) {\n\t  if (el.staticRoot && !el.staticProcessed) {\n\t    // hoist static sub-trees out\n\t    el.staticProcessed = true;\n\t    staticRenderFns.push((\"with(this){return \" + (genElement(el)) + \"}\"));\n\t    return (\"_m(\" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n\t  } else if (el.for && !el.forProcessed) {\n\t    return genFor(el)\n\t  } else if (el.if && !el.ifProcessed) {\n\t    return genIf(el)\n\t  } else if (el.tag === 'template' && !el.slotTarget) {\n\t    return genChildren(el) || 'void 0'\n\t  } else if (el.tag === 'slot') {\n\t    return genSlot(el)\n\t  } else {\n\t    // component or element\n\t    var code;\n\t    if (el.component) {\n\t      code = genComponent(el);\n\t    } else {\n\t      var data = genData(el);\n\t      var children = el.inlineTemplate ? null : genChildren(el);\n\t      code = \"_h('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n\t    }\n\t    // module transforms\n\t    for (var i = 0; i < transforms$1.length; i++) {\n\t      code = transforms$1[i](el, code);\n\t    }\n\t    return code\n\t  }\n\t}\n\t\n\tfunction genIf (el) {\n\t  var exp = el.if;\n\t  el.ifProcessed = true; // avoid recursion\n\t  return (\"(\" + exp + \")?\" + (genElement(el)) + \":\" + (genElse(el)))\n\t}\n\t\n\tfunction genElse (el) {\n\t  return el.elseBlock\n\t    ? genElement(el.elseBlock)\n\t    : '_e()'\n\t}\n\t\n\tfunction genFor (el) {\n\t  var exp = el.for;\n\t  var alias = el.alias;\n\t  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n\t  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\t  el.forProcessed = true; // avoid recursion\n\t  return \"_l((\" + exp + \"),\" +\n\t    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n\t      \"return \" + (genElement(el)) +\n\t    '})'\n\t}\n\t\n\tfunction genData (el) {\n\t  if (el.plain) {\n\t    return\n\t  }\n\t\n\t  var data = '{';\n\t\n\t  // directives first.\n\t  // directives may mutate the el's other properties before they are generated.\n\t  var dirs = genDirectives(el);\n\t  if (dirs) { data += dirs + ','; }\n\t\n\t  // key\n\t  if (el.key) {\n\t    data += \"key:\" + (el.key) + \",\";\n\t  }\n\t  // ref\n\t  if (el.ref) {\n\t    data += \"ref:\" + (el.ref) + \",\";\n\t  }\n\t  if (el.refInFor) {\n\t    data += \"refInFor:true,\";\n\t  }\n\t  // record original tag name for components using \"is\" attribute\n\t  if (el.component) {\n\t    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n\t  }\n\t  // slot target\n\t  if (el.slotTarget) {\n\t    data += \"slot:\" + (el.slotTarget) + \",\";\n\t  }\n\t  // module data generation functions\n\t  for (var i = 0; i < dataGenFns.length; i++) {\n\t    data += dataGenFns[i](el);\n\t  }\n\t  // attributes\n\t  if (el.attrs) {\n\t    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n\t  }\n\t  // DOM props\n\t  if (el.props) {\n\t    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n\t  }\n\t  // event handlers\n\t  if (el.events) {\n\t    data += (genHandlers(el.events)) + \",\";\n\t  }\n\t  if (el.nativeEvents) {\n\t    data += (genHandlers(el.nativeEvents, true)) + \",\";\n\t  }\n\t  // inline-template\n\t  if (el.inlineTemplate) {\n\t    var ast = el.children[0];\n\t    if (\"development\" !== 'production' && (\n\t      el.children.length > 1 || ast.type !== 1\n\t    )) {\n\t      warn$2('Inline-template components must have exactly one child element.');\n\t    }\n\t    if (ast.type === 1) {\n\t      var inlineRenderFns = generate(ast, currentOptions);\n\t      data += \"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\";\n\t    }\n\t  }\n\t  data = data.replace(/,$/, '') + '}';\n\t  // v-bind data wrap\n\t  if (el.wrapData) {\n\t    data = el.wrapData(data);\n\t  }\n\t  return data\n\t}\n\t\n\tfunction genDirectives (el) {\n\t  var dirs = el.directives;\n\t  if (!dirs) { return }\n\t  var res = 'directives:[';\n\t  var hasRuntime = false;\n\t  var i, l, dir, needRuntime;\n\t  for (i = 0, l = dirs.length; i < l; i++) {\n\t    dir = dirs[i];\n\t    needRuntime = true;\n\t    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n\t    if (gen) {\n\t      // compile-time directive that manipulates AST.\n\t      // returns true if it also needs a runtime counterpart.\n\t      needRuntime = !!gen(el, dir, warn$2);\n\t    }\n\t    if (needRuntime) {\n\t      hasRuntime = true;\n\t      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n\t    }\n\t  }\n\t  if (hasRuntime) {\n\t    return res.slice(0, -1) + ']'\n\t  }\n\t}\n\t\n\tfunction genChildren (el) {\n\t  if (el.children.length) {\n\t    return '[' + el.children.map(genNode).join(',') + ']'\n\t  }\n\t}\n\t\n\tfunction genNode (node) {\n\t  if (node.type === 1) {\n\t    return genElement(node)\n\t  } else {\n\t    return genText(node)\n\t  }\n\t}\n\t\n\tfunction genText (text) {\n\t  return text.type === 2\n\t    ? text.expression // no need for () because already wrapped in _s()\n\t    : JSON.stringify(text.text)\n\t}\n\t\n\tfunction genSlot (el) {\n\t  var slotName = el.slotName || '\"default\"';\n\t  var children = genChildren(el);\n\t  return children\n\t    ? (\"_t(\" + slotName + \",\" + children + \")\")\n\t    : (\"_t(\" + slotName + \")\")\n\t}\n\t\n\tfunction genComponent (el) {\n\t  var children = el.inlineTemplate ? null : genChildren(el);\n\t  return (\"_h(\" + (el.component) + \",\" + (genData(el)) + (children ? (\",\" + children) : '') + \")\")\n\t}\n\t\n\tfunction genProps (props) {\n\t  var res = '';\n\t  for (var i = 0; i < props.length; i++) {\n\t    var prop = props[i];\n\t    res += \"\\\"\" + (prop.name) + \"\\\":\" + (prop.value) + \",\";\n\t  }\n\t  return res.slice(0, -1)\n\t}\n\t\n\t/*  */\n\t\n\t/**\n\t * Compile a template.\n\t */\n\tfunction compile$1 (\n\t  template,\n\t  options\n\t) {\n\t  var ast = parse(template.trim(), options);\n\t  optimize(ast, options);\n\t  var code = generate(ast, options);\n\t  return {\n\t    ast: ast,\n\t    render: code.render,\n\t    staticRenderFns: code.staticRenderFns\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\t// operators like typeof, instanceof and in are allowed\n\tvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n\t  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n\t  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n\t  'extends,finally,continue,debugger,function,arguments'\n\t).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\t// check valid identifier for v-for\n\tvar identRE = /[A-Za-z_$][\\w$]*/;\n\t// strip strings in expressions\n\tvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\t\n\t// detect problematic expressions in a template\n\tfunction detectErrors (ast) {\n\t  var errors = [];\n\t  if (ast) {\n\t    checkNode(ast, errors);\n\t  }\n\t  return errors\n\t}\n\t\n\tfunction checkNode (node, errors) {\n\t  if (node.type === 1) {\n\t    for (var name in node.attrsMap) {\n\t      if (dirRE.test(name)) {\n\t        var value = node.attrsMap[name];\n\t        if (value) {\n\t          if (name === 'v-for') {\n\t            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n\t          } else {\n\t            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n\t          }\n\t        }\n\t      }\n\t    }\n\t    if (node.children) {\n\t      for (var i = 0; i < node.children.length; i++) {\n\t        checkNode(node.children[i], errors);\n\t      }\n\t    }\n\t  } else if (node.type === 2) {\n\t    checkExpression(node.expression, node.text, errors);\n\t  }\n\t}\n\t\n\tfunction checkFor (node, text, errors) {\n\t  checkExpression(node.for || '', text, errors);\n\t  checkIdentifier(node.alias, 'v-for alias', text, errors);\n\t  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n\t  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n\t}\n\t\n\tfunction checkIdentifier (ident, type, text, errors) {\n\t  if (typeof ident === 'string' && !identRE.test(ident)) {\n\t    errors.push((\"- invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text));\n\t  }\n\t}\n\t\n\tfunction checkExpression (exp, text, errors) {\n\t  try {\n\t    new Function((\"return \" + exp));\n\t  } catch (e) {\n\t    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n\t    if (keywordMatch) {\n\t      errors.push(\n\t        \"- avoid using JavaScript keyword as property name: \" +\n\t        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + text\n\t      );\n\t    } else {\n\t      errors.push((\"- invalid expression: \" + text));\n\t    }\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction transformNode (el, options) {\n\t  var warn = options.warn || baseWarn;\n\t  var staticClass = getAndRemoveAttr(el, 'class');\n\t  if (\"development\" !== 'production' && staticClass) {\n\t    var expression = parseText(staticClass, options.delimiters);\n\t    if (expression) {\n\t      warn(\n\t        \"class=\\\"\" + staticClass + \"\\\": \" +\n\t        'Interpolation inside attributes has been deprecated. ' +\n\t        'Use v-bind or the colon shorthand instead.'\n\t      );\n\t    }\n\t  }\n\t  if (staticClass) {\n\t    el.staticClass = JSON.stringify(staticClass);\n\t  }\n\t  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n\t  if (classBinding) {\n\t    el.classBinding = classBinding;\n\t  }\n\t}\n\t\n\tfunction genData$1 (el) {\n\t  var data = '';\n\t  if (el.staticClass) {\n\t    data += \"staticClass:\" + (el.staticClass) + \",\";\n\t  }\n\t  if (el.classBinding) {\n\t    data += \"class:\" + (el.classBinding) + \",\";\n\t  }\n\t  return data\n\t}\n\t\n\tvar klass$1 = {\n\t  staticKeys: ['staticClass'],\n\t  transformNode: transformNode,\n\t  genData: genData$1\n\t};\n\t\n\t/*  */\n\t\n\tfunction transformNode$1 (el) {\n\t  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n\t  if (styleBinding) {\n\t    el.styleBinding = styleBinding;\n\t  }\n\t}\n\t\n\tfunction genData$2 (el) {\n\t  return el.styleBinding\n\t    ? (\"style:(\" + (el.styleBinding) + \"),\")\n\t    : ''\n\t}\n\t\n\tvar style$1 = {\n\t  transformNode: transformNode$1,\n\t  genData: genData$2\n\t};\n\t\n\tvar modules$1 = [\n\t  klass$1,\n\t  style$1\n\t];\n\t\n\t/*  */\n\t\n\tvar warn$3;\n\t\n\tfunction model$1 (\n\t  el,\n\t  dir,\n\t  _warn\n\t) {\n\t  warn$3 = _warn;\n\t  var value = dir.value;\n\t  var modifiers = dir.modifiers;\n\t  var tag = el.tag;\n\t  var type = el.attrsMap.type;\n\t  {\n\t    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n\t    if (tag === 'input' && dynamicType) {\n\t      warn$3(\n\t        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\n\t        \"v-model does not support dynamic input types. Use v-if branches instead.\"\n\t      );\n\t    }\n\t  }\n\t  if (tag === 'select') {\n\t    genSelect(el, value);\n\t  } else if (tag === 'input' && type === 'checkbox') {\n\t    genCheckboxModel(el, value);\n\t  } else if (tag === 'input' && type === 'radio') {\n\t    genRadioModel(el, value);\n\t  } else {\n\t    genDefaultModel(el, value, modifiers);\n\t  }\n\t  // ensure runtime directive metadata\n\t  return true\n\t}\n\t\n\tfunction genCheckboxModel (el, value) {\n\t  if (\"development\" !== 'production' &&\n\t    el.attrsMap.checked != null) {\n\t    warn$3(\n\t      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" checked>:\\n\" +\n\t      \"inline checked attributes will be ignored when using v-model. \" +\n\t      'Declare initial values in the component\\'s data option instead.'\n\t    );\n\t  }\n\t  var valueBinding = getBindingAttr(el, 'value') || 'null';\n\t  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n\t  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n\t  addProp(el, 'checked',\n\t    \"Array.isArray(\" + value + \")\" +\n\t      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" +\n\t      \":_q(\" + value + \",\" + trueValueBinding + \")\"\n\t  );\n\t  addHandler(el, 'change',\n\t    \"var $$a=\" + value + \",\" +\n\t        '$$el=$event.target,' +\n\t        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n\t    'if(Array.isArray($$a)){' +\n\t      \"var $$v=\" + valueBinding + \",\" +\n\t          '$$i=_i($$a,$$v);' +\n\t      \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" +\n\t      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n\t    \"}else{\" + value + \"=$$c}\",\n\t    null, true\n\t  );\n\t}\n\t\n\tfunction genRadioModel (el, value) {\n\t  if (\"development\" !== 'production' &&\n\t    el.attrsMap.checked != null) {\n\t    warn$3(\n\t      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" checked>:\\n\" +\n\t      \"inline checked attributes will be ignored when using v-model. \" +\n\t      'Declare initial values in the component\\'s data option instead.'\n\t    );\n\t  }\n\t  var valueBinding = getBindingAttr(el, 'value') || 'null';\n\t  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n\t  addHandler(el, 'change', (value + \"=\" + valueBinding), null, true);\n\t}\n\t\n\tfunction genDefaultModel (\n\t  el,\n\t  value,\n\t  modifiers\n\t) {\n\t  {\n\t    if (el.tag === 'input' && el.attrsMap.value) {\n\t      warn$3(\n\t        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" value=\\\"\" + (el.attrsMap.value) + \"\\\">:\\n\" +\n\t        'inline value attributes will be ignored when using v-model. ' +\n\t        'Declare initial values in the component\\'s data option instead.'\n\t      );\n\t    }\n\t    if (el.tag === 'textarea' && el.children.length) {\n\t      warn$3(\n\t        \"<textarea v-model=\\\"\" + value + \"\\\">:\\n\" +\n\t        'inline content inside <textarea> will be ignored when using v-model. ' +\n\t        'Declare initial values in the component\\'s data option instead.'\n\t      );\n\t    }\n\t  }\n\t\n\t  var type = el.attrsMap.type;\n\t  var ref = modifiers || {};\n\t  var lazy = ref.lazy;\n\t  var number = ref.number;\n\t  var trim = ref.trim;\n\t  var event = lazy || (isIE && type === 'range') ? 'change' : 'input';\n\t  var needCompositionGuard = !lazy && type !== 'range';\n\t  var isNative = el.tag === 'input' || el.tag === 'textarea';\n\t\n\t  var valueExpression = isNative\n\t    ? (\"$event.target.value\" + (trim ? '.trim()' : ''))\n\t    : \"$event\";\n\t  var code = number || type === 'number'\n\t    ? (value + \"=_n(\" + valueExpression + \")\")\n\t    : (value + \"=\" + valueExpression);\n\t  if (isNative && needCompositionGuard) {\n\t    code = \"if($event.target.composing)return;\" + code;\n\t  }\n\t  // inputs with type=\"file\" are read only and setting the input's\n\t  // value will throw an error.\n\t  if (\"development\" !== 'production' &&\n\t      type === 'file') {\n\t    warn$3(\n\t      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n\t      \"File inputs are read only. Use a v-on:change listener instead.\"\n\t    );\n\t  }\n\t  addProp(el, 'value', isNative ? (\"_s(\" + value + \")\") : (\"(\" + value + \")\"));\n\t  addHandler(el, event, code, null, true);\n\t}\n\t\n\tfunction genSelect (el, value) {\n\t  {\n\t    el.children.some(checkOptionWarning);\n\t  }\n\t  var code = value + \"=Array.prototype.filter\" +\n\t    \".call($event.target.options,function(o){return o.selected})\" +\n\t    \".map(function(o){return \\\"_value\\\" in o ? o._value : o.value})\" +\n\t    (el.attrsMap.multiple == null ? '[0]' : '');\n\t  addHandler(el, 'change', code, null, true);\n\t}\n\t\n\tfunction checkOptionWarning (option) {\n\t  if (option.type === 1 &&\n\t    option.tag === 'option' &&\n\t    option.attrsMap.selected != null) {\n\t    warn$3(\n\t      \"<select v-model=\\\"\" + (option.parent.attrsMap['v-model']) + \"\\\">:\\n\" +\n\t      'inline selected attributes on <option> will be ignored when using v-model. ' +\n\t      'Declare initial values in the component\\'s data option instead.'\n\t    );\n\t    return true\n\t  }\n\t  return false\n\t}\n\t\n\t/*  */\n\t\n\tfunction text (el, dir) {\n\t  if (dir.value) {\n\t    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tfunction html (el, dir) {\n\t  if (dir.value) {\n\t    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n\t  }\n\t}\n\t\n\tvar directives$1 = {\n\t  model: model$1,\n\t  text: text,\n\t  html: html\n\t};\n\t\n\t/*  */\n\t\n\tvar cache = Object.create(null);\n\t\n\tvar baseOptions = {\n\t  isIE: isIE,\n\t  expectHTML: true,\n\t  modules: modules$1,\n\t  staticKeys: genStaticKeys(modules$1),\n\t  directives: directives$1,\n\t  isReservedTag: isReservedTag,\n\t  isUnaryTag: isUnaryTag,\n\t  mustUseProp: mustUseProp,\n\t  getTagNamespace: getTagNamespace,\n\t  isPreTag: isPreTag\n\t};\n\t\n\tfunction compile$$1 (\n\t  template,\n\t  options\n\t) {\n\t  options = options\n\t    ? extend(extend({}, baseOptions), options)\n\t    : baseOptions;\n\t  return compile$1(template, options)\n\t}\n\t\n\tfunction compileToFunctions (\n\t  template,\n\t  options,\n\t  vm\n\t) {\n\t  var _warn = (options && options.warn) || warn;\n\t  // detect possible CSP restriction\n\t  /* istanbul ignore if */\n\t  {\n\t    try {\n\t      new Function('return 1');\n\t    } catch (e) {\n\t      if (e.toString().match(/unsafe-eval|CSP/)) {\n\t        _warn(\n\t          'It seems you are using the standalone build of Vue.js in an ' +\n\t          'environment with Content Security Policy that prohibits unsafe-eval. ' +\n\t          'The template compiler cannot work in this environment. Consider ' +\n\t          'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n\t          'templates into render functions.'\n\t        );\n\t      }\n\t    }\n\t  }\n\t  var key = options && options.delimiters\n\t    ? String(options.delimiters) + template\n\t    : template;\n\t  if (cache[key]) {\n\t    return cache[key]\n\t  }\n\t  var res = {};\n\t  var compiled = compile$$1(template, options);\n\t  res.render = makeFunction(compiled.render);\n\t  var l = compiled.staticRenderFns.length;\n\t  res.staticRenderFns = new Array(l);\n\t  for (var i = 0; i < l; i++) {\n\t    res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i]);\n\t  }\n\t  {\n\t    if (res.render === noop || res.staticRenderFns.some(function (fn) { return fn === noop; })) {\n\t      _warn(\n\t        \"failed to compile template:\\n\\n\" + template + \"\\n\\n\" +\n\t        detectErrors(compiled.ast).join('\\n') +\n\t        '\\n\\n',\n\t        vm\n\t      );\n\t    }\n\t  }\n\t  return (cache[key] = res)\n\t}\n\t\n\tfunction makeFunction (code) {\n\t  try {\n\t    return new Function(code)\n\t  } catch (e) {\n\t    return noop\n\t  }\n\t}\n\t\n\t/*  */\n\t\n\tvar idToTemplate = cached(function (id) {\n\t  var el = query(id);\n\t  return el && el.innerHTML\n\t});\n\t\n\tvar mount = Vue$3.prototype.$mount;\n\tVue$3.prototype.$mount = function (\n\t  el,\n\t  hydrating\n\t) {\n\t  el = el && query(el);\n\t\n\t  /* istanbul ignore if */\n\t  if (el === document.body || el === document.documentElement) {\n\t    \"development\" !== 'production' && warn(\n\t      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n\t    );\n\t    return this\n\t  }\n\t\n\t  var options = this.$options;\n\t  // resolve template/el and convert to render function\n\t  if (!options.render) {\n\t    var template = options.template;\n\t    if (template) {\n\t      if (typeof template === 'string') {\n\t        if (template.charAt(0) === '#') {\n\t          template = idToTemplate(template);\n\t        }\n\t      } else if (template.nodeType) {\n\t        template = template.innerHTML;\n\t      } else {\n\t        {\n\t          warn('invalid template option:' + template, this);\n\t        }\n\t        return this\n\t      }\n\t    } else if (el) {\n\t      template = getOuterHTML(el);\n\t    }\n\t    if (template) {\n\t      var ref = compileToFunctions(template, {\n\t        warn: warn,\n\t        shouldDecodeNewlines: shouldDecodeNewlines,\n\t        delimiters: options.delimiters\n\t      }, this);\n\t      var render = ref.render;\n\t      var staticRenderFns = ref.staticRenderFns;\n\t      options.render = render;\n\t      options.staticRenderFns = staticRenderFns;\n\t    }\n\t  }\n\t  return mount.call(this, el, hydrating)\n\t};\n\t\n\t/**\n\t * Get outerHTML of elements, taking care\n\t * of SVG elements in IE as well.\n\t */\n\tfunction getOuterHTML (el) {\n\t  if (el.outerHTML) {\n\t    return el.outerHTML\n\t  } else {\n\t    var container = document.createElement('div');\n\t    container.appendChild(el.cloneNode(true));\n\t    return container.innerHTML\n\t  }\n\t}\n\t\n\tVue$3.compile = compileToFunctions;\n\t\n\treturn Vue$3;\n\t\n\t})));\n\n\n/***/ },\n/* 160 */\n/***/ function(module, exports) {\n\n\t\n\tvar XML_CHARACTER_MAP = {\n\t    '&': '&amp;',\n\t    '\"': '&quot;',\n\t    \"'\": '&apos;',\n\t    '<': '&lt;',\n\t    '>': '&gt;'\n\t};\n\t\n\tfunction escapeForXML(string) {\n\t    return string && string.replace\n\t        ? string.replace(/([&\"<>'])/g, function(str, item) {\n\t            return XML_CHARACTER_MAP[item];\n\t          })\n\t        : string;\n\t}\n\t\n\tmodule.exports = escapeForXML;\n\n\n/***/ },\n/* 161 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {var escapeForXML = __webpack_require__(160);\n\tvar Stream = __webpack_require__(22).Stream;\n\t\n\tvar DEFAULT_INDENT = '    ';\n\t\n\tfunction xml(input, options) {\n\t\n\t    if (typeof options !== 'object') {\n\t        options = {\n\t            indent: options\n\t        };\n\t    }\n\t\n\t    var stream      = options.stream ? new Stream() : null,\n\t        output      = \"\",\n\t        interrupted = false,\n\t        indent      = !options.indent ? ''\n\t                        : options.indent === true ? DEFAULT_INDENT\n\t                            : options.indent,\n\t        instant     = true;\n\t\n\t\n\t    function delay (func) {\n\t        if (!instant) {\n\t            func();\n\t        } else {\n\t            process.nextTick(func);\n\t        }\n\t    }\n\t\n\t    function append (interrupt, out) {\n\t        if (out !== undefined) {\n\t            output += out;\n\t        }\n\t        if (interrupt && !interrupted) {\n\t            stream = stream || new Stream();\n\t            interrupted = true;\n\t        }\n\t        if (interrupt && interrupted) {\n\t            var data = output;\n\t            delay(function () { stream.emit('data', data) });\n\t            output = \"\";\n\t        }\n\t    }\n\t\n\t    function add (value, last) {\n\t        format(append, resolve(value, indent, indent ? 1 : 0), last);\n\t    }\n\t\n\t    function end() {\n\t        if (stream) {\n\t            var data = output;\n\t            delay(function () {\n\t              stream.emit('data', data);\n\t              stream.emit('end');\n\t              stream.readable = false;\n\t              stream.emit('close');\n\t            });\n\t        }\n\t    }\n\t\n\t    function addXmlDeclaration(declaration) {\n\t        var encoding = declaration.encoding || 'UTF-8',\n\t            attr =  { version: '1.0', encoding: encoding };\n\t\n\t        if (declaration.standalone) {\n\t            attr.standalone = declaration.standalone\n\t        }\n\t\n\t        add({'?xml': { _attr: attr } });\n\t        output = output.replace('/>', '?>');\n\t    }\n\t\n\t    // disable delay delayed\n\t    delay(function () { instant = false });\n\t\n\t    if (options.declaration) {\n\t        addXmlDeclaration(options.declaration);\n\t    }\n\t\n\t    if (input && input.forEach) {\n\t        input.forEach(function (value, i) {\n\t            var last;\n\t            if (i + 1 === input.length)\n\t                last = end;\n\t            add(value, last);\n\t        });\n\t    } else {\n\t        add(input, end);\n\t    }\n\t\n\t    if (stream) {\n\t        stream.readable = true;\n\t        return stream;\n\t    }\n\t    return output;\n\t}\n\t\n\tfunction element (/*input, …*/) {\n\t    var input = Array.prototype.slice.call(arguments),\n\t        self = {\n\t            _elem:  resolve(input)\n\t        };\n\t\n\t    self.push = function (input) {\n\t        if (!this.append) {\n\t            throw new Error(\"not assigned to a parent!\");\n\t        }\n\t        var that = this;\n\t        var indent = this._elem.indent;\n\t        format(this.append, resolve(\n\t            input, indent, this._elem.icount + (indent ? 1 : 0)),\n\t            function () { that.append(true) });\n\t    };\n\t\n\t    self.close = function (input) {\n\t        if (input !== undefined) {\n\t            this.push(input);\n\t        }\n\t        if (this.end) {\n\t            this.end();\n\t        }\n\t    };\n\t\n\t    return self;\n\t}\n\t\n\tfunction create_indent(character, count) {\n\t    return (new Array(count || 0).join(character || ''))\n\t}\n\t\n\tfunction resolve(data, indent, indent_count) {\n\t    indent_count = indent_count || 0;\n\t    var indent_spaces = create_indent(indent, indent_count);\n\t    var name;\n\t    var values = data;\n\t    var interrupt = false;\n\t\n\t    if (typeof data === 'object') {\n\t        var keys = Object.keys(data);\n\t        name = keys[0];\n\t        values = data[name];\n\t\n\t        if (values && values._elem) {\n\t            values._elem.name = name;\n\t            values._elem.icount = indent_count;\n\t            values._elem.indent = indent;\n\t            values._elem.indents = indent_spaces;\n\t            values._elem.interrupt = values;\n\t            return values._elem;\n\t        }\n\t    }\n\t\n\t    var attributes = [],\n\t        content = [];\n\t\n\t    var isStringContent;\n\t\n\t    function get_attributes(obj){\n\t        var keys = Object.keys(obj);\n\t        keys.forEach(function(key){\n\t            attributes.push(attribute(key, obj[key]));\n\t        });\n\t    }\n\t\n\t    switch(typeof values) {\n\t        case 'object':\n\t            if (values === null) break;\n\t\n\t            if (values._attr) {\n\t                get_attributes(values._attr);\n\t            }\n\t\n\t            if (values._cdata) {\n\t                content.push(\n\t                    ('<![CDATA[' + values._cdata).replace(/\\]\\]>/g, ']]]]><![CDATA[>') + ']]>'\n\t                );\n\t            }\n\t\n\t            if (values.forEach) {\n\t                isStringContent = false;\n\t                content.push('');\n\t                values.forEach(function(value) {\n\t                    if (typeof value == 'object') {\n\t                        var _name = Object.keys(value)[0];\n\t\n\t                        if (_name == '_attr') {\n\t                            get_attributes(value._attr);\n\t                        } else {\n\t                            content.push(resolve(\n\t                                value, indent, indent_count + 1));\n\t                        }\n\t                    } else {\n\t                        //string\n\t                        content.pop();\n\t                        isStringContent=true;\n\t                        content.push(escapeForXML(value));\n\t                    }\n\t\n\t                });\n\t                if (!isStringContent) {\n\t                    content.push('');\n\t                }\n\t            }\n\t        break;\n\t\n\t        default:\n\t            //string\n\t            content.push(escapeForXML(values));\n\t\n\t    }\n\t\n\t    return {\n\t        name:       name,\n\t        interrupt:  interrupt,\n\t        attributes: attributes,\n\t        content:    content,\n\t        icount:     indent_count,\n\t        indents:    indent_spaces,\n\t        indent:     indent\n\t    };\n\t}\n\t\n\tfunction format(append, elem, end) {\n\t\n\t    if (typeof elem != 'object') {\n\t        return append(false, elem);\n\t    }\n\t\n\t    var len = elem.interrupt ? 1 : elem.content.length;\n\t\n\t    function proceed () {\n\t        while (elem.content.length) {\n\t            var value = elem.content.shift();\n\t\n\t            if (value === undefined) continue;\n\t            if (interrupt(value)) return;\n\t\n\t            format(append, value);\n\t        }\n\t\n\t        append(false, (len > 1 ? elem.indents : '')\n\t            + (elem.name ? '</' + elem.name + '>' : '')\n\t            + (elem.indent && !end ? '\\n' : ''));\n\t\n\t        if (end) {\n\t            end();\n\t        }\n\t    }\n\t\n\t    function interrupt(value) {\n\t       if (value.interrupt) {\n\t           value.interrupt.append = append;\n\t           value.interrupt.end = proceed;\n\t           value.interrupt = false;\n\t           append(true);\n\t           return true;\n\t       }\n\t       return false;\n\t    }\n\t\n\t    append(false, elem.indents\n\t        + (elem.name ? '<' + elem.name : '')\n\t        + (elem.attributes.length ? ' ' + elem.attributes.join(' ') : '')\n\t        + (len ? (elem.name ? '>' : '') : (elem.name ? '/>' : ''))\n\t        + (elem.indent && len > 1 ? '\\n' : ''));\n\t\n\t    if (!len) {\n\t        return append(false, elem.indent ? '\\n' : '');\n\t    }\n\t\n\t    if (!interrupt(elem)) {\n\t        proceed();\n\t    }\n\t}\n\t\n\tfunction attribute(key, value) {\n\t    return key + '=' + '\"' + escapeForXML(value) + '\"';\n\t}\n\t\n\tmodule.exports = xml;\n\tmodule.exports.element = module.exports.Element = element;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))\n\n/***/ },\n/* 162 */,\n/* 163 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 164 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\n\t\tAuthor Tobias Koppers @sokra\n\t*/\n\tvar stylesInDom = {},\n\t\tmemoize = function(fn) {\n\t\t\tvar memo;\n\t\t\treturn function () {\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\t\treturn memo;\n\t\t\t};\n\t\t},\n\t\tisOldIE = memoize(function() {\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\n\t\t}),\n\t\tgetHeadElement = memoize(function () {\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t\t}),\n\t\tsingletonElement = null,\n\t\tsingletonCounter = 0,\n\t\tstyleElementsInsertedAtTop = [];\n\t\n\tmodule.exports = function(list, options) {\n\t\tif(false) {\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t\t}\n\t\n\t\toptions = options || {};\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t\t// tags it will allow on a page\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\t\n\t\t// By default, add <style> tags to the bottom of <head>.\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\t\n\t\tvar styles = listToStyles(list);\n\t\taddStylesToDom(styles, options);\n\t\n\t\treturn function update(newList) {\n\t\t\tvar mayRemove = [];\n\t\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\t\tvar item = styles[i];\n\t\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\t\tdomStyle.refs--;\n\t\t\t\tmayRemove.push(domStyle);\n\t\t\t}\n\t\t\tif(newList) {\n\t\t\t\tvar newStyles = listToStyles(newList);\n\t\t\t\taddStylesToDom(newStyles, options);\n\t\t\t}\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\t\tvar domStyle = mayRemove[i];\n\t\t\t\tif(domStyle.refs === 0) {\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfunction addStylesToDom(styles, options) {\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tif(domStyle) {\n\t\t\t\tdomStyle.refs++;\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t\t}\n\t\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar parts = [];\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t\t}\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction listToStyles(list) {\n\t\tvar styles = [];\n\t\tvar newStyles = {};\n\t\tfor(var i = 0; i < list.length; i++) {\n\t\t\tvar item = list[i];\n\t\t\tvar id = item[0];\n\t\t\tvar css = item[1];\n\t\t\tvar media = item[2];\n\t\t\tvar sourceMap = item[3];\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\t\tif(!newStyles[id])\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\t\telse\n\t\t\t\tnewStyles[id].parts.push(part);\n\t\t}\n\t\treturn styles;\n\t}\n\t\n\tfunction insertStyleElement(options, styleElement) {\n\t\tvar head = getHeadElement();\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\t\tif (options.insertAt === \"top\") {\n\t\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t\t} else {\n\t\t\t\thead.appendChild(styleElement);\n\t\t\t}\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t\t} else if (options.insertAt === \"bottom\") {\n\t\t\thead.appendChild(styleElement);\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t\t}\n\t}\n\t\n\tfunction removeStyleElement(styleElement) {\n\t\tstyleElement.parentNode.removeChild(styleElement);\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\t\tif(idx >= 0) {\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t\t}\n\t}\n\t\n\tfunction createStyleElement(options) {\n\t\tvar styleElement = document.createElement(\"style\");\n\t\tstyleElement.type = \"text/css\";\n\t\tinsertStyleElement(options, styleElement);\n\t\treturn styleElement;\n\t}\n\t\n\tfunction addStyle(obj, options) {\n\t\tvar styleElement, update, remove;\n\t\n\t\tif (options.singleton) {\n\t\t\tvar styleIndex = singletonCounter++;\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t\t} else {\n\t\t\tstyleElement = createStyleElement(options);\n\t\t\tupdate = applyToTag.bind(null, styleElement);\n\t\t\tremove = function() {\n\t\t\t\tremoveStyleElement(styleElement);\n\t\t\t};\n\t\t}\n\t\n\t\tupdate(obj);\n\t\n\t\treturn function updateStyle(newObj) {\n\t\t\tif(newObj) {\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\t\treturn;\n\t\t\t\tupdate(obj = newObj);\n\t\t\t} else {\n\t\t\t\tremove();\n\t\t\t}\n\t\t};\n\t}\n\t\n\tvar replaceText = (function () {\n\t\tvar textStore = [];\n\t\n\t\treturn function (index, replacement) {\n\t\t\ttextStore[index] = replacement;\n\t\t\treturn textStore.filter(Boolean).join('\\n');\n\t\t};\n\t})();\n\t\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\t\tvar css = remove ? \"\" : obj.css;\n\t\n\t\tif (styleElement.styleSheet) {\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t\t} else {\n\t\t\tvar cssNode = document.createTextNode(css);\n\t\t\tvar childNodes = styleElement.childNodes;\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\t\tif (childNodes.length) {\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t\t} else {\n\t\t\t\tstyleElement.appendChild(cssNode);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction applyToTag(styleElement, obj) {\n\t\tvar css = obj.css;\n\t\tvar media = obj.media;\n\t\tvar sourceMap = obj.sourceMap;\n\t\n\t\tif (media) {\n\t\t\tstyleElement.setAttribute(\"media\", media);\n\t\t}\n\t\n\t\tif (sourceMap) {\n\t\t\t// https://developer.chrome.com/devtools/docs/javascript-debugging\n\t\t\t// this makes source maps inside style tags work properly in Chrome\n\t\t\tcss += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */';\n\t\t\t// http://stackoverflow.com/a/26603875\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t\t}\n\t\n\t\tif (styleElement.styleSheet) {\n\t\t\tstyleElement.styleSheet.cssText = css;\n\t\t} else {\n\t\t\twhile(styleElement.firstChild) {\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t\t}\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\n\t\t}\n\t}\n\n\n/***/ }\n]);\n\n\n// WEBPACK FOOTER //\n// static/js/vendor.007b22d751ae62bc81e6.js","var core = module.exports = {version: '2.4.0'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_core.js\n// module id = 1\n// module chunks = 1","\"use strict\";\n\nexports.__esModule = true;\n\nexports.default = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/helpers/classCallCheck.js\n// module id = 2\n// module chunks = 1","\"use strict\";\n\nexports.__esModule = true;\n\nvar _defineProperty = require(\"../core-js/object/define-property\");\n\nvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      (0, _defineProperty2.default)(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/helpers/createClass.js\n// module id = 3\n// module chunks = 1","var global    = require('./_global')\n  , core      = require('./_core')\n  , ctx       = require('./_ctx')\n  , hide      = require('./_hide')\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , IS_WRAP   = type & $export.W\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , expProto  = exports[PROTOTYPE]\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n    , key, own, out;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if(own && key in exports)continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function(C){\n      var F = function(a, b, c){\n        if(this instanceof C){\n          switch(arguments.length){\n            case 0: return new C;\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if(IS_PROTO){\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library` \nmodule.exports = $export;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_export.js\n// module id = 4\n// module chunks = 1","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_global.js\n// module id = 5\n// module chunks = 1","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject')\n  , defined = require('./_defined');\nmodule.exports = function(it){\n  return IObject(defined(it));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-iobject.js\n// module id = 6\n// module chunks = 1","var store      = require('./_shared')('wks')\n  , uid        = require('./_uid')\n  , Symbol     = require('./_global').Symbol\n  , USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function(name){\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_wks.js\n// module id = 7\n// module chunks = 1","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_descriptors.js\n// module id = 8\n// module chunks = 1","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function(it, key){\n  return hasOwnProperty.call(it, key);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_has.js\n// module id = 9\n// module chunks = 1","var anObject       = require('./_an-object')\n  , IE8_DOM_DEFINE = require('./_ie8-dom-define')\n  , toPrimitive    = require('./_to-primitive')\n  , dP             = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if(IE8_DOM_DEFINE)try {\n    return dP(O, P, Attributes);\n  } catch(e){ /* empty */ }\n  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n  if('value' in Attributes)O[P] = Attributes.value;\n  return O;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-dp.js\n// module id = 10\n// module chunks = 1","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys       = require('./_object-keys-internal')\n  , enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O){\n  return $keys(O, enumBugKeys);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-keys.js\n// module id = 11\n// module chunks = 1","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nforEach(objectKeys(Writable.prototype), function(method) {\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n});\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(this.end.bind(this));\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stream-browserify/~/readable-stream/lib/_stream_duplex.js\n// module id = 12\n// module chunks = 1","var isObject = require('./_is-object');\nmodule.exports = function(it){\n  if(!isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_an-object.js\n// module id = 13\n// module chunks = 1","module.exports = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_fails.js\n// module id = 14\n// module chunks = 1","var dP         = require('./_object-dp')\n  , createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function(object, key, value){\n  return dP.f(object, key, createDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_hide.js\n// module id = 15\n// module chunks = 1","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/inherits/inherits_browser.js\n// module id = 16\n// module chunks = 1","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/buffer/index.js\n// module id = 17\n// module chunks = 1","module.exports = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_is-object.js\n// module id = 18\n// module chunks = 1","exports.f = {}.propertyIsEnumerable;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-pie.js\n// module id = 19\n// module chunks = 1","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-util-is/lib/util.js\n// module id = 20\n// module chunks = 1","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 21\n// module chunks = 1","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stream-browserify/index.js\n// module id = 22\n// module chunks = 1","module.exports = {};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iterators.js\n// module id = 23\n// module chunks = 1","module.exports = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_property-desc.js\n// module id = 24\n// module chunks = 1","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function(it){\n  return Object(defined(it));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-object.js\n// module id = 25\n// module chunks = 1","var id = 0\n  , px = Math.random();\nmodule.exports = function(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_uid.js\n// module id = 26\n// module chunks = 1","module.exports = { \"default\": require(\"core-js/library/fn/get-iterator\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/get-iterator.js\n// module id = 27\n// module chunks = 1","var toString = {}.toString;\n\nmodule.exports = function(it){\n  return toString.call(it).slice(8, -1);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_cof.js\n// module id = 28\n// module chunks = 1","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_defined.js\n// module id = 29\n// module chunks = 1","// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_enum-bug-keys.js\n// module id = 30\n// module chunks = 1","module.exports = true;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_library.js\n// module id = 31\n// module chunks = 1","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject    = require('./_an-object')\n  , dPs         = require('./_object-dps')\n  , enumBugKeys = require('./_enum-bug-keys')\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\n  , Empty       = function(){ /* empty */ }\n  , PROTOTYPE   = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function(){\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = require('./_dom-create')('iframe')\n    , i      = enumBugKeys.length\n    , lt     = '<'\n    , gt     = '>'\n    , iframeDocument;\n  iframe.style.display = 'none';\n  require('./_html').appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties){\n  var result;\n  if(O !== null){\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty;\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-create.js\n// module id = 32\n// module chunks = 1","exports.f = Object.getOwnPropertySymbols;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-gops.js\n// module id = 33\n// module chunks = 1","var def = require('./_object-dp').f\n  , has = require('./_has')\n  , TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function(it, tag, stat){\n  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_set-to-string-tag.js\n// module id = 34\n// module chunks = 1","var shared = require('./_shared')('keys')\n  , uid    = require('./_uid');\nmodule.exports = function(key){\n  return shared[key] || (shared[key] = uid(key));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_shared-key.js\n// module id = 35\n// module chunks = 1","var global = require('./_global')\n  , SHARED = '__core-js_shared__'\n  , store  = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function(key){\n  return store[key] || (store[key] = {});\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_shared.js\n// module id = 36\n// module chunks = 1","// 7.1.4 ToInteger\nvar ceil  = Math.ceil\n  , floor = Math.floor;\nmodule.exports = function(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-integer.js\n// module id = 37\n// module chunks = 1","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function(it, S){\n  if(!isObject(it))return it;\n  var fn, val;\n  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-primitive.js\n// module id = 38\n// module chunks = 1","var global         = require('./_global')\n  , core           = require('./_core')\n  , LIBRARY        = require('./_library')\n  , wksExt         = require('./_wks-ext')\n  , defineProperty = require('./_object-dp').f;\nmodule.exports = function(name){\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_wks-define.js\n// module id = 39\n// module chunks = 1","exports.f = require('./_wks');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_wks-ext.js\n// module id = 40\n// module chunks = 1","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(options, stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (!util.isNullOrUndefined(data))\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(options, this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  this.once('prefinish', function() {\n    if (util.isFunction(this._flush))\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stream-browserify/~/readable-stream/lib/_stream_transform.js\n// module id = 41\n// module chunks = 1","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Stream = require('stream');\n\nutil.inherits(Writable, Stream);\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n}\n\nfunction WritableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.buffer = [];\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n}\n\nfunction Writable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, state, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  process.nextTick(function() {\n    cb(er);\n  });\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  if (!util.isBuffer(chunk) &&\n      !util.isString(chunk) &&\n      !util.isNullOrUndefined(chunk) &&\n      !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    process.nextTick(function() {\n      cb(er);\n    });\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (util.isFunction(encoding)) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (util.isBuffer(chunk))\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (!util.isFunction(cb))\n    cb = function() {};\n\n  if (state.ended)\n    writeAfterEnd(this, state, cb);\n  else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function() {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing &&\n        !state.corked &&\n        !state.finished &&\n        !state.bufferProcessing &&\n        state.buffer.length)\n      clearBuffer(this, state);\n  }\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      util.isString(chunk)) {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n  if (util.isBuffer(chunk))\n    encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked)\n    state.buffer.push(new WriteReq(chunk, encoding, cb));\n  else\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev)\n    stream._writev(chunk, state.onwrite);\n  else\n    stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  if (sync)\n    process.nextTick(function() {\n      state.pendingcb--;\n      cb(er);\n    });\n  else {\n    state.pendingcb--;\n    cb(er);\n  }\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(stream, state);\n\n    if (!finished &&\n        !state.corked &&\n        !state.bufferProcessing &&\n        state.buffer.length) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(function() {\n        afterWrite(stream, state, finished, cb);\n      });\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n\n  if (stream._writev && state.buffer.length > 1) {\n    // Fast case, write everything using _writev()\n    var cbs = [];\n    for (var c = 0; c < state.buffer.length; c++)\n      cbs.push(state.buffer[c].callback);\n\n    // count the one we are adding, as well.\n    // TODO(isaacs) clean this up\n    state.pendingcb++;\n    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {\n      for (var i = 0; i < cbs.length; i++) {\n        state.pendingcb--;\n        cbs[i](err);\n      }\n    });\n\n    // Clear buffer\n    state.buffer = [];\n  } else {\n    // Slow case, write chunks one-by-one\n    for (var c = 0; c < state.buffer.length; c++) {\n      var entry = state.buffer[c];\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        c++;\n        break;\n      }\n    }\n\n    if (c < state.buffer.length)\n      state.buffer = state.buffer.slice(c);\n    else\n      state.buffer.length = 0;\n  }\n\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (util.isFunction(chunk)) {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (util.isFunction(encoding)) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (!util.isNullOrUndefined(chunk))\n    this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(stream, state) {\n  return (state.ending &&\n          state.length === 0 &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(stream, state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else\n      prefinish(stream, state);\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      process.nextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stream-browserify/~/readable-stream/lib/_stream_writable.js\n// module id = 42\n// module chunks = 1","module.exports = { \"default\": require(\"core-js/library/fn/object/get-prototype-of\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/object/get-prototype-of.js\n// module id = 44\n// module chunks = 1","module.exports = { \"default\": require(\"core-js/library/fn/object/keys\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/object/keys.js\n// module id = 45\n// module chunks = 1","module.exports = { \"default\": require(\"core-js/library/fn/object/values\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/object/values.js\n// module id = 46\n// module chunks = 1","\"use strict\";\n\nexports.__esModule = true;\n\nvar _setPrototypeOf = require(\"../core-js/object/set-prototype-of\");\n\nvar _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);\n\nvar _create = require(\"../core-js/object/create\");\n\nvar _create2 = _interopRequireDefault(_create);\n\nvar _typeof2 = require(\"../helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(superClass)));\n  }\n\n  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/helpers/inherits.js\n// module id = 47\n// module chunks = 1","\"use strict\";\n\nexports.__esModule = true;\n\nvar _typeof2 = require(\"../helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && ((typeof call === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(call)) === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/helpers/possibleConstructorReturn.js\n// module id = 48\n// module chunks = 1","\"use strict\";\n\nexports.__esModule = true;\n\nvar _iterator = require(\"../core-js/symbol/iterator\");\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _symbol = require(\"../core-js/symbol\");\n\nvar _symbol2 = _interopRequireDefault(_symbol);\n\nvar _typeof = typeof _symbol2.default === \"function\" && typeof _iterator2.default === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = typeof _symbol2.default === \"function\" && _typeof(_iterator2.default) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n} : function (obj) {\n  return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/helpers/typeof.js\n// module id = 49\n// module chunks = 1","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function(fn, that, length){\n  aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_ctx.js\n// module id = 50\n// module chunks = 1","var isObject = require('./_is-object')\n  , document = require('./_global').document\n  // in old IE typeof document.createElement is 'object'\n  , is = isObject(document) && isObject(document.createElement);\nmodule.exports = function(it){\n  return is ? document.createElement(it) : {};\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_dom-create.js\n// module id = 51\n// module chunks = 1","module.exports = !require('./_descriptors') && !require('./_fails')(function(){\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_ie8-dom-define.js\n// module id = 52\n// module chunks = 1","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iobject.js\n// module id = 53\n// module chunks = 1","'use strict';\nvar LIBRARY        = require('./_library')\n  , $export        = require('./_export')\n  , redefine       = require('./_redefine')\n  , hide           = require('./_hide')\n  , has            = require('./_has')\n  , Iterators      = require('./_iterators')\n  , $iterCreate    = require('./_iter-create')\n  , setToStringTag = require('./_set-to-string-tag')\n  , getPrototypeOf = require('./_object-gpo')\n  , ITERATOR       = require('./_wks')('iterator')\n  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n  , FF_ITERATOR    = '@@iterator'\n  , KEYS           = 'keys'\n  , VALUES         = 'values';\n\nvar returnThis = function(){ return this; };\n\nmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function(kind){\n    if(!BUGGY && kind in proto)return proto[kind];\n    switch(kind){\n      case KEYS: return function keys(){ return new Constructor(this, kind); };\n      case VALUES: return function values(){ return new Constructor(this, kind); };\n    } return function entries(){ return new Constructor(this, kind); };\n  };\n  var TAG        = NAME + ' Iterator'\n    , DEF_VALUES = DEFAULT == VALUES\n    , VALUES_BUG = false\n    , proto      = Base.prototype\n    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n    , $default   = $native || getMethod(DEFAULT)\n    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n    , methods, key, IteratorPrototype;\n  // Fix native\n  if($anyNative){\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n    if(IteratorPrototype !== Object.prototype){\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if(DEF_VALUES && $native && $native.name !== VALUES){\n    VALUES_BUG = true;\n    $default = function values(){ return $native.call(this); };\n  }\n  // Define iterator\n  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG]  = returnThis;\n  if(DEFAULT){\n    methods = {\n      values:  DEF_VALUES ? $default : getMethod(VALUES),\n      keys:    IS_SET     ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if(FORCED)for(key in methods){\n      if(!(key in proto))redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iter-define.js\n// module id = 54\n// module chunks = 1","var pIE            = require('./_object-pie')\n  , createDesc     = require('./_property-desc')\n  , toIObject      = require('./_to-iobject')\n  , toPrimitive    = require('./_to-primitive')\n  , has            = require('./_has')\n  , IE8_DOM_DEFINE = require('./_ie8-dom-define')\n  , gOPD           = Object.getOwnPropertyDescriptor;\n\nexports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if(IE8_DOM_DEFINE)try {\n    return gOPD(O, P);\n  } catch(e){ /* empty */ }\n  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-gopd.js\n// module id = 55\n// module chunks = 1","// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys      = require('./_object-keys-internal')\n  , hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){\n  return $keys(O, hiddenKeys);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-gopn.js\n// module id = 56\n// module chunks = 1","// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has         = require('./_has')\n  , toObject    = require('./_to-object')\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\n  , ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function(O){\n  O = toObject(O);\n  if(has(O, IE_PROTO))return O[IE_PROTO];\n  if(typeof O.constructor == 'function' && O instanceof O.constructor){\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-gpo.js\n// module id = 57\n// module chunks = 1","var has          = require('./_has')\n  , toIObject    = require('./_to-iobject')\n  , arrayIndexOf = require('./_array-includes')(false)\n  , IE_PROTO     = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function(object, names){\n  var O      = toIObject(object)\n    , i      = 0\n    , result = []\n    , key;\n  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while(names.length > i)if(has(O, key = names[i++])){\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-keys-internal.js\n// module id = 58\n// module chunks = 1","// most Object methods by ES6 should accept primitives\nvar $export = require('./_export')\n  , core    = require('./_core')\n  , fails   = require('./_fails');\nmodule.exports = function(KEY, exec){\n  var fn  = (core.Object || {})[KEY] || Object[KEY]\n    , exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-sap.js\n// module id = 59\n// module chunks = 1","module.exports = require('./_hide');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_redefine.js\n// module id = 60\n// module chunks = 1","'use strict';\nvar $at  = require('./_string-at')(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\nrequire('./_iter-define')(String, 'String', function(iterated){\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , index = this._i\n    , point;\n  if(index >= O.length)return {value: undefined, done: true};\n  point = $at(O, index);\n  this._i += point.length;\n  return {value: point, done: false};\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.string.iterator.js\n// module id = 61\n// module chunks = 1","require('./es6.array.iterator');\nvar global        = require('./_global')\n  , hide          = require('./_hide')\n  , Iterators     = require('./_iterators')\n  , TO_STRING_TAG = require('./_wks')('toStringTag');\n\nfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n  var NAME       = collections[i]\n    , Collection = global[NAME]\n    , proto      = Collection && Collection.prototype;\n  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);\n  Iterators[NAME] = Iterators.Array;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/web.dom.iterable.js\n// module id = 62\n// module chunks = 1","// https://d3js.org/d3-collection/ Version 1.0.1. Copyright 2016 Mike Bostock.\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.d3 = global.d3 || {})));\n}(this, function (exports) { 'use strict';\n\n  var prefix = \"$\";\n\n  function Map() {}\n\n  Map.prototype = map.prototype = {\n    constructor: Map,\n    has: function(key) {\n      return (prefix + key) in this;\n    },\n    get: function(key) {\n      return this[prefix + key];\n    },\n    set: function(key, value) {\n      this[prefix + key] = value;\n      return this;\n    },\n    remove: function(key) {\n      var property = prefix + key;\n      return property in this && delete this[property];\n    },\n    clear: function() {\n      for (var property in this) if (property[0] === prefix) delete this[property];\n    },\n    keys: function() {\n      var keys = [];\n      for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));\n      return keys;\n    },\n    values: function() {\n      var values = [];\n      for (var property in this) if (property[0] === prefix) values.push(this[property]);\n      return values;\n    },\n    entries: function() {\n      var entries = [];\n      for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});\n      return entries;\n    },\n    size: function() {\n      var size = 0;\n      for (var property in this) if (property[0] === prefix) ++size;\n      return size;\n    },\n    empty: function() {\n      for (var property in this) if (property[0] === prefix) return false;\n      return true;\n    },\n    each: function(f) {\n      for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);\n    }\n  };\n\n  function map(object, f) {\n    var map = new Map;\n\n    // Copy constructor.\n    if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });\n\n    // Index array by numeric index or specified key function.\n    else if (Array.isArray(object)) {\n      var i = -1,\n          n = object.length,\n          o;\n\n      if (f == null) while (++i < n) map.set(i, object[i]);\n      else while (++i < n) map.set(f(o = object[i], i, object), o);\n    }\n\n    // Convert object to map.\n    else if (object) for (var key in object) map.set(key, object[key]);\n\n    return map;\n  }\n\n  function nest() {\n    var keys = [],\n        sortKeys = [],\n        sortValues,\n        rollup,\n        nest;\n\n    function apply(array, depth, createResult, setResult) {\n      if (depth >= keys.length) return rollup != null\n          ? rollup(array) : (sortValues != null\n          ? array.sort(sortValues)\n          : array);\n\n      var i = -1,\n          n = array.length,\n          key = keys[depth++],\n          keyValue,\n          value,\n          valuesByKey = map(),\n          values,\n          result = createResult();\n\n      while (++i < n) {\n        if (values = valuesByKey.get(keyValue = key(value = array[i]) + \"\")) {\n          values.push(value);\n        } else {\n          valuesByKey.set(keyValue, [value]);\n        }\n      }\n\n      valuesByKey.each(function(values, key) {\n        setResult(result, key, apply(values, depth, createResult, setResult));\n      });\n\n      return result;\n    }\n\n    function entries(map, depth) {\n      if (++depth > keys.length) return map;\n      var array, sortKey = sortKeys[depth - 1];\n      if (rollup != null && depth >= keys.length) array = map.entries();\n      else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });\n      return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;\n    }\n\n    return nest = {\n      object: function(array) { return apply(array, 0, createObject, setObject); },\n      map: function(array) { return apply(array, 0, createMap, setMap); },\n      entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },\n      key: function(d) { keys.push(d); return nest; },\n      sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },\n      sortValues: function(order) { sortValues = order; return nest; },\n      rollup: function(f) { rollup = f; return nest; }\n    };\n  }\n\n  function createObject() {\n    return {};\n  }\n\n  function setObject(object, key, value) {\n    object[key] = value;\n  }\n\n  function createMap() {\n    return map();\n  }\n\n  function setMap(map, key, value) {\n    map.set(key, value);\n  }\n\n  function Set() {}\n\n  var proto = map.prototype;\n\n  Set.prototype = set.prototype = {\n    constructor: Set,\n    has: proto.has,\n    add: function(value) {\n      value += \"\";\n      this[prefix + value] = value;\n      return this;\n    },\n    remove: proto.remove,\n    clear: proto.clear,\n    values: proto.keys,\n    size: proto.size,\n    empty: proto.empty,\n    each: proto.each\n  };\n\n  function set(object, f) {\n    var set = new Set;\n\n    // Copy constructor.\n    if (object instanceof Set) object.each(function(value) { set.add(value); });\n\n    // Otherwise, assume it’s an array.\n    else if (object) {\n      var i = -1, n = object.length;\n      if (f == null) while (++i < n) set.add(object[i]);\n      else while (++i < n) set.add(f(object[i], i, object));\n    }\n\n    return set;\n  }\n\n  function keys(map) {\n    var keys = [];\n    for (var key in map) keys.push(key);\n    return keys;\n  }\n\n  function values(map) {\n    var values = [];\n    for (var key in map) values.push(map[key]);\n    return values;\n  }\n\n  function entries(map) {\n    var entries = [];\n    for (var key in map) entries.push({key: key, value: map[key]});\n    return entries;\n  }\n\n  exports.nest = nest;\n  exports.set = set;\n  exports.map = map;\n  exports.keys = keys;\n  exports.values = values;\n  exports.entries = entries;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/d3-collection/build/d3-collection.js\n// module id = 63\n// module chunks = 1","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/events/events.js\n// module id = 64\n// module chunks = 1","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stream-browserify/~/readable-stream/lib/_stream_passthrough.js\n// module id = 65\n// module chunks = 1","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events').EventEmitter;\n\n/*<replacement>*/\nif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\nvar Stream = require('stream');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar StringDecoder;\n\n\n/*<replacement>*/\nvar debug = require('util');\nif (debug && debug.debuglog) {\n  debug = debug.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (util.isString(chunk) && !state.objectMode) {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (util.isNullOrUndefined(chunk)) {\n    state.reading = false;\n    if (!state.ended)\n      onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      if (!addToFront)\n        state.reading = false;\n\n      // if we want the data now, just emit it.\n      if (state.flowing && state.length === 0 && !state.sync) {\n        stream.emit('data', chunk);\n        stream.read(0);\n      } else {\n        // update the buffer info.\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront)\n          state.buffer.unshift(chunk);\n        else\n          state.buffer.push(chunk);\n\n        if (state.needReadable)\n          emitReadable(stream);\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    for (var p = 1; p < 32; p <<= 1) n |= n >> p;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (isNaN(n) || util.isNull(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = roundUpToNextPowerOf2(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else\n      return state.length;\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read', n);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (!util.isNumber(n) || n > 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  }\n\n  if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read pushed data synchronously, then `reading` will be false,\n  // and we need to re-evaluate how much data we can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  var ret;\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (util.isNull(ret)) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we tried to read() past the EOF, then emit end on the next tick.\n  if (nOrig !== n && state.ended && state.length === 0)\n    endReadable(this);\n\n  if (!util.isNull(ret))\n    this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!util.isBuffer(chunk) &&\n      !util.isString(chunk) &&\n      !util.isNullOrUndefined(chunk) &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.decoder && !state.ended) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync)\n      process.nextTick(function() {\n        emitReadable_(stream);\n      });\n    else\n      emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(function() {\n      maybeReadMore_(stream, state);\n    });\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    if (false === ret) {\n      debug('false write response, pause',\n            src._readableState.awaitDrain);\n      src._readableState.awaitDrain++;\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EE.listenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on('error', onerror);\n  else if (isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain)\n      state.awaitDrain--;\n    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  // If listening to data, and it has not explicitly been paused,\n  // then call resume to start the flow of data on the next tick.\n  if (ev === 'data' && false !== this._readableState.flowing) {\n    this.resume();\n  }\n\n  if (ev === 'readable' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        var self = this;\n        process.nextTick(function() {\n          debug('readable nexttick read 0');\n          self.read(0);\n        });\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    if (!state.reading) {\n      debug('resume read 0');\n      this.read(0);\n    }\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(function() {\n      resume_(stream, state);\n    });\n  }\n}\n\nfunction resume_(stream, state) {\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  if (state.flowing) {\n    do {\n      var chunk = stream.read();\n    } while (null !== chunk && state.flowing);\n  }\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    debug('wrapped data');\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n    if (!chunk || !state.objectMode && !chunk.length)\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }}(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join('');\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = '';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(function() {\n      // Check that we didn't get one last unshift.\n      if (!state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.readable = false;\n        stream.emit('end');\n      }\n    });\n  }\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf (xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stream-browserify/~/readable-stream/lib/_stream_readable.js\n// module id = 66\n// module chunks = 1","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require('buffer').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/string_decoder/index.js\n// module id = 67\n// module chunks = 1","/*!\n\tPapa Parse\n\tv4.1.2\n\thttps://github.com/mholt/PapaParse\n*/\n(function(global)\n{\n\t\"use strict\";\n\n\tvar IS_WORKER = !global.document && !!global.postMessage,\n\t\tIS_PAPA_WORKER = IS_WORKER && /(\\?|&)papaworker(=|&|$)/.test(global.location.search),\n\t\tLOADED_SYNC = false, AUTO_SCRIPT_PATH;\n\tvar workers = {}, workerIdCounter = 0;\n\n\tvar Papa = {};\n\n\tPapa.parse = CsvToJson;\n\tPapa.unparse = JsonToCsv;\n\n\tPapa.RECORD_SEP = String.fromCharCode(30);\n\tPapa.UNIT_SEP = String.fromCharCode(31);\n\tPapa.BYTE_ORDER_MARK = \"\\ufeff\";\n\tPapa.BAD_DELIMITERS = [\"\\r\", \"\\n\", \"\\\"\", Papa.BYTE_ORDER_MARK];\n\tPapa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker;\n\tPapa.SCRIPT_PATH = null;\t// Must be set by your code if you use workers and this lib is loaded asynchronously\n\n\t// Configurable chunk sizes for local and remote files, respectively\n\tPapa.LocalChunkSize = 1024 * 1024 * 10;\t// 10 MB\n\tPapa.RemoteChunkSize = 1024 * 1024 * 5;\t// 5 MB\n\tPapa.DefaultDelimiter = \",\";\t\t\t// Used if not specified and detection fails\n\n\t// Exposed for testing and development only\n\tPapa.Parser = Parser;\n\tPapa.ParserHandle = ParserHandle;\n\tPapa.NetworkStreamer = NetworkStreamer;\n\tPapa.FileStreamer = FileStreamer;\n\tPapa.StringStreamer = StringStreamer;\n\n\tif (typeof module !== 'undefined' && module.exports)\n\t{\n\t\t// Export to Node...\n\t\tmodule.exports = Papa;\n\t}\n\telse if (isFunction(global.define) && global.define.amd)\n\t{\n\t\t// Wireup with RequireJS\n\t\tdefine(function() { return Papa; });\n\t}\n\telse\n\t{\n\t\t// ...or as browser global\n\t\tglobal.Papa = Papa;\n\t}\n\n\tif (global.jQuery)\n\t{\n\t\tvar $ = global.jQuery;\n\t\t$.fn.parse = function(options)\n\t\t{\n\t\t\tvar config = options.config || {};\n\t\t\tvar queue = [];\n\n\t\t\tthis.each(function(idx)\n\t\t\t{\n\t\t\t\tvar supported = $(this).prop('tagName').toUpperCase() == \"INPUT\"\n\t\t\t\t\t\t\t\t&& $(this).attr('type').toLowerCase() == \"file\"\n\t\t\t\t\t\t\t\t&& global.FileReader;\n\n\t\t\t\tif (!supported || !this.files || this.files.length == 0)\n\t\t\t\t\treturn true;\t// continue to next input element\n\n\t\t\t\tfor (var i = 0; i < this.files.length; i++)\n\t\t\t\t{\n\t\t\t\t\tqueue.push({\n\t\t\t\t\t\tfile: this.files[i],\n\t\t\t\t\t\tinputElem: this,\n\t\t\t\t\t\tinstanceConfig: $.extend({}, config)\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tparseNextFile();\t// begin parsing\n\t\t\treturn this;\t\t// maintains chainability\n\n\n\t\t\tfunction parseNextFile()\n\t\t\t{\n\t\t\t\tif (queue.length == 0)\n\t\t\t\t{\n\t\t\t\t\tif (isFunction(options.complete))\n\t\t\t\t\t\toptions.complete();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar f = queue[0];\n\n\t\t\t\tif (isFunction(options.before))\n\t\t\t\t{\n\t\t\t\t\tvar returned = options.before(f.file, f.inputElem);\n\n\t\t\t\t\tif (typeof returned === 'object')\n\t\t\t\t\t{\n\t\t\t\t\t\tif (returned.action == \"abort\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror(\"AbortError\", f.file, f.inputElem, returned.reason);\n\t\t\t\t\t\t\treturn;\t// Aborts all queued files immediately\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (returned.action == \"skip\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfileComplete();\t// parse the next file in the queue, if any\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (typeof returned.config === 'object')\n\t\t\t\t\t\t\tf.instanceConfig = $.extend(f.instanceConfig, returned.config);\n\t\t\t\t\t}\n\t\t\t\t\telse if (returned == \"skip\")\n\t\t\t\t\t{\n\t\t\t\t\t\tfileComplete();\t// parse the next file in the queue, if any\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Wrap up the user's complete callback, if any, so that ours also gets executed\n\t\t\t\tvar userCompleteFunc = f.instanceConfig.complete;\n\t\t\t\tf.instanceConfig.complete = function(results)\n\t\t\t\t{\n\t\t\t\t\tif (isFunction(userCompleteFunc))\n\t\t\t\t\t\tuserCompleteFunc(results, f.file, f.inputElem);\n\t\t\t\t\tfileComplete();\n\t\t\t\t};\n\n\t\t\t\tPapa.parse(f.file, f.instanceConfig);\n\t\t\t}\n\n\t\t\tfunction error(name, file, elem, reason)\n\t\t\t{\n\t\t\t\tif (isFunction(options.error))\n\t\t\t\t\toptions.error({name: name}, file, elem, reason);\n\t\t\t}\n\n\t\t\tfunction fileComplete()\n\t\t\t{\n\t\t\t\tqueue.splice(0, 1);\n\t\t\t\tparseNextFile();\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif (IS_PAPA_WORKER)\n\t{\n\t\tglobal.onmessage = workerThreadReceivedMessage;\n\t}\n\telse if (Papa.WORKERS_SUPPORTED)\n\t{\n\t\tAUTO_SCRIPT_PATH = getScriptPath();\n\n\t\t// Check if the script was loaded synchronously\n\t\tif (!document.body)\n\t\t{\n\t\t\t// Body doesn't exist yet, must be synchronous\n\t\t\tLOADED_SYNC = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdocument.addEventListener('DOMContentLoaded', function () {\n\t\t\t\tLOADED_SYNC = true;\n\t\t\t}, true);\n\t\t}\n\t}\n\n\n\n\n\tfunction CsvToJson(_input, _config)\n\t{\n\t\t_config = _config || {};\n\n\t\tif (_config.worker && Papa.WORKERS_SUPPORTED)\n\t\t{\n\t\t\tvar w = newWorker();\n\n\t\t\tw.userStep = _config.step;\n\t\t\tw.userChunk = _config.chunk;\n\t\t\tw.userComplete = _config.complete;\n\t\t\tw.userError = _config.error;\n\n\t\t\t_config.step = isFunction(_config.step);\n\t\t\t_config.chunk = isFunction(_config.chunk);\n\t\t\t_config.complete = isFunction(_config.complete);\n\t\t\t_config.error = isFunction(_config.error);\n\t\t\tdelete _config.worker;\t// prevent infinite loop\n\n\t\t\tw.postMessage({\n\t\t\t\tinput: _input,\n\t\t\t\tconfig: _config,\n\t\t\t\tworkerId: w.id\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\tvar streamer = null;\n\t\tif (typeof _input === 'string')\n\t\t{\n\t\t\tif (_config.download)\n\t\t\t\tstreamer = new NetworkStreamer(_config);\n\t\t\telse\n\t\t\t\tstreamer = new StringStreamer(_config);\n\t\t}\n\t\telse if ((global.File && _input instanceof File) || _input instanceof Object)\t// ...Safari. (see issue #106)\n\t\t\tstreamer = new FileStreamer(_config);\n\n\t\treturn streamer.stream(_input);\n\t}\n\n\n\n\n\n\n\tfunction JsonToCsv(_input, _config)\n\t{\n\t\tvar _output = \"\";\n\t\tvar _fields = [];\n\n\t\t// Default configuration\n\n\t\t/** whether to surround every datum with quotes */\n\t\tvar _quotes = false;\n\n\t\t/** delimiting character */\n\t\tvar _delimiter = \",\";\n\n\t\t/** newline character(s) */\n\t\tvar _newline = \"\\r\\n\";\n\n\t\tunpackConfig();\n\n\t\tif (typeof _input === 'string')\n\t\t\t_input = JSON.parse(_input);\n\n\t\tif (_input instanceof Array)\n\t\t{\n\t\t\tif (!_input.length || _input[0] instanceof Array)\n\t\t\t\treturn serialize(null, _input);\n\t\t\telse if (typeof _input[0] === 'object')\n\t\t\t\treturn serialize(objectKeys(_input[0]), _input);\n\t\t}\n\t\telse if (typeof _input === 'object')\n\t\t{\n\t\t\tif (typeof _input.data === 'string')\n\t\t\t\t_input.data = JSON.parse(_input.data);\n\n\t\t\tif (_input.data instanceof Array)\n\t\t\t{\n\t\t\t\tif (!_input.fields)\n\t\t\t\t\t_input.fields = _input.data[0] instanceof Array\n\t\t\t\t\t\t\t\t\t? _input.fields\n\t\t\t\t\t\t\t\t\t: objectKeys(_input.data[0]);\n\n\t\t\t\tif (!(_input.data[0] instanceof Array) && typeof _input.data[0] !== 'object')\n\t\t\t\t\t_input.data = [_input.data];\t// handles input like [1,2,3] or [\"asdf\"]\n\t\t\t}\n\n\t\t\treturn serialize(_input.fields || [], _input.data || []);\n\t\t}\n\n\t\t// Default (any valid paths should return before this)\n\t\tthrow \"exception: Unable to serialize unrecognized input\";\n\n\n\t\tfunction unpackConfig()\n\t\t{\n\t\t\tif (typeof _config !== 'object')\n\t\t\t\treturn;\n\n\t\t\tif (typeof _config.delimiter === 'string'\n\t\t\t\t&& _config.delimiter.length == 1\n\t\t\t\t&& Papa.BAD_DELIMITERS.indexOf(_config.delimiter) == -1)\n\t\t\t{\n\t\t\t\t_delimiter = _config.delimiter;\n\t\t\t}\n\n\t\t\tif (typeof _config.quotes === 'boolean'\n\t\t\t\t|| _config.quotes instanceof Array)\n\t\t\t\t_quotes = _config.quotes;\n\n\t\t\tif (typeof _config.newline === 'string')\n\t\t\t\t_newline = _config.newline;\n\t\t}\n\n\n\t\t/** Turns an object's keys into an array */\n\t\tfunction objectKeys(obj)\n\t\t{\n\t\t\tif (typeof obj !== 'object')\n\t\t\t\treturn [];\n\t\t\tvar keys = [];\n\t\t\tfor (var key in obj)\n\t\t\t\tkeys.push(key);\n\t\t\treturn keys;\n\t\t}\n\n\t\t/** The double for loop that iterates the data and writes out a CSV string including header row */\n\t\tfunction serialize(fields, data)\n\t\t{\n\t\t\tvar csv = \"\";\n\n\t\t\tif (typeof fields === 'string')\n\t\t\t\tfields = JSON.parse(fields);\n\t\t\tif (typeof data === 'string')\n\t\t\t\tdata = JSON.parse(data);\n\n\t\t\tvar hasHeader = fields instanceof Array && fields.length > 0;\n\t\t\tvar dataKeyedByField = !(data[0] instanceof Array);\n\n\t\t\t// If there a header row, write it first\n\t\t\tif (hasHeader)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < fields.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (i > 0)\n\t\t\t\t\t\tcsv += _delimiter;\n\t\t\t\t\tcsv += safe(fields[i], i);\n\t\t\t\t}\n\t\t\t\tif (data.length > 0)\n\t\t\t\t\tcsv += _newline;\n\t\t\t}\n\n\t\t\t// Then write out the data\n\t\t\tfor (var row = 0; row < data.length; row++)\n\t\t\t{\n\t\t\t\tvar maxCol = hasHeader ? fields.length : data[row].length;\n\n\t\t\t\tfor (var col = 0; col < maxCol; col++)\n\t\t\t\t{\n\t\t\t\t\tif (col > 0)\n\t\t\t\t\t\tcsv += _delimiter;\n\t\t\t\t\tvar colIdx = hasHeader && dataKeyedByField ? fields[col] : col;\n\t\t\t\t\tcsv += safe(data[row][colIdx], col);\n\t\t\t\t}\n\n\t\t\t\tif (row < data.length - 1)\n\t\t\t\t\tcsv += _newline;\n\t\t\t}\n\n\t\t\treturn csv;\n\t\t}\n\n\t\t/** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */\n\t\tfunction safe(str, col)\n\t\t{\n\t\t\tif (typeof str === \"undefined\" || str === null)\n\t\t\t\treturn \"\";\n\n\t\t\tstr = str.toString().replace(/\"/g, '\"\"');\n\n\t\t\tvar needsQuotes = (typeof _quotes === 'boolean' && _quotes)\n\t\t\t\t\t\t\t|| (_quotes instanceof Array && _quotes[col])\n\t\t\t\t\t\t\t|| hasAny(str, Papa.BAD_DELIMITERS)\n\t\t\t\t\t\t\t|| str.indexOf(_delimiter) > -1\n\t\t\t\t\t\t\t|| str.charAt(0) == ' '\n\t\t\t\t\t\t\t|| str.charAt(str.length - 1) == ' ';\n\n\t\t\treturn needsQuotes ? '\"' + str + '\"' : str;\n\t\t}\n\n\t\tfunction hasAny(str, substrings)\n\t\t{\n\t\t\tfor (var i = 0; i < substrings.length; i++)\n\t\t\t\tif (str.indexOf(substrings[i]) > -1)\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/** ChunkStreamer is the base prototype for various streamer implementations. */\n\tfunction ChunkStreamer(config)\n\t{\n\t\tthis._handle = null;\n\t\tthis._paused = false;\n\t\tthis._finished = false;\n\t\tthis._input = null;\n\t\tthis._baseIndex = 0;\n\t\tthis._partialLine = \"\";\n\t\tthis._rowCount = 0;\n\t\tthis._start = 0;\n\t\tthis._nextChunk = null;\n\t\tthis.isFirstChunk = true;\n\t\tthis._completeResults = {\n\t\t\tdata: [],\n\t\t\terrors: [],\n\t\t\tmeta: {}\n\t\t};\n\t\treplaceConfig.call(this, config);\n\n\t\tthis.parseChunk = function(chunk)\n\t\t{\n\t\t\t// First chunk pre-processing\n\t\t\tif (this.isFirstChunk && isFunction(this._config.beforeFirstChunk))\n\t\t\t{\n\t\t\t\tvar modifiedChunk = this._config.beforeFirstChunk(chunk);\n\t\t\t\tif (modifiedChunk !== undefined)\n\t\t\t\t\tchunk = modifiedChunk;\n\t\t\t}\n\t\t\tthis.isFirstChunk = false;\n\n\t\t\t// Rejoin the line we likely just split in two by chunking the file\n\t\t\tvar aggregate = this._partialLine + chunk;\n\t\t\tthis._partialLine = \"\";\n\n\t\t\tvar results = this._handle.parse(aggregate, this._baseIndex, !this._finished);\n\t\t\t\n\t\t\tif (this._handle.paused() || this._handle.aborted())\n\t\t\t\treturn;\n\t\t\t\n\t\t\tvar lastIndex = results.meta.cursor;\n\t\t\t\n\t\t\tif (!this._finished)\n\t\t\t{\n\t\t\t\tthis._partialLine = aggregate.substring(lastIndex - this._baseIndex);\n\t\t\t\tthis._baseIndex = lastIndex;\n\t\t\t}\n\n\t\t\tif (results && results.data)\n\t\t\t\tthis._rowCount += results.data.length;\n\n\t\t\tvar finishedIncludingPreview = this._finished || (this._config.preview && this._rowCount >= this._config.preview);\n\n\t\t\tif (IS_PAPA_WORKER)\n\t\t\t{\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tresults: results,\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\tfinished: finishedIncludingPreview\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if (isFunction(this._config.chunk))\n\t\t\t{\n\t\t\t\tthis._config.chunk(results, this._handle);\n\t\t\t\tif (this._paused)\n\t\t\t\t\treturn;\n\t\t\t\tresults = undefined;\n\t\t\t\tthis._completeResults = undefined;\n\t\t\t}\n\n\t\t\tif (!this._config.step && !this._config.chunk) {\n\t\t\t\tthis._completeResults.data = this._completeResults.data.concat(results.data);\n\t\t\t\tthis._completeResults.errors = this._completeResults.errors.concat(results.errors);\n\t\t\t\tthis._completeResults.meta = results.meta;\n\t\t\t}\n\n\t\t\tif (finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted))\n\t\t\t\tthis._config.complete(this._completeResults);\n\n\t\t\tif (!finishedIncludingPreview && (!results || !results.meta.paused))\n\t\t\t\tthis._nextChunk();\n\n\t\t\treturn results;\n\t\t};\n\n\t\tthis._sendError = function(error)\n\t\t{\n\t\t\tif (isFunction(this._config.error))\n\t\t\t\tthis._config.error(error);\n\t\t\telse if (IS_PAPA_WORKER && this._config.error)\n\t\t\t{\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\terror: error,\n\t\t\t\t\tfinished: false\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tfunction replaceConfig(config)\n\t\t{\n\t\t\t// Deep-copy the config so we can edit it\n\t\t\tvar configCopy = copy(config);\n\t\t\tconfigCopy.chunkSize = parseInt(configCopy.chunkSize);\t// parseInt VERY important so we don't concatenate strings!\n\t\t\tif (!config.step && !config.chunk)\n\t\t\t\tconfigCopy.chunkSize = null;  // disable Range header if not streaming; bad values break IIS - see issue #196\n\t\t\tthis._handle = new ParserHandle(configCopy);\n\t\t\tthis._handle.streamer = this;\n\t\t\tthis._config = configCopy;\t// persist the copy to the caller\n\t\t}\n\t}\n\n\n\tfunction NetworkStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tif (!config.chunkSize)\n\t\t\tconfig.chunkSize = Papa.RemoteChunkSize;\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar xhr;\n\n\t\tif (IS_WORKER)\n\t\t{\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tthis._readChunk();\n\t\t\t\tthis._chunkLoaded();\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tthis._readChunk();\n\t\t\t};\n\t\t}\n\n\t\tthis.stream = function(url)\n\t\t{\n\t\t\tthis._input = url;\n\t\t\tthis._nextChunk();\t// Starts streaming\n\t\t};\n\n\t\tthis._readChunk = function()\n\t\t{\n\t\t\tif (this._finished)\n\t\t\t{\n\t\t\t\tthis._chunkLoaded();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\txhr = new XMLHttpRequest();\n\t\t\t\n\t\t\tif (!IS_WORKER)\n\t\t\t{\n\t\t\t\txhr.onload = bindFunction(this._chunkLoaded, this);\n\t\t\t\txhr.onerror = bindFunction(this._chunkError, this);\n\t\t\t}\n\n\t\t\txhr.open(\"GET\", this._input, !IS_WORKER);\n\t\t\t\n\t\t\tif (this._config.chunkSize)\n\t\t\t{\n\t\t\t\tvar end = this._start + this._config.chunkSize - 1;\t// minus one because byte range is inclusive\n\t\t\t\txhr.setRequestHeader(\"Range\", \"bytes=\"+this._start+\"-\"+end);\n\t\t\t\txhr.setRequestHeader(\"If-None-Match\", \"webkit-no-cache\"); // https://bugs.webkit.org/show_bug.cgi?id=82672\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\txhr.send();\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\tthis._chunkError(err.message);\n\t\t\t}\n\n\t\t\tif (IS_WORKER && xhr.status == 0)\n\t\t\t\tthis._chunkError();\n\t\t\telse\n\t\t\t\tthis._start += this._config.chunkSize;\n\t\t}\n\n\t\tthis._chunkLoaded = function()\n\t\t{\n\t\t\tif (xhr.readyState != 4)\n\t\t\t\treturn;\n\n\t\t\tif (xhr.status < 200 || xhr.status >= 400)\n\t\t\t{\n\t\t\t\tthis._chunkError();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._finished = !this._config.chunkSize || this._start > getFileSize(xhr);\n\t\t\tthis.parseChunk(xhr.responseText);\n\t\t}\n\n\t\tthis._chunkError = function(errorMessage)\n\t\t{\n\t\t\tvar errorText = xhr.statusText || errorMessage;\n\t\t\tthis._sendError(errorText);\n\t\t}\n\n\t\tfunction getFileSize(xhr)\n\t\t{\n\t\t\tvar contentRange = xhr.getResponseHeader(\"Content-Range\");\n\t\t\treturn parseInt(contentRange.substr(contentRange.lastIndexOf(\"/\") + 1));\n\t\t}\n\t}\n\tNetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\tNetworkStreamer.prototype.constructor = NetworkStreamer;\n\n\n\tfunction FileStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tif (!config.chunkSize)\n\t\t\tconfig.chunkSize = Papa.LocalChunkSize;\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar reader, slice;\n\n\t\t// FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862\n\t\t// But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76\n\t\tvar usingAsyncReader = typeof FileReader !== 'undefined';\t// Safari doesn't consider it a function - see issue #105\n\n\t\tthis.stream = function(file)\n\t\t{\n\t\t\tthis._input = file;\n\t\t\tslice = file.slice || file.webkitSlice || file.mozSlice;\n\n\t\t\tif (usingAsyncReader)\n\t\t\t{\n\t\t\t\treader = new FileReader();\t\t// Preferred method of reading files, even in workers\n\t\t\t\treader.onload = bindFunction(this._chunkLoaded, this);\n\t\t\t\treader.onerror = bindFunction(this._chunkError, this);\n\t\t\t}\n\t\t\telse\n\t\t\t\treader = new FileReaderSync();\t// Hack for running in a web worker in Firefox\n\n\t\t\tthis._nextChunk();\t// Starts streaming\n\t\t};\n\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tif (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))\n\t\t\t\tthis._readChunk();\n\t\t}\n\n\t\tthis._readChunk = function()\n\t\t{\n\t\t\tvar input = this._input;\n\t\t\tif (this._config.chunkSize)\n\t\t\t{\n\t\t\t\tvar end = Math.min(this._start + this._config.chunkSize, this._input.size);\n\t\t\t\tinput = slice.call(input, this._start, end);\n\t\t\t}\n\t\t\tvar txt = reader.readAsText(input, this._config.encoding);\n\t\t\tif (!usingAsyncReader)\n\t\t\t\tthis._chunkLoaded({ target: { result: txt } });\t// mimic the async signature\n\t\t}\n\n\t\tthis._chunkLoaded = function(event)\n\t\t{\n\t\t\t// Very important to increment start each time before handling results\n\t\t\tthis._start += this._config.chunkSize;\n\t\t\tthis._finished = !this._config.chunkSize || this._start >= this._input.size;\n\t\t\tthis.parseChunk(event.target.result);\n\t\t}\n\n\t\tthis._chunkError = function()\n\t\t{\n\t\t\tthis._sendError(reader.error);\n\t\t}\n\n\t}\n\tFileStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\tFileStreamer.prototype.constructor = FileStreamer;\n\n\n\tfunction StringStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar string;\n\t\tvar remaining;\n\t\tthis.stream = function(s)\n\t\t{\n\t\t\tstring = s;\n\t\t\tremaining = s;\n\t\t\treturn this._nextChunk();\n\t\t}\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tif (this._finished) return;\n\t\t\tvar size = this._config.chunkSize;\n\t\t\tvar chunk = size ? remaining.substr(0, size) : remaining;\n\t\t\tremaining = size ? remaining.substr(size) : '';\n\t\t\tthis._finished = !remaining;\n\t\t\treturn this.parseChunk(chunk);\n\t\t}\n\t}\n\tStringStreamer.prototype = Object.create(StringStreamer.prototype);\n\tStringStreamer.prototype.constructor = StringStreamer;\n\n\n\n\t// Use one ParserHandle per entire CSV file or string\n\tfunction ParserHandle(_config)\n\t{\n\t\t// One goal is to minimize the use of regular expressions...\n\t\tvar FLOAT = /^\\s*-?(\\d*\\.?\\d+|\\d+\\.?\\d*)(e[-+]?\\d+)?\\s*$/i;\n\n\t\tvar self = this;\n\t\tvar _stepCounter = 0;\t// Number of times step was called (number of rows parsed)\n\t\tvar _input;\t\t\t\t// The input being parsed\n\t\tvar _parser;\t\t\t// The core parser being used\n\t\tvar _paused = false;\t// Whether we are paused or not\n\t\tvar _aborted = false;   // Whether the parser has aborted or not\n\t\tvar _delimiterError;\t// Temporary state between delimiter detection and processing results\n\t\tvar _fields = [];\t\t// Fields are from the header row of the input, if there is one\n\t\tvar _results = {\t\t// The last results returned from the parser\n\t\t\tdata: [],\n\t\t\terrors: [],\n\t\t\tmeta: {}\n\t\t};\n\n\t\tif (isFunction(_config.step))\n\t\t{\n\t\t\tvar userStep = _config.step;\n\t\t\t_config.step = function(results)\n\t\t\t{\n\t\t\t\t_results = results;\n\n\t\t\t\tif (needsHeaderRow())\n\t\t\t\t\tprocessResults();\n\t\t\t\telse\t// only call user's step function after header row\n\t\t\t\t{\n\t\t\t\t\tprocessResults();\n\n\t\t\t\t\t// It's possbile that this line was empty and there's no row here after all\n\t\t\t\t\tif (_results.data.length == 0)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t_stepCounter += results.data.length;\n\t\t\t\t\tif (_config.preview && _stepCounter > _config.preview)\n\t\t\t\t\t\t_parser.abort();\n\t\t\t\t\telse\n\t\t\t\t\t\tuserStep(_results, self);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Parses input. Most users won't need, and shouldn't mess with, the baseIndex\n\t\t * and ignoreLastRow parameters. They are used by streamers (wrapper functions)\n\t\t * when an input comes in multiple chunks, like from a file.\n\t\t */\n\t\tthis.parse = function(input, baseIndex, ignoreLastRow)\n\t\t{\n\t\t\tif (!_config.newline)\n\t\t\t\t_config.newline = guessLineEndings(input);\n\n\t\t\t_delimiterError = false;\n\t\t\tif (!_config.delimiter)\n\t\t\t{\n\t\t\t\tvar delimGuess = guessDelimiter(input);\n\t\t\t\tif (delimGuess.successful)\n\t\t\t\t\t_config.delimiter = delimGuess.bestDelimiter;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_delimiterError = true;\t// add error after parsing (otherwise it would be overwritten)\n\t\t\t\t\t_config.delimiter = Papa.DefaultDelimiter;\n\t\t\t\t}\n\t\t\t\t_results.meta.delimiter = _config.delimiter;\n\t\t\t}\n\n\t\t\tvar parserConfig = copy(_config);\n\t\t\tif (_config.preview && _config.header)\n\t\t\t\tparserConfig.preview++;\t// to compensate for header row\n\n\t\t\t_input = input;\n\t\t\t_parser = new Parser(parserConfig);\n\t\t\t_results = _parser.parse(_input, baseIndex, ignoreLastRow);\n\t\t\tprocessResults();\n\t\t\treturn _paused ? { meta: { paused: true } } : (_results || { meta: { paused: false } });\n\t\t};\n\n\t\tthis.paused = function()\n\t\t{\n\t\t\treturn _paused;\n\t\t};\n\n\t\tthis.pause = function()\n\t\t{\n\t\t\t_paused = true;\n\t\t\t_parser.abort();\n\t\t\t_input = _input.substr(_parser.getCharIndex());\n\t\t};\n\n\t\tthis.resume = function()\n\t\t{\n\t\t\t_paused = false;\n\t\t\tself.streamer.parseChunk(_input);\n\t\t};\n\n\t\tthis.aborted = function () {\n\t\t\treturn _aborted;\n\t\t}\n\n\t\tthis.abort = function()\n\t\t{\n\t\t\t_aborted = true;\n\t\t\t_parser.abort();\n\t\t\t_results.meta.aborted = true;\n\t\t\tif (isFunction(_config.complete))\n\t\t\t\t_config.complete(_results);\n\t\t\t_input = \"\";\n\t\t};\n\n\t\tfunction processResults()\n\t\t{\n\t\t\tif (_results && _delimiterError)\n\t\t\t{\n\t\t\t\taddError(\"Delimiter\", \"UndetectableDelimiter\", \"Unable to auto-detect delimiting character; defaulted to '\"+Papa.DefaultDelimiter+\"'\");\n\t\t\t\t_delimiterError = false;\n\t\t\t}\n\n\t\t\tif (_config.skipEmptyLines)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < _results.data.length; i++)\n\t\t\t\t\tif (_results.data[i].length == 1 && _results.data[i][0] == \"\")\n\t\t\t\t\t\t_results.data.splice(i--, 1);\n\t\t\t}\n\n\t\t\tif (needsHeaderRow())\n\t\t\t\tfillHeaderFields();\n\n\t\t\treturn applyHeaderAndDynamicTyping();\n\t\t}\n\n\t\tfunction needsHeaderRow()\n\t\t{\n\t\t\treturn _config.header && _fields.length == 0;\n\t\t}\n\n\t\tfunction fillHeaderFields()\n\t\t{\n\t\t\tif (!_results)\n\t\t\t\treturn;\n\t\t\tfor (var i = 0; needsHeaderRow() && i < _results.data.length; i++)\n\t\t\t\tfor (var j = 0; j < _results.data[i].length; j++)\n\t\t\t\t\t_fields.push(_results.data[i][j]);\n\t\t\t_results.data.splice(0, 1);\n\t\t}\n\n\t\tfunction applyHeaderAndDynamicTyping()\n\t\t{\n\t\t\tif (!_results || (!_config.header && !_config.dynamicTyping))\n\t\t\t\treturn _results;\n\n\t\t\tfor (var i = 0; i < _results.data.length; i++)\n\t\t\t{\n\t\t\t\tvar row = {};\n\n\t\t\t\tfor (var j = 0; j < _results.data[i].length; j++)\n\t\t\t\t{\n\t\t\t\t\tif (_config.dynamicTyping)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar value = _results.data[i][j];\n\t\t\t\t\t\tif (value == \"true\" || value == \"TRUE\")\n\t\t\t\t\t\t\t_results.data[i][j] = true;\n\t\t\t\t\t\telse if (value == \"false\" || value == \"FALSE\")\n\t\t\t\t\t\t\t_results.data[i][j] = false;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t_results.data[i][j] = tryParseFloat(value);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_config.header)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (j >= _fields.length)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!row[\"__parsed_extra\"])\n\t\t\t\t\t\t\t\trow[\"__parsed_extra\"] = [];\n\t\t\t\t\t\t\trow[\"__parsed_extra\"].push(_results.data[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\trow[_fields[j]] = _results.data[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (_config.header)\n\t\t\t\t{\n\t\t\t\t\t_results.data[i] = row;\n\t\t\t\t\tif (j > _fields.length)\n\t\t\t\t\t\taddError(\"FieldMismatch\", \"TooManyFields\", \"Too many fields: expected \" + _fields.length + \" fields but parsed \" + j, i);\n\t\t\t\t\telse if (j < _fields.length)\n\t\t\t\t\t\taddError(\"FieldMismatch\", \"TooFewFields\", \"Too few fields: expected \" + _fields.length + \" fields but parsed \" + j, i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_config.header && _results.meta)\n\t\t\t\t_results.meta.fields = _fields;\n\t\t\treturn _results;\n\t\t}\n\n\t\tfunction guessDelimiter(input)\n\t\t{\n\t\t\tvar delimChoices = [\",\", \"\\t\", \"|\", \";\", Papa.RECORD_SEP, Papa.UNIT_SEP];\n\t\t\tvar bestDelim, bestDelta, fieldCountPrevRow;\n\n\t\t\tfor (var i = 0; i < delimChoices.length; i++)\n\t\t\t{\n\t\t\t\tvar delim = delimChoices[i];\n\t\t\t\tvar delta = 0, avgFieldCount = 0;\n\t\t\t\tfieldCountPrevRow = undefined;\n\n\t\t\t\tvar preview = new Parser({\n\t\t\t\t\tdelimiter: delim,\n\t\t\t\t\tpreview: 10\n\t\t\t\t}).parse(input);\n\n\t\t\t\tfor (var j = 0; j < preview.data.length; j++)\n\t\t\t\t{\n\t\t\t\t\tvar fieldCount = preview.data[j].length;\n\t\t\t\t\tavgFieldCount += fieldCount;\n\n\t\t\t\t\tif (typeof fieldCountPrevRow === 'undefined')\n\t\t\t\t\t{\n\t\t\t\t\t\tfieldCountPrevRow = fieldCount;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (fieldCount > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdelta += Math.abs(fieldCount - fieldCountPrevRow);\n\t\t\t\t\t\tfieldCountPrevRow = fieldCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (preview.data.length > 0)\n\t\t\t\t\tavgFieldCount /= preview.data.length;\n\n\t\t\t\tif ((typeof bestDelta === 'undefined' || delta < bestDelta)\n\t\t\t\t\t&& avgFieldCount > 1.99)\n\t\t\t\t{\n\t\t\t\t\tbestDelta = delta;\n\t\t\t\t\tbestDelim = delim;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_config.delimiter = bestDelim;\n\n\t\t\treturn {\n\t\t\t\tsuccessful: !!bestDelim,\n\t\t\t\tbestDelimiter: bestDelim\n\t\t\t}\n\t\t}\n\n\t\tfunction guessLineEndings(input)\n\t\t{\n\t\t\tinput = input.substr(0, 1024*1024);\t// max length 1 MB\n\n\t\t\tvar r = input.split('\\r');\n\n\t\t\tif (r.length == 1)\n\t\t\t\treturn '\\n';\n\n\t\t\tvar numWithN = 0;\n\t\t\tfor (var i = 0; i < r.length; i++)\n\t\t\t{\n\t\t\t\tif (r[i][0] == '\\n')\n\t\t\t\t\tnumWithN++;\n\t\t\t}\n\n\t\t\treturn numWithN >= r.length / 2 ? '\\r\\n' : '\\r';\n\t\t}\n\n\t\tfunction tryParseFloat(val)\n\t\t{\n\t\t\tvar isNumber = FLOAT.test(val);\n\t\t\treturn isNumber ? parseFloat(val) : val;\n\t\t}\n\n\t\tfunction addError(type, code, msg, row)\n\t\t{\n\t\t\t_results.errors.push({\n\t\t\t\ttype: type,\n\t\t\t\tcode: code,\n\t\t\t\tmessage: msg,\n\t\t\t\trow: row\n\t\t\t});\n\t\t}\n\t}\n\n\n\n\n\n\t/** The core parser implements speedy and correct CSV parsing */\n\tfunction Parser(config)\n\t{\n\t\t// Unpack the config object\n\t\tconfig = config || {};\n\t\tvar delim = config.delimiter;\n\t\tvar newline = config.newline;\n\t\tvar comments = config.comments;\n\t\tvar step = config.step;\n\t\tvar preview = config.preview;\n\t\tvar fastMode = config.fastMode;\n\n\t\t// Delimiter must be valid\n\t\tif (typeof delim !== 'string'\n\t\t\t|| Papa.BAD_DELIMITERS.indexOf(delim) > -1)\n\t\t\tdelim = \",\";\n\n\t\t// Comment character must be valid\n\t\tif (comments === delim)\n\t\t\tthrow \"Comment character same as delimiter\";\n\t\telse if (comments === true)\n\t\t\tcomments = \"#\";\n\t\telse if (typeof comments !== 'string'\n\t\t\t|| Papa.BAD_DELIMITERS.indexOf(comments) > -1)\n\t\t\tcomments = false;\n\n\t\t// Newline must be valid: \\r, \\n, or \\r\\n\n\t\tif (newline != '\\n' && newline != '\\r' && newline != '\\r\\n')\n\t\t\tnewline = '\\n';\n\n\t\t// We're gonna need these at the Parser scope\n\t\tvar cursor = 0;\n\t\tvar aborted = false;\n\n\t\tthis.parse = function(input, baseIndex, ignoreLastRow)\n\t\t{\n\t\t\t// For some reason, in Chrome, this speeds things up (!?)\n\t\t\tif (typeof input !== 'string')\n\t\t\t\tthrow \"Input must be a string\";\n\n\t\t\t// We don't need to compute some of these every time parse() is called,\n\t\t\t// but having them in a more local scope seems to perform better\n\t\t\tvar inputLen = input.length,\n\t\t\t\tdelimLen = delim.length,\n\t\t\t\tnewlineLen = newline.length,\n\t\t\t\tcommentsLen = comments.length;\n\t\t\tvar stepIsFunction = typeof step === 'function';\n\n\t\t\t// Establish starting state\n\t\t\tcursor = 0;\n\t\t\tvar data = [], errors = [], row = [], lastCursor = 0;\n\n\t\t\tif (!input)\n\t\t\t\treturn returnable();\n\n\t\t\tif (fastMode || (fastMode !== false && input.indexOf('\"') === -1))\n\t\t\t{\n\t\t\t\tvar rows = input.split(newline);\n\t\t\t\tfor (var i = 0; i < rows.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar row = rows[i];\n\t\t\t\t\tcursor += row.length;\n\t\t\t\t\tif (i !== rows.length - 1)\n\t\t\t\t\t\tcursor += newline.length;\n\t\t\t\t\telse if (ignoreLastRow)\n\t\t\t\t\t\treturn returnable();\n\t\t\t\t\tif (comments && row.substr(0, commentsLen) == comments)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata = [];\n\t\t\t\t\t\tpushRow(row.split(delim));\n\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tpushRow(row.split(delim));\n\t\t\t\t\tif (preview && i >= preview)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata = data.slice(0, preview);\n\t\t\t\t\t\treturn returnable(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn returnable();\n\t\t\t}\n\n\t\t\tvar nextDelim = input.indexOf(delim, cursor);\n\t\t\tvar nextNewline = input.indexOf(newline, cursor);\n\n\t\t\t// Parser loop\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\t// Field has opening quote\n\t\t\t\tif (input[cursor] == '\"')\n\t\t\t\t{\n\t\t\t\t\t// Start our search for the closing quote where the cursor is\n\t\t\t\t\tvar quoteSearch = cursor;\n\n\t\t\t\t\t// Skip the opening quote\n\t\t\t\t\tcursor++;\n\n\t\t\t\t\tfor (;;)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Find closing quote\n\t\t\t\t\t\tvar quoteSearch = input.indexOf('\"', quoteSearch+1);\n\n\t\t\t\t\t\tif (quoteSearch === -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!ignoreLastRow) {\n\t\t\t\t\t\t\t\t// No closing quote... what a pity\n\t\t\t\t\t\t\t\terrors.push({\n\t\t\t\t\t\t\t\t\ttype: \"Quotes\",\n\t\t\t\t\t\t\t\t\tcode: \"MissingQuotes\",\n\t\t\t\t\t\t\t\t\tmessage: \"Quoted field unterminated\",\n\t\t\t\t\t\t\t\t\trow: data.length,\t// row has yet to be inserted\n\t\t\t\t\t\t\t\t\tindex: cursor\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn finish();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (quoteSearch === inputLen-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Closing quote at EOF\n\t\t\t\t\t\t\tvar value = input.substring(cursor, quoteSearch).replace(/\"\"/g, '\"');\n\t\t\t\t\t\t\treturn finish(value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If this quote is escaped, it's part of the data; skip it\n\t\t\t\t\t\tif (input[quoteSearch+1] == '\"')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tquoteSearch++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (input[quoteSearch+1] == delim)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Closing quote followed by delimiter\n\t\t\t\t\t\t\trow.push(input.substring(cursor, quoteSearch).replace(/\"\"/g, '\"'));\n\t\t\t\t\t\t\tcursor = quoteSearch + 1 + delimLen;\n\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (input.substr(quoteSearch+1, newlineLen) === newline)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Closing quote followed by newline\n\t\t\t\t\t\t\trow.push(input.substring(cursor, quoteSearch).replace(/\"\"/g, '\"'));\n\t\t\t\t\t\t\tsaveRow(quoteSearch + 1 + newlineLen);\n\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\t// because we may have skipped the nextDelim in the quoted field\n\n\t\t\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (preview && data.length >= preview)\n\t\t\t\t\t\t\t\treturn returnable(true);\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Comment found at start of new line\n\t\t\t\tif (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments)\n\t\t\t\t{\n\t\t\t\t\tif (nextNewline == -1)\t// Comment ends at EOF\n\t\t\t\t\t\treturn returnable();\n\t\t\t\t\tcursor = nextNewline + newlineLen;\n\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Next delimiter comes before next newline, so we've reached end of field\n\t\t\t\tif (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1))\n\t\t\t\t{\n\t\t\t\t\trow.push(input.substring(cursor, nextDelim));\n\t\t\t\t\tcursor = nextDelim + delimLen;\n\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// End of row\n\t\t\t\tif (nextNewline !== -1)\n\t\t\t\t{\n\t\t\t\t\trow.push(input.substring(cursor, nextNewline));\n\t\t\t\t\tsaveRow(nextNewline + newlineLen);\n\n\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t{\n\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (preview && data.length >= preview)\n\t\t\t\t\t\treturn returnable(true);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\n\t\t\treturn finish();\n\n\n\t\t\tfunction pushRow(row)\n\t\t\t{\n\t\t\t\tdata.push(row);\n\t\t\t\tlastCursor = cursor;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Appends the remaining input from cursor to the end into\n\t\t\t * row, saves the row, calls step, and returns the results.\n\t\t\t */\n\t\t\tfunction finish(value)\n\t\t\t{\n\t\t\t\tif (ignoreLastRow)\n\t\t\t\t\treturn returnable();\n\t\t\t\tif (typeof value === 'undefined')\n\t\t\t\t\tvalue = input.substr(cursor);\n\t\t\t\trow.push(value);\n\t\t\t\tcursor = inputLen;\t// important in case parsing is paused\n\t\t\t\tpushRow(row);\n\t\t\t\tif (stepIsFunction)\n\t\t\t\t\tdoStep();\n\t\t\t\treturn returnable();\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Appends the current row to the results. It sets the cursor\n\t\t\t * to newCursor and finds the nextNewline. The caller should\n\t\t\t * take care to execute user's step function and check for\n\t\t\t * preview and end parsing if necessary.\n\t\t\t */\n\t\t\tfunction saveRow(newCursor)\n\t\t\t{\n\t\t\t\tcursor = newCursor;\n\t\t\t\tpushRow(row);\n\t\t\t\trow = [];\n\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t}\n\n\t\t\t/** Returns an object with the results, errors, and meta. */\n\t\t\tfunction returnable(stopped)\n\t\t\t{\n\t\t\t\treturn {\n\t\t\t\t\tdata: data,\n\t\t\t\t\terrors: errors,\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\tdelimiter: delim,\n\t\t\t\t\t\tlinebreak: newline,\n\t\t\t\t\t\taborted: aborted,\n\t\t\t\t\t\ttruncated: !!stopped,\n\t\t\t\t\t\tcursor: lastCursor + (baseIndex || 0)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t/** Executes the user's step function and resets data & errors. */\n\t\t\tfunction doStep()\n\t\t\t{\n\t\t\t\tstep(returnable());\n\t\t\t\tdata = [], errors = [];\n\t\t\t}\n\t\t};\n\n\t\t/** Sets the abort flag */\n\t\tthis.abort = function()\n\t\t{\n\t\t\taborted = true;\n\t\t};\n\n\t\t/** Gets the cursor position */\n\t\tthis.getCharIndex = function()\n\t\t{\n\t\t\treturn cursor;\n\t\t};\n\t}\n\n\n\t// If you need to load Papa Parse asynchronously and you also need worker threads, hard-code\n\t// the script path here. See: https://github.com/mholt/PapaParse/issues/87#issuecomment-57885358\n\tfunction getScriptPath()\n\t{\n\t\tvar scripts = document.getElementsByTagName('script');\n\t\treturn scripts.length ? scripts[scripts.length - 1].src : '';\n\t}\n\n\tfunction newWorker()\n\t{\n\t\tif (!Papa.WORKERS_SUPPORTED)\n\t\t\treturn false;\n\t\tif (!LOADED_SYNC && Papa.SCRIPT_PATH === null)\n\t\t\tthrow new Error(\n\t\t\t\t'Script path cannot be determined automatically when Papa Parse is loaded asynchronously. ' +\n\t\t\t\t'You need to set Papa.SCRIPT_PATH manually.'\n\t\t\t);\n\t\tvar workerUrl = Papa.SCRIPT_PATH || AUTO_SCRIPT_PATH;\n\t\t// Append \"papaworker\" to the search string to tell papaparse that this is our worker.\n\t\tworkerUrl += (workerUrl.indexOf('?') !== -1 ? '&' : '?') + 'papaworker';\n\t\tvar w = new global.Worker(workerUrl);\n\t\tw.onmessage = mainThreadReceivedMessage;\n\t\tw.id = workerIdCounter++;\n\t\tworkers[w.id] = w;\n\t\treturn w;\n\t}\n\n\t/** Callback when main thread receives a message */\n\tfunction mainThreadReceivedMessage(e)\n\t{\n\t\tvar msg = e.data;\n\t\tvar worker = workers[msg.workerId];\n\t\tvar aborted = false;\n\n\t\tif (msg.error)\n\t\t\tworker.userError(msg.error, msg.file);\n\t\telse if (msg.results && msg.results.data)\n\t\t{\n\t\t\tvar abort = function() {\n\t\t\t\taborted = true;\n\t\t\t\tcompleteWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });\n\t\t\t};\n\n\t\t\tvar handle = {\n\t\t\t\tabort: abort,\n\t\t\t\tpause: notImplemented,\n\t\t\t\tresume: notImplemented\n\t\t\t};\n\n\t\t\tif (isFunction(worker.userStep))\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < msg.results.data.length; i++)\n\t\t\t\t{\n\t\t\t\t\tworker.userStep({\n\t\t\t\t\t\tdata: [msg.results.data[i]],\n\t\t\t\t\t\terrors: msg.results.errors,\n\t\t\t\t\t\tmeta: msg.results.meta\n\t\t\t\t\t}, handle);\n\t\t\t\t\tif (aborted)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdelete msg.results;\t// free memory ASAP\n\t\t\t}\n\t\t\telse if (isFunction(worker.userChunk))\n\t\t\t{\n\t\t\t\tworker.userChunk(msg.results, handle, msg.file);\n\t\t\t\tdelete msg.results;\n\t\t\t}\n\t\t}\n\n\t\tif (msg.finished && !aborted)\n\t\t\tcompleteWorker(msg.workerId, msg.results);\n\t}\n\n\tfunction completeWorker(workerId, results) {\n\t\tvar worker = workers[workerId];\n\t\tif (isFunction(worker.userComplete))\n\t\t\tworker.userComplete(results);\n\t\tworker.terminate();\n\t\tdelete workers[workerId];\n\t}\n\n\tfunction notImplemented() {\n\t\tthrow \"Not implemented.\";\n\t}\n\n\t/** Callback when worker thread receives a message */\n\tfunction workerThreadReceivedMessage(e)\n\t{\n\t\tvar msg = e.data;\n\n\t\tif (typeof Papa.WORKER_ID === 'undefined' && msg)\n\t\t\tPapa.WORKER_ID = msg.workerId;\n\n\t\tif (typeof msg.input === 'string')\n\t\t{\n\t\t\tglobal.postMessage({\n\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\tresults: Papa.parse(msg.input, msg.config),\n\t\t\t\tfinished: true\n\t\t\t});\n\t\t}\n\t\telse if ((global.File && msg.input instanceof File) || msg.input instanceof Object)\t// thank you, Safari (see issue #106)\n\t\t{\n\t\t\tvar results = Papa.parse(msg.input, msg.config);\n\t\t\tif (results)\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\tresults: results,\n\t\t\t\t\tfinished: true\n\t\t\t\t});\n\t\t}\n\t}\n\n\t/** Makes a deep copy of an array or object (mostly) */\n\tfunction copy(obj)\n\t{\n\t\tif (typeof obj !== 'object')\n\t\t\treturn obj;\n\t\tvar cpy = obj instanceof Array ? [] : {};\n\t\tfor (var key in obj)\n\t\t\tcpy[key] = copy(obj[key]);\n\t\treturn cpy;\n\t}\n\n\tfunction bindFunction(f, self)\n\t{\n\t\treturn function() { f.apply(self, arguments); };\n\t}\n\n\tfunction isFunction(func)\n\t{\n\t\treturn typeof func === 'function';\n\t}\n})(typeof window !== 'undefined' ? window : this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/PapaParse/papaparse.js\n// module id = 68\n// module chunks = 1","module.exports = { \"default\": require(\"core-js/library/fn/json/stringify\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/json/stringify.js\n// module id = 83\n// module chunks = 1","module.exports = { \"default\": require(\"core-js/library/fn/object/assign\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/object/assign.js\n// module id = 84\n// module chunks = 1","module.exports = { \"default\": require(\"core-js/library/fn/object/create\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/object/create.js\n// module id = 85\n// module chunks = 1","module.exports = { \"default\": require(\"core-js/library/fn/object/define-property\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/object/define-property.js\n// module id = 86\n// module chunks = 1","module.exports = { \"default\": require(\"core-js/library/fn/object/set-prototype-of\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/object/set-prototype-of.js\n// module id = 87\n// module chunks = 1","module.exports = { \"default\": require(\"core-js/library/fn/symbol\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/symbol.js\n// module id = 88\n// module chunks = 1","module.exports = { \"default\": require(\"core-js/library/fn/symbol/iterator\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/symbol/iterator.js\n// module id = 89\n// module chunks = 1","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/base64-js/index.js\n// module id = 90\n// module chunks = 1","require('../modules/web.dom.iterable');\nrequire('../modules/es6.string.iterator');\nmodule.exports = require('../modules/core.get-iterator');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/get-iterator.js\n// module id = 91\n// module chunks = 1","var core  = require('../../modules/_core')\n  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});\nmodule.exports = function stringify(it){ // eslint-disable-line no-unused-vars\n  return $JSON.stringify.apply($JSON, arguments);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/json/stringify.js\n// module id = 92\n// module chunks = 1","require('../../modules/es6.object.assign');\nmodule.exports = require('../../modules/_core').Object.assign;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/object/assign.js\n// module id = 93\n// module chunks = 1","require('../../modules/es6.object.create');\nvar $Object = require('../../modules/_core').Object;\nmodule.exports = function create(P, D){\n  return $Object.create(P, D);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/object/create.js\n// module id = 94\n// module chunks = 1","require('../../modules/es6.object.define-property');\nvar $Object = require('../../modules/_core').Object;\nmodule.exports = function defineProperty(it, key, desc){\n  return $Object.defineProperty(it, key, desc);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/object/define-property.js\n// module id = 95\n// module chunks = 1","require('../../modules/es6.object.get-prototype-of');\nmodule.exports = require('../../modules/_core').Object.getPrototypeOf;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/object/get-prototype-of.js\n// module id = 96\n// module chunks = 1","require('../../modules/es6.object.keys');\nmodule.exports = require('../../modules/_core').Object.keys;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/object/keys.js\n// module id = 97\n// module chunks = 1","require('../../modules/es6.object.set-prototype-of');\nmodule.exports = require('../../modules/_core').Object.setPrototypeOf;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/object/set-prototype-of.js\n// module id = 98\n// module chunks = 1","require('../../modules/es7.object.values');\nmodule.exports = require('../../modules/_core').Object.values;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/object/values.js\n// module id = 99\n// module chunks = 1","require('../../modules/es6.symbol');\nrequire('../../modules/es6.object.to-string');\nrequire('../../modules/es7.symbol.async-iterator');\nrequire('../../modules/es7.symbol.observable');\nmodule.exports = require('../../modules/_core').Symbol;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/symbol/index.js\n// module id = 100\n// module chunks = 1","require('../../modules/es6.string.iterator');\nrequire('../../modules/web.dom.iterable');\nmodule.exports = require('../../modules/_wks-ext').f('iterator');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/symbol/iterator.js\n// module id = 101\n// module chunks = 1","module.exports = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_a-function.js\n// module id = 102\n// module chunks = 1","module.exports = function(){ /* empty */ };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_add-to-unscopables.js\n// module id = 103\n// module chunks = 1","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject')\n  , toLength  = require('./_to-length')\n  , toIndex   = require('./_to-index');\nmodule.exports = function(IS_INCLUDES){\n  return function($this, el, fromIndex){\n    var O      = toIObject($this)\n      , length = toLength(O.length)\n      , index  = toIndex(fromIndex, length)\n      , value;\n    // Array#includes uses SameValueZero equality algorithm\n    if(IS_INCLUDES && el != el)while(length > index){\n      value = O[index++];\n      if(value != value)return true;\n    // Array#toIndex ignores holes, Array#includes - not\n    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n      if(O[index] === el)return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_array-includes.js\n// module id = 104\n// module chunks = 1","// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = require('./_cof')\n  , TAG = require('./_wks')('toStringTag')\n  // ES3 wrong here\n  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function(it, key){\n  try {\n    return it[key];\n  } catch(e){ /* empty */ }\n};\n\nmodule.exports = function(it){\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_classof.js\n// module id = 105\n// module chunks = 1","// all enumerable object keys, includes symbols\nvar getKeys = require('./_object-keys')\n  , gOPS    = require('./_object-gops')\n  , pIE     = require('./_object-pie');\nmodule.exports = function(it){\n  var result     = getKeys(it)\n    , getSymbols = gOPS.f;\n  if(getSymbols){\n    var symbols = getSymbols(it)\n      , isEnum  = pIE.f\n      , i       = 0\n      , key;\n    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);\n  } return result;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_enum-keys.js\n// module id = 106\n// module chunks = 1","module.exports = require('./_global').document && document.documentElement;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_html.js\n// module id = 107\n// module chunks = 1","// 7.2.2 IsArray(argument)\nvar cof = require('./_cof');\nmodule.exports = Array.isArray || function isArray(arg){\n  return cof(arg) == 'Array';\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_is-array.js\n// module id = 108\n// module chunks = 1","'use strict';\nvar create         = require('./_object-create')\n  , descriptor     = require('./_property-desc')\n  , setToStringTag = require('./_set-to-string-tag')\n  , IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function(){ return this; });\n\nmodule.exports = function(Constructor, NAME, next){\n  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iter-create.js\n// module id = 109\n// module chunks = 1","module.exports = function(done, value){\n  return {value: value, done: !!done};\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iter-step.js\n// module id = 110\n// module chunks = 1","var getKeys   = require('./_object-keys')\n  , toIObject = require('./_to-iobject');\nmodule.exports = function(object, el){\n  var O      = toIObject(object)\n    , keys   = getKeys(O)\n    , length = keys.length\n    , index  = 0\n    , key;\n  while(length > index)if(O[key = keys[index++]] === el)return key;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_keyof.js\n// module id = 111\n// module chunks = 1","var META     = require('./_uid')('meta')\n  , isObject = require('./_is-object')\n  , has      = require('./_has')\n  , setDesc  = require('./_object-dp').f\n  , id       = 0;\nvar isExtensible = Object.isExtensible || function(){\n  return true;\n};\nvar FREEZE = !require('./_fails')(function(){\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function(it){\n  setDesc(it, META, {value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  }});\n};\nvar fastKey = function(it, create){\n  // return primitive with prefix\n  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if(!has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return 'F';\n    // not necessary to add metadata\n    if(!create)return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function(it, create){\n  if(!has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return true;\n    // not necessary to add metadata\n    if(!create)return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function(it){\n  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY:      META,\n  NEED:     false,\n  fastKey:  fastKey,\n  getWeak:  getWeak,\n  onFreeze: onFreeze\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_meta.js\n// module id = 112\n// module chunks = 1","'use strict';\n// 19.1.2.1 Object.assign(target, source, ...)\nvar getKeys  = require('./_object-keys')\n  , gOPS     = require('./_object-gops')\n  , pIE      = require('./_object-pie')\n  , toObject = require('./_to-object')\n  , IObject  = require('./_iobject')\n  , $assign  = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || require('./_fails')(function(){\n  var A = {}\n    , B = {}\n    , S = Symbol()\n    , K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function(k){ B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source){ // eslint-disable-line no-unused-vars\n  var T     = toObject(target)\n    , aLen  = arguments.length\n    , index = 1\n    , getSymbols = gOPS.f\n    , isEnum     = pIE.f;\n  while(aLen > index){\n    var S      = IObject(arguments[index++])\n      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)\n      , length = keys.length\n      , j      = 0\n      , key;\n    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];\n  } return T;\n} : $assign;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-assign.js\n// module id = 113\n// module chunks = 1","var dP       = require('./_object-dp')\n  , anObject = require('./_an-object')\n  , getKeys  = require('./_object-keys');\n\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){\n  anObject(O);\n  var keys   = getKeys(Properties)\n    , length = keys.length\n    , i = 0\n    , P;\n  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-dps.js\n// module id = 114\n// module chunks = 1","// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = require('./_to-iobject')\n  , gOPN      = require('./_object-gopn').f\n  , toString  = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function(it){\n  try {\n    return gOPN(it);\n  } catch(e){\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.f = function getOwnPropertyNames(it){\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-gopn-ext.js\n// module id = 115\n// module chunks = 1","var getKeys   = require('./_object-keys')\n  , toIObject = require('./_to-iobject')\n  , isEnum    = require('./_object-pie').f;\nmodule.exports = function(isEntries){\n  return function(it){\n    var O      = toIObject(it)\n      , keys   = getKeys(O)\n      , length = keys.length\n      , i      = 0\n      , result = []\n      , key;\n    while(length > i)if(isEnum.call(O, key = keys[i++])){\n      result.push(isEntries ? [key, O[key]] : O[key]);\n    } return result;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-to-array.js\n// module id = 116\n// module chunks = 1","// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nvar isObject = require('./_is-object')\n  , anObject = require('./_an-object');\nvar check = function(O, proto){\n  anObject(O);\n  if(!isObject(proto) && proto !== null)throw TypeError(proto + \": can't set as prototype!\");\n};\nmodule.exports = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n    function(test, buggy, set){\n      try {\n        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch(e){ buggy = true; }\n      return function setPrototypeOf(O, proto){\n        check(O, proto);\n        if(buggy)O.__proto__ = proto;\n        else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n  check: check\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_set-proto.js\n// module id = 117\n// module chunks = 1","var toInteger = require('./_to-integer')\n  , defined   = require('./_defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function(TO_STRING){\n  return function(that, pos){\n    var s = String(defined(that))\n      , i = toInteger(pos)\n      , l = s.length\n      , a, b;\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_string-at.js\n// module id = 118\n// module chunks = 1","var toInteger = require('./_to-integer')\n  , max       = Math.max\n  , min       = Math.min;\nmodule.exports = function(index, length){\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-index.js\n// module id = 119\n// module chunks = 1","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer')\n  , min       = Math.min;\nmodule.exports = function(it){\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-length.js\n// module id = 120\n// module chunks = 1","var classof   = require('./_classof')\n  , ITERATOR  = require('./_wks')('iterator')\n  , Iterators = require('./_iterators');\nmodule.exports = require('./_core').getIteratorMethod = function(it){\n  if(it != undefined)return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/core.get-iterator-method.js\n// module id = 121\n// module chunks = 1","var anObject = require('./_an-object')\n  , get      = require('./core.get-iterator-method');\nmodule.exports = require('./_core').getIterator = function(it){\n  var iterFn = get(it);\n  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');\n  return anObject(iterFn.call(it));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/core.get-iterator.js\n// module id = 122\n// module chunks = 1","'use strict';\nvar addToUnscopables = require('./_add-to-unscopables')\n  , step             = require('./_iter-step')\n  , Iterators        = require('./_iterators')\n  , toIObject        = require('./_to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./_iter-define')(Array, 'Array', function(iterated, kind){\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , kind  = this._k\n    , index = this._i++;\n  if(!O || index >= O.length){\n    this._t = undefined;\n    return step(1);\n  }\n  if(kind == 'keys'  )return step(0, index);\n  if(kind == 'values')return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.array.iterator.js\n// module id = 123\n// module chunks = 1","// 19.1.3.1 Object.assign(target, source)\nvar $export = require('./_export');\n\n$export($export.S + $export.F, 'Object', {assign: require('./_object-assign')});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.object.assign.js\n// module id = 124\n// module chunks = 1","var $export = require('./_export')\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n$export($export.S, 'Object', {create: require('./_object-create')});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.object.create.js\n// module id = 125\n// module chunks = 1","var $export = require('./_export');\n// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\n$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperty: require('./_object-dp').f});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.object.define-property.js\n// module id = 126\n// module chunks = 1","// 19.1.2.9 Object.getPrototypeOf(O)\nvar toObject        = require('./_to-object')\n  , $getPrototypeOf = require('./_object-gpo');\n\nrequire('./_object-sap')('getPrototypeOf', function(){\n  return function getPrototypeOf(it){\n    return $getPrototypeOf(toObject(it));\n  };\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.object.get-prototype-of.js\n// module id = 127\n// module chunks = 1","// 19.1.2.14 Object.keys(O)\nvar toObject = require('./_to-object')\n  , $keys    = require('./_object-keys');\n\nrequire('./_object-sap')('keys', function(){\n  return function keys(it){\n    return $keys(toObject(it));\n  };\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.object.keys.js\n// module id = 128\n// module chunks = 1","// 19.1.3.19 Object.setPrototypeOf(O, proto)\nvar $export = require('./_export');\n$export($export.S, 'Object', {setPrototypeOf: require('./_set-proto').set});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.object.set-prototype-of.js\n// module id = 129\n// module chunks = 1","'use strict';\n// ECMAScript 6 symbols shim\nvar global         = require('./_global')\n  , has            = require('./_has')\n  , DESCRIPTORS    = require('./_descriptors')\n  , $export        = require('./_export')\n  , redefine       = require('./_redefine')\n  , META           = require('./_meta').KEY\n  , $fails         = require('./_fails')\n  , shared         = require('./_shared')\n  , setToStringTag = require('./_set-to-string-tag')\n  , uid            = require('./_uid')\n  , wks            = require('./_wks')\n  , wksExt         = require('./_wks-ext')\n  , wksDefine      = require('./_wks-define')\n  , keyOf          = require('./_keyof')\n  , enumKeys       = require('./_enum-keys')\n  , isArray        = require('./_is-array')\n  , anObject       = require('./_an-object')\n  , toIObject      = require('./_to-iobject')\n  , toPrimitive    = require('./_to-primitive')\n  , createDesc     = require('./_property-desc')\n  , _create        = require('./_object-create')\n  , gOPNExt        = require('./_object-gopn-ext')\n  , $GOPD          = require('./_object-gopd')\n  , $DP            = require('./_object-dp')\n  , $keys          = require('./_object-keys')\n  , gOPD           = $GOPD.f\n  , dP             = $DP.f\n  , gOPN           = gOPNExt.f\n  , $Symbol        = global.Symbol\n  , $JSON          = global.JSON\n  , _stringify     = $JSON && $JSON.stringify\n  , PROTOTYPE      = 'prototype'\n  , HIDDEN         = wks('_hidden')\n  , TO_PRIMITIVE   = wks('toPrimitive')\n  , isEnum         = {}.propertyIsEnumerable\n  , SymbolRegistry = shared('symbol-registry')\n  , AllSymbols     = shared('symbols')\n  , OPSymbols      = shared('op-symbols')\n  , ObjectProto    = Object[PROTOTYPE]\n  , USE_NATIVE     = typeof $Symbol == 'function'\n  , QObject        = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function(){\n  return _create(dP({}, 'a', {\n    get: function(){ return dP(this, 'a', {value: 7}).a; }\n  })).a != 7;\n}) ? function(it, key, D){\n  var protoDesc = gOPD(ObjectProto, key);\n  if(protoDesc)delete ObjectProto[key];\n  dP(it, key, D);\n  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);\n} : dP;\n\nvar wrap = function(tag){\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){\n  return typeof it == 'symbol';\n} : function(it){\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D){\n  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);\n  anObject(it);\n  key = toPrimitive(key, true);\n  anObject(D);\n  if(has(AllSymbols, key)){\n    if(!D.enumerable){\n      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n      D = _create(D, {enumerable: createDesc(0, false)});\n    } return setSymbolDesc(it, key, D);\n  } return dP(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P){\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P))\n    , i    = 0\n    , l = keys.length\n    , key;\n  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P){\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n  var E = isEnum.call(this, key = toPrimitive(key, true));\n  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n  it  = toIObject(it);\n  key = toPrimitive(key, true);\n  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;\n  var D = gOPD(it, key);\n  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n  var names  = gOPN(toIObject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i){\n    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n  var IS_OP  = it === ObjectProto\n    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i){\n    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif(!USE_NATIVE){\n  $Symbol = function Symbol(){\n    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function(value){\n      if(this === ObjectProto)$set.call(OPSymbols, value);\n      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    };\n    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});\n    return wrap(tag);\n  };\n  redefine($Symbol[PROTOTYPE], 'toString', function toString(){\n    return this._k;\n  });\n\n  $GOPD.f = $getOwnPropertyDescriptor;\n  $DP.f   = $defineProperty;\n  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;\n  require('./_object-pie').f  = $propertyIsEnumerable;\n  require('./_object-gops').f = $getOwnPropertySymbols;\n\n  if(DESCRIPTORS && !require('./_library')){\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  wksExt.f = function(name){\n    return wrap(wks(name));\n  }\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});\n\nfor(var symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);\n\nfor(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);\n\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function(key){\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(key){\n    if(isSymbol(key))return keyOf(SymbolRegistry, key);\n    throw TypeError(key + ' is not a symbol!');\n  },\n  useSetter: function(){ setter = true; },\n  useSimple: function(){ setter = false; }\n});\n\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it){\n    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n    var args = [it]\n      , i    = 1\n      , replacer, $replacer;\n    while(arguments.length > i)args.push(arguments[i++]);\n    replacer = args[1];\n    if(typeof replacer == 'function')$replacer = replacer;\n    if($replacer || !isArray(replacer))replacer = function(key, value){\n      if($replacer)value = $replacer.call(this, key, value);\n      if(!isSymbol(value))return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.symbol.js\n// module id = 131\n// module chunks = 1","// https://github.com/tc39/proposal-object-values-entries\nvar $export = require('./_export')\n  , $values = require('./_object-to-array')(false);\n\n$export($export.S, 'Object', {\n  values: function values(it){\n    return $values(it);\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es7.object.values.js\n// module id = 132\n// module chunks = 1","require('./_wks-define')('asyncIterator');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es7.symbol.async-iterator.js\n// module id = 133\n// module chunks = 1","require('./_wks-define')('observable');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es7.symbol.observable.js\n// module id = 134\n// module chunks = 1","// https://d3js.org Version 4.3.0. Copyright 2016 Mike Bostock.\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.d3 = global.d3 || {})));\n}(this, (function (exports) { 'use strict';\n\nvar version = \"4.3.0\";\n\nvar ascending = function(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n};\n\nvar bisector = function(compare) {\n  if (compare.length === 1) compare = ascendingComparator(compare);\n  return {\n    left: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      }\n      return lo;\n    },\n    right: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) > 0) hi = mid;\n        else lo = mid + 1;\n      }\n      return lo;\n    }\n  };\n};\n\nfunction ascendingComparator(f) {\n  return function(d, x) {\n    return ascending(f(d), x);\n  };\n}\n\nvar ascendingBisect = bisector(ascending);\nvar bisectRight = ascendingBisect.right;\nvar bisectLeft = ascendingBisect.left;\n\nvar descending = function(a, b) {\n  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n};\n\nvar number = function(x) {\n  return x === null ? NaN : +x;\n};\n\nvar variance = function(array, f) {\n  var n = array.length,\n      m = 0,\n      a,\n      d,\n      s = 0,\n      i = -1,\n      j = 0;\n\n  if (f == null) {\n    while (++i < n) {\n      if (!isNaN(a = number(array[i]))) {\n        d = a - m;\n        m += d / ++j;\n        s += d * (a - m);\n      }\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (!isNaN(a = number(f(array[i], i, array)))) {\n        d = a - m;\n        m += d / ++j;\n        s += d * (a - m);\n      }\n    }\n  }\n\n  if (j > 1) return s / (j - 1);\n};\n\nvar deviation = function(array, f) {\n  var v = variance(array, f);\n  return v ? Math.sqrt(v) : v;\n};\n\nvar extent = function(array, f) {\n  var i = -1,\n      n = array.length,\n      a,\n      b,\n      c;\n\n  if (f == null) {\n    while (++i < n) if ((b = array[i]) != null && b >= b) { a = c = b; break; }\n    while (++i < n) if ((b = array[i]) != null) {\n      if (a > b) a = b;\n      if (c < b) c = b;\n    }\n  }\n\n  else {\n    while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = c = b; break; }\n    while (++i < n) if ((b = f(array[i], i, array)) != null) {\n      if (a > b) a = b;\n      if (c < b) c = b;\n    }\n  }\n\n  return [a, c];\n};\n\nvar array = Array.prototype;\n\nvar slice = array.slice;\nvar map = array.map;\n\nvar constant$1 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nvar identity = function(x) {\n  return x;\n};\n\nvar range = function(start, stop, step) {\n  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n\n  var i = -1,\n      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n      range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n};\n\nvar e10 = Math.sqrt(50);\nvar e5 = Math.sqrt(10);\nvar e2 = Math.sqrt(2);\n\nvar ticks = function(start, stop, count) {\n  var step = tickStep(start, stop, count);\n  return range(\n    Math.ceil(start / step) * step,\n    Math.floor(stop / step) * step + step / 2, // inclusive\n    step\n  );\n};\n\nfunction tickStep(start, stop, count) {\n  var step0 = Math.abs(stop - start) / Math.max(0, count),\n      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),\n      error = step0 / step1;\n  if (error >= e10) step1 *= 10;\n  else if (error >= e5) step1 *= 5;\n  else if (error >= e2) step1 *= 2;\n  return stop < start ? -step1 : step1;\n}\n\nvar sturges = function(values) {\n  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;\n};\n\nvar histogram = function() {\n  var value = identity,\n      domain = extent,\n      threshold = sturges;\n\n  function histogram(data) {\n    var i,\n        n = data.length,\n        x,\n        values = new Array(n);\n\n    for (i = 0; i < n; ++i) {\n      values[i] = value(data[i], i, data);\n    }\n\n    var xz = domain(values),\n        x0 = xz[0],\n        x1 = xz[1],\n        tz = threshold(values, x0, x1);\n\n    // Convert number of thresholds into uniform thresholds.\n    if (!Array.isArray(tz)) tz = ticks(x0, x1, tz);\n\n    // Remove any thresholds outside the domain.\n    var m = tz.length;\n    while (tz[0] <= x0) tz.shift(), --m;\n    while (tz[m - 1] >= x1) tz.pop(), --m;\n\n    var bins = new Array(m + 1),\n        bin;\n\n    // Initialize bins.\n    for (i = 0; i <= m; ++i) {\n      bin = bins[i] = [];\n      bin.x0 = i > 0 ? tz[i - 1] : x0;\n      bin.x1 = i < m ? tz[i] : x1;\n    }\n\n    // Assign data to bins by value, ignoring any outside the domain.\n    for (i = 0; i < n; ++i) {\n      x = values[i];\n      if (x0 <= x && x <= x1) {\n        bins[bisectRight(tz, x, 0, m)].push(data[i]);\n      }\n    }\n\n    return bins;\n  }\n\n  histogram.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant$1(_), histogram) : value;\n  };\n\n  histogram.domain = function(_) {\n    return arguments.length ? (domain = typeof _ === \"function\" ? _ : constant$1([_[0], _[1]]), histogram) : domain;\n  };\n\n  histogram.thresholds = function(_) {\n    return arguments.length ? (threshold = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant$1(slice.call(_)) : constant$1(_), histogram) : threshold;\n  };\n\n  return histogram;\n};\n\nvar threshold = function(array, p, f) {\n  if (f == null) f = number;\n  if (!(n = array.length)) return;\n  if ((p = +p) <= 0 || n < 2) return +f(array[0], 0, array);\n  if (p >= 1) return +f(array[n - 1], n - 1, array);\n  var n,\n      h = (n - 1) * p,\n      i = Math.floor(h),\n      a = +f(array[i], i, array),\n      b = +f(array[i + 1], i + 1, array);\n  return a + (b - a) * (h - i);\n};\n\nvar freedmanDiaconis = function(values, min, max) {\n  values = map.call(values, number).sort(ascending);\n  return Math.ceil((max - min) / (2 * (threshold(values, 0.75) - threshold(values, 0.25)) * Math.pow(values.length, -1 / 3)));\n};\n\nvar scott = function(values, min, max) {\n  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));\n};\n\nvar max = function(array, f) {\n  var i = -1,\n      n = array.length,\n      a,\n      b;\n\n  if (f == null) {\n    while (++i < n) if ((b = array[i]) != null && b >= b) { a = b; break; }\n    while (++i < n) if ((b = array[i]) != null && b > a) a = b;\n  }\n\n  else {\n    while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = b; break; }\n    while (++i < n) if ((b = f(array[i], i, array)) != null && b > a) a = b;\n  }\n\n  return a;\n};\n\nvar mean = function(array, f) {\n  var s = 0,\n      n = array.length,\n      a,\n      i = -1,\n      j = n;\n\n  if (f == null) {\n    while (++i < n) if (!isNaN(a = number(array[i]))) s += a; else --j;\n  }\n\n  else {\n    while (++i < n) if (!isNaN(a = number(f(array[i], i, array)))) s += a; else --j;\n  }\n\n  if (j) return s / j;\n};\n\nvar median = function(array, f) {\n  var numbers = [],\n      n = array.length,\n      a,\n      i = -1;\n\n  if (f == null) {\n    while (++i < n) if (!isNaN(a = number(array[i]))) numbers.push(a);\n  }\n\n  else {\n    while (++i < n) if (!isNaN(a = number(f(array[i], i, array)))) numbers.push(a);\n  }\n\n  return threshold(numbers.sort(ascending), 0.5);\n};\n\nvar merge = function(arrays) {\n  var n = arrays.length,\n      m,\n      i = -1,\n      j = 0,\n      merged,\n      array;\n\n  while (++i < n) j += arrays[i].length;\n  merged = new Array(j);\n\n  while (--n >= 0) {\n    array = arrays[n];\n    m = array.length;\n    while (--m >= 0) {\n      merged[--j] = array[m];\n    }\n  }\n\n  return merged;\n};\n\nvar min = function(array, f) {\n  var i = -1,\n      n = array.length,\n      a,\n      b;\n\n  if (f == null) {\n    while (++i < n) if ((b = array[i]) != null && b >= b) { a = b; break; }\n    while (++i < n) if ((b = array[i]) != null && a > b) a = b;\n  }\n\n  else {\n    while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = b; break; }\n    while (++i < n) if ((b = f(array[i], i, array)) != null && a > b) a = b;\n  }\n\n  return a;\n};\n\nvar pairs = function(array) {\n  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);\n  while (i < n) pairs[i] = [p, p = array[++i]];\n  return pairs;\n};\n\nvar permute = function(array, indexes) {\n  var i = indexes.length, permutes = new Array(i);\n  while (i--) permutes[i] = array[indexes[i]];\n  return permutes;\n};\n\nvar scan = function(array, compare) {\n  if (!(n = array.length)) return;\n  var i = 0,\n      n,\n      j = 0,\n      xi,\n      xj = array[j];\n\n  if (!compare) compare = ascending;\n\n  while (++i < n) if (compare(xi = array[i], xj) < 0 || compare(xj, xj) !== 0) xj = xi, j = i;\n\n  if (compare(xj, xj) === 0) return j;\n};\n\nvar shuffle = function(array, i0, i1) {\n  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),\n      t,\n      i;\n\n  while (m) {\n    i = Math.random() * m-- | 0;\n    t = array[m + i0];\n    array[m + i0] = array[i + i0];\n    array[i + i0] = t;\n  }\n\n  return array;\n};\n\nvar sum = function(array, f) {\n  var s = 0,\n      n = array.length,\n      a,\n      i = -1;\n\n  if (f == null) {\n    while (++i < n) if (a = +array[i]) s += a; // Note: zero and null are equivalent.\n  }\n\n  else {\n    while (++i < n) if (a = +f(array[i], i, array)) s += a;\n  }\n\n  return s;\n};\n\nvar transpose = function(matrix) {\n  if (!(n = matrix.length)) return [];\n  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {\n    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {\n      row[j] = matrix[j][i];\n    }\n  }\n  return transpose;\n};\n\nfunction length(d) {\n  return d.length;\n}\n\nvar zip = function() {\n  return transpose(arguments);\n};\n\nvar prefix = \"$\";\n\nfunction Map() {}\n\nMap.prototype = map$1.prototype = {\n  constructor: Map,\n  has: function(key) {\n    return (prefix + key) in this;\n  },\n  get: function(key) {\n    return this[prefix + key];\n  },\n  set: function(key, value) {\n    this[prefix + key] = value;\n    return this;\n  },\n  remove: function(key) {\n    var property = prefix + key;\n    return property in this && delete this[property];\n  },\n  clear: function() {\n    for (var property in this) if (property[0] === prefix) delete this[property];\n  },\n  keys: function() {\n    var keys = [];\n    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));\n    return keys;\n  },\n  values: function() {\n    var values = [];\n    for (var property in this) if (property[0] === prefix) values.push(this[property]);\n    return values;\n  },\n  entries: function() {\n    var entries = [];\n    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});\n    return entries;\n  },\n  size: function() {\n    var size = 0;\n    for (var property in this) if (property[0] === prefix) ++size;\n    return size;\n  },\n  empty: function() {\n    for (var property in this) if (property[0] === prefix) return false;\n    return true;\n  },\n  each: function(f) {\n    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);\n  }\n};\n\nfunction map$1(object, f) {\n  var map = new Map;\n\n  // Copy constructor.\n  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });\n\n  // Index array by numeric index or specified key function.\n  else if (Array.isArray(object)) {\n    var i = -1,\n        n = object.length,\n        o;\n\n    if (f == null) while (++i < n) map.set(i, object[i]);\n    else while (++i < n) map.set(f(o = object[i], i, object), o);\n  }\n\n  // Convert object to map.\n  else if (object) for (var key in object) map.set(key, object[key]);\n\n  return map;\n}\n\nvar nest = function() {\n  var keys = [],\n      sortKeys = [],\n      sortValues,\n      rollup,\n      nest;\n\n  function apply(array, depth, createResult, setResult) {\n    if (depth >= keys.length) return rollup != null\n        ? rollup(array) : (sortValues != null\n        ? array.sort(sortValues)\n        : array);\n\n    var i = -1,\n        n = array.length,\n        key = keys[depth++],\n        keyValue,\n        value,\n        valuesByKey = map$1(),\n        values,\n        result = createResult();\n\n    while (++i < n) {\n      if (values = valuesByKey.get(keyValue = key(value = array[i]) + \"\")) {\n        values.push(value);\n      } else {\n        valuesByKey.set(keyValue, [value]);\n      }\n    }\n\n    valuesByKey.each(function(values, key) {\n      setResult(result, key, apply(values, depth, createResult, setResult));\n    });\n\n    return result;\n  }\n\n  function entries(map, depth) {\n    if (++depth > keys.length) return map;\n    var array, sortKey = sortKeys[depth - 1];\n    if (rollup != null && depth >= keys.length) array = map.entries();\n    else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });\n    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;\n  }\n\n  return nest = {\n    object: function(array) { return apply(array, 0, createObject, setObject); },\n    map: function(array) { return apply(array, 0, createMap, setMap); },\n    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },\n    key: function(d) { keys.push(d); return nest; },\n    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },\n    sortValues: function(order) { sortValues = order; return nest; },\n    rollup: function(f) { rollup = f; return nest; }\n  };\n};\n\nfunction createObject() {\n  return {};\n}\n\nfunction setObject(object, key, value) {\n  object[key] = value;\n}\n\nfunction createMap() {\n  return map$1();\n}\n\nfunction setMap(map, key, value) {\n  map.set(key, value);\n}\n\nfunction Set() {}\n\nvar proto = map$1.prototype;\n\nSet.prototype = set.prototype = {\n  constructor: Set,\n  has: proto.has,\n  add: function(value) {\n    value += \"\";\n    this[prefix + value] = value;\n    return this;\n  },\n  remove: proto.remove,\n  clear: proto.clear,\n  values: proto.keys,\n  size: proto.size,\n  empty: proto.empty,\n  each: proto.each\n};\n\nfunction set(object, f) {\n  var set = new Set;\n\n  // Copy constructor.\n  if (object instanceof Set) object.each(function(value) { set.add(value); });\n\n  // Otherwise, assume it’s an array.\n  else if (object) {\n    var i = -1, n = object.length;\n    if (f == null) while (++i < n) set.add(object[i]);\n    else while (++i < n) set.add(f(object[i], i, object));\n  }\n\n  return set;\n}\n\nvar keys = function(map) {\n  var keys = [];\n  for (var key in map) keys.push(key);\n  return keys;\n};\n\nvar values = function(map) {\n  var values = [];\n  for (var key in map) values.push(map[key]);\n  return values;\n};\n\nvar entries = function(map) {\n  var entries = [];\n  for (var key in map) entries.push({key: key, value: map[key]});\n  return entries;\n};\n\nvar uniform = function(min, max) {\n  min = min == null ? 0 : +min;\n  max = max == null ? 1 : +max;\n  if (arguments.length === 1) max = min, min = 0;\n  else max -= min;\n  return function() {\n    return Math.random() * max + min;\n  };\n};\n\nvar normal = function(mu, sigma) {\n  var x, r;\n  mu = mu == null ? 0 : +mu;\n  sigma = sigma == null ? 1 : +sigma;\n  return function() {\n    var y;\n\n    // If available, use the second previously-generated uniform random.\n    if (x != null) y = x, x = null;\n\n    // Otherwise, generate a new x and y.\n    else do {\n      x = Math.random() * 2 - 1;\n      y = Math.random() * 2 - 1;\n      r = x * x + y * y;\n    } while (!r || r > 1);\n\n    return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);\n  };\n};\n\nvar logNormal = function() {\n  var randomNormal = normal.apply(this, arguments);\n  return function() {\n    return Math.exp(randomNormal());\n  };\n};\n\nvar irwinHall = function(n) {\n  return function() {\n    for (var sum = 0, i = 0; i < n; ++i) sum += Math.random();\n    return sum;\n  };\n};\n\nvar bates = function(n) {\n  var randomIrwinHall = irwinHall(n);\n  return function() {\n    return randomIrwinHall() / n;\n  };\n};\n\nvar exponential = function(lambda) {\n  return function() {\n    return -Math.log(1 - Math.random()) / lambda;\n  };\n};\n\nfunction linear(t) {\n  return +t;\n}\n\nfunction quadIn(t) {\n  return t * t;\n}\n\nfunction quadOut(t) {\n  return t * (2 - t);\n}\n\nfunction quadInOut(t) {\n  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;\n}\n\nfunction cubicIn(t) {\n  return t * t * t;\n}\n\nfunction cubicOut(t) {\n  return --t * t * t + 1;\n}\n\nfunction cubicInOut(t) {\n  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\n}\n\nvar exponent = 3;\n\nvar polyIn = (function custom(e) {\n  e = +e;\n\n  function polyIn(t) {\n    return Math.pow(t, e);\n  }\n\n  polyIn.exponent = custom;\n\n  return polyIn;\n})(exponent);\n\nvar polyOut = (function custom(e) {\n  e = +e;\n\n  function polyOut(t) {\n    return 1 - Math.pow(1 - t, e);\n  }\n\n  polyOut.exponent = custom;\n\n  return polyOut;\n})(exponent);\n\nvar polyInOut = (function custom(e) {\n  e = +e;\n\n  function polyInOut(t) {\n    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;\n  }\n\n  polyInOut.exponent = custom;\n\n  return polyInOut;\n})(exponent);\n\nvar pi = Math.PI;\nvar halfPi = pi / 2;\n\nfunction sinIn(t) {\n  return 1 - Math.cos(t * halfPi);\n}\n\nfunction sinOut(t) {\n  return Math.sin(t * halfPi);\n}\n\nfunction sinInOut(t) {\n  return (1 - Math.cos(pi * t)) / 2;\n}\n\nfunction expIn(t) {\n  return Math.pow(2, 10 * t - 10);\n}\n\nfunction expOut(t) {\n  return 1 - Math.pow(2, -10 * t);\n}\n\nfunction expInOut(t) {\n  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;\n}\n\nfunction circleIn(t) {\n  return 1 - Math.sqrt(1 - t * t);\n}\n\nfunction circleOut(t) {\n  return Math.sqrt(1 - --t * t);\n}\n\nfunction circleInOut(t) {\n  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;\n}\n\nvar b1 = 4 / 11;\nvar b2 = 6 / 11;\nvar b3 = 8 / 11;\nvar b4 = 3 / 4;\nvar b5 = 9 / 11;\nvar b6 = 10 / 11;\nvar b7 = 15 / 16;\nvar b8 = 21 / 22;\nvar b9 = 63 / 64;\nvar b0 = 1 / b1 / b1;\n\nfunction bounceIn(t) {\n  return 1 - bounceOut(1 - t);\n}\n\nfunction bounceOut(t) {\n  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;\n}\n\nfunction bounceInOut(t) {\n  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;\n}\n\nvar overshoot = 1.70158;\n\nvar backIn = (function custom(s) {\n  s = +s;\n\n  function backIn(t) {\n    return t * t * ((s + 1) * t - s);\n  }\n\n  backIn.overshoot = custom;\n\n  return backIn;\n})(overshoot);\n\nvar backOut = (function custom(s) {\n  s = +s;\n\n  function backOut(t) {\n    return --t * t * ((s + 1) * t + s) + 1;\n  }\n\n  backOut.overshoot = custom;\n\n  return backOut;\n})(overshoot);\n\nvar backInOut = (function custom(s) {\n  s = +s;\n\n  function backInOut(t) {\n    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;\n  }\n\n  backInOut.overshoot = custom;\n\n  return backInOut;\n})(overshoot);\n\nvar tau = 2 * Math.PI;\nvar amplitude = 1;\nvar period = 0.3;\n\nvar elasticIn = (function custom(a, p) {\n  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);\n\n  function elasticIn(t) {\n    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);\n  }\n\n  elasticIn.amplitude = function(a) { return custom(a, p * tau); };\n  elasticIn.period = function(p) { return custom(a, p); };\n\n  return elasticIn;\n})(amplitude, period);\n\nvar elasticOut = (function custom(a, p) {\n  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);\n\n  function elasticOut(t) {\n    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);\n  }\n\n  elasticOut.amplitude = function(a) { return custom(a, p * tau); };\n  elasticOut.period = function(p) { return custom(a, p); };\n\n  return elasticOut;\n})(amplitude, period);\n\nvar elasticInOut = (function custom(a, p) {\n  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);\n\n  function elasticInOut(t) {\n    return ((t = t * 2 - 1) < 0\n        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)\n        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;\n  }\n\n  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };\n  elasticInOut.period = function(p) { return custom(a, p); };\n\n  return elasticInOut;\n})(amplitude, period);\n\nvar area = function(polygon) {\n  var i = -1,\n      n = polygon.length,\n      a,\n      b = polygon[n - 1],\n      area = 0;\n\n  while (++i < n) {\n    a = b;\n    b = polygon[i];\n    area += a[1] * b[0] - a[0] * b[1];\n  }\n\n  return area / 2;\n};\n\nvar centroid = function(polygon) {\n  var i = -1,\n      n = polygon.length,\n      x = 0,\n      y = 0,\n      a,\n      b = polygon[n - 1],\n      c,\n      k = 0;\n\n  while (++i < n) {\n    a = b;\n    b = polygon[i];\n    k += c = a[0] * b[1] - b[0] * a[1];\n    x += (a[0] + b[0]) * c;\n    y += (a[1] + b[1]) * c;\n  }\n\n  return k *= 3, [x / k, y / k];\n};\n\n// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of\n// the 3D cross product in a quadrant I Cartesian coordinate system (+x is\n// right, +y is up). Returns a positive value if ABC is counter-clockwise,\n// negative if clockwise, and zero if the points are collinear.\nvar cross = function(a, b, c) {\n  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\n};\n\nfunction lexicographicOrder(a, b) {\n  return a[0] - b[0] || a[1] - b[1];\n}\n\n// Computes the upper convex hull per the monotone chain algorithm.\n// Assumes points.length >= 3, is sorted by x, unique in y.\n// Returns an array of indices into points in left-to-right order.\nfunction computeUpperHullIndexes(points) {\n  var n = points.length,\n      indexes = [0, 1],\n      size = 2;\n\n  for (var i = 2; i < n; ++i) {\n    while (size > 1 && cross(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;\n    indexes[size++] = i;\n  }\n\n  return indexes.slice(0, size); // remove popped points\n}\n\nvar hull = function(points) {\n  if ((n = points.length) < 3) return null;\n\n  var i,\n      n,\n      sortedPoints = new Array(n),\n      flippedPoints = new Array(n);\n\n  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];\n  sortedPoints.sort(lexicographicOrder);\n  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];\n\n  var upperIndexes = computeUpperHullIndexes(sortedPoints),\n      lowerIndexes = computeUpperHullIndexes(flippedPoints);\n\n  // Construct the hull polygon, removing possible duplicate endpoints.\n  var skipLeft = lowerIndexes[0] === upperIndexes[0],\n      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],\n      hull = [];\n\n  // Add upper hull in right-to-l order.\n  // Then add lower hull in left-to-right order.\n  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);\n  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);\n\n  return hull;\n};\n\nvar contains = function(polygon, point) {\n  var n = polygon.length,\n      p = polygon[n - 1],\n      x = point[0], y = point[1],\n      x0 = p[0], y0 = p[1],\n      x1, y1,\n      inside = false;\n\n  for (var i = 0; i < n; ++i) {\n    p = polygon[i], x1 = p[0], y1 = p[1];\n    if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;\n    x0 = x1, y0 = y1;\n  }\n\n  return inside;\n};\n\nvar length$1 = function(polygon) {\n  var i = -1,\n      n = polygon.length,\n      b = polygon[n - 1],\n      xa,\n      ya,\n      xb = b[0],\n      yb = b[1],\n      perimeter = 0;\n\n  while (++i < n) {\n    xa = xb;\n    ya = yb;\n    b = polygon[i];\n    xb = b[0];\n    yb = b[1];\n    xa -= xb;\n    ya -= yb;\n    perimeter += Math.sqrt(xa * xa + ya * ya);\n  }\n\n  return perimeter;\n};\n\nvar pi$1 = Math.PI;\nvar tau$1 = 2 * pi$1;\nvar epsilon = 1e-6;\nvar tauEpsilon = tau$1 - epsilon;\n\nfunction Path() {\n  this._x0 = this._y0 = // start of current subpath\n  this._x1 = this._y1 = null; // end of current subpath\n  this._ = [];\n}\n\nfunction path() {\n  return new Path;\n}\n\nPath.prototype = path.prototype = {\n  constructor: Path,\n  moveTo: function(x, y) {\n    this._.push(\"M\", this._x0 = this._x1 = +x, \",\", this._y0 = this._y1 = +y);\n  },\n  closePath: function() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._.push(\"Z\");\n    }\n  },\n  lineTo: function(x, y) {\n    this._.push(\"L\", this._x1 = +x, \",\", this._y1 = +y);\n  },\n  quadraticCurveTo: function(x1, y1, x, y) {\n    this._.push(\"Q\", +x1, \",\", +y1, \",\", this._x1 = +x, \",\", this._y1 = +y);\n  },\n  bezierCurveTo: function(x1, y1, x2, y2, x, y) {\n    this._.push(\"C\", +x1, \",\", +y1, \",\", +x2, \",\", +y2, \",\", this._x1 = +x, \",\", this._y1 = +y);\n  },\n  arcTo: function(x1, y1, x2, y2, r) {\n    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;\n    var x0 = this._x1,\n        y0 = this._y1,\n        x21 = x2 - x1,\n        y21 = y2 - y1,\n        x01 = x0 - x1,\n        y01 = y0 - y1,\n        l01_2 = x01 * x01 + y01 * y01;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(\"negative radius: \" + r);\n\n    // Is this path empty? Move to (x1,y1).\n    if (this._x1 === null) {\n      this._.push(\n        \"M\", this._x1 = x1, \",\", this._y1 = y1\n      );\n    }\n\n    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.\n    else if (!(l01_2 > epsilon)) {}\n\n    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?\n    // Equivalently, is (x1,y1) coincident with (x2,y2)?\n    // Or, is the radius zero? Line to (x1,y1).\n    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {\n      this._.push(\n        \"L\", this._x1 = x1, \",\", this._y1 = y1\n      );\n    }\n\n    // Otherwise, draw an arc!\n    else {\n      var x20 = x2 - x0,\n          y20 = y2 - y0,\n          l21_2 = x21 * x21 + y21 * y21,\n          l20_2 = x20 * x20 + y20 * y20,\n          l21 = Math.sqrt(l21_2),\n          l01 = Math.sqrt(l01_2),\n          l = r * Math.tan((pi$1 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),\n          t01 = l / l01,\n          t21 = l / l21;\n\n      // If the start tangent is not coincident with (x0,y0), line to.\n      if (Math.abs(t01 - 1) > epsilon) {\n        this._.push(\n          \"L\", x1 + t01 * x01, \",\", y1 + t01 * y01\n        );\n      }\n\n      this._.push(\n        \"A\", r, \",\", r, \",0,0,\", +(y01 * x20 > x01 * y20), \",\", this._x1 = x1 + t21 * x21, \",\", this._y1 = y1 + t21 * y21\n      );\n    }\n  },\n  arc: function(x, y, r, a0, a1, ccw) {\n    x = +x, y = +y, r = +r;\n    var dx = r * Math.cos(a0),\n        dy = r * Math.sin(a0),\n        x0 = x + dx,\n        y0 = y + dy,\n        cw = 1 ^ ccw,\n        da = ccw ? a0 - a1 : a1 - a0;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(\"negative radius: \" + r);\n\n    // Is this path empty? Move to (x0,y0).\n    if (this._x1 === null) {\n      this._.push(\n        \"M\", x0, \",\", y0\n      );\n    }\n\n    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).\n    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {\n      this._.push(\n        \"L\", x0, \",\", y0\n      );\n    }\n\n    // Is this arc empty? We’re done.\n    if (!r) return;\n\n    // Is this a complete circle? Draw two arcs to complete the circle.\n    if (da > tauEpsilon) {\n      this._.push(\n        \"A\", r, \",\", r, \",0,1,\", cw, \",\", x - dx, \",\", y - dy,\n        \"A\", r, \",\", r, \",0,1,\", cw, \",\", this._x1 = x0, \",\", this._y1 = y0\n      );\n    }\n\n    // Otherwise, draw an arc!\n    else {\n      if (da < 0) da = da % tau$1 + tau$1;\n      this._.push(\n        \"A\", r, \",\", r, \",0,\", +(da >= pi$1), \",\", cw, \",\", this._x1 = x + r * Math.cos(a1), \",\", this._y1 = y + r * Math.sin(a1)\n      );\n    }\n  },\n  rect: function(x, y, w, h) {\n    this._.push(\"M\", this._x0 = this._x1 = +x, \",\", this._y0 = this._y1 = +y, \"h\", +w, \"v\", +h, \"h\", -w, \"Z\");\n  },\n  toString: function() {\n    return this._.join(\"\");\n  }\n};\n\nvar tree_add = function(d) {\n  var x = +this._x.call(null, d),\n      y = +this._y.call(null, d);\n  return add(this.cover(x, y), x, y, d);\n};\n\nfunction add(tree, x, y, d) {\n  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points\n\n  var parent,\n      node = tree._root,\n      leaf = {data: d},\n      x0 = tree._x0,\n      y0 = tree._y0,\n      x1 = tree._x1,\n      y1 = tree._y1,\n      xm,\n      ym,\n      xp,\n      yp,\n      right,\n      bottom,\n      i,\n      j;\n\n  // If the tree is empty, initialize the root as a leaf.\n  if (!node) return tree._root = leaf, tree;\n\n  // Find the existing leaf for the new point, or add it.\n  while (node.length) {\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;\n  }\n\n  // Is the new point is exactly coincident with the existing point?\n  xp = +tree._x.call(null, node.data);\n  yp = +tree._y.call(null, node.data);\n  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;\n\n  // Otherwise, split the leaf node until the old and new point are separated.\n  do {\n    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));\n  return parent[j] = node, parent[i] = leaf, tree;\n}\n\nfunction addAll(data) {\n  var d, i, n = data.length,\n      x,\n      y,\n      xz = new Array(n),\n      yz = new Array(n),\n      x0 = Infinity,\n      y0 = Infinity,\n      x1 = -Infinity,\n      y1 = -Infinity;\n\n  // Compute the points and their extent.\n  for (i = 0; i < n; ++i) {\n    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;\n    xz[i] = x;\n    yz[i] = y;\n    if (x < x0) x0 = x;\n    if (x > x1) x1 = x;\n    if (y < y0) y0 = y;\n    if (y > y1) y1 = y;\n  }\n\n  // If there were no (valid) points, inherit the existing extent.\n  if (x1 < x0) x0 = this._x0, x1 = this._x1;\n  if (y1 < y0) y0 = this._y0, y1 = this._y1;\n\n  // Expand the tree to cover the new points.\n  this.cover(x0, y0).cover(x1, y1);\n\n  // Add the new points.\n  for (i = 0; i < n; ++i) {\n    add(this, xz[i], yz[i], data[i]);\n  }\n\n  return this;\n}\n\nvar tree_cover = function(x, y) {\n  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points\n\n  var x0 = this._x0,\n      y0 = this._y0,\n      x1 = this._x1,\n      y1 = this._y1;\n\n  // If the quadtree has no extent, initialize them.\n  // Integer extent are necessary so that if we later double the extent,\n  // the existing quadrant boundaries don’t change due to floating point error!\n  if (isNaN(x0)) {\n    x1 = (x0 = Math.floor(x)) + 1;\n    y1 = (y0 = Math.floor(y)) + 1;\n  }\n\n  // Otherwise, double repeatedly to cover.\n  else if (x0 > x || x > x1 || y0 > y || y > y1) {\n    var z = x1 - x0,\n        node = this._root,\n        parent,\n        i;\n\n    switch (i = (y < (y0 + y1) / 2) << 1 | (x < (x0 + x1) / 2)) {\n      case 0: {\n        do parent = new Array(4), parent[i] = node, node = parent;\n        while (z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1);\n        break;\n      }\n      case 1: {\n        do parent = new Array(4), parent[i] = node, node = parent;\n        while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1);\n        break;\n      }\n      case 2: {\n        do parent = new Array(4), parent[i] = node, node = parent;\n        while (z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y);\n        break;\n      }\n      case 3: {\n        do parent = new Array(4), parent[i] = node, node = parent;\n        while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y);\n        break;\n      }\n    }\n\n    if (this._root && this._root.length) this._root = node;\n  }\n\n  // If the quadtree covers the point already, just return.\n  else return this;\n\n  this._x0 = x0;\n  this._y0 = y0;\n  this._x1 = x1;\n  this._y1 = y1;\n  return this;\n};\n\nvar tree_data = function() {\n  var data = [];\n  this.visit(function(node) {\n    if (!node.length) do data.push(node.data); while (node = node.next)\n  });\n  return data;\n};\n\nvar tree_extent = function(_) {\n  return arguments.length\n      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])\n      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];\n};\n\nvar Quad = function(node, x0, y0, x1, y1) {\n  this.node = node;\n  this.x0 = x0;\n  this.y0 = y0;\n  this.x1 = x1;\n  this.y1 = y1;\n};\n\nvar tree_find = function(x, y, radius) {\n  var data,\n      x0 = this._x0,\n      y0 = this._y0,\n      x1,\n      y1,\n      x2,\n      y2,\n      x3 = this._x1,\n      y3 = this._y1,\n      quads = [],\n      node = this._root,\n      q,\n      i;\n\n  if (node) quads.push(new Quad(node, x0, y0, x3, y3));\n  if (radius == null) radius = Infinity;\n  else {\n    x0 = x - radius, y0 = y - radius;\n    x3 = x + radius, y3 = y + radius;\n    radius *= radius;\n  }\n\n  while (q = quads.pop()) {\n\n    // Stop searching if this quadrant can’t contain a closer node.\n    if (!(node = q.node)\n        || (x1 = q.x0) > x3\n        || (y1 = q.y0) > y3\n        || (x2 = q.x1) < x0\n        || (y2 = q.y1) < y0) continue;\n\n    // Bisect the current quadrant.\n    if (node.length) {\n      var xm = (x1 + x2) / 2,\n          ym = (y1 + y2) / 2;\n\n      quads.push(\n        new Quad(node[3], xm, ym, x2, y2),\n        new Quad(node[2], x1, ym, xm, y2),\n        new Quad(node[1], xm, y1, x2, ym),\n        new Quad(node[0], x1, y1, xm, ym)\n      );\n\n      // Visit the closest quadrant first.\n      if (i = (y >= ym) << 1 | (x >= xm)) {\n        q = quads[quads.length - 1];\n        quads[quads.length - 1] = quads[quads.length - 1 - i];\n        quads[quads.length - 1 - i] = q;\n      }\n    }\n\n    // Visit this point. (Visiting coincident points isn’t necessary!)\n    else {\n      var dx = x - +this._x.call(null, node.data),\n          dy = y - +this._y.call(null, node.data),\n          d2 = dx * dx + dy * dy;\n      if (d2 < radius) {\n        var d = Math.sqrt(radius = d2);\n        x0 = x - d, y0 = y - d;\n        x3 = x + d, y3 = y + d;\n        data = node.data;\n      }\n    }\n  }\n\n  return data;\n};\n\nvar tree_remove = function(d) {\n  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points\n\n  var parent,\n      node = this._root,\n      retainer,\n      previous,\n      next,\n      x0 = this._x0,\n      y0 = this._y0,\n      x1 = this._x1,\n      y1 = this._y1,\n      x,\n      y,\n      xm,\n      ym,\n      right,\n      bottom,\n      i,\n      j;\n\n  // If the tree is empty, initialize the root as a leaf.\n  if (!node) return this;\n\n  // Find the leaf node for the point.\n  // While descending, also retain the deepest parent with a non-removed sibling.\n  if (node.length) while (true) {\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;\n    if (!node.length) break;\n    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;\n  }\n\n  // Find the point to remove.\n  while (node.data !== d) if (!(previous = node, node = node.next)) return this;\n  if (next = node.next) delete node.next;\n\n  // If there are multiple coincident points, remove just the point.\n  if (previous) return (next ? previous.next = next : delete previous.next), this;\n\n  // If this is the root point, remove it.\n  if (!parent) return this._root = next, this;\n\n  // Remove this leaf.\n  next ? parent[i] = next : delete parent[i];\n\n  // If the parent now contains exactly one leaf, collapse superfluous parents.\n  if ((node = parent[0] || parent[1] || parent[2] || parent[3])\n      && node === (parent[3] || parent[2] || parent[1] || parent[0])\n      && !node.length) {\n    if (retainer) retainer[j] = node;\n    else this._root = node;\n  }\n\n  return this;\n};\n\nfunction removeAll(data) {\n  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);\n  return this;\n}\n\nvar tree_root = function() {\n  return this._root;\n};\n\nvar tree_size = function() {\n  var size = 0;\n  this.visit(function(node) {\n    if (!node.length) do ++size; while (node = node.next)\n  });\n  return size;\n};\n\nvar tree_visit = function(callback) {\n  var quads = [], q, node = this._root, child, x0, y0, x1, y1;\n  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));\n  while (q = quads.pop()) {\n    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {\n      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));\n      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));\n      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));\n      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));\n    }\n  }\n  return this;\n};\n\nvar tree_visitAfter = function(callback) {\n  var quads = [], next = [], q;\n  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));\n  while (q = quads.pop()) {\n    var node = q.node;\n    if (node.length) {\n      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));\n      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));\n      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));\n      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));\n    }\n    next.push(q);\n  }\n  while (q = next.pop()) {\n    callback(q.node, q.x0, q.y0, q.x1, q.y1);\n  }\n  return this;\n};\n\nfunction defaultX(d) {\n  return d[0];\n}\n\nvar tree_x = function(_) {\n  return arguments.length ? (this._x = _, this) : this._x;\n};\n\nfunction defaultY(d) {\n  return d[1];\n}\n\nvar tree_y = function(_) {\n  return arguments.length ? (this._y = _, this) : this._y;\n};\n\nfunction quadtree(nodes, x, y) {\n  var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);\n  return nodes == null ? tree : tree.addAll(nodes);\n}\n\nfunction Quadtree(x, y, x0, y0, x1, y1) {\n  this._x = x;\n  this._y = y;\n  this._x0 = x0;\n  this._y0 = y0;\n  this._x1 = x1;\n  this._y1 = y1;\n  this._root = undefined;\n}\n\nfunction leaf_copy(leaf) {\n  var copy = {data: leaf.data}, next = copy;\n  while (leaf = leaf.next) next = next.next = {data: leaf.data};\n  return copy;\n}\n\nvar treeProto = quadtree.prototype = Quadtree.prototype;\n\ntreeProto.copy = function() {\n  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),\n      node = this._root,\n      nodes,\n      child;\n\n  if (!node) return copy;\n\n  if (!node.length) return copy._root = leaf_copy(node), copy;\n\n  nodes = [{source: node, target: copy._root = new Array(4)}];\n  while (node = nodes.pop()) {\n    for (var i = 0; i < 4; ++i) {\n      if (child = node.source[i]) {\n        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});\n        else node.target[i] = leaf_copy(child);\n      }\n    }\n  }\n\n  return copy;\n};\n\ntreeProto.add = tree_add;\ntreeProto.addAll = addAll;\ntreeProto.cover = tree_cover;\ntreeProto.data = tree_data;\ntreeProto.extent = tree_extent;\ntreeProto.find = tree_find;\ntreeProto.remove = tree_remove;\ntreeProto.removeAll = removeAll;\ntreeProto.root = tree_root;\ntreeProto.size = tree_size;\ntreeProto.visit = tree_visit;\ntreeProto.visitAfter = tree_visitAfter;\ntreeProto.x = tree_x;\ntreeProto.y = tree_y;\n\nvar slice$1 = [].slice;\n\nvar noabort = {};\n\nfunction Queue(size) {\n  if (!(size >= 1)) throw new Error;\n  this._size = size;\n  this._call =\n  this._error = null;\n  this._tasks = [];\n  this._data = [];\n  this._waiting =\n  this._active =\n  this._ended =\n  this._start = 0; // inside a synchronous task callback?\n}\n\nQueue.prototype = queue.prototype = {\n  constructor: Queue,\n  defer: function(callback) {\n    if (typeof callback !== \"function\" || this._call) throw new Error;\n    if (this._error != null) return this;\n    var t = slice$1.call(arguments, 1);\n    t.push(callback);\n    ++this._waiting, this._tasks.push(t);\n    poke(this);\n    return this;\n  },\n  abort: function() {\n    if (this._error == null) abort(this, new Error(\"abort\"));\n    return this;\n  },\n  await: function(callback) {\n    if (typeof callback !== \"function\" || this._call) throw new Error;\n    this._call = function(error, results) { callback.apply(null, [error].concat(results)); };\n    maybeNotify(this);\n    return this;\n  },\n  awaitAll: function(callback) {\n    if (typeof callback !== \"function\" || this._call) throw new Error;\n    this._call = callback;\n    maybeNotify(this);\n    return this;\n  }\n};\n\nfunction poke(q) {\n  if (!q._start) {\n    try { start(q); } // let the current task complete\n    catch (e) {\n      if (q._tasks[q._ended + q._active - 1]) abort(q, e); // task errored synchronously\n      else if (!q._data) throw e; // await callback errored synchronously\n    }\n  }\n}\n\nfunction start(q) {\n  while (q._start = q._waiting && q._active < q._size) {\n    var i = q._ended + q._active,\n        t = q._tasks[i],\n        j = t.length - 1,\n        c = t[j];\n    t[j] = end(q, i);\n    --q._waiting, ++q._active;\n    t = c.apply(null, t);\n    if (!q._tasks[i]) continue; // task finished synchronously\n    q._tasks[i] = t || noabort;\n  }\n}\n\nfunction end(q, i) {\n  return function(e, r) {\n    if (!q._tasks[i]) return; // ignore multiple callbacks\n    --q._active, ++q._ended;\n    q._tasks[i] = null;\n    if (q._error != null) return; // ignore secondary errors\n    if (e != null) {\n      abort(q, e);\n    } else {\n      q._data[i] = r;\n      if (q._waiting) poke(q);\n      else maybeNotify(q);\n    }\n  };\n}\n\nfunction abort(q, e) {\n  var i = q._tasks.length, t;\n  q._error = e; // ignore active callbacks\n  q._data = undefined; // allow gc\n  q._waiting = NaN; // prevent starting\n\n  while (--i >= 0) {\n    if (t = q._tasks[i]) {\n      q._tasks[i] = null;\n      if (t.abort) {\n        try { t.abort(); }\n        catch (e) { /* ignore */ }\n      }\n    }\n  }\n\n  q._active = NaN; // allow notification\n  maybeNotify(q);\n}\n\nfunction maybeNotify(q) {\n  if (!q._active && q._call) {\n    var d = q._data;\n    q._data = undefined; // allow gc\n    q._call(q._error, d);\n  }\n}\n\nfunction queue(concurrency) {\n  return new Queue(arguments.length ? +concurrency : Infinity);\n}\n\nvar constant$2 = function(x) {\n  return function constant() {\n    return x;\n  };\n};\n\nvar epsilon$1 = 1e-12;\nvar pi$2 = Math.PI;\nvar halfPi$1 = pi$2 / 2;\nvar tau$2 = 2 * pi$2;\n\nfunction arcInnerRadius(d) {\n  return d.innerRadius;\n}\n\nfunction arcOuterRadius(d) {\n  return d.outerRadius;\n}\n\nfunction arcStartAngle(d) {\n  return d.startAngle;\n}\n\nfunction arcEndAngle(d) {\n  return d.endAngle;\n}\n\nfunction arcPadAngle(d) {\n  return d && d.padAngle; // Note: optional!\n}\n\nfunction asin(x) {\n  return x >= 1 ? halfPi$1 : x <= -1 ? -halfPi$1 : Math.asin(x);\n}\n\nfunction intersect(x0, y0, x1, y1, x2, y2, x3, y3) {\n  var x10 = x1 - x0, y10 = y1 - y0,\n      x32 = x3 - x2, y32 = y3 - y2,\n      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);\n  return [x0 + t * x10, y0 + t * y10];\n}\n\n// Compute perpendicular offset line of length rc.\n// http://mathworld.wolfram.com/Circle-LineIntersection.html\nfunction cornerTangents(x0, y0, x1, y1, r1, rc, cw) {\n  var x01 = x0 - x1,\n      y01 = y0 - y1,\n      lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01),\n      ox = lo * y01,\n      oy = -lo * x01,\n      x11 = x0 + ox,\n      y11 = y0 + oy,\n      x10 = x1 + ox,\n      y10 = y1 + oy,\n      x00 = (x11 + x10) / 2,\n      y00 = (y11 + y10) / 2,\n      dx = x10 - x11,\n      dy = y10 - y11,\n      d2 = dx * dx + dy * dy,\n      r = r1 - rc,\n      D = x11 * y10 - x10 * y11,\n      d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)),\n      cx0 = (D * dy - dx * d) / d2,\n      cy0 = (-D * dx - dy * d) / d2,\n      cx1 = (D * dy + dx * d) / d2,\n      cy1 = (-D * dx + dy * d) / d2,\n      dx0 = cx0 - x00,\n      dy0 = cy0 - y00,\n      dx1 = cx1 - x00,\n      dy1 = cy1 - y00;\n\n  // Pick the closer of the two intersection points.\n  // TODO Is there a faster way to determine which intersection to use?\n  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;\n\n  return {\n    cx: cx0,\n    cy: cy0,\n    x01: -ox,\n    y01: -oy,\n    x11: cx0 * (r1 / r - 1),\n    y11: cy0 * (r1 / r - 1)\n  };\n}\n\nvar arc = function() {\n  var innerRadius = arcInnerRadius,\n      outerRadius = arcOuterRadius,\n      cornerRadius = constant$2(0),\n      padRadius = null,\n      startAngle = arcStartAngle,\n      endAngle = arcEndAngle,\n      padAngle = arcPadAngle,\n      context = null;\n\n  function arc() {\n    var buffer,\n        r,\n        r0 = +innerRadius.apply(this, arguments),\n        r1 = +outerRadius.apply(this, arguments),\n        a0 = startAngle.apply(this, arguments) - halfPi$1,\n        a1 = endAngle.apply(this, arguments) - halfPi$1,\n        da = Math.abs(a1 - a0),\n        cw = a1 > a0;\n\n    if (!context) context = buffer = path();\n\n    // Ensure that the outer radius is always larger than the inner radius.\n    if (r1 < r0) r = r1, r1 = r0, r0 = r;\n\n    // Is it a point?\n    if (!(r1 > epsilon$1)) context.moveTo(0, 0);\n\n    // Or is it a circle or annulus?\n    else if (da > tau$2 - epsilon$1) {\n      context.moveTo(r1 * Math.cos(a0), r1 * Math.sin(a0));\n      context.arc(0, 0, r1, a0, a1, !cw);\n      if (r0 > epsilon$1) {\n        context.moveTo(r0 * Math.cos(a1), r0 * Math.sin(a1));\n        context.arc(0, 0, r0, a1, a0, cw);\n      }\n    }\n\n    // Or is it a circular or annular sector?\n    else {\n      var a01 = a0,\n          a11 = a1,\n          a00 = a0,\n          a10 = a1,\n          da0 = da,\n          da1 = da,\n          ap = padAngle.apply(this, arguments) / 2,\n          rp = (ap > epsilon$1) && (padRadius ? +padRadius.apply(this, arguments) : Math.sqrt(r0 * r0 + r1 * r1)),\n          rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),\n          rc0 = rc,\n          rc1 = rc,\n          t0,\n          t1;\n\n      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.\n      if (rp > epsilon$1) {\n        var p0 = asin(rp / r0 * Math.sin(ap)),\n            p1 = asin(rp / r1 * Math.sin(ap));\n        if ((da0 -= p0 * 2) > epsilon$1) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;\n        else da0 = 0, a00 = a10 = (a0 + a1) / 2;\n        if ((da1 -= p1 * 2) > epsilon$1) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;\n        else da1 = 0, a01 = a11 = (a0 + a1) / 2;\n      }\n\n      var x01 = r1 * Math.cos(a01),\n          y01 = r1 * Math.sin(a01),\n          x10 = r0 * Math.cos(a10),\n          y10 = r0 * Math.sin(a10);\n\n      // Apply rounded corners?\n      if (rc > epsilon$1) {\n        var x11 = r1 * Math.cos(a11),\n            y11 = r1 * Math.sin(a11),\n            x00 = r0 * Math.cos(a00),\n            y00 = r0 * Math.sin(a00);\n\n        // Restrict the corner radius according to the sector angle.\n        if (da < pi$2) {\n          var oc = da0 > epsilon$1 ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],\n              ax = x01 - oc[0],\n              ay = y01 - oc[1],\n              bx = x11 - oc[0],\n              by = y11 - oc[1],\n              kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2),\n              lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);\n          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));\n          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));\n        }\n      }\n\n      // Is the sector collapsed to a line?\n      if (!(da1 > epsilon$1)) context.moveTo(x01, y01);\n\n      // Does the sector’s outer ring have rounded corners?\n      else if (rc1 > epsilon$1) {\n        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);\n        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);\n\n        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);\n\n        // Have the corners merged?\n        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);\n\n        // Otherwise, draw the two corners and the ring.\n        else {\n          context.arc(t0.cx, t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);\n          context.arc(0, 0, r1, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);\n          context.arc(t1.cx, t1.cy, rc1, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);\n        }\n      }\n\n      // Or is the outer ring just a circular arc?\n      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);\n\n      // Is there no inner ring, and it’s a circular sector?\n      // Or perhaps it’s an annular sector collapsed due to padding?\n      if (!(r0 > epsilon$1) || !(da0 > epsilon$1)) context.lineTo(x10, y10);\n\n      // Does the sector’s inner ring (or point) have rounded corners?\n      else if (rc0 > epsilon$1) {\n        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);\n        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);\n\n        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);\n\n        // Have the corners merged?\n        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);\n\n        // Otherwise, draw the two corners and the ring.\n        else {\n          context.arc(t0.cx, t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);\n          context.arc(0, 0, r0, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);\n          context.arc(t1.cx, t1.cy, rc0, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);\n        }\n      }\n\n      // Or is the inner ring just a circular arc?\n      else context.arc(0, 0, r0, a10, a00, cw);\n    }\n\n    context.closePath();\n\n    if (buffer) return context = null, buffer + \"\" || null;\n  }\n\n  arc.centroid = function() {\n    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,\n        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$2 / 2;\n    return [Math.cos(a) * r, Math.sin(a) * r];\n  };\n\n  arc.innerRadius = function(_) {\n    return arguments.length ? (innerRadius = typeof _ === \"function\" ? _ : constant$2(+_), arc) : innerRadius;\n  };\n\n  arc.outerRadius = function(_) {\n    return arguments.length ? (outerRadius = typeof _ === \"function\" ? _ : constant$2(+_), arc) : outerRadius;\n  };\n\n  arc.cornerRadius = function(_) {\n    return arguments.length ? (cornerRadius = typeof _ === \"function\" ? _ : constant$2(+_), arc) : cornerRadius;\n  };\n\n  arc.padRadius = function(_) {\n    return arguments.length ? (padRadius = _ == null ? null : typeof _ === \"function\" ? _ : constant$2(+_), arc) : padRadius;\n  };\n\n  arc.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant$2(+_), arc) : startAngle;\n  };\n\n  arc.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant$2(+_), arc) : endAngle;\n  };\n\n  arc.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant$2(+_), arc) : padAngle;\n  };\n\n  arc.context = function(_) {\n    return arguments.length ? ((context = _ == null ? null : _), arc) : context;\n  };\n\n  return arc;\n};\n\nfunction Linear(context) {\n  this._context = context;\n}\n\nLinear.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; // proceed\n      default: this._context.lineTo(x, y); break;\n    }\n  }\n};\n\nvar curveLinear = function(context) {\n  return new Linear(context);\n};\n\nfunction x(p) {\n  return p[0];\n}\n\nfunction y(p) {\n  return p[1];\n}\n\nvar line = function() {\n  var x$$1 = x,\n      y$$1 = y,\n      defined = constant$2(true),\n      context = null,\n      curve = curveLinear,\n      output = null;\n\n  function line(data) {\n    var i,\n        n = data.length,\n        d,\n        defined0 = false,\n        buffer;\n\n    if (context == null) output = curve(buffer = path());\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) output.lineStart();\n        else output.lineEnd();\n      }\n      if (defined0) output.point(+x$$1(d, i, data), +y$$1(d, i, data));\n    }\n\n    if (buffer) return output = null, buffer + \"\" || null;\n  }\n\n  line.x = function(_) {\n    return arguments.length ? (x$$1 = typeof _ === \"function\" ? _ : constant$2(+_), line) : x$$1;\n  };\n\n  line.y = function(_) {\n    return arguments.length ? (y$$1 = typeof _ === \"function\" ? _ : constant$2(+_), line) : y$$1;\n  };\n\n  line.defined = function(_) {\n    return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant$2(!!_), line) : defined;\n  };\n\n  line.curve = function(_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;\n  };\n\n  line.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;\n  };\n\n  return line;\n};\n\nvar area$1 = function() {\n  var x0 = x,\n      x1 = null,\n      y0 = constant$2(0),\n      y1 = y,\n      defined = constant$2(true),\n      context = null,\n      curve = curveLinear,\n      output = null;\n\n  function area(data) {\n    var i,\n        j,\n        k,\n        n = data.length,\n        d,\n        defined0 = false,\n        buffer,\n        x0z = new Array(n),\n        y0z = new Array(n);\n\n    if (context == null) output = curve(buffer = path());\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) {\n          j = i;\n          output.areaStart();\n          output.lineStart();\n        } else {\n          output.lineEnd();\n          output.lineStart();\n          for (k = i - 1; k >= j; --k) {\n            output.point(x0z[k], y0z[k]);\n          }\n          output.lineEnd();\n          output.areaEnd();\n        }\n      }\n      if (defined0) {\n        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);\n        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);\n      }\n    }\n\n    if (buffer) return output = null, buffer + \"\" || null;\n  }\n\n  function arealine() {\n    return line().defined(defined).curve(curve).context(context);\n  }\n\n  area.x = function(_) {\n    return arguments.length ? (x0 = typeof _ === \"function\" ? _ : constant$2(+_), x1 = null, area) : x0;\n  };\n\n  area.x0 = function(_) {\n    return arguments.length ? (x0 = typeof _ === \"function\" ? _ : constant$2(+_), area) : x0;\n  };\n\n  area.x1 = function(_) {\n    return arguments.length ? (x1 = _ == null ? null : typeof _ === \"function\" ? _ : constant$2(+_), area) : x1;\n  };\n\n  area.y = function(_) {\n    return arguments.length ? (y0 = typeof _ === \"function\" ? _ : constant$2(+_), y1 = null, area) : y0;\n  };\n\n  area.y0 = function(_) {\n    return arguments.length ? (y0 = typeof _ === \"function\" ? _ : constant$2(+_), area) : y0;\n  };\n\n  area.y1 = function(_) {\n    return arguments.length ? (y1 = _ == null ? null : typeof _ === \"function\" ? _ : constant$2(+_), area) : y1;\n  };\n\n  area.lineX0 =\n  area.lineY0 = function() {\n    return arealine().x(x0).y(y0);\n  };\n\n  area.lineY1 = function() {\n    return arealine().x(x0).y(y1);\n  };\n\n  area.lineX1 = function() {\n    return arealine().x(x1).y(y0);\n  };\n\n  area.defined = function(_) {\n    return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant$2(!!_), area) : defined;\n  };\n\n  area.curve = function(_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;\n  };\n\n  area.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;\n  };\n\n  return area;\n};\n\nvar descending$1 = function(a, b) {\n  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n};\n\nvar identity$1 = function(d) {\n  return d;\n};\n\nvar pie = function() {\n  var value = identity$1,\n      sortValues = descending$1,\n      sort = null,\n      startAngle = constant$2(0),\n      endAngle = constant$2(tau$2),\n      padAngle = constant$2(0);\n\n  function pie(data) {\n    var i,\n        n = data.length,\n        j,\n        k,\n        sum = 0,\n        index = new Array(n),\n        arcs = new Array(n),\n        a0 = +startAngle.apply(this, arguments),\n        da = Math.min(tau$2, Math.max(-tau$2, endAngle.apply(this, arguments) - a0)),\n        a1,\n        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),\n        pa = p * (da < 0 ? -1 : 1),\n        v;\n\n    for (i = 0; i < n; ++i) {\n      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {\n        sum += v;\n      }\n    }\n\n    // Optionally sort the arcs by previously-computed values or by data.\n    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });\n    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });\n\n    // Compute the arcs! They are stored in the original data's order.\n    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {\n      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {\n        data: data[j],\n        index: i,\n        value: v,\n        startAngle: a0,\n        endAngle: a1,\n        padAngle: p\n      };\n    }\n\n    return arcs;\n  }\n\n  pie.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant$2(+_), pie) : value;\n  };\n\n  pie.sortValues = function(_) {\n    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;\n  };\n\n  pie.sort = function(_) {\n    return arguments.length ? (sort = _, sortValues = null, pie) : sort;\n  };\n\n  pie.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant$2(+_), pie) : startAngle;\n  };\n\n  pie.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant$2(+_), pie) : endAngle;\n  };\n\n  pie.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant$2(+_), pie) : padAngle;\n  };\n\n  return pie;\n};\n\nvar curveRadialLinear = curveRadial(curveLinear);\n\nfunction Radial(curve) {\n  this._curve = curve;\n}\n\nRadial.prototype = {\n  areaStart: function() {\n    this._curve.areaStart();\n  },\n  areaEnd: function() {\n    this._curve.areaEnd();\n  },\n  lineStart: function() {\n    this._curve.lineStart();\n  },\n  lineEnd: function() {\n    this._curve.lineEnd();\n  },\n  point: function(a, r) {\n    this._curve.point(r * Math.sin(a), r * -Math.cos(a));\n  }\n};\n\nfunction curveRadial(curve) {\n\n  function radial(context) {\n    return new Radial(curve(context));\n  }\n\n  radial._curve = curve;\n\n  return radial;\n}\n\nfunction radialLine(l) {\n  var c = l.curve;\n\n  l.angle = l.x, delete l.x;\n  l.radius = l.y, delete l.y;\n\n  l.curve = function(_) {\n    return arguments.length ? c(curveRadial(_)) : c()._curve;\n  };\n\n  return l;\n}\n\nvar radialLine$1 = function() {\n  return radialLine(line().curve(curveRadialLinear));\n};\n\nvar radialArea = function() {\n  var a = area$1().curve(curveRadialLinear),\n      c = a.curve,\n      x0 = a.lineX0,\n      x1 = a.lineX1,\n      y0 = a.lineY0,\n      y1 = a.lineY1;\n\n  a.angle = a.x, delete a.x;\n  a.startAngle = a.x0, delete a.x0;\n  a.endAngle = a.x1, delete a.x1;\n  a.radius = a.y, delete a.y;\n  a.innerRadius = a.y0, delete a.y0;\n  a.outerRadius = a.y1, delete a.y1;\n  a.lineStartAngle = function() { return radialLine(x0()); }, delete a.lineX0;\n  a.lineEndAngle = function() { return radialLine(x1()); }, delete a.lineX1;\n  a.lineInnerRadius = function() { return radialLine(y0()); }, delete a.lineY0;\n  a.lineOuterRadius = function() { return radialLine(y1()); }, delete a.lineY1;\n\n  a.curve = function(_) {\n    return arguments.length ? c(curveRadial(_)) : c()._curve;\n  };\n\n  return a;\n};\n\nvar circle = {\n  draw: function(context, size) {\n    var r = Math.sqrt(size / pi$2);\n    context.moveTo(r, 0);\n    context.arc(0, 0, r, 0, tau$2);\n  }\n};\n\nvar cross$1 = {\n  draw: function(context, size) {\n    var r = Math.sqrt(size / 5) / 2;\n    context.moveTo(-3 * r, -r);\n    context.lineTo(-r, -r);\n    context.lineTo(-r, -3 * r);\n    context.lineTo(r, -3 * r);\n    context.lineTo(r, -r);\n    context.lineTo(3 * r, -r);\n    context.lineTo(3 * r, r);\n    context.lineTo(r, r);\n    context.lineTo(r, 3 * r);\n    context.lineTo(-r, 3 * r);\n    context.lineTo(-r, r);\n    context.lineTo(-3 * r, r);\n    context.closePath();\n  }\n};\n\nvar tan30 = Math.sqrt(1 / 3);\nvar tan30_2 = tan30 * 2;\n\nvar diamond = {\n  draw: function(context, size) {\n    var y = Math.sqrt(size / tan30_2),\n        x = y * tan30;\n    context.moveTo(0, -y);\n    context.lineTo(x, 0);\n    context.lineTo(0, y);\n    context.lineTo(-x, 0);\n    context.closePath();\n  }\n};\n\nvar ka = 0.89081309152928522810;\nvar kr = Math.sin(pi$2 / 10) / Math.sin(7 * pi$2 / 10);\nvar kx = Math.sin(tau$2 / 10) * kr;\nvar ky = -Math.cos(tau$2 / 10) * kr;\n\nvar star = {\n  draw: function(context, size) {\n    var r = Math.sqrt(size * ka),\n        x = kx * r,\n        y = ky * r;\n    context.moveTo(0, -r);\n    context.lineTo(x, y);\n    for (var i = 1; i < 5; ++i) {\n      var a = tau$2 * i / 5,\n          c = Math.cos(a),\n          s = Math.sin(a);\n      context.lineTo(s * r, -c * r);\n      context.lineTo(c * x - s * y, s * x + c * y);\n    }\n    context.closePath();\n  }\n};\n\nvar square = {\n  draw: function(context, size) {\n    var w = Math.sqrt(size),\n        x = -w / 2;\n    context.rect(x, x, w, w);\n  }\n};\n\nvar sqrt3 = Math.sqrt(3);\n\nvar triangle = {\n  draw: function(context, size) {\n    var y = -Math.sqrt(size / (sqrt3 * 3));\n    context.moveTo(0, y * 2);\n    context.lineTo(-sqrt3 * y, -y);\n    context.lineTo(sqrt3 * y, -y);\n    context.closePath();\n  }\n};\n\nvar c = -0.5;\nvar s = Math.sqrt(3) / 2;\nvar k = 1 / Math.sqrt(12);\nvar a = (k / 2 + 1) * 3;\n\nvar wye = {\n  draw: function(context, size) {\n    var r = Math.sqrt(size / a),\n        x0 = r / 2,\n        y0 = r * k,\n        x1 = x0,\n        y1 = r * k + r,\n        x2 = -x1,\n        y2 = y1;\n    context.moveTo(x0, y0);\n    context.lineTo(x1, y1);\n    context.lineTo(x2, y2);\n    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);\n    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);\n    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);\n    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);\n    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);\n    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);\n    context.closePath();\n  }\n};\n\nvar symbols = [\n  circle,\n  cross$1,\n  diamond,\n  square,\n  star,\n  triangle,\n  wye\n];\n\nvar symbol = function() {\n  var type = constant$2(circle),\n      size = constant$2(64),\n      context = null;\n\n  function symbol() {\n    var buffer;\n    if (!context) context = buffer = path();\n    type.apply(this, arguments).draw(context, +size.apply(this, arguments));\n    if (buffer) return context = null, buffer + \"\" || null;\n  }\n\n  symbol.type = function(_) {\n    return arguments.length ? (type = typeof _ === \"function\" ? _ : constant$2(_), symbol) : type;\n  };\n\n  symbol.size = function(_) {\n    return arguments.length ? (size = typeof _ === \"function\" ? _ : constant$2(+_), symbol) : size;\n  };\n\n  symbol.context = function(_) {\n    return arguments.length ? (context = _ == null ? null : _, symbol) : context;\n  };\n\n  return symbol;\n};\n\nvar noop = function() {};\n\nfunction point(that, x, y) {\n  that._context.bezierCurveTo(\n    (2 * that._x0 + that._x1) / 3,\n    (2 * that._y0 + that._y1) / 3,\n    (that._x0 + 2 * that._x1) / 3,\n    (that._y0 + 2 * that._y1) / 3,\n    (that._x0 + 4 * that._x1 + x) / 6,\n    (that._y0 + 4 * that._y1 + y) / 6\n  );\n}\n\nfunction Basis(context) {\n  this._context = context;\n}\n\nBasis.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 3: point(this, this._x1, this._y1); // proceed\n      case 2: this._context.lineTo(this._x1, this._y1); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n  }\n};\n\nvar basis = function(context) {\n  return new Basis(context);\n};\n\nfunction BasisClosed(context) {\n  this._context = context;\n}\n\nBasisClosed.prototype = {\n  areaStart: noop,\n  areaEnd: noop,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =\n    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x2, this._y2);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);\n        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x2, this._y2);\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        break;\n      }\n    }\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;\n      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;\n      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n  }\n};\n\nvar basisClosed = function(context) {\n  return new BasisClosed(context);\n};\n\nfunction BasisOpen(context) {\n  this._context = context;\n}\n\nBasisOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;\n      case 3: this._point = 4; // proceed\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n  }\n};\n\nvar basisOpen = function(context) {\n  return new BasisOpen(context);\n};\n\nfunction Bundle(context, beta) {\n  this._basis = new Basis(context);\n  this._beta = beta;\n}\n\nBundle.prototype = {\n  lineStart: function() {\n    this._x = [];\n    this._y = [];\n    this._basis.lineStart();\n  },\n  lineEnd: function() {\n    var x = this._x,\n        y = this._y,\n        j = x.length - 1;\n\n    if (j > 0) {\n      var x0 = x[0],\n          y0 = y[0],\n          dx = x[j] - x0,\n          dy = y[j] - y0,\n          i = -1,\n          t;\n\n      while (++i <= j) {\n        t = i / j;\n        this._basis.point(\n          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),\n          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)\n        );\n      }\n    }\n\n    this._x = this._y = null;\n    this._basis.lineEnd();\n  },\n  point: function(x, y) {\n    this._x.push(+x);\n    this._y.push(+y);\n  }\n};\n\nvar bundle = (function custom(beta) {\n\n  function bundle(context) {\n    return beta === 1 ? new Basis(context) : new Bundle(context, beta);\n  }\n\n  bundle.beta = function(beta) {\n    return custom(+beta);\n  };\n\n  return bundle;\n})(0.85);\n\nfunction point$1(that, x, y) {\n  that._context.bezierCurveTo(\n    that._x1 + that._k * (that._x2 - that._x0),\n    that._y1 + that._k * (that._y2 - that._y0),\n    that._x2 + that._k * (that._x1 - x),\n    that._y2 + that._k * (that._y1 - y),\n    that._x2,\n    that._y2\n  );\n}\n\nfunction Cardinal(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinal.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x2, this._y2); break;\n      case 3: point$1(this, this._x1, this._y1); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;\n      case 2: this._point = 3; // proceed\n      default: point$1(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nvar cardinal = (function custom(tension) {\n\n  function cardinal(context) {\n    return new Cardinal(context, tension);\n  }\n\n  cardinal.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal;\n})(0);\n\nfunction CardinalClosed(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinalClosed.prototype = {\n  areaStart: noop,\n  areaEnd: noop,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =\n    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.lineTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        this.point(this._x5, this._y5);\n        break;\n      }\n    }\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;\n      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;\n      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;\n      default: point$1(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nvar cardinalClosed = (function custom(tension) {\n\n  function cardinal(context) {\n    return new CardinalClosed(context, tension);\n  }\n\n  cardinal.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal;\n})(0);\n\nfunction CardinalOpen(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinalOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;\n      case 3: this._point = 4; // proceed\n      default: point$1(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nvar cardinalOpen = (function custom(tension) {\n\n  function cardinal(context) {\n    return new CardinalOpen(context, tension);\n  }\n\n  cardinal.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal;\n})(0);\n\nfunction point$2(that, x, y) {\n  var x1 = that._x1,\n      y1 = that._y1,\n      x2 = that._x2,\n      y2 = that._y2;\n\n  if (that._l01_a > epsilon$1) {\n    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,\n        n = 3 * that._l01_a * (that._l01_a + that._l12_a);\n    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;\n    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;\n  }\n\n  if (that._l23_a > epsilon$1) {\n    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,\n        m = 3 * that._l23_a * (that._l23_a + that._l12_a);\n    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;\n    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;\n  }\n\n  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);\n}\n\nfunction CatmullRom(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\n\nCatmullRom.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._l01_a = this._l12_a = this._l23_a =\n    this._l01_2a = this._l12_2a = this._l23_2a =\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x2, this._y2); break;\n      case 3: this.point(this._x2, this._y2); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n\n    if (this._point) {\n      var x23 = this._x2 - x,\n          y23 = this._y2 - y;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; // proceed\n      default: point$2(this, x, y); break;\n    }\n\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nvar catmullRom = (function custom(alpha) {\n\n  function catmullRom(context) {\n    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);\n  }\n\n  catmullRom.alpha = function(alpha) {\n    return custom(+alpha);\n  };\n\n  return catmullRom;\n})(0.5);\n\nfunction CatmullRomClosed(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\n\nCatmullRomClosed.prototype = {\n  areaStart: noop,\n  areaEnd: noop,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =\n    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n    this._l01_a = this._l12_a = this._l23_a =\n    this._l01_2a = this._l12_2a = this._l23_2a =\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.lineTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        this.point(this._x5, this._y5);\n        break;\n      }\n    }\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n\n    if (this._point) {\n      var x23 = this._x2 - x,\n          y23 = this._y2 - y;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n\n    switch (this._point) {\n      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;\n      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;\n      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;\n      default: point$2(this, x, y); break;\n    }\n\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nvar catmullRomClosed = (function custom(alpha) {\n\n  function catmullRom(context) {\n    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);\n  }\n\n  catmullRom.alpha = function(alpha) {\n    return custom(+alpha);\n  };\n\n  return catmullRom;\n})(0.5);\n\nfunction CatmullRomOpen(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\n\nCatmullRomOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._l01_a = this._l12_a = this._l23_a =\n    this._l01_2a = this._l12_2a = this._l23_2a =\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n\n    if (this._point) {\n      var x23 = this._x2 - x,\n          y23 = this._y2 - y;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n\n    switch (this._point) {\n      case 0: this._point = 1; break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;\n      case 3: this._point = 4; // proceed\n      default: point$2(this, x, y); break;\n    }\n\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nvar catmullRomOpen = (function custom(alpha) {\n\n  function catmullRom(context) {\n    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);\n  }\n\n  catmullRom.alpha = function(alpha) {\n    return custom(+alpha);\n  };\n\n  return catmullRom;\n})(0.5);\n\nfunction LinearClosed(context) {\n  this._context = context;\n}\n\nLinearClosed.prototype = {\n  areaStart: noop,\n  areaEnd: noop,\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._point) this._context.closePath();\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    if (this._point) this._context.lineTo(x, y);\n    else this._point = 1, this._context.moveTo(x, y);\n  }\n};\n\nvar linearClosed = function(context) {\n  return new LinearClosed(context);\n};\n\nfunction sign(x) {\n  return x < 0 ? -1 : 1;\n}\n\n// Calculate the slopes of the tangents (Hermite-type interpolation) based on\n// the following paper: Steffen, M. 1990. A Simple Method for Monotonic\n// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.\n// NOV(II), P. 443, 1990.\nfunction slope3(that, x2, y2) {\n  var h0 = that._x1 - that._x0,\n      h1 = x2 - that._x1,\n      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),\n      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),\n      p = (s0 * h1 + s1 * h0) / (h0 + h1);\n  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;\n}\n\n// Calculate a one-sided slope.\nfunction slope2(that, t) {\n  var h = that._x1 - that._x0;\n  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;\n}\n\n// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations\n// \"you can express cubic Hermite interpolation in terms of cubic Bézier curves\n// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1\".\nfunction point$3(that, t0, t1) {\n  var x0 = that._x0,\n      y0 = that._y0,\n      x1 = that._x1,\n      y1 = that._y1,\n      dx = (x1 - x0) / 3;\n  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);\n}\n\nfunction MonotoneX(context) {\n  this._context = context;\n}\n\nMonotoneX.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 =\n    this._t0 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x1, this._y1); break;\n      case 3: point$3(this, this._t0, slope2(this, this._t0)); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    var t1 = NaN;\n\n    x = +x, y = +y;\n    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; point$3(this, slope2(this, t1 = slope3(this, x, y)), t1); break;\n      default: point$3(this, this._t0, t1 = slope3(this, x, y)); break;\n    }\n\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n    this._t0 = t1;\n  }\n};\n\nfunction MonotoneY(context) {\n  this._context = new ReflectContext(context);\n}\n\n(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {\n  MonotoneX.prototype.point.call(this, y, x);\n};\n\nfunction ReflectContext(context) {\n  this._context = context;\n}\n\nReflectContext.prototype = {\n  moveTo: function(x, y) { this._context.moveTo(y, x); },\n  closePath: function() { this._context.closePath(); },\n  lineTo: function(x, y) { this._context.lineTo(y, x); },\n  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }\n};\n\nfunction monotoneX(context) {\n  return new MonotoneX(context);\n}\n\nfunction monotoneY(context) {\n  return new MonotoneY(context);\n}\n\nfunction Natural(context) {\n  this._context = context;\n}\n\nNatural.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = [];\n    this._y = [];\n  },\n  lineEnd: function() {\n    var x = this._x,\n        y = this._y,\n        n = x.length;\n\n    if (n) {\n      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);\n      if (n === 2) {\n        this._context.lineTo(x[1], y[1]);\n      } else {\n        var px = controlPoints(x),\n            py = controlPoints(y);\n        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {\n          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);\n        }\n      }\n    }\n\n    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n    this._x = this._y = null;\n  },\n  point: function(x, y) {\n    this._x.push(+x);\n    this._y.push(+y);\n  }\n};\n\n// See https://www.particleincell.com/2012/bezier-splines/ for derivation.\nfunction controlPoints(x) {\n  var i,\n      n = x.length - 1,\n      m,\n      a = new Array(n),\n      b = new Array(n),\n      r = new Array(n);\n  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];\n  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];\n  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];\n  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];\n  a[n - 1] = r[n - 1] / b[n - 1];\n  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];\n  b[n - 1] = (x[n] + a[n - 1]) / 2;\n  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];\n  return [a, b];\n}\n\nvar natural = function(context) {\n  return new Natural(context);\n};\n\nfunction Step(context, t) {\n  this._context = context;\n  this._t = t;\n}\n\nStep.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = this._y = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; // proceed\n      default: {\n        if (this._t <= 0) {\n          this._context.lineTo(this._x, y);\n          this._context.lineTo(x, y);\n        } else {\n          var x1 = this._x * (1 - this._t) + x * this._t;\n          this._context.lineTo(x1, this._y);\n          this._context.lineTo(x1, y);\n        }\n        break;\n      }\n    }\n    this._x = x, this._y = y;\n  }\n};\n\nvar step = function(context) {\n  return new Step(context, 0.5);\n};\n\nfunction stepBefore(context) {\n  return new Step(context, 0);\n}\n\nfunction stepAfter(context) {\n  return new Step(context, 1);\n}\n\nvar slice$2 = Array.prototype.slice;\n\nvar none = function(series, order) {\n  if (!((n = series.length) > 1)) return;\n  for (var i = 1, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {\n    s0 = s1, s1 = series[order[i]];\n    for (var j = 0; j < m; ++j) {\n      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];\n    }\n  }\n};\n\nvar none$1 = function(series) {\n  var n = series.length, o = new Array(n);\n  while (--n >= 0) o[n] = n;\n  return o;\n};\n\nfunction stackValue(d, key) {\n  return d[key];\n}\n\nvar stack = function() {\n  var keys = constant$2([]),\n      order = none$1,\n      offset = none,\n      value = stackValue;\n\n  function stack(data) {\n    var kz = keys.apply(this, arguments),\n        i,\n        m = data.length,\n        n = kz.length,\n        sz = new Array(n),\n        oz;\n\n    for (i = 0; i < n; ++i) {\n      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {\n        si[j] = sij = [0, +value(data[j], ki, j, data)];\n        sij.data = data[j];\n      }\n      si.key = ki;\n    }\n\n    for (i = 0, oz = order(sz); i < n; ++i) {\n      sz[oz[i]].index = i;\n    }\n\n    offset(sz, oz);\n    return sz;\n  }\n\n  stack.keys = function(_) {\n    return arguments.length ? (keys = typeof _ === \"function\" ? _ : constant$2(slice$2.call(_)), stack) : keys;\n  };\n\n  stack.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant$2(+_), stack) : value;\n  };\n\n  stack.order = function(_) {\n    return arguments.length ? (order = _ == null ? none$1 : typeof _ === \"function\" ? _ : constant$2(slice$2.call(_)), stack) : order;\n  };\n\n  stack.offset = function(_) {\n    return arguments.length ? (offset = _ == null ? none : _, stack) : offset;\n  };\n\n  return stack;\n};\n\nvar expand = function(series, order) {\n  if (!((n = series.length) > 0)) return;\n  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {\n    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;\n    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;\n  }\n  none(series, order);\n};\n\nvar silhouette = function(series, order) {\n  if (!((n = series.length) > 0)) return;\n  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {\n    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;\n    s0[j][1] += s0[j][0] = -y / 2;\n  }\n  none(series, order);\n};\n\nvar wiggle = function(series, order) {\n  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;\n  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {\n    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {\n      var si = series[order[i]],\n          sij0 = si[j][1] || 0,\n          sij1 = si[j - 1][1] || 0,\n          s3 = (sij0 - sij1) / 2;\n      for (var k = 0; k < i; ++k) {\n        var sk = series[order[k]],\n            skj0 = sk[j][1] || 0,\n            skj1 = sk[j - 1][1] || 0;\n        s3 += skj0 - skj1;\n      }\n      s1 += sij0, s2 += s3 * sij0;\n    }\n    s0[j - 1][1] += s0[j - 1][0] = y;\n    if (s1) y -= s2 / s1;\n  }\n  s0[j - 1][1] += s0[j - 1][0] = y;\n  none(series, order);\n};\n\nvar ascending$1 = function(series) {\n  var sums = series.map(sum$1);\n  return none$1(series).sort(function(a, b) { return sums[a] - sums[b]; });\n};\n\nfunction sum$1(series) {\n  var s = 0, i = -1, n = series.length, v;\n  while (++i < n) if (v = +series[i][1]) s += v;\n  return s;\n}\n\nvar descending$2 = function(series) {\n  return ascending$1(series).reverse();\n};\n\nvar insideOut = function(series) {\n  var n = series.length,\n      i,\n      j,\n      sums = series.map(sum$1),\n      order = none$1(series).sort(function(a, b) { return sums[b] - sums[a]; }),\n      top = 0,\n      bottom = 0,\n      tops = [],\n      bottoms = [];\n\n  for (i = 0; i < n; ++i) {\n    j = order[i];\n    if (top < bottom) {\n      top += sums[j];\n      tops.push(j);\n    } else {\n      bottom += sums[j];\n      bottoms.push(j);\n    }\n  }\n\n  return bottoms.reverse().concat(tops);\n};\n\nvar reverse = function(series) {\n  return none$1(series).reverse();\n};\n\nvar define = function(constructor, factory, prototype) {\n  constructor.prototype = factory.prototype = prototype;\n  prototype.constructor = constructor;\n};\n\nfunction extend(parent, definition) {\n  var prototype = Object.create(parent.prototype);\n  for (var key in definition) prototype[key] = definition[key];\n  return prototype;\n}\n\nfunction Color() {}\n\nvar darker = 0.7;\nvar brighter = 1 / darker;\n\nvar reHex3 = /^#([0-9a-f]{3})$/;\nvar reHex6 = /^#([0-9a-f]{6})$/;\nvar reRgbInteger = /^rgb\\(\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*\\)$/;\nvar reRgbPercent = /^rgb\\(\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\nvar reRgbaInteger = /^rgba\\(\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)\\s*\\)$/;\nvar reRgbaPercent = /^rgba\\(\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)\\s*\\)$/;\nvar reHslPercent = /^hsl\\(\\s*([-+]?\\d+(?:\\.\\d+)?)\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\nvar reHslaPercent = /^hsla\\(\\s*([-+]?\\d+(?:\\.\\d+)?)\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)\\s*\\)$/;\n\nvar named = {\n  aliceblue: 0xf0f8ff,\n  antiquewhite: 0xfaebd7,\n  aqua: 0x00ffff,\n  aquamarine: 0x7fffd4,\n  azure: 0xf0ffff,\n  beige: 0xf5f5dc,\n  bisque: 0xffe4c4,\n  black: 0x000000,\n  blanchedalmond: 0xffebcd,\n  blue: 0x0000ff,\n  blueviolet: 0x8a2be2,\n  brown: 0xa52a2a,\n  burlywood: 0xdeb887,\n  cadetblue: 0x5f9ea0,\n  chartreuse: 0x7fff00,\n  chocolate: 0xd2691e,\n  coral: 0xff7f50,\n  cornflowerblue: 0x6495ed,\n  cornsilk: 0xfff8dc,\n  crimson: 0xdc143c,\n  cyan: 0x00ffff,\n  darkblue: 0x00008b,\n  darkcyan: 0x008b8b,\n  darkgoldenrod: 0xb8860b,\n  darkgray: 0xa9a9a9,\n  darkgreen: 0x006400,\n  darkgrey: 0xa9a9a9,\n  darkkhaki: 0xbdb76b,\n  darkmagenta: 0x8b008b,\n  darkolivegreen: 0x556b2f,\n  darkorange: 0xff8c00,\n  darkorchid: 0x9932cc,\n  darkred: 0x8b0000,\n  darksalmon: 0xe9967a,\n  darkseagreen: 0x8fbc8f,\n  darkslateblue: 0x483d8b,\n  darkslategray: 0x2f4f4f,\n  darkslategrey: 0x2f4f4f,\n  darkturquoise: 0x00ced1,\n  darkviolet: 0x9400d3,\n  deeppink: 0xff1493,\n  deepskyblue: 0x00bfff,\n  dimgray: 0x696969,\n  dimgrey: 0x696969,\n  dodgerblue: 0x1e90ff,\n  firebrick: 0xb22222,\n  floralwhite: 0xfffaf0,\n  forestgreen: 0x228b22,\n  fuchsia: 0xff00ff,\n  gainsboro: 0xdcdcdc,\n  ghostwhite: 0xf8f8ff,\n  gold: 0xffd700,\n  goldenrod: 0xdaa520,\n  gray: 0x808080,\n  green: 0x008000,\n  greenyellow: 0xadff2f,\n  grey: 0x808080,\n  honeydew: 0xf0fff0,\n  hotpink: 0xff69b4,\n  indianred: 0xcd5c5c,\n  indigo: 0x4b0082,\n  ivory: 0xfffff0,\n  khaki: 0xf0e68c,\n  lavender: 0xe6e6fa,\n  lavenderblush: 0xfff0f5,\n  lawngreen: 0x7cfc00,\n  lemonchiffon: 0xfffacd,\n  lightblue: 0xadd8e6,\n  lightcoral: 0xf08080,\n  lightcyan: 0xe0ffff,\n  lightgoldenrodyellow: 0xfafad2,\n  lightgray: 0xd3d3d3,\n  lightgreen: 0x90ee90,\n  lightgrey: 0xd3d3d3,\n  lightpink: 0xffb6c1,\n  lightsalmon: 0xffa07a,\n  lightseagreen: 0x20b2aa,\n  lightskyblue: 0x87cefa,\n  lightslategray: 0x778899,\n  lightslategrey: 0x778899,\n  lightsteelblue: 0xb0c4de,\n  lightyellow: 0xffffe0,\n  lime: 0x00ff00,\n  limegreen: 0x32cd32,\n  linen: 0xfaf0e6,\n  magenta: 0xff00ff,\n  maroon: 0x800000,\n  mediumaquamarine: 0x66cdaa,\n  mediumblue: 0x0000cd,\n  mediumorchid: 0xba55d3,\n  mediumpurple: 0x9370db,\n  mediumseagreen: 0x3cb371,\n  mediumslateblue: 0x7b68ee,\n  mediumspringgreen: 0x00fa9a,\n  mediumturquoise: 0x48d1cc,\n  mediumvioletred: 0xc71585,\n  midnightblue: 0x191970,\n  mintcream: 0xf5fffa,\n  mistyrose: 0xffe4e1,\n  moccasin: 0xffe4b5,\n  navajowhite: 0xffdead,\n  navy: 0x000080,\n  oldlace: 0xfdf5e6,\n  olive: 0x808000,\n  olivedrab: 0x6b8e23,\n  orange: 0xffa500,\n  orangered: 0xff4500,\n  orchid: 0xda70d6,\n  palegoldenrod: 0xeee8aa,\n  palegreen: 0x98fb98,\n  paleturquoise: 0xafeeee,\n  palevioletred: 0xdb7093,\n  papayawhip: 0xffefd5,\n  peachpuff: 0xffdab9,\n  peru: 0xcd853f,\n  pink: 0xffc0cb,\n  plum: 0xdda0dd,\n  powderblue: 0xb0e0e6,\n  purple: 0x800080,\n  rebeccapurple: 0x663399,\n  red: 0xff0000,\n  rosybrown: 0xbc8f8f,\n  royalblue: 0x4169e1,\n  saddlebrown: 0x8b4513,\n  salmon: 0xfa8072,\n  sandybrown: 0xf4a460,\n  seagreen: 0x2e8b57,\n  seashell: 0xfff5ee,\n  sienna: 0xa0522d,\n  silver: 0xc0c0c0,\n  skyblue: 0x87ceeb,\n  slateblue: 0x6a5acd,\n  slategray: 0x708090,\n  slategrey: 0x708090,\n  snow: 0xfffafa,\n  springgreen: 0x00ff7f,\n  steelblue: 0x4682b4,\n  tan: 0xd2b48c,\n  teal: 0x008080,\n  thistle: 0xd8bfd8,\n  tomato: 0xff6347,\n  turquoise: 0x40e0d0,\n  violet: 0xee82ee,\n  wheat: 0xf5deb3,\n  white: 0xffffff,\n  whitesmoke: 0xf5f5f5,\n  yellow: 0xffff00,\n  yellowgreen: 0x9acd32\n};\n\ndefine(Color, color, {\n  displayable: function() {\n    return this.rgb().displayable();\n  },\n  toString: function() {\n    return this.rgb() + \"\";\n  }\n});\n\nfunction color(format) {\n  var m;\n  format = (format + \"\").trim().toLowerCase();\n  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00\n      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000\n      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)\n      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)\n      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)\n      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)\n      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)\n      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)\n      : named.hasOwnProperty(format) ? rgbn(named[format])\n      : format === \"transparent\" ? new Rgb(NaN, NaN, NaN, 0)\n      : null;\n}\n\nfunction rgbn(n) {\n  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);\n}\n\nfunction rgba(r, g, b, a) {\n  if (a <= 0) r = g = b = NaN;\n  return new Rgb(r, g, b, a);\n}\n\nfunction rgbConvert(o) {\n  if (!(o instanceof Color)) o = color(o);\n  if (!o) return new Rgb;\n  o = o.rgb();\n  return new Rgb(o.r, o.g, o.b, o.opacity);\n}\n\nfunction rgb(r, g, b, opacity) {\n  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);\n}\n\nfunction Rgb(r, g, b, opacity) {\n  this.r = +r;\n  this.g = +g;\n  this.b = +b;\n  this.opacity = +opacity;\n}\n\ndefine(Rgb, rgb, extend(Color, {\n  brighter: function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);\n  },\n  darker: function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);\n  },\n  rgb: function() {\n    return this;\n  },\n  displayable: function() {\n    return (0 <= this.r && this.r <= 255)\n        && (0 <= this.g && this.g <= 255)\n        && (0 <= this.b && this.b <= 255)\n        && (0 <= this.opacity && this.opacity <= 1);\n  },\n  toString: function() {\n    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));\n    return (a === 1 ? \"rgb(\" : \"rgba(\")\n        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + \", \"\n        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + \", \"\n        + Math.max(0, Math.min(255, Math.round(this.b) || 0))\n        + (a === 1 ? \")\" : \", \" + a + \")\");\n  }\n}));\n\nfunction hsla(h, s, l, a) {\n  if (a <= 0) h = s = l = NaN;\n  else if (l <= 0 || l >= 1) h = s = NaN;\n  else if (s <= 0) h = NaN;\n  return new Hsl(h, s, l, a);\n}\n\nfunction hslConvert(o) {\n  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);\n  if (!(o instanceof Color)) o = color(o);\n  if (!o) return new Hsl;\n  if (o instanceof Hsl) return o;\n  o = o.rgb();\n  var r = o.r / 255,\n      g = o.g / 255,\n      b = o.b / 255,\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      h = NaN,\n      s = max - min,\n      l = (max + min) / 2;\n  if (s) {\n    if (r === max) h = (g - b) / s + (g < b) * 6;\n    else if (g === max) h = (b - r) / s + 2;\n    else h = (r - g) / s + 4;\n    s /= l < 0.5 ? max + min : 2 - max - min;\n    h *= 60;\n  } else {\n    s = l > 0 && l < 1 ? 0 : h;\n  }\n  return new Hsl(h, s, l, o.opacity);\n}\n\nfunction hsl(h, s, l, opacity) {\n  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);\n}\n\nfunction Hsl(h, s, l, opacity) {\n  this.h = +h;\n  this.s = +s;\n  this.l = +l;\n  this.opacity = +opacity;\n}\n\ndefine(Hsl, hsl, extend(Color, {\n  brighter: function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Hsl(this.h, this.s, this.l * k, this.opacity);\n  },\n  darker: function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Hsl(this.h, this.s, this.l * k, this.opacity);\n  },\n  rgb: function() {\n    var h = this.h % 360 + (this.h < 0) * 360,\n        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,\n        l = this.l,\n        m2 = l + (l < 0.5 ? l : 1 - l) * s,\n        m1 = 2 * l - m2;\n    return new Rgb(\n      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),\n      hsl2rgb(h, m1, m2),\n      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),\n      this.opacity\n    );\n  },\n  displayable: function() {\n    return (0 <= this.s && this.s <= 1 || isNaN(this.s))\n        && (0 <= this.l && this.l <= 1)\n        && (0 <= this.opacity && this.opacity <= 1);\n  }\n}));\n\n/* From FvD 13.37, CSS Color Module Level 3 */\nfunction hsl2rgb(h, m1, m2) {\n  return (h < 60 ? m1 + (m2 - m1) * h / 60\n      : h < 180 ? m2\n      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60\n      : m1) * 255;\n}\n\nvar deg2rad = Math.PI / 180;\nvar rad2deg = 180 / Math.PI;\n\nvar Kn = 18;\nvar Xn = 0.950470;\nvar Yn = 1;\nvar Zn = 1.088830;\nvar t0 = 4 / 29;\nvar t1 = 6 / 29;\nvar t2 = 3 * t1 * t1;\nvar t3 = t1 * t1 * t1;\n\nfunction labConvert(o) {\n  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);\n  if (o instanceof Hcl) {\n    var h = o.h * deg2rad;\n    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);\n  }\n  if (!(o instanceof Rgb)) o = rgbConvert(o);\n  var b = rgb2xyz(o.r),\n      a = rgb2xyz(o.g),\n      l = rgb2xyz(o.b),\n      x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),\n      y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),\n      z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);\n  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);\n}\n\nfunction lab(l, a, b, opacity) {\n  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);\n}\n\nfunction Lab(l, a, b, opacity) {\n  this.l = +l;\n  this.a = +a;\n  this.b = +b;\n  this.opacity = +opacity;\n}\n\ndefine(Lab, lab, extend(Color, {\n  brighter: function(k) {\n    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);\n  },\n  darker: function(k) {\n    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);\n  },\n  rgb: function() {\n    var y = (this.l + 16) / 116,\n        x = isNaN(this.a) ? y : y + this.a / 500,\n        z = isNaN(this.b) ? y : y - this.b / 200;\n    y = Yn * lab2xyz(y);\n    x = Xn * lab2xyz(x);\n    z = Zn * lab2xyz(z);\n    return new Rgb(\n      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB\n      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),\n      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z),\n      this.opacity\n    );\n  }\n}));\n\nfunction xyz2lab(t) {\n  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n}\n\nfunction lab2xyz(t) {\n  return t > t1 ? t * t * t : t2 * (t - t0);\n}\n\nfunction xyz2rgb(x) {\n  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);\n}\n\nfunction rgb2xyz(x) {\n  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n}\n\nfunction hclConvert(o) {\n  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);\n  if (!(o instanceof Lab)) o = labConvert(o);\n  var h = Math.atan2(o.b, o.a) * rad2deg;\n  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);\n}\n\nfunction hcl(h, c, l, opacity) {\n  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);\n}\n\nfunction Hcl(h, c, l, opacity) {\n  this.h = +h;\n  this.c = +c;\n  this.l = +l;\n  this.opacity = +opacity;\n}\n\ndefine(Hcl, hcl, extend(Color, {\n  brighter: function(k) {\n    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);\n  },\n  darker: function(k) {\n    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);\n  },\n  rgb: function() {\n    return labConvert(this).rgb();\n  }\n}));\n\nvar A = -0.14861;\nvar B = +1.78277;\nvar C = -0.29227;\nvar D = -0.90649;\nvar E = +1.97294;\nvar ED = E * D;\nvar EB = E * B;\nvar BC_DA = B * C - D * A;\n\nfunction cubehelixConvert(o) {\n  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);\n  if (!(o instanceof Rgb)) o = rgbConvert(o);\n  var r = o.r / 255,\n      g = o.g / 255,\n      b = o.b / 255,\n      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),\n      bl = b - l,\n      k = (E * (g - l) - C * bl) / D,\n      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1\n      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;\n  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);\n}\n\nfunction cubehelix(h, s, l, opacity) {\n  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);\n}\n\nfunction Cubehelix(h, s, l, opacity) {\n  this.h = +h;\n  this.s = +s;\n  this.l = +l;\n  this.opacity = +opacity;\n}\n\ndefine(Cubehelix, cubehelix, extend(Color, {\n  brighter: function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);\n  },\n  darker: function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);\n  },\n  rgb: function() {\n    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,\n        l = +this.l,\n        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),\n        cosh = Math.cos(h),\n        sinh = Math.sin(h);\n    return new Rgb(\n      255 * (l + a * (A * cosh + B * sinh)),\n      255 * (l + a * (C * cosh + D * sinh)),\n      255 * (l + a * (E * cosh)),\n      this.opacity\n    );\n  }\n}));\n\nfunction basis$1(t1, v0, v1, v2, v3) {\n  var t2 = t1 * t1, t3 = t2 * t1;\n  return ((1 - 3 * t1 + 3 * t2 - t3) * v0\n      + (4 - 6 * t2 + 3 * t3) * v1\n      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2\n      + t3 * v3) / 6;\n}\n\nvar basis$2 = function(values) {\n  var n = values.length - 1;\n  return function(t) {\n    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),\n        v1 = values[i],\n        v2 = values[i + 1],\n        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,\n        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;\n    return basis$1((t - i / n) * n, v0, v1, v2, v3);\n  };\n};\n\nvar basisClosed$1 = function(values) {\n  var n = values.length;\n  return function(t) {\n    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),\n        v0 = values[(i + n - 1) % n],\n        v1 = values[i % n],\n        v2 = values[(i + 1) % n],\n        v3 = values[(i + 2) % n];\n    return basis$1((t - i / n) * n, v0, v1, v2, v3);\n  };\n};\n\nvar constant$3 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nfunction linear$1(a, d) {\n  return function(t) {\n    return a + t * d;\n  };\n}\n\nfunction exponential$1(a, b, y) {\n  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {\n    return Math.pow(a + t * b, y);\n  };\n}\n\nfunction hue(a, b) {\n  var d = b - a;\n  return d ? linear$1(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$3(isNaN(a) ? b : a);\n}\n\nfunction gamma(y) {\n  return (y = +y) === 1 ? nogamma : function(a, b) {\n    return b - a ? exponential$1(a, b, y) : constant$3(isNaN(a) ? b : a);\n  };\n}\n\nfunction nogamma(a, b) {\n  var d = b - a;\n  return d ? linear$1(a, d) : constant$3(isNaN(a) ? b : a);\n}\n\nvar interpolateRgb = (function rgbGamma(y) {\n  var color$$1 = gamma(y);\n\n  function rgb$$1(start, end) {\n    var r = color$$1((start = rgb(start)).r, (end = rgb(end)).r),\n        g = color$$1(start.g, end.g),\n        b = color$$1(start.b, end.b),\n        opacity = color$$1(start.opacity, end.opacity);\n    return function(t) {\n      start.r = r(t);\n      start.g = g(t);\n      start.b = b(t);\n      start.opacity = opacity(t);\n      return start + \"\";\n    };\n  }\n\n  rgb$$1.gamma = rgbGamma;\n\n  return rgb$$1;\n})(1);\n\nfunction rgbSpline(spline) {\n  return function(colors) {\n    var n = colors.length,\n        r = new Array(n),\n        g = new Array(n),\n        b = new Array(n),\n        i, color$$1;\n    for (i = 0; i < n; ++i) {\n      color$$1 = rgb(colors[i]);\n      r[i] = color$$1.r || 0;\n      g[i] = color$$1.g || 0;\n      b[i] = color$$1.b || 0;\n    }\n    r = spline(r);\n    g = spline(g);\n    b = spline(b);\n    color$$1.opacity = 1;\n    return function(t) {\n      color$$1.r = r(t);\n      color$$1.g = g(t);\n      color$$1.b = b(t);\n      return color$$1 + \"\";\n    };\n  };\n}\n\nvar rgbBasis = rgbSpline(basis$2);\nvar rgbBasisClosed = rgbSpline(basisClosed$1);\n\nvar array$1 = function(a, b) {\n  var nb = b ? b.length : 0,\n      na = a ? Math.min(nb, a.length) : 0,\n      x = new Array(nb),\n      c = new Array(nb),\n      i;\n\n  for (i = 0; i < na; ++i) x[i] = interpolate(a[i], b[i]);\n  for (; i < nb; ++i) c[i] = b[i];\n\n  return function(t) {\n    for (i = 0; i < na; ++i) c[i] = x[i](t);\n    return c;\n  };\n};\n\nvar date = function(a, b) {\n  var d = new Date;\n  return a = +a, b -= a, function(t) {\n    return d.setTime(a + b * t), d;\n  };\n};\n\nvar interpolateNumber = function(a, b) {\n  return a = +a, b -= a, function(t) {\n    return a + b * t;\n  };\n};\n\nvar object = function(a, b) {\n  var i = {},\n      c = {},\n      k;\n\n  if (a === null || typeof a !== \"object\") a = {};\n  if (b === null || typeof b !== \"object\") b = {};\n\n  for (k in b) {\n    if (k in a) {\n      i[k] = interpolate(a[k], b[k]);\n    } else {\n      c[k] = b[k];\n    }\n  }\n\n  return function(t) {\n    for (k in i) c[k] = i[k](t);\n    return c;\n  };\n};\n\nvar reA = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g;\nvar reB = new RegExp(reA.source, \"g\");\n\nfunction zero(b) {\n  return function() {\n    return b;\n  };\n}\n\nfunction one(b) {\n  return function(t) {\n    return b(t) + \"\";\n  };\n}\n\nvar interpolateString = function(a, b) {\n  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b\n      am, // current match in a\n      bm, // current match in b\n      bs, // string preceding current number in b, if any\n      i = -1, // index in s\n      s = [], // string constants and placeholders\n      q = []; // number interpolators\n\n  // Coerce inputs to strings.\n  a = a + \"\", b = b + \"\";\n\n  // Interpolate pairs of numbers in a & b.\n  while ((am = reA.exec(a))\n      && (bm = reB.exec(b))) {\n    if ((bs = bm.index) > bi) { // a string precedes the next number in b\n      bs = b.slice(bi, bs);\n      if (s[i]) s[i] += bs; // coalesce with previous string\n      else s[++i] = bs;\n    }\n    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match\n      if (s[i]) s[i] += bm; // coalesce with previous string\n      else s[++i] = bm;\n    } else { // interpolate non-matching numbers\n      s[++i] = null;\n      q.push({i: i, x: interpolateNumber(am, bm)});\n    }\n    bi = reB.lastIndex;\n  }\n\n  // Add remains of b.\n  if (bi < b.length) {\n    bs = b.slice(bi);\n    if (s[i]) s[i] += bs; // coalesce with previous string\n    else s[++i] = bs;\n  }\n\n  // Special optimization for only a single match.\n  // Otherwise, interpolate each of the numbers and rejoin the string.\n  return s.length < 2 ? (q[0]\n      ? one(q[0].x)\n      : zero(b))\n      : (b = q.length, function(t) {\n          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);\n          return s.join(\"\");\n        });\n};\n\nvar interpolate = function(a, b) {\n  var t = typeof b, c;\n  return b == null || t === \"boolean\" ? constant$3(b)\n      : (t === \"number\" ? interpolateNumber\n      : t === \"string\" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)\n      : b instanceof color ? interpolateRgb\n      : b instanceof Date ? date\n      : Array.isArray(b) ? array$1\n      : isNaN(b) ? object\n      : interpolateNumber)(a, b);\n};\n\nvar interpolateRound = function(a, b) {\n  return a = +a, b -= a, function(t) {\n    return Math.round(a + b * t);\n  };\n};\n\nvar degrees = 180 / Math.PI;\n\nvar identity$2 = {\n  translateX: 0,\n  translateY: 0,\n  rotate: 0,\n  skewX: 0,\n  scaleX: 1,\n  scaleY: 1\n};\n\nvar decompose = function(a, b, c, d, e, f) {\n  var scaleX, scaleY, skewX;\n  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;\n  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;\n  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;\n  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;\n  return {\n    translateX: e,\n    translateY: f,\n    rotate: Math.atan2(b, a) * degrees,\n    skewX: Math.atan(skewX) * degrees,\n    scaleX: scaleX,\n    scaleY: scaleY\n  };\n};\n\nvar cssNode;\nvar cssRoot;\nvar cssView;\nvar svgNode;\n\nfunction parseCss(value) {\n  if (value === \"none\") return identity$2;\n  if (!cssNode) cssNode = document.createElement(\"DIV\"), cssRoot = document.documentElement, cssView = document.defaultView;\n  cssNode.style.transform = value;\n  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue(\"transform\");\n  cssRoot.removeChild(cssNode);\n  value = value.slice(7, -1).split(\",\");\n  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);\n}\n\nfunction parseSvg(value) {\n  if (value == null) return identity$2;\n  if (!svgNode) svgNode = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n  svgNode.setAttribute(\"transform\", value);\n  if (!(value = svgNode.transform.baseVal.consolidate())) return identity$2;\n  value = value.matrix;\n  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);\n}\n\nfunction interpolateTransform(parse, pxComma, pxParen, degParen) {\n\n  function pop(s) {\n    return s.length ? s.pop() + \" \" : \"\";\n  }\n\n  function translate(xa, ya, xb, yb, s, q) {\n    if (xa !== xb || ya !== yb) {\n      var i = s.push(\"translate(\", null, pxComma, null, pxParen);\n      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});\n    } else if (xb || yb) {\n      s.push(\"translate(\" + xb + pxComma + yb + pxParen);\n    }\n  }\n\n  function rotate(a, b, s, q) {\n    if (a !== b) {\n      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path\n      q.push({i: s.push(pop(s) + \"rotate(\", null, degParen) - 2, x: interpolateNumber(a, b)});\n    } else if (b) {\n      s.push(pop(s) + \"rotate(\" + b + degParen);\n    }\n  }\n\n  function skewX(a, b, s, q) {\n    if (a !== b) {\n      q.push({i: s.push(pop(s) + \"skewX(\", null, degParen) - 2, x: interpolateNumber(a, b)});\n    } else if (b) {\n      s.push(pop(s) + \"skewX(\" + b + degParen);\n    }\n  }\n\n  function scale(xa, ya, xb, yb, s, q) {\n    if (xa !== xb || ya !== yb) {\n      var i = s.push(pop(s) + \"scale(\", null, \",\", null, \")\");\n      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});\n    } else if (xb !== 1 || yb !== 1) {\n      s.push(pop(s) + \"scale(\" + xb + \",\" + yb + \")\");\n    }\n  }\n\n  return function(a, b) {\n    var s = [], // string constants and placeholders\n        q = []; // number interpolators\n    a = parse(a), b = parse(b);\n    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);\n    rotate(a.rotate, b.rotate, s, q);\n    skewX(a.skewX, b.skewX, s, q);\n    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);\n    a = b = null; // gc\n    return function(t) {\n      var i = -1, n = q.length, o;\n      while (++i < n) s[(o = q[i]).i] = o.x(t);\n      return s.join(\"\");\n    };\n  };\n}\n\nvar interpolateTransformCss = interpolateTransform(parseCss, \"px, \", \"px)\", \"deg)\");\nvar interpolateTransformSvg = interpolateTransform(parseSvg, \", \", \")\", \")\");\n\nvar rho = Math.SQRT2;\nvar rho2 = 2;\nvar rho4 = 4;\nvar epsilon2 = 1e-12;\n\nfunction cosh(x) {\n  return ((x = Math.exp(x)) + 1 / x) / 2;\n}\n\nfunction sinh(x) {\n  return ((x = Math.exp(x)) - 1 / x) / 2;\n}\n\nfunction tanh(x) {\n  return ((x = Math.exp(2 * x)) - 1) / (x + 1);\n}\n\n// p0 = [ux0, uy0, w0]\n// p1 = [ux1, uy1, w1]\nvar interpolateZoom = function(p0, p1) {\n  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],\n      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],\n      dx = ux1 - ux0,\n      dy = uy1 - uy0,\n      d2 = dx * dx + dy * dy,\n      i,\n      S;\n\n  // Special case for u0 ≅ u1.\n  if (d2 < epsilon2) {\n    S = Math.log(w1 / w0) / rho;\n    i = function(t) {\n      return [\n        ux0 + t * dx,\n        uy0 + t * dy,\n        w0 * Math.exp(rho * t * S)\n      ];\n    };\n  }\n\n  // General case.\n  else {\n    var d1 = Math.sqrt(d2),\n        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),\n        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),\n        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),\n        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n    S = (r1 - r0) / rho;\n    i = function(t) {\n      var s = t * S,\n          coshr0 = cosh(r0),\n          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));\n      return [\n        ux0 + u * dx,\n        uy0 + u * dy,\n        w0 * coshr0 / cosh(rho * s + r0)\n      ];\n    };\n  }\n\n  i.duration = S * 1000;\n\n  return i;\n};\n\nfunction hsl$1(hue$$1) {\n  return function(start, end) {\n    var h = hue$$1((start = hsl(start)).h, (end = hsl(end)).h),\n        s = nogamma(start.s, end.s),\n        l = nogamma(start.l, end.l),\n        opacity = nogamma(start.opacity, end.opacity);\n    return function(t) {\n      start.h = h(t);\n      start.s = s(t);\n      start.l = l(t);\n      start.opacity = opacity(t);\n      return start + \"\";\n    };\n  }\n}\n\nvar hsl$2 = hsl$1(hue);\nvar hslLong = hsl$1(nogamma);\n\nfunction lab$1(start, end) {\n  var l = nogamma((start = lab(start)).l, (end = lab(end)).l),\n      a = nogamma(start.a, end.a),\n      b = nogamma(start.b, end.b),\n      opacity = nogamma(start.opacity, end.opacity);\n  return function(t) {\n    start.l = l(t);\n    start.a = a(t);\n    start.b = b(t);\n    start.opacity = opacity(t);\n    return start + \"\";\n  };\n}\n\nfunction hcl$1(hue$$1) {\n  return function(start, end) {\n    var h = hue$$1((start = hcl(start)).h, (end = hcl(end)).h),\n        c = nogamma(start.c, end.c),\n        l = nogamma(start.l, end.l),\n        opacity = nogamma(start.opacity, end.opacity);\n    return function(t) {\n      start.h = h(t);\n      start.c = c(t);\n      start.l = l(t);\n      start.opacity = opacity(t);\n      return start + \"\";\n    };\n  }\n}\n\nvar hcl$2 = hcl$1(hue);\nvar hclLong = hcl$1(nogamma);\n\nfunction cubehelix$1(hue$$1) {\n  return (function cubehelixGamma(y) {\n    y = +y;\n\n    function cubehelix$$1(start, end) {\n      var h = hue$$1((start = cubehelix(start)).h, (end = cubehelix(end)).h),\n          s = nogamma(start.s, end.s),\n          l = nogamma(start.l, end.l),\n          opacity = nogamma(start.opacity, end.opacity);\n      return function(t) {\n        start.h = h(t);\n        start.s = s(t);\n        start.l = l(Math.pow(t, y));\n        start.opacity = opacity(t);\n        return start + \"\";\n      };\n    }\n\n    cubehelix$$1.gamma = cubehelixGamma;\n\n    return cubehelix$$1;\n  })(1);\n}\n\nvar cubehelix$2 = cubehelix$1(hue);\nvar cubehelixLong = cubehelix$1(nogamma);\n\nvar quantize = function(interpolator, n) {\n  var samples = new Array(n);\n  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));\n  return samples;\n};\n\nvar noop$1 = {value: function() {}};\n\nfunction dispatch() {\n  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {\n    if (!(t = arguments[i] + \"\") || (t in _)) throw new Error(\"illegal type: \" + t);\n    _[t] = [];\n  }\n  return new Dispatch(_);\n}\n\nfunction Dispatch(_) {\n  this._ = _;\n}\n\nfunction parseTypenames(typenames, types) {\n  return typenames.trim().split(/^|\\s+/).map(function(t) {\n    var name = \"\", i = t.indexOf(\".\");\n    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n    if (t && !types.hasOwnProperty(t)) throw new Error(\"unknown type: \" + t);\n    return {type: t, name: name};\n  });\n}\n\nDispatch.prototype = dispatch.prototype = {\n  constructor: Dispatch,\n  on: function(typename, callback) {\n    var _ = this._,\n        T = parseTypenames(typename + \"\", _),\n        t,\n        i = -1,\n        n = T.length;\n\n    // If no callback was specified, return the callback of the given type and name.\n    if (arguments.length < 2) {\n      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;\n      return;\n    }\n\n    // If a type was specified, set the callback for the given type and name.\n    // Otherwise, if a null callback was specified, remove callbacks of the given name.\n    if (callback != null && typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback);\n    while (++i < n) {\n      if (t = (typename = T[i]).type) _[t] = set$2(_[t], typename.name, callback);\n      else if (callback == null) for (t in _) _[t] = set$2(_[t], typename.name, null);\n    }\n\n    return this;\n  },\n  copy: function() {\n    var copy = {}, _ = this._;\n    for (var t in _) copy[t] = _[t].slice();\n    return new Dispatch(copy);\n  },\n  call: function(type, that) {\n    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];\n    if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n  },\n  apply: function(type, that, args) {\n    if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n  }\n};\n\nfunction get(type, name) {\n  for (var i = 0, n = type.length, c; i < n; ++i) {\n    if ((c = type[i]).name === name) {\n      return c.value;\n    }\n  }\n}\n\nfunction set$2(type, name, callback) {\n  for (var i = 0, n = type.length; i < n; ++i) {\n    if (type[i].name === name) {\n      type[i] = noop$1, type = type.slice(0, i).concat(type.slice(i + 1));\n      break;\n    }\n  }\n  if (callback != null) type.push({name: name, value: callback});\n  return type;\n}\n\nfunction objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n    return JSON.stringify(name) + \": d[\" + i + \"]\";\n  }).join(\",\") + \"}\");\n}\n\nfunction customConverter(columns, f) {\n  var object = objectConverter(columns);\n  return function(row, i) {\n    return f(object(row), i, columns);\n  };\n}\n\n// Compute unique columns in order of discovery.\nfunction inferColumns(rows) {\n  var columnSet = Object.create(null),\n      columns = [];\n\n  rows.forEach(function(row) {\n    for (var column in row) {\n      if (!(column in columnSet)) {\n        columns.push(columnSet[column] = column);\n      }\n    }\n  });\n\n  return columns;\n}\n\nvar dsv = function(delimiter) {\n  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n]\"),\n      delimiterCode = delimiter.charCodeAt(0);\n\n  function parse(text, f) {\n    var convert, columns, rows = parseRows(text, function(row, i) {\n      if (convert) return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns;\n    return rows;\n  }\n\n  function parseRows(text, f) {\n    var EOL = {}, // sentinel value for end-of-line\n        EOF = {}, // sentinel value for end-of-file\n        rows = [], // output rows\n        N = text.length,\n        I = 0, // current character index\n        n = 0, // the current line number\n        t, // the current token\n        eol; // is the current token followed by EOL?\n\n    function token() {\n      if (I >= N) return EOF; // special case: end of file\n      if (eol) return eol = false, EOL; // special case: end of line\n\n      // special case: quotes\n      var j = I, c;\n      if (text.charCodeAt(j) === 34) {\n        var i = j;\n        while (i++ < N) {\n          if (text.charCodeAt(i) === 34) {\n            if (text.charCodeAt(i + 1) !== 34) break;\n            ++i;\n          }\n        }\n        I = i + 2;\n        c = text.charCodeAt(i + 1);\n        if (c === 13) {\n          eol = true;\n          if (text.charCodeAt(i + 2) === 10) ++I;\n        } else if (c === 10) {\n          eol = true;\n        }\n        return text.slice(j + 1, i).replace(/\"\"/g, \"\\\"\");\n      }\n\n      // common case: find next delimiter or newline\n      while (I < N) {\n        var k = 1;\n        c = text.charCodeAt(I++);\n        if (c === 10) eol = true; // \\n\n        else if (c === 13) { eol = true; if (text.charCodeAt(I) === 10) ++I, ++k; } // \\r|\\r\\n\n        else if (c !== delimiterCode) continue;\n        return text.slice(j, I - k);\n      }\n\n      // special case: last token before EOF\n      return text.slice(j);\n    }\n\n    while ((t = token()) !== EOF) {\n      var a = [];\n      while (t !== EOL && t !== EOF) {\n        a.push(t);\n        t = token();\n      }\n      if (f && (a = f(a, n++)) == null) continue;\n      rows.push(a);\n    }\n\n    return rows;\n  }\n\n  function format(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {\n      return columns.map(function(column) {\n        return formatValue(row[column]);\n      }).join(delimiter);\n    })).join(\"\\n\");\n  }\n\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n\n  function formatValue(text) {\n    return text == null ? \"\"\n        : reFormat.test(text += \"\") ? \"\\\"\" + text.replace(/\\\"/g, \"\\\"\\\"\") + \"\\\"\"\n        : text;\n  }\n\n  return {\n    parse: parse,\n    parseRows: parseRows,\n    format: format,\n    formatRows: formatRows\n  };\n};\n\nvar csv = dsv(\",\");\n\nvar csvParse = csv.parse;\nvar csvParseRows = csv.parseRows;\nvar csvFormat = csv.format;\nvar csvFormatRows = csv.formatRows;\n\nvar tsv = dsv(\"\\t\");\n\nvar tsvParse = tsv.parse;\nvar tsvParseRows = tsv.parseRows;\nvar tsvFormat = tsv.format;\nvar tsvFormatRows = tsv.formatRows;\n\nvar request = function(url, callback) {\n  var request,\n      event = dispatch(\"beforesend\", \"progress\", \"load\", \"error\"),\n      mimeType,\n      headers = map$1(),\n      xhr = new XMLHttpRequest,\n      user = null,\n      password = null,\n      response,\n      responseType,\n      timeout = 0;\n\n  // If IE does not support CORS, use XDomainRequest.\n  if (typeof XDomainRequest !== \"undefined\"\n      && !(\"withCredentials\" in xhr)\n      && /^(http(s)?:)?\\/\\//.test(url)) xhr = new XDomainRequest;\n\n  \"onload\" in xhr\n      ? xhr.onload = xhr.onerror = xhr.ontimeout = respond\n      : xhr.onreadystatechange = function(o) { xhr.readyState > 3 && respond(o); };\n\n  function respond(o) {\n    var status = xhr.status, result;\n    if (!status && hasResponse(xhr)\n        || status >= 200 && status < 300\n        || status === 304) {\n      if (response) {\n        try {\n          result = response.call(request, xhr);\n        } catch (e) {\n          event.call(\"error\", request, e);\n          return;\n        }\n      } else {\n        result = xhr;\n      }\n      event.call(\"load\", request, result);\n    } else {\n      event.call(\"error\", request, o);\n    }\n  }\n\n  xhr.onprogress = function(e) {\n    event.call(\"progress\", request, e);\n  };\n\n  request = {\n    header: function(name, value) {\n      name = (name + \"\").toLowerCase();\n      if (arguments.length < 2) return headers.get(name);\n      if (value == null) headers.remove(name);\n      else headers.set(name, value + \"\");\n      return request;\n    },\n\n    // If mimeType is non-null and no Accept header is set, a default is used.\n    mimeType: function(value) {\n      if (!arguments.length) return mimeType;\n      mimeType = value == null ? null : value + \"\";\n      return request;\n    },\n\n    // Specifies what type the response value should take;\n    // for instance, arraybuffer, blob, document, or text.\n    responseType: function(value) {\n      if (!arguments.length) return responseType;\n      responseType = value;\n      return request;\n    },\n\n    timeout: function(value) {\n      if (!arguments.length) return timeout;\n      timeout = +value;\n      return request;\n    },\n\n    user: function(value) {\n      return arguments.length < 1 ? user : (user = value == null ? null : value + \"\", request);\n    },\n\n    password: function(value) {\n      return arguments.length < 1 ? password : (password = value == null ? null : value + \"\", request);\n    },\n\n    // Specify how to convert the response content to a specific type;\n    // changes the callback value on \"load\" events.\n    response: function(value) {\n      response = value;\n      return request;\n    },\n\n    // Alias for send(\"GET\", …).\n    get: function(data, callback) {\n      return request.send(\"GET\", data, callback);\n    },\n\n    // Alias for send(\"POST\", …).\n    post: function(data, callback) {\n      return request.send(\"POST\", data, callback);\n    },\n\n    // If callback is non-null, it will be used for error and load events.\n    send: function(method, data, callback) {\n      xhr.open(method, url, true, user, password);\n      if (mimeType != null && !headers.has(\"accept\")) headers.set(\"accept\", mimeType + \",*/*\");\n      if (xhr.setRequestHeader) headers.each(function(value, name) { xhr.setRequestHeader(name, value); });\n      if (mimeType != null && xhr.overrideMimeType) xhr.overrideMimeType(mimeType);\n      if (responseType != null) xhr.responseType = responseType;\n      if (timeout > 0) xhr.timeout = timeout;\n      if (callback == null && typeof data === \"function\") callback = data, data = null;\n      if (callback != null && callback.length === 1) callback = fixCallback(callback);\n      if (callback != null) request.on(\"error\", callback).on(\"load\", function(xhr) { callback(null, xhr); });\n      event.call(\"beforesend\", request, xhr);\n      xhr.send(data == null ? null : data);\n      return request;\n    },\n\n    abort: function() {\n      xhr.abort();\n      return request;\n    },\n\n    on: function() {\n      var value = event.on.apply(event, arguments);\n      return value === event ? request : value;\n    }\n  };\n\n  if (callback != null) {\n    if (typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback);\n    return request.get(callback);\n  }\n\n  return request;\n};\n\nfunction fixCallback(callback) {\n  return function(error, xhr) {\n    callback(error == null ? xhr : null);\n  };\n}\n\nfunction hasResponse(xhr) {\n  var type = xhr.responseType;\n  return type && type !== \"text\"\n      ? xhr.response // null on error\n      : xhr.responseText; // \"\" on error\n}\n\nvar type = function(defaultMimeType, response) {\n  return function(url, callback) {\n    var r = request(url).mimeType(defaultMimeType).response(response);\n    if (callback != null) {\n      if (typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback);\n      return r.get(callback);\n    }\n    return r;\n  };\n};\n\nvar html = type(\"text/html\", function(xhr) {\n  return document.createRange().createContextualFragment(xhr.responseText);\n});\n\nvar json = type(\"application/json\", function(xhr) {\n  return JSON.parse(xhr.responseText);\n});\n\nvar text = type(\"text/plain\", function(xhr) {\n  return xhr.responseText;\n});\n\nvar xml = type(\"application/xml\", function(xhr) {\n  var xml = xhr.responseXML;\n  if (!xml) throw new Error(\"parse error\");\n  return xml;\n});\n\nvar dsv$1 = function(defaultMimeType, parse) {\n  return function(url, row, callback) {\n    if (arguments.length < 3) callback = row, row = null;\n    var r = request(url).mimeType(defaultMimeType);\n    r.row = function(_) { return arguments.length ? r.response(responseOf(parse, row = _)) : row; };\n    r.row(row);\n    return callback ? r.get(callback) : r;\n  };\n};\n\nfunction responseOf(parse, row) {\n  return function(request$$1) {\n    return parse(request$$1.responseText, row);\n  };\n}\n\nvar csv$1 = dsv$1(\"text/csv\", csvParse);\n\nvar tsv$1 = dsv$1(\"text/tab-separated-values\", tsvParse);\n\nvar frame = 0;\nvar timeout = 0;\nvar interval = 0;\nvar pokeDelay = 1000;\nvar taskHead;\nvar taskTail;\nvar clockLast = 0;\nvar clockNow = 0;\nvar clockSkew = 0;\nvar clock = typeof performance === \"object\" && performance.now ? performance : Date;\nvar setFrame = typeof requestAnimationFrame === \"function\" ? requestAnimationFrame : function(f) { setTimeout(f, 17); };\n\nfunction now() {\n  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);\n}\n\nfunction clearNow() {\n  clockNow = 0;\n}\n\nfunction Timer() {\n  this._call =\n  this._time =\n  this._next = null;\n}\n\nTimer.prototype = timer.prototype = {\n  constructor: Timer,\n  restart: function(callback, delay, time) {\n    if (typeof callback !== \"function\") throw new TypeError(\"callback is not a function\");\n    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);\n    if (!this._next && taskTail !== this) {\n      if (taskTail) taskTail._next = this;\n      else taskHead = this;\n      taskTail = this;\n    }\n    this._call = callback;\n    this._time = time;\n    sleep();\n  },\n  stop: function() {\n    if (this._call) {\n      this._call = null;\n      this._time = Infinity;\n      sleep();\n    }\n  }\n};\n\nfunction timer(callback, delay, time) {\n  var t = new Timer;\n  t.restart(callback, delay, time);\n  return t;\n}\n\nfunction timerFlush() {\n  now(); // Get the current time, if not already set.\n  ++frame; // Pretend we’ve set an alarm, if we haven’t already.\n  var t = taskHead, e;\n  while (t) {\n    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);\n    t = t._next;\n  }\n  --frame;\n}\n\nfunction wake() {\n  clockNow = (clockLast = clock.now()) + clockSkew;\n  frame = timeout = 0;\n  try {\n    timerFlush();\n  } finally {\n    frame = 0;\n    nap();\n    clockNow = 0;\n  }\n}\n\nfunction poke$1() {\n  var now = clock.now(), delay = now - clockLast;\n  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;\n}\n\nfunction nap() {\n  var t0, t1 = taskHead, t2, time = Infinity;\n  while (t1) {\n    if (t1._call) {\n      if (time > t1._time) time = t1._time;\n      t0 = t1, t1 = t1._next;\n    } else {\n      t2 = t1._next, t1._next = null;\n      t1 = t0 ? t0._next = t2 : taskHead = t2;\n    }\n  }\n  taskTail = t0;\n  sleep(time);\n}\n\nfunction sleep(time) {\n  if (frame) return; // Soonest alarm already set, or will be.\n  if (timeout) timeout = clearTimeout(timeout);\n  var delay = time - clockNow;\n  if (delay > 24) {\n    if (time < Infinity) timeout = setTimeout(wake, delay);\n    if (interval) interval = clearInterval(interval);\n  } else {\n    if (!interval) interval = setInterval(poke$1, pokeDelay);\n    frame = 1, setFrame(wake);\n  }\n}\n\nvar timeout$1 = function(callback, delay, time) {\n  var t = new Timer;\n  delay = delay == null ? 0 : +delay;\n  t.restart(function(elapsed) {\n    t.stop();\n    callback(elapsed + delay);\n  }, delay, time);\n  return t;\n};\n\nvar interval$1 = function(callback, delay, time) {\n  var t = new Timer, total = delay;\n  if (delay == null) return t.restart(callback, delay, time), t;\n  delay = +delay, time = time == null ? now() : +time;\n  t.restart(function tick(elapsed) {\n    elapsed += total;\n    t.restart(tick, total += delay, time);\n    callback(elapsed);\n  }, delay, time);\n  return t;\n};\n\nvar t0$1 = new Date;\nvar t1$1 = new Date;\n\nfunction newInterval(floori, offseti, count, field) {\n\n  function interval(date) {\n    return floori(date = new Date(+date)), date;\n  }\n\n  interval.floor = interval;\n\n  interval.ceil = function(date) {\n    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;\n  };\n\n  interval.round = function(date) {\n    var d0 = interval(date),\n        d1 = interval.ceil(date);\n    return date - d0 < d1 - date ? d0 : d1;\n  };\n\n  interval.offset = function(date, step) {\n    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n  };\n\n  interval.range = function(start, stop, step) {\n    var range = [];\n    start = interval.ceil(start);\n    step = step == null ? 1 : Math.floor(step);\n    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n    do range.push(new Date(+start)); while (offseti(start, step), floori(start), start < stop)\n    return range;\n  };\n\n  interval.filter = function(test) {\n    return newInterval(function(date) {\n      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);\n    }, function(date, step) {\n      if (date >= date) while (--step >= 0) while (offseti(date, 1), !test(date)) {} // eslint-disable-line no-empty\n    });\n  };\n\n  if (count) {\n    interval.count = function(start, end) {\n      t0$1.setTime(+start), t1$1.setTime(+end);\n      floori(t0$1), floori(t1$1);\n      return Math.floor(count(t0$1, t1$1));\n    };\n\n    interval.every = function(step) {\n      step = Math.floor(step);\n      return !isFinite(step) || !(step > 0) ? null\n          : !(step > 1) ? interval\n          : interval.filter(field\n              ? function(d) { return field(d) % step === 0; }\n              : function(d) { return interval.count(0, d) % step === 0; });\n    };\n  }\n\n  return interval;\n}\n\nvar millisecond = newInterval(function() {\n  // noop\n}, function(date, step) {\n  date.setTime(+date + step);\n}, function(start, end) {\n  return end - start;\n});\n\n// An optimized implementation for this simple case.\nmillisecond.every = function(k) {\n  k = Math.floor(k);\n  if (!isFinite(k) || !(k > 0)) return null;\n  if (!(k > 1)) return millisecond;\n  return newInterval(function(date) {\n    date.setTime(Math.floor(date / k) * k);\n  }, function(date, step) {\n    date.setTime(+date + step * k);\n  }, function(start, end) {\n    return (end - start) / k;\n  });\n};\n\nvar milliseconds = millisecond.range;\n\nvar durationSecond = 1e3;\nvar durationMinute = 6e4;\nvar durationHour = 36e5;\nvar durationDay = 864e5;\nvar durationWeek = 6048e5;\n\nvar second = newInterval(function(date) {\n  date.setTime(Math.floor(date / durationSecond) * durationSecond);\n}, function(date, step) {\n  date.setTime(+date + step * durationSecond);\n}, function(start, end) {\n  return (end - start) / durationSecond;\n}, function(date) {\n  return date.getUTCSeconds();\n});\n\nvar seconds = second.range;\n\nvar minute = newInterval(function(date) {\n  date.setTime(Math.floor(date / durationMinute) * durationMinute);\n}, function(date, step) {\n  date.setTime(+date + step * durationMinute);\n}, function(start, end) {\n  return (end - start) / durationMinute;\n}, function(date) {\n  return date.getMinutes();\n});\n\nvar minutes = minute.range;\n\nvar hour = newInterval(function(date) {\n  var offset = date.getTimezoneOffset() * durationMinute % durationHour;\n  if (offset < 0) offset += durationHour;\n  date.setTime(Math.floor((+date - offset) / durationHour) * durationHour + offset);\n}, function(date, step) {\n  date.setTime(+date + step * durationHour);\n}, function(start, end) {\n  return (end - start) / durationHour;\n}, function(date) {\n  return date.getHours();\n});\n\nvar hours = hour.range;\n\nvar day = newInterval(function(date) {\n  date.setHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setDate(date.getDate() + step);\n}, function(start, end) {\n  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;\n}, function(date) {\n  return date.getDate() - 1;\n});\n\nvar days = day.range;\n\nfunction weekday(i) {\n  return newInterval(function(date) {\n    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step * 7);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;\n  });\n}\n\nvar sunday = weekday(0);\nvar monday = weekday(1);\nvar tuesday = weekday(2);\nvar wednesday = weekday(3);\nvar thursday = weekday(4);\nvar friday = weekday(5);\nvar saturday = weekday(6);\n\nvar sundays = sunday.range;\nvar mondays = monday.range;\nvar tuesdays = tuesday.range;\nvar wednesdays = wednesday.range;\nvar thursdays = thursday.range;\nvar fridays = friday.range;\nvar saturdays = saturday.range;\n\nvar month = newInterval(function(date) {\n  date.setDate(1);\n  date.setHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setMonth(date.getMonth() + step);\n}, function(start, end) {\n  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n}, function(date) {\n  return date.getMonth();\n});\n\nvar months = month.range;\n\nvar year = newInterval(function(date) {\n  date.setMonth(0, 1);\n  date.setHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setFullYear(date.getFullYear() + step);\n}, function(start, end) {\n  return end.getFullYear() - start.getFullYear();\n}, function(date) {\n  return date.getFullYear();\n});\n\n// An optimized implementation for this simple case.\nyear.every = function(k) {\n  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {\n    date.setFullYear(Math.floor(date.getFullYear() / k) * k);\n    date.setMonth(0, 1);\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step * k);\n  });\n};\n\nvar years = year.range;\n\nvar utcMinute = newInterval(function(date) {\n  date.setUTCSeconds(0, 0);\n}, function(date, step) {\n  date.setTime(+date + step * durationMinute);\n}, function(start, end) {\n  return (end - start) / durationMinute;\n}, function(date) {\n  return date.getUTCMinutes();\n});\n\nvar utcMinutes = utcMinute.range;\n\nvar utcHour = newInterval(function(date) {\n  date.setUTCMinutes(0, 0, 0);\n}, function(date, step) {\n  date.setTime(+date + step * durationHour);\n}, function(start, end) {\n  return (end - start) / durationHour;\n}, function(date) {\n  return date.getUTCHours();\n});\n\nvar utcHours = utcHour.range;\n\nvar utcDay = newInterval(function(date) {\n  date.setUTCHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setUTCDate(date.getUTCDate() + step);\n}, function(start, end) {\n  return (end - start) / durationDay;\n}, function(date) {\n  return date.getUTCDate() - 1;\n});\n\nvar utcDays = utcDay.range;\n\nfunction utcWeekday(i) {\n  return newInterval(function(date) {\n    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step * 7);\n  }, function(start, end) {\n    return (end - start) / durationWeek;\n  });\n}\n\nvar utcSunday = utcWeekday(0);\nvar utcMonday = utcWeekday(1);\nvar utcTuesday = utcWeekday(2);\nvar utcWednesday = utcWeekday(3);\nvar utcThursday = utcWeekday(4);\nvar utcFriday = utcWeekday(5);\nvar utcSaturday = utcWeekday(6);\n\nvar utcSundays = utcSunday.range;\nvar utcMondays = utcMonday.range;\nvar utcTuesdays = utcTuesday.range;\nvar utcWednesdays = utcWednesday.range;\nvar utcThursdays = utcThursday.range;\nvar utcFridays = utcFriday.range;\nvar utcSaturdays = utcSaturday.range;\n\nvar utcMonth = newInterval(function(date) {\n  date.setUTCDate(1);\n  date.setUTCHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setUTCMonth(date.getUTCMonth() + step);\n}, function(start, end) {\n  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n}, function(date) {\n  return date.getUTCMonth();\n});\n\nvar utcMonths = utcMonth.range;\n\nvar utcYear = newInterval(function(date) {\n  date.setUTCMonth(0, 1);\n  date.setUTCHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setUTCFullYear(date.getUTCFullYear() + step);\n}, function(start, end) {\n  return end.getUTCFullYear() - start.getUTCFullYear();\n}, function(date) {\n  return date.getUTCFullYear();\n});\n\n// An optimized implementation for this simple case.\nutcYear.every = function(k) {\n  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {\n    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);\n    date.setUTCMonth(0, 1);\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step * k);\n  });\n};\n\nvar utcYears = utcYear.range;\n\n// Computes the decimal coefficient and exponent of the specified number x with\n// significant digits p, where x is positive and p is in [1, 21] or undefined.\n// For example, formatDecimal(1.23) returns [\"123\", 0].\nvar formatDecimal = function(x, p) {\n  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, ±Infinity\n  var i, coefficient = x.slice(0, i);\n\n  // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n  // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n  return [\n    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n    +x.slice(i + 1)\n  ];\n};\n\nvar exponent$1 = function(x) {\n  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;\n};\n\nvar formatGroup = function(grouping, thousands) {\n  return function(value, width) {\n    var i = value.length,\n        t = [],\n        j = 0,\n        g = grouping[0],\n        length = 0;\n\n    while (i > 0 && g > 0) {\n      if (length + g + 1 > width) g = Math.max(1, width - length);\n      t.push(value.substring(i -= g, i + g));\n      if ((length += g + 1) > width) break;\n      g = grouping[j = (j + 1) % grouping.length];\n    }\n\n    return t.reverse().join(thousands);\n  };\n};\n\nvar formatDefault = function(x, p) {\n  x = x.toPrecision(p);\n\n  out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {\n    switch (x[i]) {\n      case \".\": i0 = i1 = i; break;\n      case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n      case \"e\": break out;\n      default: if (i0 > 0) i0 = 0; break;\n    }\n  }\n\n  return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;\n};\n\nvar prefixExponent;\n\nvar formatPrefixAuto = function(x, p) {\n  var d = formatDecimal(x, p);\n  if (!d) return x + \"\";\n  var coefficient = d[0],\n      exponent = d[1],\n      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n      n = coefficient.length;\n  return i === n ? coefficient\n      : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n      : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n      : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!\n};\n\nvar formatRounded = function(x, p) {\n  var d = formatDecimal(x, p);\n  if (!d) return x + \"\";\n  var coefficient = d[0],\n      exponent = d[1];\n  return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n      : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n};\n\nvar formatTypes = {\n  \"\": formatDefault,\n  \"%\": function(x, p) { return (x * 100).toFixed(p); },\n  \"b\": function(x) { return Math.round(x).toString(2); },\n  \"c\": function(x) { return x + \"\"; },\n  \"d\": function(x) { return Math.round(x).toString(10); },\n  \"e\": function(x, p) { return x.toExponential(p); },\n  \"f\": function(x, p) { return x.toFixed(p); },\n  \"g\": function(x, p) { return x.toPrecision(p); },\n  \"o\": function(x) { return Math.round(x).toString(8); },\n  \"p\": function(x, p) { return formatRounded(x * 100, p); },\n  \"r\": formatRounded,\n  \"s\": formatPrefixAuto,\n  \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); },\n  \"x\": function(x) { return Math.round(x).toString(16); }\n};\n\n// [[fill]align][sign][symbol][0][width][,][.precision][type]\nvar re = /^(?:(.)?([<>=^]))?([+\\-\\( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?([a-z%])?$/i;\n\nvar formatSpecifier = function(specifier) {\n  return new FormatSpecifier(specifier);\n};\n\nfunction FormatSpecifier(specifier) {\n  if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n\n  var match,\n      fill = match[1] || \" \",\n      align = match[2] || \">\",\n      sign = match[3] || \"-\",\n      symbol = match[4] || \"\",\n      zero = !!match[5],\n      width = match[6] && +match[6],\n      comma = !!match[7],\n      precision = match[8] && +match[8].slice(1),\n      type = match[9] || \"\";\n\n  // The \"n\" type is an alias for \",g\".\n  if (type === \"n\") comma = true, type = \"g\";\n\n  // Map invalid types to the default format.\n  else if (!formatTypes[type]) type = \"\";\n\n  // If zero fill is specified, padding goes after sign and before digits.\n  if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\n  this.fill = fill;\n  this.align = align;\n  this.sign = sign;\n  this.symbol = symbol;\n  this.zero = zero;\n  this.width = width;\n  this.comma = comma;\n  this.precision = precision;\n  this.type = type;\n}\n\nFormatSpecifier.prototype.toString = function() {\n  return this.fill\n      + this.align\n      + this.sign\n      + this.symbol\n      + (this.zero ? \"0\" : \"\")\n      + (this.width == null ? \"\" : Math.max(1, this.width | 0))\n      + (this.comma ? \",\" : \"\")\n      + (this.precision == null ? \"\" : \".\" + Math.max(0, this.precision | 0))\n      + this.type;\n};\n\nvar prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"\\xB5\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\nfunction identity$3(x) {\n  return x;\n}\n\nvar formatLocale = function(locale) {\n  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity$3,\n      currency = locale.currency,\n      decimal = locale.decimal;\n\n  function newFormat(specifier) {\n    specifier = formatSpecifier(specifier);\n\n    var fill = specifier.fill,\n        align = specifier.align,\n        sign = specifier.sign,\n        symbol = specifier.symbol,\n        zero = specifier.zero,\n        width = specifier.width,\n        comma = specifier.comma,\n        precision = specifier.precision,\n        type = specifier.type;\n\n    // Compute the prefix and suffix.\n    // For SI-prefix, the suffix is lazily computed.\n    var prefix = symbol === \"$\" ? currency[0] : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n        suffix = symbol === \"$\" ? currency[1] : /[%p]/.test(type) ? \"%\" : \"\";\n\n    // What format function should we use?\n    // Is this an integer type?\n    // Can this type generate exponential notation?\n    var formatType = formatTypes[type],\n        maybeSuffix = !type || /[defgprs%]/.test(type);\n\n    // Set the default precision if not specified,\n    // or clamp the specified precision to the supported range.\n    // For significant precision, it must be in [1, 21].\n    // For fixed precision, it must be in [0, 20].\n    precision = precision == null ? (type ? 6 : 12)\n        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n        : Math.max(0, Math.min(20, precision));\n\n    function format(value) {\n      var valuePrefix = prefix,\n          valueSuffix = suffix,\n          i, n, c;\n\n      if (type === \"c\") {\n        valueSuffix = formatType(value) + valueSuffix;\n        value = \"\";\n      } else {\n        value = +value;\n\n        // Convert negative to positive, and compute the prefix.\n        // Note that -0 is not less than 0, but 1 / -0 is!\n        var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);\n\n        // Perform the initial formatting.\n        value = formatType(value, precision);\n\n        // If the original value was negative, it may be rounded to zero during\n        // formatting; treat this as (positive) zero.\n        if (valueNegative) {\n          i = -1, n = value.length;\n          valueNegative = false;\n          while (++i < n) {\n            if (c = value.charCodeAt(i), (48 < c && c < 58)\n                || (type === \"x\" && 96 < c && c < 103)\n                || (type === \"X\" && 64 < c && c < 71)) {\n              valueNegative = true;\n              break;\n            }\n          }\n        }\n\n        // Compute the prefix and suffix.\n        valuePrefix = (valueNegative ? (sign === \"(\" ? sign : \"-\") : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n        valueSuffix = valueSuffix + (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\n        // Break the formatted value into the integer “value” part that can be\n        // grouped, and fractional or exponential “suffix” part that is not.\n        if (maybeSuffix) {\n          i = -1, n = value.length;\n          while (++i < n) {\n            if (c = value.charCodeAt(i), 48 > c || c > 57) {\n              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n              value = value.slice(0, i);\n              break;\n            }\n          }\n        }\n      }\n\n      // If the fill character is not \"0\", grouping is applied before padding.\n      if (comma && !zero) value = group(value, Infinity);\n\n      // Compute the padding.\n      var length = valuePrefix.length + value.length + valueSuffix.length,\n          padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\n      // If the fill character is \"0\", grouping is applied after padding.\n      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\n      // Reconstruct the final output based on the desired alignment.\n      switch (align) {\n        case \"<\": return valuePrefix + value + valueSuffix + padding;\n        case \"=\": return valuePrefix + padding + value + valueSuffix;\n        case \"^\": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);\n      }\n      return padding + valuePrefix + value + valueSuffix;\n    }\n\n    format.toString = function() {\n      return specifier + \"\";\n    };\n\n    return format;\n  }\n\n  function formatPrefix(specifier, value) {\n    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n        e = Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3,\n        k = Math.pow(10, -e),\n        prefix = prefixes[8 + e / 3];\n    return function(value) {\n      return f(k * value) + prefix;\n    };\n  }\n\n  return {\n    format: newFormat,\n    formatPrefix: formatPrefix\n  };\n};\n\nvar locale$1;\n\n\n\ndefaultLocale({\n  decimal: \".\",\n  thousands: \",\",\n  grouping: [3],\n  currency: [\"$\", \"\"]\n});\n\nfunction defaultLocale(definition) {\n  locale$1 = formatLocale(definition);\n  exports.format = locale$1.format;\n  exports.formatPrefix = locale$1.formatPrefix;\n  return locale$1;\n}\n\nvar precisionFixed = function(step) {\n  return Math.max(0, -exponent$1(Math.abs(step)));\n};\n\nvar precisionPrefix = function(step, value) {\n  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3 - exponent$1(Math.abs(step)));\n};\n\nvar precisionRound = function(step, max) {\n  step = Math.abs(step), max = Math.abs(max) - step;\n  return Math.max(0, exponent$1(max) - exponent$1(step)) + 1;\n};\n\nfunction localDate(d) {\n  if (0 <= d.y && d.y < 100) {\n    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n    date.setFullYear(d.y);\n    return date;\n  }\n  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n}\n\nfunction utcDate(d) {\n  if (0 <= d.y && d.y < 100) {\n    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n    date.setUTCFullYear(d.y);\n    return date;\n  }\n  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n}\n\nfunction newYear(y) {\n  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};\n}\n\nfunction formatLocale$1(locale) {\n  var locale_dateTime = locale.dateTime,\n      locale_date = locale.date,\n      locale_time = locale.time,\n      locale_periods = locale.periods,\n      locale_weekdays = locale.days,\n      locale_shortWeekdays = locale.shortDays,\n      locale_months = locale.months,\n      locale_shortMonths = locale.shortMonths;\n\n  var periodRe = formatRe(locale_periods),\n      periodLookup = formatLookup(locale_periods),\n      weekdayRe = formatRe(locale_weekdays),\n      weekdayLookup = formatLookup(locale_weekdays),\n      shortWeekdayRe = formatRe(locale_shortWeekdays),\n      shortWeekdayLookup = formatLookup(locale_shortWeekdays),\n      monthRe = formatRe(locale_months),\n      monthLookup = formatLookup(locale_months),\n      shortMonthRe = formatRe(locale_shortMonths),\n      shortMonthLookup = formatLookup(locale_shortMonths);\n\n  var formats = {\n    \"a\": formatShortWeekday,\n    \"A\": formatWeekday,\n    \"b\": formatShortMonth,\n    \"B\": formatMonth,\n    \"c\": null,\n    \"d\": formatDayOfMonth,\n    \"e\": formatDayOfMonth,\n    \"H\": formatHour24,\n    \"I\": formatHour12,\n    \"j\": formatDayOfYear,\n    \"L\": formatMilliseconds,\n    \"m\": formatMonthNumber,\n    \"M\": formatMinutes,\n    \"p\": formatPeriod,\n    \"S\": formatSeconds,\n    \"U\": formatWeekNumberSunday,\n    \"w\": formatWeekdayNumber,\n    \"W\": formatWeekNumberMonday,\n    \"x\": null,\n    \"X\": null,\n    \"y\": formatYear,\n    \"Y\": formatFullYear,\n    \"Z\": formatZone,\n    \"%\": formatLiteralPercent\n  };\n\n  var utcFormats = {\n    \"a\": formatUTCShortWeekday,\n    \"A\": formatUTCWeekday,\n    \"b\": formatUTCShortMonth,\n    \"B\": formatUTCMonth,\n    \"c\": null,\n    \"d\": formatUTCDayOfMonth,\n    \"e\": formatUTCDayOfMonth,\n    \"H\": formatUTCHour24,\n    \"I\": formatUTCHour12,\n    \"j\": formatUTCDayOfYear,\n    \"L\": formatUTCMilliseconds,\n    \"m\": formatUTCMonthNumber,\n    \"M\": formatUTCMinutes,\n    \"p\": formatUTCPeriod,\n    \"S\": formatUTCSeconds,\n    \"U\": formatUTCWeekNumberSunday,\n    \"w\": formatUTCWeekdayNumber,\n    \"W\": formatUTCWeekNumberMonday,\n    \"x\": null,\n    \"X\": null,\n    \"y\": formatUTCYear,\n    \"Y\": formatUTCFullYear,\n    \"Z\": formatUTCZone,\n    \"%\": formatLiteralPercent\n  };\n\n  var parses = {\n    \"a\": parseShortWeekday,\n    \"A\": parseWeekday,\n    \"b\": parseShortMonth,\n    \"B\": parseMonth,\n    \"c\": parseLocaleDateTime,\n    \"d\": parseDayOfMonth,\n    \"e\": parseDayOfMonth,\n    \"H\": parseHour24,\n    \"I\": parseHour24,\n    \"j\": parseDayOfYear,\n    \"L\": parseMilliseconds,\n    \"m\": parseMonthNumber,\n    \"M\": parseMinutes,\n    \"p\": parsePeriod,\n    \"S\": parseSeconds,\n    \"U\": parseWeekNumberSunday,\n    \"w\": parseWeekdayNumber,\n    \"W\": parseWeekNumberMonday,\n    \"x\": parseLocaleDate,\n    \"X\": parseLocaleTime,\n    \"y\": parseYear,\n    \"Y\": parseFullYear,\n    \"Z\": parseZone,\n    \"%\": parseLiteralPercent\n  };\n\n  // These recursive directive definitions must be deferred.\n  formats.x = newFormat(locale_date, formats);\n  formats.X = newFormat(locale_time, formats);\n  formats.c = newFormat(locale_dateTime, formats);\n  utcFormats.x = newFormat(locale_date, utcFormats);\n  utcFormats.X = newFormat(locale_time, utcFormats);\n  utcFormats.c = newFormat(locale_dateTime, utcFormats);\n\n  function newFormat(specifier, formats) {\n    return function(date) {\n      var string = [],\n          i = -1,\n          j = 0,\n          n = specifier.length,\n          c,\n          pad,\n          format;\n\n      if (!(date instanceof Date)) date = new Date(+date);\n\n      while (++i < n) {\n        if (specifier.charCodeAt(i) === 37) {\n          string.push(specifier.slice(j, i));\n          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);\n          else pad = c === \"e\" ? \" \" : \"0\";\n          if (format = formats[c]) c = format(date, pad);\n          string.push(c);\n          j = i + 1;\n        }\n      }\n\n      string.push(specifier.slice(j, i));\n      return string.join(\"\");\n    };\n  }\n\n  function newParse(specifier, newDate) {\n    return function(string) {\n      var d = newYear(1900),\n          i = parseSpecifier(d, specifier, string += \"\", 0);\n      if (i != string.length) return null;\n\n      // The am-pm flag is 0 for AM, and 1 for PM.\n      if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n\n      // Convert day-of-week and week-of-year to day-of-year.\n      if (\"W\" in d || \"U\" in d) {\n        if (!(\"w\" in d)) d.w = \"W\" in d ? 1 : 0;\n        var day$$1 = \"Z\" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();\n        d.m = 0;\n        d.d = \"W\" in d ? (d.w + 6) % 7 + d.W * 7 - (day$$1 + 5) % 7 : d.w + d.U * 7 - (day$$1 + 6) % 7;\n      }\n\n      // If a time zone is specified, all fields are interpreted as UTC and then\n      // offset according to the specified time zone.\n      if (\"Z\" in d) {\n        d.H += d.Z / 100 | 0;\n        d.M += d.Z % 100;\n        return utcDate(d);\n      }\n\n      // Otherwise, all fields are in local time.\n      return newDate(d);\n    };\n  }\n\n  function parseSpecifier(d, specifier, string, j) {\n    var i = 0,\n        n = specifier.length,\n        m = string.length,\n        c,\n        parse;\n\n    while (i < n) {\n      if (j >= m) return -1;\n      c = specifier.charCodeAt(i++);\n      if (c === 37) {\n        c = specifier.charAt(i++);\n        parse = parses[c in pads ? specifier.charAt(i++) : c];\n        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;\n      } else if (c != string.charCodeAt(j++)) {\n        return -1;\n      }\n    }\n\n    return j;\n  }\n\n  function parsePeriod(d, string, i) {\n    var n = periodRe.exec(string.slice(i));\n    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseShortWeekday(d, string, i) {\n    var n = shortWeekdayRe.exec(string.slice(i));\n    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseWeekday(d, string, i) {\n    var n = weekdayRe.exec(string.slice(i));\n    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseShortMonth(d, string, i) {\n    var n = shortMonthRe.exec(string.slice(i));\n    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseMonth(d, string, i) {\n    var n = monthRe.exec(string.slice(i));\n    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseLocaleDateTime(d, string, i) {\n    return parseSpecifier(d, locale_dateTime, string, i);\n  }\n\n  function parseLocaleDate(d, string, i) {\n    return parseSpecifier(d, locale_date, string, i);\n  }\n\n  function parseLocaleTime(d, string, i) {\n    return parseSpecifier(d, locale_time, string, i);\n  }\n\n  function formatShortWeekday(d) {\n    return locale_shortWeekdays[d.getDay()];\n  }\n\n  function formatWeekday(d) {\n    return locale_weekdays[d.getDay()];\n  }\n\n  function formatShortMonth(d) {\n    return locale_shortMonths[d.getMonth()];\n  }\n\n  function formatMonth(d) {\n    return locale_months[d.getMonth()];\n  }\n\n  function formatPeriod(d) {\n    return locale_periods[+(d.getHours() >= 12)];\n  }\n\n  function formatUTCShortWeekday(d) {\n    return locale_shortWeekdays[d.getUTCDay()];\n  }\n\n  function formatUTCWeekday(d) {\n    return locale_weekdays[d.getUTCDay()];\n  }\n\n  function formatUTCShortMonth(d) {\n    return locale_shortMonths[d.getUTCMonth()];\n  }\n\n  function formatUTCMonth(d) {\n    return locale_months[d.getUTCMonth()];\n  }\n\n  function formatUTCPeriod(d) {\n    return locale_periods[+(d.getUTCHours() >= 12)];\n  }\n\n  return {\n    format: function(specifier) {\n      var f = newFormat(specifier += \"\", formats);\n      f.toString = function() { return specifier; };\n      return f;\n    },\n    parse: function(specifier) {\n      var p = newParse(specifier += \"\", localDate);\n      p.toString = function() { return specifier; };\n      return p;\n    },\n    utcFormat: function(specifier) {\n      var f = newFormat(specifier += \"\", utcFormats);\n      f.toString = function() { return specifier; };\n      return f;\n    },\n    utcParse: function(specifier) {\n      var p = newParse(specifier, utcDate);\n      p.toString = function() { return specifier; };\n      return p;\n    }\n  };\n}\n\nvar pads = {\"-\": \"\", \"_\": \" \", \"0\": \"0\"};\nvar numberRe = /^\\s*\\d+/;\nvar percentRe = /^%/;\nvar requoteRe = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\nfunction pad(value, fill, width) {\n  var sign = value < 0 ? \"-\" : \"\",\n      string = (sign ? -value : value) + \"\",\n      length = string.length;\n  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n}\n\nfunction requote(s) {\n  return s.replace(requoteRe, \"\\\\$&\");\n}\n\nfunction formatRe(names) {\n  return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n}\n\nfunction formatLookup(names) {\n  var map = {}, i = -1, n = names.length;\n  while (++i < n) map[names[i].toLowerCase()] = i;\n  return map;\n}\n\nfunction parseWeekdayNumber(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 1));\n  return n ? (d.w = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseWeekNumberSunday(d, string, i) {\n  var n = numberRe.exec(string.slice(i));\n  return n ? (d.U = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseWeekNumberMonday(d, string, i) {\n  var n = numberRe.exec(string.slice(i));\n  return n ? (d.W = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseFullYear(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 4));\n  return n ? (d.y = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseYear(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;\n}\n\nfunction parseZone(d, string, i) {\n  var n = /^(Z)|([+-]\\d\\d)(?:\\:?(\\d\\d))?/.exec(string.slice(i, i + 6));\n  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || \"00\")), i + n[0].length) : -1;\n}\n\nfunction parseMonthNumber(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n}\n\nfunction parseDayOfMonth(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.d = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseDayOfYear(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 3));\n  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseHour24(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.H = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseMinutes(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.M = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseSeconds(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.S = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseMilliseconds(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 3));\n  return n ? (d.L = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseLiteralPercent(d, string, i) {\n  var n = percentRe.exec(string.slice(i, i + 1));\n  return n ? i + n[0].length : -1;\n}\n\nfunction formatDayOfMonth(d, p) {\n  return pad(d.getDate(), p, 2);\n}\n\nfunction formatHour24(d, p) {\n  return pad(d.getHours(), p, 2);\n}\n\nfunction formatHour12(d, p) {\n  return pad(d.getHours() % 12 || 12, p, 2);\n}\n\nfunction formatDayOfYear(d, p) {\n  return pad(1 + day.count(year(d), d), p, 3);\n}\n\nfunction formatMilliseconds(d, p) {\n  return pad(d.getMilliseconds(), p, 3);\n}\n\nfunction formatMonthNumber(d, p) {\n  return pad(d.getMonth() + 1, p, 2);\n}\n\nfunction formatMinutes(d, p) {\n  return pad(d.getMinutes(), p, 2);\n}\n\nfunction formatSeconds(d, p) {\n  return pad(d.getSeconds(), p, 2);\n}\n\nfunction formatWeekNumberSunday(d, p) {\n  return pad(sunday.count(year(d), d), p, 2);\n}\n\nfunction formatWeekdayNumber(d) {\n  return d.getDay();\n}\n\nfunction formatWeekNumberMonday(d, p) {\n  return pad(monday.count(year(d), d), p, 2);\n}\n\nfunction formatYear(d, p) {\n  return pad(d.getFullYear() % 100, p, 2);\n}\n\nfunction formatFullYear(d, p) {\n  return pad(d.getFullYear() % 10000, p, 4);\n}\n\nfunction formatZone(d) {\n  var z = d.getTimezoneOffset();\n  return (z > 0 ? \"-\" : (z *= -1, \"+\"))\n      + pad(z / 60 | 0, \"0\", 2)\n      + pad(z % 60, \"0\", 2);\n}\n\nfunction formatUTCDayOfMonth(d, p) {\n  return pad(d.getUTCDate(), p, 2);\n}\n\nfunction formatUTCHour24(d, p) {\n  return pad(d.getUTCHours(), p, 2);\n}\n\nfunction formatUTCHour12(d, p) {\n  return pad(d.getUTCHours() % 12 || 12, p, 2);\n}\n\nfunction formatUTCDayOfYear(d, p) {\n  return pad(1 + utcDay.count(utcYear(d), d), p, 3);\n}\n\nfunction formatUTCMilliseconds(d, p) {\n  return pad(d.getUTCMilliseconds(), p, 3);\n}\n\nfunction formatUTCMonthNumber(d, p) {\n  return pad(d.getUTCMonth() + 1, p, 2);\n}\n\nfunction formatUTCMinutes(d, p) {\n  return pad(d.getUTCMinutes(), p, 2);\n}\n\nfunction formatUTCSeconds(d, p) {\n  return pad(d.getUTCSeconds(), p, 2);\n}\n\nfunction formatUTCWeekNumberSunday(d, p) {\n  return pad(utcSunday.count(utcYear(d), d), p, 2);\n}\n\nfunction formatUTCWeekdayNumber(d) {\n  return d.getUTCDay();\n}\n\nfunction formatUTCWeekNumberMonday(d, p) {\n  return pad(utcMonday.count(utcYear(d), d), p, 2);\n}\n\nfunction formatUTCYear(d, p) {\n  return pad(d.getUTCFullYear() % 100, p, 2);\n}\n\nfunction formatUTCFullYear(d, p) {\n  return pad(d.getUTCFullYear() % 10000, p, 4);\n}\n\nfunction formatUTCZone() {\n  return \"+0000\";\n}\n\nfunction formatLiteralPercent() {\n  return \"%\";\n}\n\nvar locale$2;\n\n\n\n\n\ndefaultLocale$1({\n  dateTime: \"%x, %X\",\n  date: \"%-m/%-d/%Y\",\n  time: \"%-I:%M:%S %p\",\n  periods: [\"AM\", \"PM\"],\n  days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n  shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n  months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n  shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n});\n\nfunction defaultLocale$1(definition) {\n  locale$2 = formatLocale$1(definition);\n  exports.timeFormat = locale$2.format;\n  exports.timeParse = locale$2.parse;\n  exports.utcFormat = locale$2.utcFormat;\n  exports.utcParse = locale$2.utcParse;\n  return locale$2;\n}\n\nvar isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\n\nfunction formatIsoNative(date) {\n  return date.toISOString();\n}\n\nvar formatIso = Date.prototype.toISOString\n    ? formatIsoNative\n    : exports.utcFormat(isoSpecifier);\n\nfunction parseIsoNative(string) {\n  var date = new Date(string);\n  return isNaN(date) ? null : date;\n}\n\nvar parseIso = +new Date(\"2000-01-01T00:00:00.000Z\")\n    ? parseIsoNative\n    : exports.utcParse(isoSpecifier);\n\nvar array$2 = Array.prototype;\n\nvar map$3 = array$2.map;\nvar slice$3 = array$2.slice;\n\nvar implicit = {name: \"implicit\"};\n\nfunction ordinal(range) {\n  var index = map$1(),\n      domain = [],\n      unknown = implicit;\n\n  range = range == null ? [] : slice$3.call(range);\n\n  function scale(d) {\n    var key = d + \"\", i = index.get(key);\n    if (!i) {\n      if (unknown !== implicit) return unknown;\n      index.set(key, i = domain.push(d));\n    }\n    return range[(i - 1) % range.length];\n  }\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [], index = map$1();\n    var i = -1, n = _.length, d, key;\n    while (++i < n) if (!index.has(key = (d = _[i]) + \"\")) index.set(key, domain.push(d));\n    return scale;\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice$3.call(_), scale) : range.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return ordinal()\n        .domain(domain)\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return scale;\n}\n\nfunction band() {\n  var scale = ordinal().unknown(undefined),\n      domain = scale.domain,\n      ordinalRange = scale.range,\n      range$$1 = [0, 1],\n      step,\n      bandwidth,\n      round = false,\n      paddingInner = 0,\n      paddingOuter = 0,\n      align = 0.5;\n\n  delete scale.unknown;\n\n  function rescale() {\n    var n = domain().length,\n        reverse = range$$1[1] < range$$1[0],\n        start = range$$1[reverse - 0],\n        stop = range$$1[1 - reverse];\n    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);\n    if (round) step = Math.floor(step);\n    start += (stop - start - step * (n - paddingInner)) * align;\n    bandwidth = step * (1 - paddingInner);\n    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);\n    var values = range(n).map(function(i) { return start + step * i; });\n    return ordinalRange(reverse ? values.reverse() : values);\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range$$1 = [+_[0], +_[1]], rescale()) : range$$1.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range$$1 = [+_[0], +_[1]], round = true, rescale();\n  };\n\n  scale.bandwidth = function() {\n    return bandwidth;\n  };\n\n  scale.step = function() {\n    return step;\n  };\n\n  scale.round = function(_) {\n    return arguments.length ? (round = !!_, rescale()) : round;\n  };\n\n  scale.padding = function(_) {\n    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;\n  };\n\n  scale.paddingInner = function(_) {\n    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;\n  };\n\n  scale.paddingOuter = function(_) {\n    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;\n  };\n\n  scale.align = function(_) {\n    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;\n  };\n\n  scale.copy = function() {\n    return band()\n        .domain(domain())\n        .range(range$$1)\n        .round(round)\n        .paddingInner(paddingInner)\n        .paddingOuter(paddingOuter)\n        .align(align);\n  };\n\n  return rescale();\n}\n\nfunction pointish(scale) {\n  var copy = scale.copy;\n\n  scale.padding = scale.paddingOuter;\n  delete scale.paddingInner;\n  delete scale.paddingOuter;\n\n  scale.copy = function() {\n    return pointish(copy());\n  };\n\n  return scale;\n}\n\nfunction point$4() {\n  return pointish(band().paddingInner(1));\n}\n\nvar constant$4 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nvar number$1 = function(x) {\n  return +x;\n};\n\nvar unit = [0, 1];\n\nfunction deinterpolateLinear(a, b) {\n  return (b -= (a = +a))\n      ? function(x) { return (x - a) / b; }\n      : constant$4(b);\n}\n\nfunction deinterpolateClamp(deinterpolate) {\n  return function(a, b) {\n    var d = deinterpolate(a = +a, b = +b);\n    return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };\n  };\n}\n\nfunction reinterpolateClamp(reinterpolate) {\n  return function(a, b) {\n    var r = reinterpolate(a = +a, b = +b);\n    return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };\n  };\n}\n\nfunction bimap(domain, range$$1, deinterpolate, reinterpolate) {\n  var d0 = domain[0], d1 = domain[1], r0 = range$$1[0], r1 = range$$1[1];\n  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);\n  else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);\n  return function(x) { return r0(d0(x)); };\n}\n\nfunction polymap(domain, range$$1, deinterpolate, reinterpolate) {\n  var j = Math.min(domain.length, range$$1.length) - 1,\n      d = new Array(j),\n      r = new Array(j),\n      i = -1;\n\n  // Reverse descending domains.\n  if (domain[j] < domain[0]) {\n    domain = domain.slice().reverse();\n    range$$1 = range$$1.slice().reverse();\n  }\n\n  while (++i < j) {\n    d[i] = deinterpolate(domain[i], domain[i + 1]);\n    r[i] = reinterpolate(range$$1[i], range$$1[i + 1]);\n  }\n\n  return function(x) {\n    var i = bisectRight(domain, x, 1, j) - 1;\n    return r[i](d[i](x));\n  };\n}\n\nfunction copy(source, target) {\n  return target\n      .domain(source.domain())\n      .range(source.range())\n      .interpolate(source.interpolate())\n      .clamp(source.clamp());\n}\n\n// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].\n// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].\nfunction continuous(deinterpolate, reinterpolate) {\n  var domain = unit,\n      range$$1 = unit,\n      interpolate$$1 = interpolate,\n      clamp = false,\n      piecewise,\n      output,\n      input;\n\n  function rescale() {\n    piecewise = Math.min(domain.length, range$$1.length) > 2 ? polymap : bimap;\n    output = input = null;\n    return scale;\n  }\n\n  function scale(x) {\n    return (output || (output = piecewise(domain, range$$1, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate$$1)))(+x);\n  }\n\n  scale.invert = function(y) {\n    return (input || (input = piecewise(range$$1, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = map$3.call(_, number$1), rescale()) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range$$1 = slice$3.call(_), rescale()) : range$$1.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range$$1 = slice$3.call(_), interpolate$$1 = interpolateRound, rescale();\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, rescale()) : clamp;\n  };\n\n  scale.interpolate = function(_) {\n    return arguments.length ? (interpolate$$1 = _, rescale()) : interpolate$$1;\n  };\n\n  return rescale();\n}\n\nvar tickFormat = function(domain, count, specifier) {\n  var start = domain[0],\n      stop = domain[domain.length - 1],\n      step = tickStep(start, stop, count == null ? 10 : count),\n      precision;\n  specifier = formatSpecifier(specifier == null ? \",f\" : specifier);\n  switch (specifier.type) {\n    case \"s\": {\n      var value = Math.max(Math.abs(start), Math.abs(stop));\n      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;\n      return exports.formatPrefix(specifier, value);\n    }\n    case \"\":\n    case \"e\":\n    case \"g\":\n    case \"p\":\n    case \"r\": {\n      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === \"e\");\n      break;\n    }\n    case \"f\":\n    case \"%\": {\n      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === \"%\") * 2;\n      break;\n    }\n  }\n  return exports.format(specifier);\n};\n\nfunction linearish(scale) {\n  var domain = scale.domain;\n\n  scale.ticks = function(count) {\n    var d = domain();\n    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    return tickFormat(domain(), count, specifier);\n  };\n\n  scale.nice = function(count) {\n    var d = domain(),\n        i = d.length - 1,\n        n = count == null ? 10 : count,\n        start = d[0],\n        stop = d[i],\n        step = tickStep(start, stop, n);\n\n    if (step) {\n      step = tickStep(Math.floor(start / step) * step, Math.ceil(stop / step) * step, n);\n      d[0] = Math.floor(start / step) * step;\n      d[i] = Math.ceil(stop / step) * step;\n      domain(d);\n    }\n\n    return scale;\n  };\n\n  return scale;\n}\n\nfunction linear$2() {\n  var scale = continuous(deinterpolateLinear, interpolateNumber);\n\n  scale.copy = function() {\n    return copy(scale, linear$2());\n  };\n\n  return linearish(scale);\n}\n\nfunction identity$4() {\n  var domain = [0, 1];\n\n  function scale(x) {\n    return +x;\n  }\n\n  scale.invert = scale;\n\n  scale.domain = scale.range = function(_) {\n    return arguments.length ? (domain = map$3.call(_, number$1), scale) : domain.slice();\n  };\n\n  scale.copy = function() {\n    return identity$4().domain(domain);\n  };\n\n  return linearish(scale);\n}\n\nvar nice = function(domain, interval) {\n  domain = domain.slice();\n\n  var i0 = 0,\n      i1 = domain.length - 1,\n      x0 = domain[i0],\n      x1 = domain[i1],\n      t;\n\n  if (x1 < x0) {\n    t = i0, i0 = i1, i1 = t;\n    t = x0, x0 = x1, x1 = t;\n  }\n\n  domain[i0] = interval.floor(x0);\n  domain[i1] = interval.ceil(x1);\n  return domain;\n};\n\nfunction deinterpolate(a, b) {\n  return (b = Math.log(b / a))\n      ? function(x) { return Math.log(x / a) / b; }\n      : constant$4(b);\n}\n\nfunction reinterpolate(a, b) {\n  return a < 0\n      ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }\n      : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };\n}\n\nfunction pow10(x) {\n  return isFinite(x) ? +(\"1e\" + x) : x < 0 ? 0 : x;\n}\n\nfunction powp(base) {\n  return base === 10 ? pow10\n      : base === Math.E ? Math.exp\n      : function(x) { return Math.pow(base, x); };\n}\n\nfunction logp(base) {\n  return base === Math.E ? Math.log\n      : base === 10 && Math.log10\n      || base === 2 && Math.log2\n      || (base = Math.log(base), function(x) { return Math.log(x) / base; });\n}\n\nfunction reflect(f) {\n  return function(x) {\n    return -f(-x);\n  };\n}\n\nfunction log() {\n  var scale = continuous(deinterpolate, reinterpolate).domain([1, 10]),\n      domain = scale.domain,\n      base = 10,\n      logs = logp(10),\n      pows = powp(10);\n\n  function rescale() {\n    logs = logp(base), pows = powp(base);\n    if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);\n    return scale;\n  }\n\n  scale.base = function(_) {\n    return arguments.length ? (base = +_, rescale()) : base;\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.ticks = function(count) {\n    var d = domain(),\n        u = d[0],\n        v = d[d.length - 1],\n        r;\n\n    if (r = v < u) i = u, u = v, v = i;\n\n    var i = logs(u),\n        j = logs(v),\n        p,\n        k,\n        t,\n        n = count == null ? 10 : +count,\n        z = [];\n\n    if (!(base % 1) && j - i < n) {\n      i = Math.round(i) - 1, j = Math.round(j) + 1;\n      if (u > 0) for (; i < j; ++i) {\n        for (k = 1, p = pows(i); k < base; ++k) {\n          t = p * k;\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      } else for (; i < j; ++i) {\n        for (k = base - 1, p = pows(i); k >= 1; --k) {\n          t = p * k;\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      }\n    } else {\n      z = ticks(i, j, Math.min(j - i, n)).map(pows);\n    }\n\n    return r ? z.reverse() : z;\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    if (specifier == null) specifier = base === 10 ? \".0e\" : \",\";\n    if (typeof specifier !== \"function\") specifier = exports.format(specifier);\n    if (count === Infinity) return specifier;\n    if (count == null) count = 10;\n    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?\n    return function(d) {\n      var i = d / pows(Math.round(logs(d)));\n      if (i * base < base - 0.5) i *= base;\n      return i <= k ? specifier(d) : \"\";\n    };\n  };\n\n  scale.nice = function() {\n    return domain(nice(domain(), {\n      floor: function(x) { return pows(Math.floor(logs(x))); },\n      ceil: function(x) { return pows(Math.ceil(logs(x))); }\n    }));\n  };\n\n  scale.copy = function() {\n    return copy(scale, log().base(base));\n  };\n\n  return scale;\n}\n\nfunction raise(x, exponent) {\n  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);\n}\n\nfunction pow() {\n  var exponent = 1,\n      scale = continuous(deinterpolate, reinterpolate),\n      domain = scale.domain;\n\n  function deinterpolate(a, b) {\n    return (b = raise(b, exponent) - (a = raise(a, exponent)))\n        ? function(x) { return (raise(x, exponent) - a) / b; }\n        : constant$4(b);\n  }\n\n  function reinterpolate(a, b) {\n    b = raise(b, exponent) - (a = raise(a, exponent));\n    return function(t) { return raise(a + b * t, 1 / exponent); };\n  }\n\n  scale.exponent = function(_) {\n    return arguments.length ? (exponent = +_, domain(domain())) : exponent;\n  };\n\n  scale.copy = function() {\n    return copy(scale, pow().exponent(exponent));\n  };\n\n  return linearish(scale);\n}\n\nfunction sqrt() {\n  return pow().exponent(0.5);\n}\n\nfunction quantile$$1() {\n  var domain = [],\n      range$$1 = [],\n      thresholds = [];\n\n  function rescale() {\n    var i = 0, n = Math.max(1, range$$1.length);\n    thresholds = new Array(n - 1);\n    while (++i < n) thresholds[i - 1] = threshold(domain, i / n);\n    return scale;\n  }\n\n  function scale(x) {\n    if (!isNaN(x = +x)) return range$$1[bisectRight(thresholds, x)];\n  }\n\n  scale.invertExtent = function(y) {\n    var i = range$$1.indexOf(y);\n    return i < 0 ? [NaN, NaN] : [\n      i > 0 ? thresholds[i - 1] : domain[0],\n      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]\n    ];\n  };\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [];\n    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);\n    domain.sort(ascending);\n    return rescale();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range$$1 = slice$3.call(_), rescale()) : range$$1.slice();\n  };\n\n  scale.quantiles = function() {\n    return thresholds.slice();\n  };\n\n  scale.copy = function() {\n    return quantile$$1()\n        .domain(domain)\n        .range(range$$1);\n  };\n\n  return scale;\n}\n\nfunction quantize$1() {\n  var x0 = 0,\n      x1 = 1,\n      n = 1,\n      domain = [0.5],\n      range$$1 = [0, 1];\n\n  function scale(x) {\n    if (x <= x) return range$$1[bisectRight(domain, x, 0, n)];\n  }\n\n  function rescale() {\n    var i = -1;\n    domain = new Array(n);\n    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);\n    return scale;\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (n = (range$$1 = slice$3.call(_)).length - 1, rescale()) : range$$1.slice();\n  };\n\n  scale.invertExtent = function(y) {\n    var i = range$$1.indexOf(y);\n    return i < 0 ? [NaN, NaN]\n        : i < 1 ? [x0, domain[0]]\n        : i >= n ? [domain[n - 1], x1]\n        : [domain[i - 1], domain[i]];\n  };\n\n  scale.copy = function() {\n    return quantize$1()\n        .domain([x0, x1])\n        .range(range$$1);\n  };\n\n  return linearish(scale);\n}\n\nfunction threshold$1() {\n  var domain = [0.5],\n      range$$1 = [0, 1],\n      n = 1;\n\n  function scale(x) {\n    if (x <= x) return range$$1[bisectRight(domain, x, 0, n)];\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = slice$3.call(_), n = Math.min(domain.length, range$$1.length - 1), scale) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range$$1 = slice$3.call(_), n = Math.min(domain.length, range$$1.length - 1), scale) : range$$1.slice();\n  };\n\n  scale.invertExtent = function(y) {\n    var i = range$$1.indexOf(y);\n    return [domain[i - 1], domain[i]];\n  };\n\n  scale.copy = function() {\n    return threshold$1()\n        .domain(domain)\n        .range(range$$1);\n  };\n\n  return scale;\n}\n\nvar durationSecond$1 = 1000;\nvar durationMinute$1 = durationSecond$1 * 60;\nvar durationHour$1 = durationMinute$1 * 60;\nvar durationDay$1 = durationHour$1 * 24;\nvar durationWeek$1 = durationDay$1 * 7;\nvar durationMonth = durationDay$1 * 30;\nvar durationYear = durationDay$1 * 365;\n\nfunction date$1(t) {\n  return new Date(t);\n}\n\nfunction number$2(t) {\n  return t instanceof Date ? +t : +new Date(+t);\n}\n\nfunction calendar(year$$1, month$$1, week, day$$1, hour$$1, minute$$1, second$$1, millisecond$$1, format) {\n  var scale = continuous(deinterpolateLinear, interpolateNumber),\n      invert = scale.invert,\n      domain = scale.domain;\n\n  var formatMillisecond = format(\".%L\"),\n      formatSecond = format(\":%S\"),\n      formatMinute = format(\"%I:%M\"),\n      formatHour = format(\"%I %p\"),\n      formatDay = format(\"%a %d\"),\n      formatWeek = format(\"%b %d\"),\n      formatMonth = format(\"%B\"),\n      formatYear = format(\"%Y\");\n\n  var tickIntervals = [\n    [second$$1,  1,      durationSecond$1],\n    [second$$1,  5,  5 * durationSecond$1],\n    [second$$1, 15, 15 * durationSecond$1],\n    [second$$1, 30, 30 * durationSecond$1],\n    [minute$$1,  1,      durationMinute$1],\n    [minute$$1,  5,  5 * durationMinute$1],\n    [minute$$1, 15, 15 * durationMinute$1],\n    [minute$$1, 30, 30 * durationMinute$1],\n    [  hour$$1,  1,      durationHour$1  ],\n    [  hour$$1,  3,  3 * durationHour$1  ],\n    [  hour$$1,  6,  6 * durationHour$1  ],\n    [  hour$$1, 12, 12 * durationHour$1  ],\n    [   day$$1,  1,      durationDay$1   ],\n    [   day$$1,  2,  2 * durationDay$1   ],\n    [  week,  1,      durationWeek$1  ],\n    [ month$$1,  1,      durationMonth ],\n    [ month$$1,  3,  3 * durationMonth ],\n    [  year$$1,  1,      durationYear  ]\n  ];\n\n  function tickFormat(date) {\n    return (second$$1(date) < date ? formatMillisecond\n        : minute$$1(date) < date ? formatSecond\n        : hour$$1(date) < date ? formatMinute\n        : day$$1(date) < date ? formatHour\n        : month$$1(date) < date ? (week(date) < date ? formatDay : formatWeek)\n        : year$$1(date) < date ? formatMonth\n        : formatYear)(date);\n  }\n\n  function tickInterval(interval, start, stop, step) {\n    if (interval == null) interval = 10;\n\n    // If a desired tick count is specified, pick a reasonable tick interval\n    // based on the extent of the domain and a rough estimate of tick size.\n    // Otherwise, assume interval is already a time interval and use it.\n    if (typeof interval === \"number\") {\n      var target = Math.abs(stop - start) / interval,\n          i = bisector(function(i) { return i[2]; }).right(tickIntervals, target);\n      if (i === tickIntervals.length) {\n        step = tickStep(start / durationYear, stop / durationYear, interval);\n        interval = year$$1;\n      } else if (i) {\n        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];\n        step = i[1];\n        interval = i[0];\n      } else {\n        step = tickStep(start, stop, interval);\n        interval = millisecond$$1;\n      }\n    }\n\n    return step == null ? interval : interval.every(step);\n  }\n\n  scale.invert = function(y) {\n    return new Date(invert(y));\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? domain(map$3.call(_, number$2)) : domain().map(date$1);\n  };\n\n  scale.ticks = function(interval, step) {\n    var d = domain(),\n        t0 = d[0],\n        t1 = d[d.length - 1],\n        r = t1 < t0,\n        t;\n    if (r) t = t0, t0 = t1, t1 = t;\n    t = tickInterval(interval, t0, t1, step);\n    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop\n    return r ? t.reverse() : t;\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    return specifier == null ? tickFormat : format(specifier);\n  };\n\n  scale.nice = function(interval, step) {\n    var d = domain();\n    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))\n        ? domain(nice(d, interval))\n        : scale;\n  };\n\n  scale.copy = function() {\n    return copy(scale, calendar(year$$1, month$$1, week, day$$1, hour$$1, minute$$1, second$$1, millisecond$$1, format));\n  };\n\n  return scale;\n}\n\nvar time = function() {\n  return calendar(year, month, sunday, day, hour, minute, second, millisecond, exports.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);\n};\n\nvar utcTime = function() {\n  return calendar(utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, millisecond, exports.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);\n};\n\nvar colors = function(s) {\n  return s.match(/.{6}/g).map(function(x) {\n    return \"#\" + x;\n  });\n};\n\nvar category10 = colors(\"1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf\");\n\nvar category20b = colors(\"393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6\");\n\nvar category20c = colors(\"3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9\");\n\nvar category20 = colors(\"1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5\");\n\nvar cubehelix$3 = cubehelixLong(cubehelix(300, 0.5, 0.0), cubehelix(-240, 0.5, 1.0));\n\nvar warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));\n\nvar cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));\n\nvar rainbow = cubehelix();\n\nvar rainbow$1 = function(t) {\n  if (t < 0 || t > 1) t -= Math.floor(t);\n  var ts = Math.abs(t - 0.5);\n  rainbow.h = 360 * t - 100;\n  rainbow.s = 1.5 - 1.5 * ts;\n  rainbow.l = 0.8 - 0.9 * ts;\n  return rainbow + \"\";\n};\n\nfunction ramp(range) {\n  var n = range.length;\n  return function(t) {\n    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];\n  };\n}\n\nvar viridis = ramp(colors(\"44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725\"));\n\nvar magma = ramp(colors(\"00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf\"));\n\nvar inferno = ramp(colors(\"00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4\"));\n\nvar plasma = ramp(colors(\"0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921\"));\n\nfunction sequential(interpolator) {\n  var x0 = 0,\n      x1 = 1,\n      clamp = false;\n\n  function scale(x) {\n    var t = (x - x0) / (x1 - x0);\n    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale) : clamp;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.copy = function() {\n    return sequential(interpolator).domain([x0, x1]).clamp(clamp);\n  };\n\n  return linearish(scale);\n}\n\nvar xhtml = \"http://www.w3.org/1999/xhtml\";\n\nvar namespaces = {\n  svg: \"http://www.w3.org/2000/svg\",\n  xhtml: xhtml,\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\",\n  xmlns: \"http://www.w3.org/2000/xmlns/\"\n};\n\nvar namespace = function(name) {\n  var prefix = name += \"\", i = prefix.indexOf(\":\");\n  if (i >= 0 && (prefix = name.slice(0, i)) !== \"xmlns\") name = name.slice(i + 1);\n  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;\n};\n\nfunction creatorInherit(name) {\n  return function() {\n    var document = this.ownerDocument,\n        uri = this.namespaceURI;\n    return uri === xhtml && document.documentElement.namespaceURI === xhtml\n        ? document.createElement(name)\n        : document.createElementNS(uri, name);\n  };\n}\n\nfunction creatorFixed(fullname) {\n  return function() {\n    return this.ownerDocument.createElementNS(fullname.space, fullname.local);\n  };\n}\n\nvar creator = function(name) {\n  var fullname = namespace(name);\n  return (fullname.local\n      ? creatorFixed\n      : creatorInherit)(fullname);\n};\n\nvar nextId = 0;\n\nfunction local() {\n  return new Local;\n}\n\nfunction Local() {\n  this._ = \"@\" + (++nextId).toString(36);\n}\n\nLocal.prototype = local.prototype = {\n  constructor: Local,\n  get: function(node) {\n    var id = this._;\n    while (!(id in node)) if (!(node = node.parentNode)) return;\n    return node[id];\n  },\n  set: function(node, value) {\n    return node[this._] = value;\n  },\n  remove: function(node) {\n    return this._ in node && delete node[this._];\n  },\n  toString: function() {\n    return this._;\n  }\n};\n\nvar matcher = function(selector) {\n  return function() {\n    return this.matches(selector);\n  };\n};\n\nif (typeof document !== \"undefined\") {\n  var element = document.documentElement;\n  if (!element.matches) {\n    var vendorMatches = element.webkitMatchesSelector\n        || element.msMatchesSelector\n        || element.mozMatchesSelector\n        || element.oMatchesSelector;\n    matcher = function(selector) {\n      return function() {\n        return vendorMatches.call(this, selector);\n      };\n    };\n  }\n}\n\nvar matcher$1 = matcher;\n\nvar filterEvents = {};\n\nexports.event = null;\n\nif (typeof document !== \"undefined\") {\n  var element$1 = document.documentElement;\n  if (!(\"onmouseenter\" in element$1)) {\n    filterEvents = {mouseenter: \"mouseover\", mouseleave: \"mouseout\"};\n  }\n}\n\nfunction filterContextListener(listener, index, group) {\n  listener = contextListener(listener, index, group);\n  return function(event) {\n    var related = event.relatedTarget;\n    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {\n      listener.call(this, event);\n    }\n  };\n}\n\nfunction contextListener(listener, index, group) {\n  return function(event1) {\n    var event0 = exports.event; // Events can be reentrant (e.g., focus).\n    exports.event = event1;\n    try {\n      listener.call(this, this.__data__, index, group);\n    } finally {\n      exports.event = event0;\n    }\n  };\n}\n\nfunction parseTypenames$1(typenames) {\n  return typenames.trim().split(/^|\\s+/).map(function(t) {\n    var name = \"\", i = t.indexOf(\".\");\n    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n    return {type: t, name: name};\n  });\n}\n\nfunction onRemove(typename) {\n  return function() {\n    var on = this.__on;\n    if (!on) return;\n    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {\n      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {\n        this.removeEventListener(o.type, o.listener, o.capture);\n      } else {\n        on[++i] = o;\n      }\n    }\n    if (++i) on.length = i;\n    else delete this.__on;\n  };\n}\n\nfunction onAdd(typename, value, capture) {\n  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;\n  return function(d, i, group) {\n    var on = this.__on, o, listener = wrap(value, i, group);\n    if (on) for (var j = 0, m = on.length; j < m; ++j) {\n      if ((o = on[j]).type === typename.type && o.name === typename.name) {\n        this.removeEventListener(o.type, o.listener, o.capture);\n        this.addEventListener(o.type, o.listener = listener, o.capture = capture);\n        o.value = value;\n        return;\n      }\n    }\n    this.addEventListener(typename.type, listener, capture);\n    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};\n    if (!on) this.__on = [o];\n    else on.push(o);\n  };\n}\n\nvar selection_on = function(typename, value, capture) {\n  var typenames = parseTypenames$1(typename + \"\"), i, n = typenames.length, t;\n\n  if (arguments.length < 2) {\n    var on = this.node().__on;\n    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {\n      for (i = 0, o = on[j]; i < n; ++i) {\n        if ((t = typenames[i]).type === o.type && t.name === o.name) {\n          return o.value;\n        }\n      }\n    }\n    return;\n  }\n\n  on = value ? onAdd : onRemove;\n  if (capture == null) capture = false;\n  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));\n  return this;\n};\n\nfunction customEvent(event1, listener, that, args) {\n  var event0 = exports.event;\n  event1.sourceEvent = exports.event;\n  exports.event = event1;\n  try {\n    return listener.apply(that, args);\n  } finally {\n    exports.event = event0;\n  }\n}\n\nvar sourceEvent = function() {\n  var current = exports.event, source;\n  while (source = current.sourceEvent) current = source;\n  return current;\n};\n\nvar point$5 = function(node, event) {\n  var svg = node.ownerSVGElement || node;\n\n  if (svg.createSVGPoint) {\n    var point = svg.createSVGPoint();\n    point.x = event.clientX, point.y = event.clientY;\n    point = point.matrixTransform(node.getScreenCTM().inverse());\n    return [point.x, point.y];\n  }\n\n  var rect = node.getBoundingClientRect();\n  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];\n};\n\nvar mouse = function(node) {\n  var event = sourceEvent();\n  if (event.changedTouches) event = event.changedTouches[0];\n  return point$5(node, event);\n};\n\nfunction none$2() {}\n\nvar selector = function(selector) {\n  return selector == null ? none$2 : function() {\n    return this.querySelector(selector);\n  };\n};\n\nvar selection_select = function(select) {\n  if (typeof select !== \"function\") select = selector(select);\n\n  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {\n      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {\n        if (\"__data__\" in node) subnode.__data__ = node.__data__;\n        subgroup[i] = subnode;\n      }\n    }\n  }\n\n  return new Selection(subgroups, this._parents);\n};\n\nfunction empty() {\n  return [];\n}\n\nvar selectorAll = function(selector) {\n  return selector == null ? empty : function() {\n    return this.querySelectorAll(selector);\n  };\n};\n\nvar selection_selectAll = function(select) {\n  if (typeof select !== \"function\") select = selectorAll(select);\n\n  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        subgroups.push(select.call(node, node.__data__, i, group));\n        parents.push(node);\n      }\n    }\n  }\n\n  return new Selection(subgroups, parents);\n};\n\nvar selection_filter = function(match) {\n  if (typeof match !== \"function\") match = matcher$1(match);\n\n  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {\n      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return new Selection(subgroups, this._parents);\n};\n\nvar sparse = function(update) {\n  return new Array(update.length);\n};\n\nvar selection_enter = function() {\n  return new Selection(this._enter || this._groups.map(sparse), this._parents);\n};\n\nfunction EnterNode(parent, datum) {\n  this.ownerDocument = parent.ownerDocument;\n  this.namespaceURI = parent.namespaceURI;\n  this._next = null;\n  this._parent = parent;\n  this.__data__ = datum;\n}\n\nEnterNode.prototype = {\n  constructor: EnterNode,\n  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },\n  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },\n  querySelector: function(selector) { return this._parent.querySelector(selector); },\n  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }\n};\n\nvar constant$5 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nvar keyPrefix = \"$\"; // Protect against keys like “__proto__”.\n\nfunction bindIndex(parent, group, enter, update, exit, data) {\n  var i = 0,\n      node,\n      groupLength = group.length,\n      dataLength = data.length;\n\n  // Put any non-null nodes that fit into update.\n  // Put any null nodes into enter.\n  // Put any remaining data into enter.\n  for (; i < dataLength; ++i) {\n    if (node = group[i]) {\n      node.__data__ = data[i];\n      update[i] = node;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Put any non-null nodes that don’t fit into exit.\n  for (; i < groupLength; ++i) {\n    if (node = group[i]) {\n      exit[i] = node;\n    }\n  }\n}\n\nfunction bindKey(parent, group, enter, update, exit, data, key) {\n  var i,\n      node,\n      nodeByKeyValue = {},\n      groupLength = group.length,\n      dataLength = data.length,\n      keyValues = new Array(groupLength),\n      keyValue;\n\n  // Compute the key for each node.\n  // If multiple nodes have the same key, the duplicates are added to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if (node = group[i]) {\n      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);\n      if (keyValue in nodeByKeyValue) {\n        exit[i] = node;\n      } else {\n        nodeByKeyValue[keyValue] = node;\n      }\n    }\n  }\n\n  // Compute the key for each datum.\n  // If there a node associated with this key, join and add it to update.\n  // If there is not (or the key is a duplicate), add it to enter.\n  for (i = 0; i < dataLength; ++i) {\n    keyValue = keyPrefix + key.call(parent, data[i], i, data);\n    if (node = nodeByKeyValue[keyValue]) {\n      update[i] = node;\n      node.__data__ = data[i];\n      nodeByKeyValue[keyValue] = null;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Add any remaining nodes that were not bound to data to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {\n      exit[i] = node;\n    }\n  }\n}\n\nvar selection_data = function(value, key) {\n  if (!value) {\n    data = new Array(this.size()), j = -1;\n    this.each(function(d) { data[++j] = d; });\n    return data;\n  }\n\n  var bind = key ? bindKey : bindIndex,\n      parents = this._parents,\n      groups = this._groups;\n\n  if (typeof value !== \"function\") value = constant$5(value);\n\n  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {\n    var parent = parents[j],\n        group = groups[j],\n        groupLength = group.length,\n        data = value.call(parent, parent && parent.__data__, j, parents),\n        dataLength = data.length,\n        enterGroup = enter[j] = new Array(dataLength),\n        updateGroup = update[j] = new Array(dataLength),\n        exitGroup = exit[j] = new Array(groupLength);\n\n    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);\n\n    // Now connect the enter nodes to their following update node, such that\n    // appendChild can insert the materialized enter node before this node,\n    // rather than at the end of the parent node.\n    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {\n      if (previous = enterGroup[i0]) {\n        if (i0 >= i1) i1 = i0 + 1;\n        while (!(next = updateGroup[i1]) && ++i1 < dataLength);\n        previous._next = next || null;\n      }\n    }\n  }\n\n  update = new Selection(update, parents);\n  update._enter = enter;\n  update._exit = exit;\n  return update;\n};\n\nvar selection_exit = function() {\n  return new Selection(this._exit || this._groups.map(sparse), this._parents);\n};\n\nvar selection_merge = function(selection) {\n\n  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {\n    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group0[i] || group1[i]) {\n        merge[i] = node;\n      }\n    }\n  }\n\n  for (; j < m0; ++j) {\n    merges[j] = groups0[j];\n  }\n\n  return new Selection(merges, this._parents);\n};\n\nvar selection_order = function() {\n\n  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {\n    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n      if (node = group[i]) {\n        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n        next = node;\n      }\n    }\n  }\n\n  return this;\n};\n\nvar selection_sort = function(compare) {\n  if (!compare) compare = ascending$2;\n\n  function compareNode(a, b) {\n    return a && b ? compare(a.__data__, b.__data__) : !a - !b;\n  }\n\n  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        sortgroup[i] = node;\n      }\n    }\n    sortgroup.sort(compareNode);\n  }\n\n  return new Selection(sortgroups, this._parents).order();\n};\n\nfunction ascending$2(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n\nvar selection_call = function() {\n  var callback = arguments[0];\n  arguments[0] = this;\n  callback.apply(null, arguments);\n  return this;\n};\n\nvar selection_nodes = function() {\n  var nodes = new Array(this.size()), i = -1;\n  this.each(function() { nodes[++i] = this; });\n  return nodes;\n};\n\nvar selection_node = function() {\n\n  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {\n    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {\n      var node = group[i];\n      if (node) return node;\n    }\n  }\n\n  return null;\n};\n\nvar selection_size = function() {\n  var size = 0;\n  this.each(function() { ++size; });\n  return size;\n};\n\nvar selection_empty = function() {\n  return !this.node();\n};\n\nvar selection_each = function(callback) {\n\n  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {\n    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {\n      if (node = group[i]) callback.call(node, node.__data__, i, group);\n    }\n  }\n\n  return this;\n};\n\nfunction attrRemove(name) {\n  return function() {\n    this.removeAttribute(name);\n  };\n}\n\nfunction attrRemoveNS(fullname) {\n  return function() {\n    this.removeAttributeNS(fullname.space, fullname.local);\n  };\n}\n\nfunction attrConstant(name, value) {\n  return function() {\n    this.setAttribute(name, value);\n  };\n}\n\nfunction attrConstantNS(fullname, value) {\n  return function() {\n    this.setAttributeNS(fullname.space, fullname.local, value);\n  };\n}\n\nfunction attrFunction(name, value) {\n  return function() {\n    var v = value.apply(this, arguments);\n    if (v == null) this.removeAttribute(name);\n    else this.setAttribute(name, v);\n  };\n}\n\nfunction attrFunctionNS(fullname, value) {\n  return function() {\n    var v = value.apply(this, arguments);\n    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);\n    else this.setAttributeNS(fullname.space, fullname.local, v);\n  };\n}\n\nvar selection_attr = function(name, value) {\n  var fullname = namespace(name);\n\n  if (arguments.length < 2) {\n    var node = this.node();\n    return fullname.local\n        ? node.getAttributeNS(fullname.space, fullname.local)\n        : node.getAttribute(fullname);\n  }\n\n  return this.each((value == null\n      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === \"function\"\n      ? (fullname.local ? attrFunctionNS : attrFunction)\n      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));\n};\n\nvar window = function(node) {\n  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node\n      || (node.document && node) // node is a Window\n      || node.defaultView; // node is a Document\n};\n\nfunction styleRemove(name) {\n  return function() {\n    this.style.removeProperty(name);\n  };\n}\n\nfunction styleConstant(name, value, priority) {\n  return function() {\n    this.style.setProperty(name, value, priority);\n  };\n}\n\nfunction styleFunction(name, value, priority) {\n  return function() {\n    var v = value.apply(this, arguments);\n    if (v == null) this.style.removeProperty(name);\n    else this.style.setProperty(name, v, priority);\n  };\n}\n\nvar selection_style = function(name, value, priority) {\n  var node;\n  return arguments.length > 1\n      ? this.each((value == null\n            ? styleRemove : typeof value === \"function\"\n            ? styleFunction\n            : styleConstant)(name, value, priority == null ? \"\" : priority))\n      : window(node = this.node())\n          .getComputedStyle(node, null)\n          .getPropertyValue(name);\n};\n\nfunction propertyRemove(name) {\n  return function() {\n    delete this[name];\n  };\n}\n\nfunction propertyConstant(name, value) {\n  return function() {\n    this[name] = value;\n  };\n}\n\nfunction propertyFunction(name, value) {\n  return function() {\n    var v = value.apply(this, arguments);\n    if (v == null) delete this[name];\n    else this[name] = v;\n  };\n}\n\nvar selection_property = function(name, value) {\n  return arguments.length > 1\n      ? this.each((value == null\n          ? propertyRemove : typeof value === \"function\"\n          ? propertyFunction\n          : propertyConstant)(name, value))\n      : this.node()[name];\n};\n\nfunction classArray(string) {\n  return string.trim().split(/^|\\s+/);\n}\n\nfunction classList(node) {\n  return node.classList || new ClassList(node);\n}\n\nfunction ClassList(node) {\n  this._node = node;\n  this._names = classArray(node.getAttribute(\"class\") || \"\");\n}\n\nClassList.prototype = {\n  add: function(name) {\n    var i = this._names.indexOf(name);\n    if (i < 0) {\n      this._names.push(name);\n      this._node.setAttribute(\"class\", this._names.join(\" \"));\n    }\n  },\n  remove: function(name) {\n    var i = this._names.indexOf(name);\n    if (i >= 0) {\n      this._names.splice(i, 1);\n      this._node.setAttribute(\"class\", this._names.join(\" \"));\n    }\n  },\n  contains: function(name) {\n    return this._names.indexOf(name) >= 0;\n  }\n};\n\nfunction classedAdd(node, names) {\n  var list = classList(node), i = -1, n = names.length;\n  while (++i < n) list.add(names[i]);\n}\n\nfunction classedRemove(node, names) {\n  var list = classList(node), i = -1, n = names.length;\n  while (++i < n) list.remove(names[i]);\n}\n\nfunction classedTrue(names) {\n  return function() {\n    classedAdd(this, names);\n  };\n}\n\nfunction classedFalse(names) {\n  return function() {\n    classedRemove(this, names);\n  };\n}\n\nfunction classedFunction(names, value) {\n  return function() {\n    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);\n  };\n}\n\nvar selection_classed = function(name, value) {\n  var names = classArray(name + \"\");\n\n  if (arguments.length < 2) {\n    var list = classList(this.node()), i = -1, n = names.length;\n    while (++i < n) if (!list.contains(names[i])) return false;\n    return true;\n  }\n\n  return this.each((typeof value === \"function\"\n      ? classedFunction : value\n      ? classedTrue\n      : classedFalse)(names, value));\n};\n\nfunction textRemove() {\n  this.textContent = \"\";\n}\n\nfunction textConstant(value) {\n  return function() {\n    this.textContent = value;\n  };\n}\n\nfunction textFunction(value) {\n  return function() {\n    var v = value.apply(this, arguments);\n    this.textContent = v == null ? \"\" : v;\n  };\n}\n\nvar selection_text = function(value) {\n  return arguments.length\n      ? this.each(value == null\n          ? textRemove : (typeof value === \"function\"\n          ? textFunction\n          : textConstant)(value))\n      : this.node().textContent;\n};\n\nfunction htmlRemove() {\n  this.innerHTML = \"\";\n}\n\nfunction htmlConstant(value) {\n  return function() {\n    this.innerHTML = value;\n  };\n}\n\nfunction htmlFunction(value) {\n  return function() {\n    var v = value.apply(this, arguments);\n    this.innerHTML = v == null ? \"\" : v;\n  };\n}\n\nvar selection_html = function(value) {\n  return arguments.length\n      ? this.each(value == null\n          ? htmlRemove : (typeof value === \"function\"\n          ? htmlFunction\n          : htmlConstant)(value))\n      : this.node().innerHTML;\n};\n\nfunction raise$1() {\n  if (this.nextSibling) this.parentNode.appendChild(this);\n}\n\nvar selection_raise = function() {\n  return this.each(raise$1);\n};\n\nfunction lower() {\n  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);\n}\n\nvar selection_lower = function() {\n  return this.each(lower);\n};\n\nvar selection_append = function(name) {\n  var create = typeof name === \"function\" ? name : creator(name);\n  return this.select(function() {\n    return this.appendChild(create.apply(this, arguments));\n  });\n};\n\nfunction constantNull() {\n  return null;\n}\n\nvar selection_insert = function(name, before) {\n  var create = typeof name === \"function\" ? name : creator(name),\n      select = before == null ? constantNull : typeof before === \"function\" ? before : selector(before);\n  return this.select(function() {\n    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);\n  });\n};\n\nfunction remove() {\n  var parent = this.parentNode;\n  if (parent) parent.removeChild(this);\n}\n\nvar selection_remove = function() {\n  return this.each(remove);\n};\n\nvar selection_datum = function(value) {\n  return arguments.length\n      ? this.property(\"__data__\", value)\n      : this.node().__data__;\n};\n\nfunction dispatchEvent(node, type, params) {\n  var window$$1 = window(node),\n      event = window$$1.CustomEvent;\n\n  if (event) {\n    event = new event(type, params);\n  } else {\n    event = window$$1.document.createEvent(\"Event\");\n    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;\n    else event.initEvent(type, false, false);\n  }\n\n  node.dispatchEvent(event);\n}\n\nfunction dispatchConstant(type, params) {\n  return function() {\n    return dispatchEvent(this, type, params);\n  };\n}\n\nfunction dispatchFunction(type, params) {\n  return function() {\n    return dispatchEvent(this, type, params.apply(this, arguments));\n  };\n}\n\nvar selection_dispatch = function(type, params) {\n  return this.each((typeof params === \"function\"\n      ? dispatchFunction\n      : dispatchConstant)(type, params));\n};\n\nvar root = [null];\n\nfunction Selection(groups, parents) {\n  this._groups = groups;\n  this._parents = parents;\n}\n\nfunction selection() {\n  return new Selection([[document.documentElement]], root);\n}\n\nSelection.prototype = selection.prototype = {\n  constructor: Selection,\n  select: selection_select,\n  selectAll: selection_selectAll,\n  filter: selection_filter,\n  data: selection_data,\n  enter: selection_enter,\n  exit: selection_exit,\n  merge: selection_merge,\n  order: selection_order,\n  sort: selection_sort,\n  call: selection_call,\n  nodes: selection_nodes,\n  node: selection_node,\n  size: selection_size,\n  empty: selection_empty,\n  each: selection_each,\n  attr: selection_attr,\n  style: selection_style,\n  property: selection_property,\n  classed: selection_classed,\n  text: selection_text,\n  html: selection_html,\n  raise: selection_raise,\n  lower: selection_lower,\n  append: selection_append,\n  insert: selection_insert,\n  remove: selection_remove,\n  datum: selection_datum,\n  on: selection_on,\n  dispatch: selection_dispatch\n};\n\nvar select = function(selector) {\n  return typeof selector === \"string\"\n      ? new Selection([[document.querySelector(selector)]], [document.documentElement])\n      : new Selection([[selector]], root);\n};\n\nvar selectAll = function(selector) {\n  return typeof selector === \"string\"\n      ? new Selection([document.querySelectorAll(selector)], [document.documentElement])\n      : new Selection([selector == null ? [] : selector], root);\n};\n\nvar touch = function(node, touches, identifier) {\n  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;\n\n  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {\n    if ((touch = touches[i]).identifier === identifier) {\n      return point$5(node, touch);\n    }\n  }\n\n  return null;\n};\n\nvar touches = function(node, touches) {\n  if (touches == null) touches = sourceEvent().touches;\n\n  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {\n    points[i] = point$5(node, touches[i]);\n  }\n\n  return points;\n};\n\nvar emptyOn = dispatch(\"start\", \"end\", \"interrupt\");\nvar emptyTween = [];\n\nvar CREATED = 0;\nvar SCHEDULED = 1;\nvar STARTING = 2;\nvar STARTED = 3;\nvar RUNNING = 4;\nvar ENDING = 5;\nvar ENDED = 6;\n\nvar schedule = function(node, name, id, index, group, timing) {\n  var schedules = node.__transition;\n  if (!schedules) node.__transition = {};\n  else if (id in schedules) return;\n  create(node, id, {\n    name: name,\n    index: index, // For context during callback.\n    group: group, // For context during callback.\n    on: emptyOn,\n    tween: emptyTween,\n    time: timing.time,\n    delay: timing.delay,\n    duration: timing.duration,\n    ease: timing.ease,\n    timer: null,\n    state: CREATED\n  });\n};\n\nfunction init(node, id) {\n  var schedule = node.__transition;\n  if (!schedule || !(schedule = schedule[id]) || schedule.state > CREATED) throw new Error(\"too late\");\n  return schedule;\n}\n\nfunction set$3(node, id) {\n  var schedule = node.__transition;\n  if (!schedule || !(schedule = schedule[id]) || schedule.state > STARTING) throw new Error(\"too late\");\n  return schedule;\n}\n\nfunction get$1(node, id) {\n  var schedule = node.__transition;\n  if (!schedule || !(schedule = schedule[id])) throw new Error(\"too late\");\n  return schedule;\n}\n\nfunction create(node, id, self) {\n  var schedules = node.__transition,\n      tween;\n\n  // Initialize the self timer when the transition is created.\n  // Note the actual delay is not known until the first callback!\n  schedules[id] = self;\n  self.timer = timer(schedule, 0, self.time);\n\n  function schedule(elapsed) {\n    self.state = SCHEDULED;\n    self.timer.restart(start, self.delay, self.time);\n\n    // If the elapsed delay is less than our first sleep, start immediately.\n    if (self.delay <= elapsed) start(elapsed - self.delay);\n  }\n\n  function start(elapsed) {\n    var i, j, n, o;\n\n    // If the state is not SCHEDULED, then we previously errored on start.\n    if (self.state !== SCHEDULED) return stop();\n\n    for (i in schedules) {\n      o = schedules[i];\n      if (o.name !== self.name) continue;\n\n      // While this element already has a starting transition during this frame,\n      // defer starting an interrupting transition until that transition has a\n      // chance to tick (and possibly end); see d3/d3-transition#54!\n      if (o.state === STARTED) return timeout$1(start);\n\n      // Interrupt the active transition, if any.\n      // Dispatch the interrupt event.\n      if (o.state === RUNNING) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call(\"interrupt\", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      }\n\n      // Cancel any pre-empted transitions. No interrupt event is dispatched\n      // because the cancelled transitions never started. Note that this also\n      // removes this transition from the pending list!\n      else if (+i < id) {\n        o.state = ENDED;\n        o.timer.stop();\n        delete schedules[i];\n      }\n    }\n\n    // Defer the first tick to end of the current frame; see d3/d3#1576.\n    // Note the transition may be canceled after start and before the first tick!\n    // Note this must be scheduled before the start event; see d3/d3-transition#16!\n    // Assuming this is successful, subsequent callbacks go straight to tick.\n    timeout$1(function() {\n      if (self.state === STARTED) {\n        self.state = RUNNING;\n        self.timer.restart(tick, self.delay, self.time);\n        tick(elapsed);\n      }\n    });\n\n    // Dispatch the start event.\n    // Note this must be done before the tween are initialized.\n    self.state = STARTING;\n    self.on.call(\"start\", node, node.__data__, self.index, self.group);\n    if (self.state !== STARTING) return; // interrupted\n    self.state = STARTED;\n\n    // Initialize the tween, deleting null tween.\n    tween = new Array(n = self.tween.length);\n    for (i = 0, j = -1; i < n; ++i) {\n      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {\n        tween[++j] = o;\n      }\n    }\n    tween.length = j + 1;\n  }\n\n  function tick(elapsed) {\n    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),\n        i = -1,\n        n = tween.length;\n\n    while (++i < n) {\n      tween[i].call(null, t);\n    }\n\n    // Dispatch the end event.\n    if (self.state === ENDING) {\n      self.on.call(\"end\", node, node.__data__, self.index, self.group);\n      stop();\n    }\n  }\n\n  function stop() {\n    self.state = ENDED;\n    self.timer.stop();\n    delete schedules[id];\n    for (var i in schedules) return; // eslint-disable-line no-unused-vars\n    delete node.__transition;\n  }\n}\n\nvar interrupt = function(node, name) {\n  var schedules = node.__transition,\n      schedule,\n      active,\n      empty = true,\n      i;\n\n  if (!schedules) return;\n\n  name = name == null ? null : name + \"\";\n\n  for (i in schedules) {\n    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }\n    active = schedule.state > STARTING && schedule.state < ENDING;\n    schedule.state = ENDED;\n    schedule.timer.stop();\n    if (active) schedule.on.call(\"interrupt\", node, node.__data__, schedule.index, schedule.group);\n    delete schedules[i];\n  }\n\n  if (empty) delete node.__transition;\n};\n\nvar selection_interrupt = function(name) {\n  return this.each(function() {\n    interrupt(this, name);\n  });\n};\n\nfunction tweenRemove(id, name) {\n  var tween0, tween1;\n  return function() {\n    var schedule = set$3(this, id),\n        tween = schedule.tween;\n\n    // If this node shared tween with the previous node,\n    // just assign the updated shared tween and we’re done!\n    // Otherwise, copy-on-write.\n    if (tween !== tween0) {\n      tween1 = tween0 = tween;\n      for (var i = 0, n = tween1.length; i < n; ++i) {\n        if (tween1[i].name === name) {\n          tween1 = tween1.slice();\n          tween1.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    schedule.tween = tween1;\n  };\n}\n\nfunction tweenFunction(id, name, value) {\n  var tween0, tween1;\n  if (typeof value !== \"function\") throw new Error;\n  return function() {\n    var schedule = set$3(this, id),\n        tween = schedule.tween;\n\n    // If this node shared tween with the previous node,\n    // just assign the updated shared tween and we’re done!\n    // Otherwise, copy-on-write.\n    if (tween !== tween0) {\n      tween1 = (tween0 = tween).slice();\n      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {\n        if (tween1[i].name === name) {\n          tween1[i] = t;\n          break;\n        }\n      }\n      if (i === n) tween1.push(t);\n    }\n\n    schedule.tween = tween1;\n  };\n}\n\nvar transition_tween = function(name, value) {\n  var id = this._id;\n\n  name += \"\";\n\n  if (arguments.length < 2) {\n    var tween = get$1(this.node(), id).tween;\n    for (var i = 0, n = tween.length, t; i < n; ++i) {\n      if ((t = tween[i]).name === name) {\n        return t.value;\n      }\n    }\n    return null;\n  }\n\n  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));\n};\n\nfunction tweenValue(transition, name, value) {\n  var id = transition._id;\n\n  transition.each(function() {\n    var schedule = set$3(this, id);\n    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);\n  });\n\n  return function(node) {\n    return get$1(node, id).value[name];\n  };\n}\n\nvar interpolate$1 = function(a, b) {\n  var c;\n  return (typeof b === \"number\" ? interpolateNumber\n      : b instanceof color ? interpolateRgb\n      : (c = color(b)) ? (b = c, interpolateRgb)\n      : interpolateString)(a, b);\n};\n\nfunction attrRemove$1(name) {\n  return function() {\n    this.removeAttribute(name);\n  };\n}\n\nfunction attrRemoveNS$1(fullname) {\n  return function() {\n    this.removeAttributeNS(fullname.space, fullname.local);\n  };\n}\n\nfunction attrConstant$1(name, interpolate$$1, value1) {\n  var value00,\n      interpolate0;\n  return function() {\n    var value0 = this.getAttribute(name);\n    return value0 === value1 ? null\n        : value0 === value00 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value1);\n  };\n}\n\nfunction attrConstantNS$1(fullname, interpolate$$1, value1) {\n  var value00,\n      interpolate0;\n  return function() {\n    var value0 = this.getAttributeNS(fullname.space, fullname.local);\n    return value0 === value1 ? null\n        : value0 === value00 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value1);\n  };\n}\n\nfunction attrFunction$1(name, interpolate$$1, value) {\n  var value00,\n      value10,\n      interpolate0;\n  return function() {\n    var value0, value1 = value(this);\n    if (value1 == null) return void this.removeAttribute(name);\n    value0 = this.getAttribute(name);\n    return value0 === value1 ? null\n        : value0 === value00 && value1 === value10 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n  };\n}\n\nfunction attrFunctionNS$1(fullname, interpolate$$1, value) {\n  var value00,\n      value10,\n      interpolate0;\n  return function() {\n    var value0, value1 = value(this);\n    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);\n    value0 = this.getAttributeNS(fullname.space, fullname.local);\n    return value0 === value1 ? null\n        : value0 === value00 && value1 === value10 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n  };\n}\n\nvar transition_attr = function(name, value) {\n  var fullname = namespace(name), i = fullname === \"transform\" ? interpolateTransformSvg : interpolate$1;\n  return this.attrTween(name, typeof value === \"function\"\n      ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, \"attr.\" + name, value))\n      : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname)\n      : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value));\n};\n\nfunction attrTweenNS(fullname, value) {\n  function tween() {\n    var node = this, i = value.apply(node, arguments);\n    return i && function(t) {\n      node.setAttributeNS(fullname.space, fullname.local, i(t));\n    };\n  }\n  tween._value = value;\n  return tween;\n}\n\nfunction attrTween(name, value) {\n  function tween() {\n    var node = this, i = value.apply(node, arguments);\n    return i && function(t) {\n      node.setAttribute(name, i(t));\n    };\n  }\n  tween._value = value;\n  return tween;\n}\n\nvar transition_attrTween = function(name, value) {\n  var key = \"attr.\" + name;\n  if (arguments.length < 2) return (key = this.tween(key)) && key._value;\n  if (value == null) return this.tween(key, null);\n  if (typeof value !== \"function\") throw new Error;\n  var fullname = namespace(name);\n  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));\n};\n\nfunction delayFunction(id, value) {\n  return function() {\n    init(this, id).delay = +value.apply(this, arguments);\n  };\n}\n\nfunction delayConstant(id, value) {\n  return value = +value, function() {\n    init(this, id).delay = value;\n  };\n}\n\nvar transition_delay = function(value) {\n  var id = this._id;\n\n  return arguments.length\n      ? this.each((typeof value === \"function\"\n          ? delayFunction\n          : delayConstant)(id, value))\n      : get$1(this.node(), id).delay;\n};\n\nfunction durationFunction(id, value) {\n  return function() {\n    set$3(this, id).duration = +value.apply(this, arguments);\n  };\n}\n\nfunction durationConstant(id, value) {\n  return value = +value, function() {\n    set$3(this, id).duration = value;\n  };\n}\n\nvar transition_duration = function(value) {\n  var id = this._id;\n\n  return arguments.length\n      ? this.each((typeof value === \"function\"\n          ? durationFunction\n          : durationConstant)(id, value))\n      : get$1(this.node(), id).duration;\n};\n\nfunction easeConstant(id, value) {\n  if (typeof value !== \"function\") throw new Error;\n  return function() {\n    set$3(this, id).ease = value;\n  };\n}\n\nvar transition_ease = function(value) {\n  var id = this._id;\n\n  return arguments.length\n      ? this.each(easeConstant(id, value))\n      : get$1(this.node(), id).ease;\n};\n\nvar transition_filter = function(match) {\n  if (typeof match !== \"function\") match = matcher$1(match);\n\n  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {\n      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {\n        subgroup.push(node);\n      }\n    }\n  }\n\n  return new Transition(subgroups, this._parents, this._name, this._id);\n};\n\nvar transition_merge = function(transition) {\n  if (transition._id !== this._id) throw new Error;\n\n  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {\n    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {\n      if (node = group0[i] || group1[i]) {\n        merge[i] = node;\n      }\n    }\n  }\n\n  for (; j < m0; ++j) {\n    merges[j] = groups0[j];\n  }\n\n  return new Transition(merges, this._parents, this._name, this._id);\n};\n\nfunction start$1(name) {\n  return (name + \"\").trim().split(/^|\\s+/).every(function(t) {\n    var i = t.indexOf(\".\");\n    if (i >= 0) t = t.slice(0, i);\n    return !t || t === \"start\";\n  });\n}\n\nfunction onFunction(id, name, listener) {\n  var on0, on1, sit = start$1(name) ? init : set$3;\n  return function() {\n    var schedule = sit(this, id),\n        on = schedule.on;\n\n    // If this node shared a dispatch with the previous node,\n    // just assign the updated shared dispatch and we’re done!\n    // Otherwise, copy-on-write.\n    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);\n\n    schedule.on = on1;\n  };\n}\n\nvar transition_on = function(name, listener) {\n  var id = this._id;\n\n  return arguments.length < 2\n      ? get$1(this.node(), id).on.on(name)\n      : this.each(onFunction(id, name, listener));\n};\n\nfunction removeFunction(id) {\n  return function() {\n    var parent = this.parentNode;\n    for (var i in this.__transition) if (+i !== id) return;\n    if (parent) parent.removeChild(this);\n  };\n}\n\nvar transition_remove = function() {\n  return this.on(\"end.remove\", removeFunction(this._id));\n};\n\nvar transition_select = function(select$$1) {\n  var name = this._name,\n      id = this._id;\n\n  if (typeof select$$1 !== \"function\") select$$1 = selector(select$$1);\n\n  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {\n      if ((node = group[i]) && (subnode = select$$1.call(node, node.__data__, i, group))) {\n        if (\"__data__\" in node) subnode.__data__ = node.__data__;\n        subgroup[i] = subnode;\n        schedule(subgroup[i], name, id, i, subgroup, get$1(node, id));\n      }\n    }\n  }\n\n  return new Transition(subgroups, this._parents, name, id);\n};\n\nvar transition_selectAll = function(select$$1) {\n  var name = this._name,\n      id = this._id;\n\n  if (typeof select$$1 !== \"function\") select$$1 = selectorAll(select$$1);\n\n  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        for (var children = select$$1.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k < l; ++k) {\n          if (child = children[k]) {\n            schedule(child, name, id, k, children, inherit);\n          }\n        }\n        subgroups.push(children);\n        parents.push(node);\n      }\n    }\n  }\n\n  return new Transition(subgroups, parents, name, id);\n};\n\nvar Selection$1 = selection.prototype.constructor;\n\nvar transition_selection = function() {\n  return new Selection$1(this._groups, this._parents);\n};\n\nfunction styleRemove$1(name, interpolate$$1) {\n  var value00,\n      value10,\n      interpolate0;\n  return function() {\n    var style = window(this).getComputedStyle(this, null),\n        value0 = style.getPropertyValue(name),\n        value1 = (this.style.removeProperty(name), style.getPropertyValue(name));\n    return value0 === value1 ? null\n        : value0 === value00 && value1 === value10 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n  };\n}\n\nfunction styleRemoveEnd(name) {\n  return function() {\n    this.style.removeProperty(name);\n  };\n}\n\nfunction styleConstant$1(name, interpolate$$1, value1) {\n  var value00,\n      interpolate0;\n  return function() {\n    var value0 = window(this).getComputedStyle(this, null).getPropertyValue(name);\n    return value0 === value1 ? null\n        : value0 === value00 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value1);\n  };\n}\n\nfunction styleFunction$1(name, interpolate$$1, value) {\n  var value00,\n      value10,\n      interpolate0;\n  return function() {\n    var style = window(this).getComputedStyle(this, null),\n        value0 = style.getPropertyValue(name),\n        value1 = value(this);\n    if (value1 == null) value1 = (this.style.removeProperty(name), style.getPropertyValue(name));\n    return value0 === value1 ? null\n        : value0 === value00 && value1 === value10 ? interpolate0\n        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);\n  };\n}\n\nvar transition_style = function(name, value, priority) {\n  var i = (name += \"\") === \"transform\" ? interpolateTransformCss : interpolate$1;\n  return value == null ? this\n          .styleTween(name, styleRemove$1(name, i))\n          .on(\"end.style.\" + name, styleRemoveEnd(name))\n      : this.styleTween(name, typeof value === \"function\"\n          ? styleFunction$1(name, i, tweenValue(this, \"style.\" + name, value))\n          : styleConstant$1(name, i, value), priority);\n};\n\nfunction styleTween(name, value, priority) {\n  function tween() {\n    var node = this, i = value.apply(node, arguments);\n    return i && function(t) {\n      node.style.setProperty(name, i(t), priority);\n    };\n  }\n  tween._value = value;\n  return tween;\n}\n\nvar transition_styleTween = function(name, value, priority) {\n  var key = \"style.\" + (name += \"\");\n  if (arguments.length < 2) return (key = this.tween(key)) && key._value;\n  if (value == null) return this.tween(key, null);\n  if (typeof value !== \"function\") throw new Error;\n  return this.tween(key, styleTween(name, value, priority == null ? \"\" : priority));\n};\n\nfunction textConstant$1(value) {\n  return function() {\n    this.textContent = value;\n  };\n}\n\nfunction textFunction$1(value) {\n  return function() {\n    var value1 = value(this);\n    this.textContent = value1 == null ? \"\" : value1;\n  };\n}\n\nvar transition_text = function(value) {\n  return this.tween(\"text\", typeof value === \"function\"\n      ? textFunction$1(tweenValue(this, \"text\", value))\n      : textConstant$1(value == null ? \"\" : value + \"\"));\n};\n\nvar transition_transition = function() {\n  var name = this._name,\n      id0 = this._id,\n      id1 = newId();\n\n  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        var inherit = get$1(node, id0);\n        schedule(node, name, id1, i, group, {\n          time: inherit.time + inherit.delay + inherit.duration,\n          delay: 0,\n          duration: inherit.duration,\n          ease: inherit.ease\n        });\n      }\n    }\n  }\n\n  return new Transition(groups, this._parents, name, id1);\n};\n\nvar id = 0;\n\nfunction Transition(groups, parents, name, id) {\n  this._groups = groups;\n  this._parents = parents;\n  this._name = name;\n  this._id = id;\n}\n\nfunction transition(name) {\n  return selection().transition(name);\n}\n\nfunction newId() {\n  return ++id;\n}\n\nvar selection_prototype = selection.prototype;\n\nTransition.prototype = transition.prototype = {\n  constructor: Transition,\n  select: transition_select,\n  selectAll: transition_selectAll,\n  filter: transition_filter,\n  merge: transition_merge,\n  selection: transition_selection,\n  transition: transition_transition,\n  call: selection_prototype.call,\n  nodes: selection_prototype.nodes,\n  node: selection_prototype.node,\n  size: selection_prototype.size,\n  empty: selection_prototype.empty,\n  each: selection_prototype.each,\n  on: transition_on,\n  attr: transition_attr,\n  attrTween: transition_attrTween,\n  style: transition_style,\n  styleTween: transition_styleTween,\n  text: transition_text,\n  remove: transition_remove,\n  tween: transition_tween,\n  delay: transition_delay,\n  duration: transition_duration,\n  ease: transition_ease\n};\n\nvar defaultTiming = {\n  time: null, // Set on use.\n  delay: 0,\n  duration: 250,\n  ease: cubicInOut\n};\n\nfunction inherit(node, id) {\n  var timing;\n  while (!(timing = node.__transition) || !(timing = timing[id])) {\n    if (!(node = node.parentNode)) {\n      return defaultTiming.time = now(), defaultTiming;\n    }\n  }\n  return timing;\n}\n\nvar selection_transition = function(name) {\n  var id,\n      timing;\n\n  if (name instanceof Transition) {\n    id = name._id, name = name._name;\n  } else {\n    id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + \"\";\n  }\n\n  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {\n    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {\n      if (node = group[i]) {\n        schedule(node, name, id, i, group, timing || inherit(node, id));\n      }\n    }\n  }\n\n  return new Transition(groups, this._parents, name, id);\n};\n\nselection.prototype.interrupt = selection_interrupt;\nselection.prototype.transition = selection_transition;\n\nvar root$1 = [null];\n\nvar active = function(node, name) {\n  var schedules = node.__transition,\n      schedule,\n      i;\n\n  if (schedules) {\n    name = name == null ? null : name + \"\";\n    for (i in schedules) {\n      if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {\n        return new Transition([[node]], root$1, name, +i);\n      }\n    }\n  }\n\n  return null;\n};\n\nvar slice$4 = Array.prototype.slice;\n\nvar identity$5 = function(x) {\n  return x;\n};\n\nvar top = 1;\nvar right = 2;\nvar bottom = 3;\nvar left = 4;\nvar epsilon$2 = 1e-6;\n\nfunction translateX(scale0, scale1, d) {\n  var x = scale0(d);\n  return \"translate(\" + (isFinite(x) ? x : scale1(d)) + \",0)\";\n}\n\nfunction translateY(scale0, scale1, d) {\n  var y = scale0(d);\n  return \"translate(0,\" + (isFinite(y) ? y : scale1(d)) + \")\";\n}\n\nfunction center(scale) {\n  var offset = scale.bandwidth() / 2;\n  if (scale.round()) offset = Math.round(offset);\n  return function(d) {\n    return scale(d) + offset;\n  };\n}\n\nfunction entering() {\n  return !this.__axis;\n}\n\nfunction axis(orient, scale) {\n  var tickArguments = [],\n      tickValues = null,\n      tickFormat = null,\n      tickSizeInner = 6,\n      tickSizeOuter = 6,\n      tickPadding = 3;\n\n  function axis(context) {\n    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,\n        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$5) : tickFormat,\n        spacing = Math.max(tickSizeInner, 0) + tickPadding,\n        transform = orient === top || orient === bottom ? translateX : translateY,\n        range = scale.range(),\n        range0 = range[0] + 0.5,\n        range1 = range[range.length - 1] + 0.5,\n        position = (scale.bandwidth ? center : identity$5)(scale.copy()),\n        selection = context.selection ? context.selection() : context,\n        path = selection.selectAll(\".domain\").data([null]),\n        tick = selection.selectAll(\".tick\").data(values, scale).order(),\n        tickExit = tick.exit(),\n        tickEnter = tick.enter().append(\"g\").attr(\"class\", \"tick\"),\n        line = tick.select(\"line\"),\n        text = tick.select(\"text\"),\n        k = orient === top || orient === left ? -1 : 1,\n        x, y = orient === left || orient === right ? (x = \"x\", \"y\") : (x = \"y\", \"x\");\n\n    path = path.merge(path.enter().insert(\"path\", \".tick\")\n        .attr(\"class\", \"domain\")\n        .attr(\"stroke\", \"#000\"));\n\n    tick = tick.merge(tickEnter);\n\n    line = line.merge(tickEnter.append(\"line\")\n        .attr(\"stroke\", \"#000\")\n        .attr(x + \"2\", k * tickSizeInner)\n        .attr(y + \"1\", 0.5)\n        .attr(y + \"2\", 0.5));\n\n    text = text.merge(tickEnter.append(\"text\")\n        .attr(\"fill\", \"#000\")\n        .attr(x, k * spacing)\n        .attr(y, 0.5)\n        .attr(\"dy\", orient === top ? \"0em\" : orient === bottom ? \"0.71em\" : \"0.32em\"));\n\n    if (context !== selection) {\n      path = path.transition(context);\n      tick = tick.transition(context);\n      line = line.transition(context);\n      text = text.transition(context);\n\n      tickExit = tickExit.transition(context)\n          .attr(\"opacity\", epsilon$2)\n          .attr(\"transform\", function(d) { return transform(position, this.parentNode.__axis || position, d); });\n\n      tickEnter\n          .attr(\"opacity\", epsilon$2)\n          .attr(\"transform\", function(d) { return transform(this.parentNode.__axis || position, position, d); });\n    }\n\n    tickExit.remove();\n\n    path\n        .attr(\"d\", orient === left || orient == right\n            ? \"M\" + k * tickSizeOuter + \",\" + range0 + \"H0.5V\" + range1 + \"H\" + k * tickSizeOuter\n            : \"M\" + range0 + \",\" + k * tickSizeOuter + \"V0.5H\" + range1 + \"V\" + k * tickSizeOuter);\n\n    tick\n        .attr(\"opacity\", 1)\n        .attr(\"transform\", function(d) { return transform(position, position, d); });\n\n    line\n        .attr(x + \"2\", k * tickSizeInner);\n\n    text\n        .attr(x, k * spacing)\n        .text(format);\n\n    selection.filter(entering)\n        .attr(\"fill\", \"none\")\n        .attr(\"font-size\", 10)\n        .attr(\"font-family\", \"sans-serif\")\n        .attr(\"text-anchor\", orient === right ? \"start\" : orient === left ? \"end\" : \"middle\");\n\n    selection\n        .each(function() { this.__axis = position; });\n  }\n\n  axis.scale = function(_) {\n    return arguments.length ? (scale = _, axis) : scale;\n  };\n\n  axis.ticks = function() {\n    return tickArguments = slice$4.call(arguments), axis;\n  };\n\n  axis.tickArguments = function(_) {\n    return arguments.length ? (tickArguments = _ == null ? [] : slice$4.call(_), axis) : tickArguments.slice();\n  };\n\n  axis.tickValues = function(_) {\n    return arguments.length ? (tickValues = _ == null ? null : slice$4.call(_), axis) : tickValues && tickValues.slice();\n  };\n\n  axis.tickFormat = function(_) {\n    return arguments.length ? (tickFormat = _, axis) : tickFormat;\n  };\n\n  axis.tickSize = function(_) {\n    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;\n  };\n\n  axis.tickSizeInner = function(_) {\n    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;\n  };\n\n  axis.tickSizeOuter = function(_) {\n    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;\n  };\n\n  axis.tickPadding = function(_) {\n    return arguments.length ? (tickPadding = +_, axis) : tickPadding;\n  };\n\n  return axis;\n}\n\nfunction axisTop(scale) {\n  return axis(top, scale);\n}\n\nfunction axisRight(scale) {\n  return axis(right, scale);\n}\n\nfunction axisBottom(scale) {\n  return axis(bottom, scale);\n}\n\nfunction axisLeft(scale) {\n  return axis(left, scale);\n}\n\nfunction defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n}\n\nfunction meanX(children) {\n  return children.reduce(meanXReduce, 0) / children.length;\n}\n\nfunction meanXReduce(x, c) {\n  return x + c.x;\n}\n\nfunction maxY(children) {\n  return 1 + children.reduce(maxYReduce, 0);\n}\n\nfunction maxYReduce(y, c) {\n  return Math.max(y, c.y);\n}\n\nfunction leafLeft(node) {\n  var children;\n  while (children = node.children) node = children[0];\n  return node;\n}\n\nfunction leafRight(node) {\n  var children;\n  while (children = node.children) node = children[children.length - 1];\n  return node;\n}\n\nvar cluster = function() {\n  var separation = defaultSeparation,\n      dx = 1,\n      dy = 1,\n      nodeSize = false;\n\n  function cluster(root) {\n    var previousNode,\n        x = 0;\n\n    // First walk, computing the initial x & y values.\n    root.eachAfter(function(node) {\n      var children = node.children;\n      if (children) {\n        node.x = meanX(children);\n        node.y = maxY(children);\n      } else {\n        node.x = previousNode ? x += separation(node, previousNode) : 0;\n        node.y = 0;\n        previousNode = node;\n      }\n    });\n\n    var left = leafLeft(root),\n        right = leafRight(root),\n        x0 = left.x - separation(left, right) / 2,\n        x1 = right.x + separation(right, left) / 2;\n\n    // Second walk, normalizing x & y to the desired size.\n    return root.eachAfter(nodeSize ? function(node) {\n      node.x = (node.x - root.x) * dx;\n      node.y = (root.y - node.y) * dy;\n    } : function(node) {\n      node.x = (node.x - x0) / (x1 - x0) * dx;\n      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;\n    });\n  }\n\n  cluster.separation = function(x) {\n    return arguments.length ? (separation = x, cluster) : separation;\n  };\n\n  cluster.size = function(x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);\n  };\n\n  cluster.nodeSize = function(x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);\n  };\n\n  return cluster;\n};\n\nvar node_each = function(callback) {\n  var node = this, current, next = [node], children, i, n;\n  do {\n    current = next.reverse(), next = [];\n    while (node = current.pop()) {\n      callback(node), children = node.children;\n      if (children) for (i = 0, n = children.length; i < n; ++i) {\n        next.push(children[i]);\n      }\n    }\n  } while (next.length);\n  return this;\n};\n\nvar node_eachBefore = function(callback) {\n  var node = this, nodes = [node], children, i;\n  while (node = nodes.pop()) {\n    callback(node), children = node.children;\n    if (children) for (i = children.length - 1; i >= 0; --i) {\n      nodes.push(children[i]);\n    }\n  }\n  return this;\n};\n\nvar node_eachAfter = function(callback) {\n  var node = this, nodes = [node], next = [], children, i, n;\n  while (node = nodes.pop()) {\n    next.push(node), children = node.children;\n    if (children) for (i = 0, n = children.length; i < n; ++i) {\n      nodes.push(children[i]);\n    }\n  }\n  while (node = next.pop()) {\n    callback(node);\n  }\n  return this;\n};\n\nvar node_sum = function(value) {\n  return this.eachAfter(function(node) {\n    var sum = +value(node.data) || 0,\n        children = node.children,\n        i = children && children.length;\n    while (--i >= 0) sum += children[i].value;\n    node.value = sum;\n  });\n};\n\nvar node_sort = function(compare) {\n  return this.eachBefore(function(node) {\n    if (node.children) {\n      node.children.sort(compare);\n    }\n  });\n};\n\nvar node_path = function(end) {\n  var start = this,\n      ancestor = leastCommonAncestor(start, end),\n      nodes = [start];\n  while (start !== ancestor) {\n    start = start.parent;\n    nodes.push(start);\n  }\n  var k = nodes.length;\n  while (end !== ancestor) {\n    nodes.splice(k, 0, end);\n    end = end.parent;\n  }\n  return nodes;\n};\n\nfunction leastCommonAncestor(a, b) {\n  if (a === b) return a;\n  var aNodes = a.ancestors(),\n      bNodes = b.ancestors(),\n      c = null;\n  a = aNodes.pop();\n  b = bNodes.pop();\n  while (a === b) {\n    c = a;\n    a = aNodes.pop();\n    b = bNodes.pop();\n  }\n  return c;\n}\n\nvar node_ancestors = function() {\n  var node = this, nodes = [node];\n  while (node = node.parent) {\n    nodes.push(node);\n  }\n  return nodes;\n};\n\nvar node_descendants = function() {\n  var nodes = [];\n  this.each(function(node) {\n    nodes.push(node);\n  });\n  return nodes;\n};\n\nvar node_leaves = function() {\n  var leaves = [];\n  this.eachBefore(function(node) {\n    if (!node.children) {\n      leaves.push(node);\n    }\n  });\n  return leaves;\n};\n\nvar node_links = function() {\n  var root = this, links = [];\n  root.each(function(node) {\n    if (node !== root) { // Don’t include the root’s parent, if any.\n      links.push({source: node.parent, target: node});\n    }\n  });\n  return links;\n};\n\nfunction hierarchy(data, children) {\n  var root = new Node(data),\n      valued = +data.value && (root.value = data.value),\n      node,\n      nodes = [root],\n      child,\n      childs,\n      i,\n      n;\n\n  if (children == null) children = defaultChildren;\n\n  while (node = nodes.pop()) {\n    if (valued) node.value = +node.data.value;\n    if ((childs = children(node.data)) && (n = childs.length)) {\n      node.children = new Array(n);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new Node(childs[i]));\n        child.parent = node;\n        child.depth = node.depth + 1;\n      }\n    }\n  }\n\n  return root.eachBefore(computeHeight);\n}\n\nfunction node_copy() {\n  return hierarchy(this).eachBefore(copyData);\n}\n\nfunction defaultChildren(d) {\n  return d.children;\n}\n\nfunction copyData(node) {\n  node.data = node.data.data;\n}\n\nfunction computeHeight(node) {\n  var height = 0;\n  do node.height = height;\n  while ((node = node.parent) && (node.height < ++height));\n}\n\nfunction Node(data) {\n  this.data = data;\n  this.depth =\n  this.height = 0;\n  this.parent = null;\n}\n\nNode.prototype = hierarchy.prototype = {\n  constructor: Node,\n  each: node_each,\n  eachAfter: node_eachAfter,\n  eachBefore: node_eachBefore,\n  sum: node_sum,\n  sort: node_sort,\n  path: node_path,\n  ancestors: node_ancestors,\n  descendants: node_descendants,\n  leaves: node_leaves,\n  links: node_links,\n  copy: node_copy\n};\n\nfunction Node$2(value) {\n  this._ = value;\n  this.next = null;\n}\n\nvar shuffle$1 = function(array) {\n  var i,\n      n = (array = array.slice()).length,\n      head = null,\n      node = head;\n\n  while (n) {\n    var next = new Node$2(array[n - 1]);\n    if (node) node = node.next = next;\n    else node = head = next;\n    array[i] = array[--n];\n  }\n\n  return {\n    head: head,\n    tail: node\n  };\n};\n\nvar enclose = function(circles) {\n  return encloseN(shuffle$1(circles), []);\n};\n\nfunction encloses(a, b) {\n  var dx = b.x - a.x,\n      dy = b.y - a.y,\n      dr = a.r - b.r;\n  return dr * dr + 1e-6 > dx * dx + dy * dy;\n}\n\n// Returns the smallest circle that contains circles L and intersects circles B.\nfunction encloseN(L, B) {\n  var circle,\n      l0 = null,\n      l1 = L.head,\n      l2,\n      p1;\n\n  switch (B.length) {\n    case 1: circle = enclose1(B[0]); break;\n    case 2: circle = enclose2(B[0], B[1]); break;\n    case 3: circle = enclose3(B[0], B[1], B[2]); break;\n  }\n\n  while (l1) {\n    p1 = l1._, l2 = l1.next;\n    if (!circle || !encloses(circle, p1)) {\n\n      // Temporarily truncate L before l1.\n      if (l0) L.tail = l0, l0.next = null;\n      else L.head = L.tail = null;\n\n      B.push(p1);\n      circle = encloseN(L, B); // Note: reorders L!\n      B.pop();\n\n      // Move l1 to the front of L and reconnect the truncated list L.\n      if (L.head) l1.next = L.head, L.head = l1;\n      else l1.next = null, L.head = L.tail = l1;\n      l0 = L.tail, l0.next = l2;\n\n    } else {\n      l0 = l1;\n    }\n    l1 = l2;\n  }\n\n  L.tail = l0;\n  return circle;\n}\n\nfunction enclose1(a) {\n  return {\n    x: a.x,\n    y: a.y,\n    r: a.r\n  };\n}\n\nfunction enclose2(a, b) {\n  var x1 = a.x, y1 = a.y, r1 = a.r,\n      x2 = b.x, y2 = b.y, r2 = b.r,\n      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,\n      l = Math.sqrt(x21 * x21 + y21 * y21);\n  return {\n    x: (x1 + x2 + x21 / l * r21) / 2,\n    y: (y1 + y2 + y21 / l * r21) / 2,\n    r: (l + r1 + r2) / 2\n  };\n}\n\nfunction enclose3(a, b, c) {\n  var x1 = a.x, y1 = a.y, r1 = a.r,\n      x2 = b.x, y2 = b.y, r2 = b.r,\n      x3 = c.x, y3 = c.y, r3 = c.r,\n      a2 = 2 * (x1 - x2),\n      b2 = 2 * (y1 - y2),\n      c2 = 2 * (r2 - r1),\n      d2 = x1 * x1 + y1 * y1 - r1 * r1 - x2 * x2 - y2 * y2 + r2 * r2,\n      a3 = 2 * (x1 - x3),\n      b3 = 2 * (y1 - y3),\n      c3 = 2 * (r3 - r1),\n      d3 = x1 * x1 + y1 * y1 - r1 * r1 - x3 * x3 - y3 * y3 + r3 * r3,\n      ab = a3 * b2 - a2 * b3,\n      xa = (b2 * d3 - b3 * d2) / ab - x1,\n      xb = (b3 * c2 - b2 * c3) / ab,\n      ya = (a3 * d2 - a2 * d3) / ab - y1,\n      yb = (a2 * c3 - a3 * c2) / ab,\n      A = xb * xb + yb * yb - 1,\n      B = 2 * (xa * xb + ya * yb + r1),\n      C = xa * xa + ya * ya - r1 * r1,\n      r = (-B - Math.sqrt(B * B - 4 * A * C)) / (2 * A);\n  return {\n    x: xa + xb * r + x1,\n    y: ya + yb * r + y1,\n    r: r\n  };\n}\n\nfunction place(a, b, c) {\n  var ax = a.x,\n      ay = a.y,\n      da = b.r + c.r,\n      db = a.r + c.r,\n      dx = b.x - ax,\n      dy = b.y - ay,\n      dc = dx * dx + dy * dy;\n  if (dc) {\n    var x = 0.5 + ((db *= db) - (da *= da)) / (2 * dc),\n        y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);\n    c.x = ax + x * dx + y * dy;\n    c.y = ay + x * dy - y * dx;\n  } else {\n    c.x = ax + db;\n    c.y = ay;\n  }\n}\n\nfunction intersects(a, b) {\n  var dx = b.x - a.x,\n      dy = b.y - a.y,\n      dr = a.r + b.r;\n  return dr * dr > dx * dx + dy * dy;\n}\n\nfunction distance2(circle, x, y) {\n  var dx = circle.x - x,\n      dy = circle.y - y;\n  return dx * dx + dy * dy;\n}\n\nfunction Node$1(circle) {\n  this._ = circle;\n  this.next = null;\n  this.previous = null;\n}\n\nfunction packEnclose(circles) {\n  if (!(n = circles.length)) return 0;\n\n  var a, b, c, n;\n\n  // Place the first circle.\n  a = circles[0], a.x = 0, a.y = 0;\n  if (!(n > 1)) return a.r;\n\n  // Place the second circle.\n  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;\n  if (!(n > 2)) return a.r + b.r;\n\n  // Place the third circle.\n  place(b, a, c = circles[2]);\n\n  // Initialize the weighted centroid.\n  var aa = a.r * a.r,\n      ba = b.r * b.r,\n      ca = c.r * c.r,\n      oa = aa + ba + ca,\n      ox = aa * a.x + ba * b.x + ca * c.x,\n      oy = aa * a.y + ba * b.y + ca * c.y,\n      cx, cy, i, j, k, sj, sk;\n\n  // Initialize the front-chain using the first three circles a, b and c.\n  a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);\n  a.next = c.previous = b;\n  b.next = a.previous = c;\n  c.next = b.previous = a;\n\n  // Attempt to place each remaining circle…\n  pack: for (i = 3; i < n; ++i) {\n    place(a._, b._, c = circles[i]), c = new Node$1(c);\n\n    // If there are only three elements in the front-chain…\n    if ((k = a.previous) === (j = b.next)) {\n      // If the new circle intersects the third circle,\n      // rotate the front chain to try the next position.\n      if (intersects(j._, c._)) {\n        a = b, b = j, --i;\n        continue pack;\n      }\n    }\n\n    // Find the closest intersecting circle on the front-chain, if any.\n    else {\n      sj = j._.r, sk = k._.r;\n      do {\n        if (sj <= sk) {\n          if (intersects(j._, c._)) {\n            b = j, a.next = b, b.previous = a, --i;\n            continue pack;\n          }\n          j = j.next, sj += j._.r;\n        } else {\n          if (intersects(k._, c._)) {\n            a = k, a.next = b, b.previous = a, --i;\n            continue pack;\n          }\n          k = k.previous, sk += k._.r;\n        }\n      } while (j !== k.next);\n    }\n\n    // Success! Insert the new circle c between a and b.\n    c.previous = a, c.next = b, a.next = b.previous = b = c;\n\n    // Update the weighted centroid.\n    oa += ca = c._.r * c._.r;\n    ox += ca * c._.x;\n    oy += ca * c._.y;\n\n    // Compute the new closest circle a to centroid.\n    aa = distance2(a._, cx = ox / oa, cy = oy / oa);\n    while ((c = c.next) !== b) {\n      if ((ca = distance2(c._, cx, cy)) < aa) {\n        a = c, aa = ca;\n      }\n    }\n    b = a.next;\n  }\n\n  // Compute the enclosing circle of the front chain.\n  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);\n\n  // Translate the circles to put the enclosing circle around the origin.\n  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;\n\n  return c.r;\n}\n\nvar siblings = function(circles) {\n  packEnclose(circles);\n  return circles;\n};\n\nfunction optional(f) {\n  return f == null ? null : required(f);\n}\n\nfunction required(f) {\n  if (typeof f !== \"function\") throw new Error;\n  return f;\n}\n\nfunction constantZero() {\n  return 0;\n}\n\nvar constant$6 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nfunction defaultRadius(d) {\n  return Math.sqrt(d.value);\n}\n\nvar index = function() {\n  var radius = null,\n      dx = 1,\n      dy = 1,\n      padding = constantZero;\n\n  function pack(root) {\n    root.x = dx / 2, root.y = dy / 2;\n    if (radius) {\n      root.eachBefore(radiusLeaf(radius))\n          .eachAfter(packChildren(padding, 0.5))\n          .eachBefore(translateChild(1));\n    } else {\n      root.eachBefore(radiusLeaf(defaultRadius))\n          .eachAfter(packChildren(constantZero, 1))\n          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))\n          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));\n    }\n    return root;\n  }\n\n  pack.radius = function(x) {\n    return arguments.length ? (radius = optional(x), pack) : radius;\n  };\n\n  pack.size = function(x) {\n    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];\n  };\n\n  pack.padding = function(x) {\n    return arguments.length ? (padding = typeof x === \"function\" ? x : constant$6(+x), pack) : padding;\n  };\n\n  return pack;\n};\n\nfunction radiusLeaf(radius) {\n  return function(node) {\n    if (!node.children) {\n      node.r = Math.max(0, +radius(node) || 0);\n    }\n  };\n}\n\nfunction packChildren(padding, k) {\n  return function(node) {\n    if (children = node.children) {\n      var children,\n          i,\n          n = children.length,\n          r = padding(node) * k || 0,\n          e;\n\n      if (r) for (i = 0; i < n; ++i) children[i].r += r;\n      e = packEnclose(children);\n      if (r) for (i = 0; i < n; ++i) children[i].r -= r;\n      node.r = e + r;\n    }\n  };\n}\n\nfunction translateChild(k) {\n  return function(node) {\n    var parent = node.parent;\n    node.r *= k;\n    if (parent) {\n      node.x = parent.x + k * node.x;\n      node.y = parent.y + k * node.y;\n    }\n  };\n}\n\nvar roundNode = function(node) {\n  node.x0 = Math.round(node.x0);\n  node.y0 = Math.round(node.y0);\n  node.x1 = Math.round(node.x1);\n  node.y1 = Math.round(node.y1);\n};\n\nvar treemapDice = function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      node,\n      i = -1,\n      n = nodes.length,\n      k = parent.value && (x1 - x0) / parent.value;\n\n  while (++i < n) {\n    node = nodes[i], node.y0 = y0, node.y1 = y1;\n    node.x0 = x0, node.x1 = x0 += node.value * k;\n  }\n};\n\nvar partition = function() {\n  var dx = 1,\n      dy = 1,\n      padding = 0,\n      round = false;\n\n  function partition(root) {\n    var n = root.height + 1;\n    root.x0 =\n    root.y0 = padding;\n    root.x1 = dx;\n    root.y1 = dy / n;\n    root.eachBefore(positionNode(dy, n));\n    if (round) root.eachBefore(roundNode);\n    return root;\n  }\n\n  function positionNode(dy, n) {\n    return function(node) {\n      if (node.children) {\n        treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);\n      }\n      var x0 = node.x0,\n          y0 = node.y0,\n          x1 = node.x1 - padding,\n          y1 = node.y1 - padding;\n      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;\n      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;\n      node.x0 = x0;\n      node.y0 = y0;\n      node.x1 = x1;\n      node.y1 = y1;\n    };\n  }\n\n  partition.round = function(x) {\n    return arguments.length ? (round = !!x, partition) : round;\n  };\n\n  partition.size = function(x) {\n    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];\n  };\n\n  partition.padding = function(x) {\n    return arguments.length ? (padding = +x, partition) : padding;\n  };\n\n  return partition;\n};\n\nvar keyPrefix$1 = \"$\";\nvar preroot = {depth: -1};\nvar ambiguous = {};\n\nfunction defaultId(d) {\n  return d.id;\n}\n\nfunction defaultParentId(d) {\n  return d.parentId;\n}\n\nvar stratify = function() {\n  var id = defaultId,\n      parentId = defaultParentId;\n\n  function stratify(data) {\n    var d,\n        i,\n        n = data.length,\n        root,\n        parent,\n        node,\n        nodes = new Array(n),\n        nodeId,\n        nodeKey,\n        nodeByKey = {};\n\n    for (i = 0; i < n; ++i) {\n      d = data[i], node = nodes[i] = new Node(d);\n      if ((nodeId = id(d, i, data)) != null && (nodeId += \"\")) {\n        nodeKey = keyPrefix$1 + (node.id = nodeId);\n        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;\n      }\n    }\n\n    for (i = 0; i < n; ++i) {\n      node = nodes[i], nodeId = parentId(data[i], i, data);\n      if (nodeId == null || !(nodeId += \"\")) {\n        if (root) throw new Error(\"multiple roots\");\n        root = node;\n      } else {\n        parent = nodeByKey[keyPrefix$1 + nodeId];\n        if (!parent) throw new Error(\"missing: \" + nodeId);\n        if (parent === ambiguous) throw new Error(\"ambiguous: \" + nodeId);\n        if (parent.children) parent.children.push(node);\n        else parent.children = [node];\n        node.parent = parent;\n      }\n    }\n\n    if (!root) throw new Error(\"no root\");\n    root.parent = preroot;\n    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);\n    root.parent = null;\n    if (n > 0) throw new Error(\"cycle\");\n\n    return root;\n  }\n\n  stratify.id = function(x) {\n    return arguments.length ? (id = required(x), stratify) : id;\n  };\n\n  stratify.parentId = function(x) {\n    return arguments.length ? (parentId = required(x), stratify) : parentId;\n  };\n\n  return stratify;\n};\n\nfunction defaultSeparation$1(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n}\n\n// function radialSeparation(a, b) {\n//   return (a.parent === b.parent ? 1 : 2) / a.depth;\n// }\n\n// This function is used to traverse the left contour of a subtree (or\n// subforest). It returns the successor of v on this contour. This successor is\n// either given by the leftmost child of v or by the thread of v. The function\n// returns null if and only if v is on the highest level of its subtree.\nfunction nextLeft(v) {\n  var children = v.children;\n  return children ? children[0] : v.t;\n}\n\n// This function works analogously to nextLeft.\nfunction nextRight(v) {\n  var children = v.children;\n  return children ? children[children.length - 1] : v.t;\n}\n\n// Shifts the current subtree rooted at w+. This is done by increasing\n// prelim(w+) and mod(w+) by shift.\nfunction moveSubtree(wm, wp, shift) {\n  var change = shift / (wp.i - wm.i);\n  wp.c -= change;\n  wp.s += shift;\n  wm.c += change;\n  wp.z += shift;\n  wp.m += shift;\n}\n\n// All other shifts, applied to the smaller subtrees between w- and w+, are\n// performed by this function. To prepare the shifts, we have to adjust\n// change(w+), shift(w+), and change(w-).\nfunction executeShifts(v) {\n  var shift = 0,\n      change = 0,\n      children = v.children,\n      i = children.length,\n      w;\n  while (--i >= 0) {\n    w = children[i];\n    w.z += shift;\n    w.m += shift;\n    shift += w.s + (change += w.c);\n  }\n}\n\n// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,\n// returns the specified (default) ancestor.\nfunction nextAncestor(vim, v, ancestor) {\n  return vim.a.parent === v.parent ? vim.a : ancestor;\n}\n\nfunction TreeNode(node, i) {\n  this._ = node;\n  this.parent = null;\n  this.children = null;\n  this.A = null; // default ancestor\n  this.a = this; // ancestor\n  this.z = 0; // prelim\n  this.m = 0; // mod\n  this.c = 0; // change\n  this.s = 0; // shift\n  this.t = null; // thread\n  this.i = i; // number\n}\n\nTreeNode.prototype = Object.create(Node.prototype);\n\nfunction treeRoot(root) {\n  var tree = new TreeNode(root, 0),\n      node,\n      nodes = [tree],\n      child,\n      children,\n      i,\n      n;\n\n  while (node = nodes.pop()) {\n    if (children = node._.children) {\n      node.children = new Array(n = children.length);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new TreeNode(children[i], i));\n        child.parent = node;\n      }\n    }\n  }\n\n  (tree.parent = new TreeNode(null, 0)).children = [tree];\n  return tree;\n}\n\n// Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\nvar tree = function() {\n  var separation = defaultSeparation$1,\n      dx = 1,\n      dy = 1,\n      nodeSize = null;\n\n  function tree(root) {\n    var t = treeRoot(root);\n\n    // Compute the layout using Buchheim et al.’s algorithm.\n    t.eachAfter(firstWalk), t.parent.m = -t.z;\n    t.eachBefore(secondWalk);\n\n    // If a fixed node size is specified, scale x and y.\n    if (nodeSize) root.eachBefore(sizeNode);\n\n    // If a fixed tree size is specified, scale x and y based on the extent.\n    // Compute the left-most, right-most, and depth-most nodes for extents.\n    else {\n      var left = root,\n          right = root,\n          bottom = root;\n      root.eachBefore(function(node) {\n        if (node.x < left.x) left = node;\n        if (node.x > right.x) right = node;\n        if (node.depth > bottom.depth) bottom = node;\n      });\n      var s = left === right ? 1 : separation(left, right) / 2,\n          tx = s - left.x,\n          kx = dx / (right.x + s + tx),\n          ky = dy / (bottom.depth || 1);\n      root.eachBefore(function(node) {\n        node.x = (node.x + tx) * kx;\n        node.y = node.depth * ky;\n      });\n    }\n\n    return root;\n  }\n\n  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is\n  // applied recursively to the children of v, as well as the function\n  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the\n  // node v is placed to the midpoint of its outermost children.\n  function firstWalk(v) {\n    var children = v.children,\n        siblings = v.parent.children,\n        w = v.i ? siblings[v.i - 1] : null;\n    if (children) {\n      executeShifts(v);\n      var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n      if (w) {\n        v.z = w.z + separation(v._, w._);\n        v.m = v.z - midpoint;\n      } else {\n        v.z = midpoint;\n      }\n    } else if (w) {\n      v.z = w.z + separation(v._, w._);\n    }\n    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n  }\n\n  // Computes all real x-coordinates by summing up the modifiers recursively.\n  function secondWalk(v) {\n    v._.x = v.z + v.parent.m;\n    v.m += v.parent.m;\n  }\n\n  // The core of the algorithm. Here, a new subtree is combined with the\n  // previous subtrees. Threads are used to traverse the inside and outside\n  // contours of the left and right subtree up to the highest common level. The\n  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the\n  // superscript o means outside and i means inside, the subscript - means left\n  // subtree and + means right subtree. For summing up the modifiers along the\n  // contour, we use respective variables si+, si-, so-, and so+. Whenever two\n  // nodes of the inside contours conflict, we compute the left one of the\n  // greatest uncommon ancestors using the function ANCESTOR and call MOVE\n  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.\n  // Finally, we add a new thread (if necessary).\n  function apportion(v, w, ancestor) {\n    if (w) {\n      var vip = v,\n          vop = v,\n          vim = w,\n          vom = vip.parent.children[0],\n          sip = vip.m,\n          sop = vop.m,\n          sim = vim.m,\n          som = vom.m,\n          shift;\n      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\n        vom = nextLeft(vom);\n        vop = nextRight(vop);\n        vop.a = v;\n        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n        if (shift > 0) {\n          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);\n          sip += shift;\n          sop += shift;\n        }\n        sim += vim.m;\n        sip += vip.m;\n        som += vom.m;\n        sop += vop.m;\n      }\n      if (vim && !nextRight(vop)) {\n        vop.t = vim;\n        vop.m += sim - sop;\n      }\n      if (vip && !nextLeft(vom)) {\n        vom.t = vip;\n        vom.m += sip - som;\n        ancestor = v;\n      }\n    }\n    return ancestor;\n  }\n\n  function sizeNode(node) {\n    node.x *= dx;\n    node.y = node.depth * dy;\n  }\n\n  tree.separation = function(x) {\n    return arguments.length ? (separation = x, tree) : separation;\n  };\n\n  tree.size = function(x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);\n  };\n\n  tree.nodeSize = function(x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);\n  };\n\n  return tree;\n};\n\nvar treemapSlice = function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      node,\n      i = -1,\n      n = nodes.length,\n      k = parent.value && (y1 - y0) / parent.value;\n\n  while (++i < n) {\n    node = nodes[i], node.x0 = x0, node.x1 = x1;\n    node.y0 = y0, node.y1 = y0 += node.value * k;\n  }\n};\n\nvar phi = (1 + Math.sqrt(5)) / 2;\n\nfunction squarifyRatio(ratio, parent, x0, y0, x1, y1) {\n  var rows = [],\n      nodes = parent.children,\n      row,\n      nodeValue,\n      i0 = 0,\n      i1,\n      n = nodes.length,\n      dx, dy,\n      value = parent.value,\n      sumValue,\n      minValue,\n      maxValue,\n      newRatio,\n      minRatio,\n      alpha,\n      beta;\n\n  while (i0 < n) {\n    dx = x1 - x0, dy = y1 - y0;\n    minValue = maxValue = sumValue = nodes[i0].value;\n    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n    beta = sumValue * sumValue * alpha;\n    minRatio = Math.max(maxValue / beta, beta / minValue);\n\n    // Keep adding nodes while the aspect ratio maintains or improves.\n    for (i1 = i0 + 1; i1 < n; ++i1) {\n      sumValue += nodeValue = nodes[i1].value;\n      if (nodeValue < minValue) minValue = nodeValue;\n      if (nodeValue > maxValue) maxValue = nodeValue;\n      beta = sumValue * sumValue * alpha;\n      newRatio = Math.max(maxValue / beta, beta / minValue);\n      if (newRatio > minRatio) { sumValue -= nodeValue; break; }\n      minRatio = newRatio;\n    }\n\n    // Position and record the row orientation.\n    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});\n    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);\n    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);\n    value -= sumValue, i0 = i1;\n  }\n\n  return rows;\n}\n\nvar squarify = (function custom(ratio) {\n\n  function squarify(parent, x0, y0, x1, y1) {\n    squarifyRatio(ratio, parent, x0, y0, x1, y1);\n  }\n\n  squarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return squarify;\n})(phi);\n\nvar index$1 = function() {\n  var tile = squarify,\n      round = false,\n      dx = 1,\n      dy = 1,\n      paddingStack = [0],\n      paddingInner = constantZero,\n      paddingTop = constantZero,\n      paddingRight = constantZero,\n      paddingBottom = constantZero,\n      paddingLeft = constantZero;\n\n  function treemap(root) {\n    root.x0 =\n    root.y0 = 0;\n    root.x1 = dx;\n    root.y1 = dy;\n    root.eachBefore(positionNode);\n    paddingStack = [0];\n    if (round) root.eachBefore(roundNode);\n    return root;\n  }\n\n  function positionNode(node) {\n    var p = paddingStack[node.depth],\n        x0 = node.x0 + p,\n        y0 = node.y0 + p,\n        x1 = node.x1 - p,\n        y1 = node.y1 - p;\n    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;\n    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;\n    node.x0 = x0;\n    node.y0 = y0;\n    node.x1 = x1;\n    node.y1 = y1;\n    if (node.children) {\n      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;\n      x0 += paddingLeft(node) - p;\n      y0 += paddingTop(node) - p;\n      x1 -= paddingRight(node) - p;\n      y1 -= paddingBottom(node) - p;\n      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;\n      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;\n      tile(node, x0, y0, x1, y1);\n    }\n  }\n\n  treemap.round = function(x) {\n    return arguments.length ? (round = !!x, treemap) : round;\n  };\n\n  treemap.size = function(x) {\n    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];\n  };\n\n  treemap.tile = function(x) {\n    return arguments.length ? (tile = required(x), treemap) : tile;\n  };\n\n  treemap.padding = function(x) {\n    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();\n  };\n\n  treemap.paddingInner = function(x) {\n    return arguments.length ? (paddingInner = typeof x === \"function\" ? x : constant$6(+x), treemap) : paddingInner;\n  };\n\n  treemap.paddingOuter = function(x) {\n    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();\n  };\n\n  treemap.paddingTop = function(x) {\n    return arguments.length ? (paddingTop = typeof x === \"function\" ? x : constant$6(+x), treemap) : paddingTop;\n  };\n\n  treemap.paddingRight = function(x) {\n    return arguments.length ? (paddingRight = typeof x === \"function\" ? x : constant$6(+x), treemap) : paddingRight;\n  };\n\n  treemap.paddingBottom = function(x) {\n    return arguments.length ? (paddingBottom = typeof x === \"function\" ? x : constant$6(+x), treemap) : paddingBottom;\n  };\n\n  treemap.paddingLeft = function(x) {\n    return arguments.length ? (paddingLeft = typeof x === \"function\" ? x : constant$6(+x), treemap) : paddingLeft;\n  };\n\n  return treemap;\n};\n\nvar binary = function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      i, n = nodes.length,\n      sum, sums = new Array(n + 1);\n\n  for (sums[0] = sum = i = 0; i < n; ++i) {\n    sums[i + 1] = sum += nodes[i].value;\n  }\n\n  partition(0, n, parent.value, x0, y0, x1, y1);\n\n  function partition(i, j, value, x0, y0, x1, y1) {\n    if (i >= j - 1) {\n      var node = nodes[i];\n      node.x0 = x0, node.y0 = y0;\n      node.x1 = x1, node.y1 = y1;\n      return;\n    }\n\n    var valueOffset = sums[i],\n        valueTarget = (value / 2) + valueOffset,\n        k = i + 1,\n        hi = j - 1;\n\n    while (k < hi) {\n      var mid = k + hi >>> 1;\n      if (sums[mid] < valueTarget) k = mid + 1;\n      else hi = mid;\n    }\n\n    var valueLeft = sums[k] - valueOffset,\n        valueRight = value - valueLeft;\n\n    if ((y1 - y0) > (x1 - x0)) {\n      var yk = (y0 * valueRight + y1 * valueLeft) / value;\n      partition(i, k, valueLeft, x0, y0, x1, yk);\n      partition(k, j, valueRight, x0, yk, x1, y1);\n    } else {\n      var xk = (x0 * valueRight + x1 * valueLeft) / value;\n      partition(i, k, valueLeft, x0, y0, xk, y1);\n      partition(k, j, valueRight, xk, y0, x1, y1);\n    }\n  }\n};\n\nvar sliceDice = function(parent, x0, y0, x1, y1) {\n  (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);\n};\n\nvar resquarify = (function custom(ratio) {\n\n  function resquarify(parent, x0, y0, x1, y1) {\n    if ((rows = parent._squarify) && (rows.ratio === ratio)) {\n      var rows,\n          row,\n          nodes,\n          i,\n          j = -1,\n          n,\n          m = rows.length,\n          value = parent.value;\n\n      while (++j < m) {\n        row = rows[j], nodes = row.children;\n        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;\n        if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);\n        else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);\n        value -= row.value;\n      }\n    } else {\n      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);\n      rows.ratio = ratio;\n    }\n  }\n\n  resquarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return resquarify;\n})(phi);\n\nvar center$1 = function(x, y) {\n  var nodes;\n\n  if (x == null) x = 0;\n  if (y == null) y = 0;\n\n  function force() {\n    var i,\n        n = nodes.length,\n        node,\n        sx = 0,\n        sy = 0;\n\n    for (i = 0; i < n; ++i) {\n      node = nodes[i], sx += node.x, sy += node.y;\n    }\n\n    for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {\n      node = nodes[i], node.x -= sx, node.y -= sy;\n    }\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n  };\n\n  force.x = function(_) {\n    return arguments.length ? (x = +_, force) : x;\n  };\n\n  force.y = function(_) {\n    return arguments.length ? (y = +_, force) : y;\n  };\n\n  return force;\n};\n\nvar constant$7 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nvar jiggle = function() {\n  return (Math.random() - 0.5) * 1e-6;\n};\n\nfunction x$1(d) {\n  return d.x + d.vx;\n}\n\nfunction y$1(d) {\n  return d.y + d.vy;\n}\n\nvar collide = function(radius) {\n  var nodes,\n      radii,\n      strength = 1,\n      iterations = 1;\n\n  if (typeof radius !== \"function\") radius = constant$7(radius == null ? 1 : +radius);\n\n  function force() {\n    var i, n = nodes.length,\n        tree,\n        node,\n        xi,\n        yi,\n        ri,\n        ri2;\n\n    for (var k = 0; k < iterations; ++k) {\n      tree = quadtree(nodes, x$1, y$1).visitAfter(prepare);\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        ri = radii[i], ri2 = ri * ri;\n        xi = node.x + node.vx;\n        yi = node.y + node.vy;\n        tree.visit(apply);\n      }\n    }\n\n    function apply(quad, x0, y0, x1, y1) {\n      var data = quad.data, rj = quad.r, r = ri + rj;\n      if (data) {\n        if (data.index > i) {\n          var x = xi - data.x - data.vx,\n              y = yi - data.y - data.vy,\n              l = x * x + y * y;\n          if (l < r * r) {\n            if (x === 0) x = jiggle(), l += x * x;\n            if (y === 0) y = jiggle(), l += y * y;\n            l = (r - (l = Math.sqrt(l))) / l * strength;\n            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));\n            node.vy += (y *= l) * r;\n            data.vx -= x * (r = 1 - r);\n            data.vy -= y * r;\n          }\n        }\n        return;\n      }\n      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;\n    }\n  }\n\n  function prepare(quad) {\n    if (quad.data) return quad.r = radii[quad.data.index];\n    for (var i = quad.r = 0; i < 4; ++i) {\n      if (quad[i] && quad[i].r > quad.r) {\n        quad.r = quad[i].r;\n      }\n    }\n  }\n\n  function initialize() {\n    if (!nodes) return;\n    var i, n = nodes.length;\n    radii = new Array(n);\n    for (i = 0; i < n; ++i) radii[i] = +radius(nodes[i], i, nodes);\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.iterations = function(_) {\n    return arguments.length ? (iterations = +_, force) : iterations;\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = +_, force) : strength;\n  };\n\n  force.radius = function(_) {\n    return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant$7(+_), initialize(), force) : radius;\n  };\n\n  return force;\n};\n\nfunction index$2(d, i) {\n  return i;\n}\n\nfunction find(nodeById, nodeId) {\n  var node = nodeById.get(nodeId);\n  if (!node) throw new Error(\"missing: \" + nodeId);\n  return node;\n}\n\nvar link = function(links) {\n  var id = index$2,\n      strength = defaultStrength,\n      strengths,\n      distance = constant$7(30),\n      distances,\n      nodes,\n      count,\n      bias,\n      iterations = 1;\n\n  if (links == null) links = [];\n\n  function defaultStrength(link) {\n    return 1 / Math.min(count[link.source.index], count[link.target.index]);\n  }\n\n  function force(alpha) {\n    for (var k = 0, n = links.length; k < iterations; ++k) {\n      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {\n        link = links[i], source = link.source, target = link.target;\n        x = target.x + target.vx - source.x - source.vx || jiggle();\n        y = target.y + target.vy - source.y - source.vy || jiggle();\n        l = Math.sqrt(x * x + y * y);\n        l = (l - distances[i]) / l * alpha * strengths[i];\n        x *= l, y *= l;\n        target.vx -= x * (b = bias[i]);\n        target.vy -= y * b;\n        source.vx += x * (b = 1 - b);\n        source.vy += y * b;\n      }\n    }\n  }\n\n  function initialize() {\n    if (!nodes) return;\n\n    var i,\n        n = nodes.length,\n        m = links.length,\n        nodeById = map$1(nodes, id),\n        link;\n\n    for (i = 0, count = new Array(n); i < n; ++i) {\n      count[i] = 0;\n    }\n\n    for (i = 0; i < m; ++i) {\n      link = links[i], link.index = i;\n      if (typeof link.source !== \"object\") link.source = find(nodeById, link.source);\n      if (typeof link.target !== \"object\") link.target = find(nodeById, link.target);\n      ++count[link.source.index], ++count[link.target.index];\n    }\n\n    for (i = 0, bias = new Array(m); i < m; ++i) {\n      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);\n    }\n\n    strengths = new Array(m), initializeStrength();\n    distances = new Array(m), initializeDistance();\n  }\n\n  function initializeStrength() {\n    if (!nodes) return;\n\n    for (var i = 0, n = links.length; i < n; ++i) {\n      strengths[i] = +strength(links[i], i, links);\n    }\n  }\n\n  function initializeDistance() {\n    if (!nodes) return;\n\n    for (var i = 0, n = links.length; i < n; ++i) {\n      distances[i] = +distance(links[i], i, links);\n    }\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.links = function(_) {\n    return arguments.length ? (links = _, initialize(), force) : links;\n  };\n\n  force.id = function(_) {\n    return arguments.length ? (id = _, force) : id;\n  };\n\n  force.iterations = function(_) {\n    return arguments.length ? (iterations = +_, force) : iterations;\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant$7(+_), initializeStrength(), force) : strength;\n  };\n\n  force.distance = function(_) {\n    return arguments.length ? (distance = typeof _ === \"function\" ? _ : constant$7(+_), initializeDistance(), force) : distance;\n  };\n\n  return force;\n};\n\nfunction x$2(d) {\n  return d.x;\n}\n\nfunction y$2(d) {\n  return d.y;\n}\n\nvar initialRadius = 10;\nvar initialAngle = Math.PI * (3 - Math.sqrt(5));\n\nvar simulation = function(nodes) {\n  var simulation,\n      alpha = 1,\n      alphaMin = 0.001,\n      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),\n      alphaTarget = 0,\n      velocityDecay = 0.6,\n      forces = map$1(),\n      stepper = timer(step),\n      event = dispatch(\"tick\", \"end\");\n\n  if (nodes == null) nodes = [];\n\n  function step() {\n    tick();\n    event.call(\"tick\", simulation);\n    if (alpha < alphaMin) {\n      stepper.stop();\n      event.call(\"end\", simulation);\n    }\n  }\n\n  function tick() {\n    var i, n = nodes.length, node;\n\n    alpha += (alphaTarget - alpha) * alphaDecay;\n\n    forces.each(function(force) {\n      force(alpha);\n    });\n\n    for (i = 0; i < n; ++i) {\n      node = nodes[i];\n      if (node.fx == null) node.x += node.vx *= velocityDecay;\n      else node.x = node.fx, node.vx = 0;\n      if (node.fy == null) node.y += node.vy *= velocityDecay;\n      else node.y = node.fy, node.vy = 0;\n    }\n  }\n\n  function initializeNodes() {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.index = i;\n      if (isNaN(node.x) || isNaN(node.y)) {\n        var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;\n        node.x = radius * Math.cos(angle);\n        node.y = radius * Math.sin(angle);\n      }\n      if (isNaN(node.vx) || isNaN(node.vy)) {\n        node.vx = node.vy = 0;\n      }\n    }\n  }\n\n  function initializeForce(force) {\n    if (force.initialize) force.initialize(nodes);\n    return force;\n  }\n\n  initializeNodes();\n\n  return simulation = {\n    tick: tick,\n\n    restart: function() {\n      return stepper.restart(step), simulation;\n    },\n\n    stop: function() {\n      return stepper.stop(), simulation;\n    },\n\n    nodes: function(_) {\n      return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;\n    },\n\n    alpha: function(_) {\n      return arguments.length ? (alpha = +_, simulation) : alpha;\n    },\n\n    alphaMin: function(_) {\n      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;\n    },\n\n    alphaDecay: function(_) {\n      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;\n    },\n\n    alphaTarget: function(_) {\n      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;\n    },\n\n    velocityDecay: function(_) {\n      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;\n    },\n\n    force: function(name, _) {\n      return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);\n    },\n\n    find: function(x, y, radius) {\n      var i = 0,\n          n = nodes.length,\n          dx,\n          dy,\n          d2,\n          node,\n          closest;\n\n      if (radius == null) radius = Infinity;\n      else radius *= radius;\n\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        dx = x - node.x;\n        dy = y - node.y;\n        d2 = dx * dx + dy * dy;\n        if (d2 < radius) closest = node, radius = d2;\n      }\n\n      return closest;\n    },\n\n    on: function(name, _) {\n      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);\n    }\n  };\n};\n\nvar manyBody = function() {\n  var nodes,\n      node,\n      alpha,\n      strength = constant$7(-30),\n      strengths,\n      distanceMin2 = 1,\n      distanceMax2 = Infinity,\n      theta2 = 0.81;\n\n  function force(_) {\n    var i, n = nodes.length, tree = quadtree(nodes, x$2, y$2).visitAfter(accumulate);\n    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);\n  }\n\n  function initialize() {\n    if (!nodes) return;\n    var i, n = nodes.length;\n    strengths = new Array(n);\n    for (i = 0; i < n; ++i) strengths[i] = +strength(nodes[i], i, nodes);\n  }\n\n  function accumulate(quad) {\n    var strength = 0, q, c, x$$1, y$$1, i;\n\n    // For internal nodes, accumulate forces from child quadrants.\n    if (quad.length) {\n      for (x$$1 = y$$1 = i = 0; i < 4; ++i) {\n        if ((q = quad[i]) && (c = q.value)) {\n          strength += c, x$$1 += c * q.x, y$$1 += c * q.y;\n        }\n      }\n      quad.x = x$$1 / strength;\n      quad.y = y$$1 / strength;\n    }\n\n    // For leaf nodes, accumulate forces from coincident quadrants.\n    else {\n      q = quad;\n      q.x = q.data.x;\n      q.y = q.data.y;\n      do strength += strengths[q.data.index];\n      while (q = q.next);\n    }\n\n    quad.value = strength;\n  }\n\n  function apply(quad, x1, _, x2) {\n    if (!quad.value) return true;\n\n    var x$$1 = quad.x - node.x,\n        y$$1 = quad.y - node.y,\n        w = x2 - x1,\n        l = x$$1 * x$$1 + y$$1 * y$$1;\n\n    // Apply the Barnes-Hut approximation if possible.\n    // Limit forces for very close nodes; randomize direction if coincident.\n    if (w * w / theta2 < l) {\n      if (l < distanceMax2) {\n        if (x$$1 === 0) x$$1 = jiggle(), l += x$$1 * x$$1;\n        if (y$$1 === 0) y$$1 = jiggle(), l += y$$1 * y$$1;\n        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n        node.vx += x$$1 * quad.value * alpha / l;\n        node.vy += y$$1 * quad.value * alpha / l;\n      }\n      return true;\n    }\n\n    // Otherwise, process points directly.\n    else if (quad.length || l >= distanceMax2) return;\n\n    // Limit forces for very close nodes; randomize direction if coincident.\n    if (quad.data !== node || quad.next) {\n      if (x$$1 === 0) x$$1 = jiggle(), l += x$$1 * x$$1;\n      if (y$$1 === 0) y$$1 = jiggle(), l += y$$1 * y$$1;\n      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n    }\n\n    do if (quad.data !== node) {\n      w = strengths[quad.data.index] * alpha / l;\n      node.vx += x$$1 * w;\n      node.vy += y$$1 * w;\n    } while (quad = quad.next);\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant$7(+_), initialize(), force) : strength;\n  };\n\n  force.distanceMin = function(_) {\n    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);\n  };\n\n  force.distanceMax = function(_) {\n    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);\n  };\n\n  force.theta = function(_) {\n    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);\n  };\n\n  return force;\n};\n\nvar x$3 = function(x) {\n  var strength = constant$7(0.1),\n      nodes,\n      strengths,\n      xz;\n\n  if (typeof x !== \"function\") x = constant$7(x == null ? 0 : +x);\n\n  function force(alpha) {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;\n    }\n  }\n\n  function initialize() {\n    if (!nodes) return;\n    var i, n = nodes.length;\n    strengths = new Array(n);\n    xz = new Array(n);\n    for (i = 0; i < n; ++i) {\n      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n    }\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant$7(+_), initialize(), force) : strength;\n  };\n\n  force.x = function(_) {\n    return arguments.length ? (x = typeof _ === \"function\" ? _ : constant$7(+_), initialize(), force) : x;\n  };\n\n  return force;\n};\n\nvar y$3 = function(y) {\n  var strength = constant$7(0.1),\n      nodes,\n      strengths,\n      yz;\n\n  if (typeof y !== \"function\") y = constant$7(y == null ? 0 : +y);\n\n  function force(alpha) {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;\n    }\n  }\n\n  function initialize() {\n    if (!nodes) return;\n    var i, n = nodes.length;\n    strengths = new Array(n);\n    yz = new Array(n);\n    for (i = 0; i < n; ++i) {\n      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n    }\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant$7(+_), initialize(), force) : strength;\n  };\n\n  force.y = function(_) {\n    return arguments.length ? (y = typeof _ === \"function\" ? _ : constant$7(+_), initialize(), force) : y;\n  };\n\n  return force;\n};\n\nfunction nopropagation() {\n  exports.event.stopImmediatePropagation();\n}\n\nvar noevent = function() {\n  exports.event.preventDefault();\n  exports.event.stopImmediatePropagation();\n};\n\nvar dragDisable = function(view) {\n  var root = view.document.documentElement,\n      selection$$1 = select(view).on(\"dragstart.drag\", noevent, true);\n  if (\"onselectstart\" in root) {\n    selection$$1.on(\"selectstart.drag\", noevent, true);\n  } else {\n    root.__noselect = root.style.MozUserSelect;\n    root.style.MozUserSelect = \"none\";\n  }\n};\n\nfunction yesdrag(view, noclick) {\n  var root = view.document.documentElement,\n      selection$$1 = select(view).on(\"dragstart.drag\", null);\n  if (noclick) {\n    selection$$1.on(\"click.drag\", noevent, true);\n    setTimeout(function() { selection$$1.on(\"click.drag\", null); }, 0);\n  }\n  if (\"onselectstart\" in root) {\n    selection$$1.on(\"selectstart.drag\", null);\n  } else {\n    root.style.MozUserSelect = root.__noselect;\n    delete root.__noselect;\n  }\n}\n\nvar constant$8 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nfunction DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {\n  this.target = target;\n  this.type = type;\n  this.subject = subject;\n  this.identifier = id;\n  this.active = active;\n  this.x = x;\n  this.y = y;\n  this.dx = dx;\n  this.dy = dy;\n  this._ = dispatch;\n}\n\nDragEvent.prototype.on = function() {\n  var value = this._.on.apply(this._, arguments);\n  return value === this._ ? this : value;\n};\n\n// Ignore right-click, since that should open the context menu.\nfunction defaultFilter() {\n  return !exports.event.button;\n}\n\nfunction defaultContainer() {\n  return this.parentNode;\n}\n\nfunction defaultSubject(d) {\n  return d == null ? {x: exports.event.x, y: exports.event.y} : d;\n}\n\nvar drag = function() {\n  var filter = defaultFilter,\n      container = defaultContainer,\n      subject = defaultSubject,\n      gestures = {},\n      listeners = dispatch(\"start\", \"drag\", \"end\"),\n      active = 0,\n      mousemoving,\n      touchending;\n\n  function drag(selection$$1) {\n    selection$$1\n        .on(\"mousedown.drag\", mousedowned)\n        .on(\"touchstart.drag\", touchstarted)\n        .on(\"touchmove.drag\", touchmoved)\n        .on(\"touchend.drag touchcancel.drag\", touchended)\n        .style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\");\n  }\n\n  function mousedowned() {\n    if (touchending || !filter.apply(this, arguments)) return;\n    var gesture = beforestart(\"mouse\", container.apply(this, arguments), mouse, this, arguments);\n    if (!gesture) return;\n    select(exports.event.view).on(\"mousemove.drag\", mousemoved, true).on(\"mouseup.drag\", mouseupped, true);\n    dragDisable(exports.event.view);\n    nopropagation();\n    mousemoving = false;\n    gesture(\"start\");\n  }\n\n  function mousemoved() {\n    noevent();\n    mousemoving = true;\n    gestures.mouse(\"drag\");\n  }\n\n  function mouseupped() {\n    select(exports.event.view).on(\"mousemove.drag mouseup.drag\", null);\n    yesdrag(exports.event.view, mousemoving);\n    noevent();\n    gestures.mouse(\"end\");\n  }\n\n  function touchstarted() {\n    if (!filter.apply(this, arguments)) return;\n    var touches$$1 = exports.event.changedTouches,\n        c = container.apply(this, arguments),\n        n = touches$$1.length, i, gesture;\n\n    for (i = 0; i < n; ++i) {\n      if (gesture = beforestart(touches$$1[i].identifier, c, touch, this, arguments)) {\n        nopropagation();\n        gesture(\"start\");\n      }\n    }\n  }\n\n  function touchmoved() {\n    var touches$$1 = exports.event.changedTouches,\n        n = touches$$1.length, i, gesture;\n\n    for (i = 0; i < n; ++i) {\n      if (gesture = gestures[touches$$1[i].identifier]) {\n        noevent();\n        gesture(\"drag\");\n      }\n    }\n  }\n\n  function touchended() {\n    var touches$$1 = exports.event.changedTouches,\n        n = touches$$1.length, i, gesture;\n\n    if (touchending) clearTimeout(touchending);\n    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!\n    for (i = 0; i < n; ++i) {\n      if (gesture = gestures[touches$$1[i].identifier]) {\n        nopropagation();\n        gesture(\"end\");\n      }\n    }\n  }\n\n  function beforestart(id, container, point, that, args) {\n    var p = point(container, id), s, dx, dy,\n        sublisteners = listeners.copy();\n\n    if (!customEvent(new DragEvent(drag, \"beforestart\", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {\n      if ((exports.event.subject = s = subject.apply(that, args)) == null) return false;\n      dx = s.x - p[0] || 0;\n      dy = s.y - p[1] || 0;\n      return true;\n    })) return;\n\n    return function gesture(type) {\n      var p0 = p, n;\n      switch (type) {\n        case \"start\": gestures[id] = gesture, n = active++; break;\n        case \"end\": delete gestures[id], --active; // nobreak\n        case \"drag\": p = point(container, id), n = active; break;\n      }\n      customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);\n    };\n  }\n\n  drag.filter = function(_) {\n    return arguments.length ? (filter = typeof _ === \"function\" ? _ : constant$8(!!_), drag) : filter;\n  };\n\n  drag.container = function(_) {\n    return arguments.length ? (container = typeof _ === \"function\" ? _ : constant$8(_), drag) : container;\n  };\n\n  drag.subject = function(_) {\n    return arguments.length ? (subject = typeof _ === \"function\" ? _ : constant$8(_), drag) : subject;\n  };\n\n  drag.on = function() {\n    var value = listeners.on.apply(listeners, arguments);\n    return value === listeners ? drag : value;\n  };\n\n  return drag;\n};\n\nvar constant$9 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nfunction x$4(d) {\n  return d[0];\n}\n\nfunction y$4(d) {\n  return d[1];\n}\n\nfunction RedBlackTree() {\n  this._ = null; // root node\n}\n\nfunction RedBlackNode(node) {\n  node.U = // parent node\n  node.C = // color - true for red, false for black\n  node.L = // left node\n  node.R = // right node\n  node.P = // previous node\n  node.N = null; // next node\n}\n\nRedBlackTree.prototype = {\n  constructor: RedBlackTree,\n\n  insert: function(after, node) {\n    var parent, grandpa, uncle;\n\n    if (after) {\n      node.P = after;\n      node.N = after.N;\n      if (after.N) after.N.P = node;\n      after.N = node;\n      if (after.R) {\n        after = after.R;\n        while (after.L) after = after.L;\n        after.L = node;\n      } else {\n        after.R = node;\n      }\n      parent = after;\n    } else if (this._) {\n      after = RedBlackFirst(this._);\n      node.P = null;\n      node.N = after;\n      after.P = after.L = node;\n      parent = after;\n    } else {\n      node.P = node.N = null;\n      this._ = node;\n      parent = null;\n    }\n    node.L = node.R = null;\n    node.U = parent;\n    node.C = true;\n\n    after = node;\n    while (parent && parent.C) {\n      grandpa = parent.U;\n      if (parent === grandpa.L) {\n        uncle = grandpa.R;\n        if (uncle && uncle.C) {\n          parent.C = uncle.C = false;\n          grandpa.C = true;\n          after = grandpa;\n        } else {\n          if (after === parent.R) {\n            RedBlackRotateLeft(this, parent);\n            after = parent;\n            parent = after.U;\n          }\n          parent.C = false;\n          grandpa.C = true;\n          RedBlackRotateRight(this, grandpa);\n        }\n      } else {\n        uncle = grandpa.L;\n        if (uncle && uncle.C) {\n          parent.C = uncle.C = false;\n          grandpa.C = true;\n          after = grandpa;\n        } else {\n          if (after === parent.L) {\n            RedBlackRotateRight(this, parent);\n            after = parent;\n            parent = after.U;\n          }\n          parent.C = false;\n          grandpa.C = true;\n          RedBlackRotateLeft(this, grandpa);\n        }\n      }\n      parent = after.U;\n    }\n    this._.C = false;\n  },\n\n  remove: function(node) {\n    if (node.N) node.N.P = node.P;\n    if (node.P) node.P.N = node.N;\n    node.N = node.P = null;\n\n    var parent = node.U,\n        sibling,\n        left = node.L,\n        right = node.R,\n        next,\n        red;\n\n    if (!left) next = right;\n    else if (!right) next = left;\n    else next = RedBlackFirst(right);\n\n    if (parent) {\n      if (parent.L === node) parent.L = next;\n      else parent.R = next;\n    } else {\n      this._ = next;\n    }\n\n    if (left && right) {\n      red = next.C;\n      next.C = node.C;\n      next.L = left;\n      left.U = next;\n      if (next !== right) {\n        parent = next.U;\n        next.U = node.U;\n        node = next.R;\n        parent.L = node;\n        next.R = right;\n        right.U = next;\n      } else {\n        next.U = parent;\n        parent = next;\n        node = next.R;\n      }\n    } else {\n      red = node.C;\n      node = next;\n    }\n\n    if (node) node.U = parent;\n    if (red) return;\n    if (node && node.C) { node.C = false; return; }\n\n    do {\n      if (node === this._) break;\n      if (node === parent.L) {\n        sibling = parent.R;\n        if (sibling.C) {\n          sibling.C = false;\n          parent.C = true;\n          RedBlackRotateLeft(this, parent);\n          sibling = parent.R;\n        }\n        if ((sibling.L && sibling.L.C)\n            || (sibling.R && sibling.R.C)) {\n          if (!sibling.R || !sibling.R.C) {\n            sibling.L.C = false;\n            sibling.C = true;\n            RedBlackRotateRight(this, sibling);\n            sibling = parent.R;\n          }\n          sibling.C = parent.C;\n          parent.C = sibling.R.C = false;\n          RedBlackRotateLeft(this, parent);\n          node = this._;\n          break;\n        }\n      } else {\n        sibling = parent.L;\n        if (sibling.C) {\n          sibling.C = false;\n          parent.C = true;\n          RedBlackRotateRight(this, parent);\n          sibling = parent.L;\n        }\n        if ((sibling.L && sibling.L.C)\n          || (sibling.R && sibling.R.C)) {\n          if (!sibling.L || !sibling.L.C) {\n            sibling.R.C = false;\n            sibling.C = true;\n            RedBlackRotateLeft(this, sibling);\n            sibling = parent.L;\n          }\n          sibling.C = parent.C;\n          parent.C = sibling.L.C = false;\n          RedBlackRotateRight(this, parent);\n          node = this._;\n          break;\n        }\n      }\n      sibling.C = true;\n      node = parent;\n      parent = parent.U;\n    } while (!node.C);\n\n    if (node) node.C = false;\n  }\n};\n\nfunction RedBlackRotateLeft(tree, node) {\n  var p = node,\n      q = node.R,\n      parent = p.U;\n\n  if (parent) {\n    if (parent.L === p) parent.L = q;\n    else parent.R = q;\n  } else {\n    tree._ = q;\n  }\n\n  q.U = parent;\n  p.U = q;\n  p.R = q.L;\n  if (p.R) p.R.U = p;\n  q.L = p;\n}\n\nfunction RedBlackRotateRight(tree, node) {\n  var p = node,\n      q = node.L,\n      parent = p.U;\n\n  if (parent) {\n    if (parent.L === p) parent.L = q;\n    else parent.R = q;\n  } else {\n    tree._ = q;\n  }\n\n  q.U = parent;\n  p.U = q;\n  p.L = q.R;\n  if (p.L) p.L.U = p;\n  q.R = p;\n}\n\nfunction RedBlackFirst(node) {\n  while (node.L) node = node.L;\n  return node;\n}\n\nfunction createEdge(left, right, v0, v1) {\n  var edge = [null, null],\n      index = edges.push(edge) - 1;\n  edge.left = left;\n  edge.right = right;\n  if (v0) setEdgeEnd(edge, left, right, v0);\n  if (v1) setEdgeEnd(edge, right, left, v1);\n  cells[left.index].halfedges.push(index);\n  cells[right.index].halfedges.push(index);\n  return edge;\n}\n\nfunction createBorderEdge(left, v0, v1) {\n  var edge = [v0, v1];\n  edge.left = left;\n  return edge;\n}\n\nfunction setEdgeEnd(edge, left, right, vertex) {\n  if (!edge[0] && !edge[1]) {\n    edge[0] = vertex;\n    edge.left = left;\n    edge.right = right;\n  } else if (edge.left === right) {\n    edge[1] = vertex;\n  } else {\n    edge[0] = vertex;\n  }\n}\n\n// Liang–Barsky line clipping.\nfunction clipEdge(edge, x0, y0, x1, y1) {\n  var a = edge[0],\n      b = edge[1],\n      ax = a[0],\n      ay = a[1],\n      bx = b[0],\n      by = b[1],\n      t0 = 0,\n      t1 = 1,\n      dx = bx - ax,\n      dy = by - ay,\n      r;\n\n  r = x0 - ax;\n  if (!dx && r > 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dx > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = x1 - ax;\n  if (!dx && r < 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dx > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  r = y0 - ay;\n  if (!dy && r > 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dy > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = y1 - ay;\n  if (!dy && r < 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dy > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?\n\n  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];\n  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];\n  return true;\n}\n\nfunction connectEdge(edge, x0, y0, x1, y1) {\n  var v1 = edge[1];\n  if (v1) return true;\n\n  var v0 = edge[0],\n      left = edge.left,\n      right = edge.right,\n      lx = left[0],\n      ly = left[1],\n      rx = right[0],\n      ry = right[1],\n      fx = (lx + rx) / 2,\n      fy = (ly + ry) / 2,\n      fm,\n      fb;\n\n  if (ry === ly) {\n    if (fx < x0 || fx >= x1) return;\n    if (lx > rx) {\n      if (!v0) v0 = [fx, y0];\n      else if (v0[1] >= y1) return;\n      v1 = [fx, y1];\n    } else {\n      if (!v0) v0 = [fx, y1];\n      else if (v0[1] < y0) return;\n      v1 = [fx, y0];\n    }\n  } else {\n    fm = (lx - rx) / (ry - ly);\n    fb = fy - fm * fx;\n    if (fm < -1 || fm > 1) {\n      if (lx > rx) {\n        if (!v0) v0 = [(y0 - fb) / fm, y0];\n        else if (v0[1] >= y1) return;\n        v1 = [(y1 - fb) / fm, y1];\n      } else {\n        if (!v0) v0 = [(y1 - fb) / fm, y1];\n        else if (v0[1] < y0) return;\n        v1 = [(y0 - fb) / fm, y0];\n      }\n    } else {\n      if (ly < ry) {\n        if (!v0) v0 = [x0, fm * x0 + fb];\n        else if (v0[0] >= x1) return;\n        v1 = [x1, fm * x1 + fb];\n      } else {\n        if (!v0) v0 = [x1, fm * x1 + fb];\n        else if (v0[0] < x0) return;\n        v1 = [x0, fm * x0 + fb];\n      }\n    }\n  }\n\n  edge[0] = v0;\n  edge[1] = v1;\n  return true;\n}\n\nfunction clipEdges(x0, y0, x1, y1) {\n  var i = edges.length,\n      edge;\n\n  while (i--) {\n    if (!connectEdge(edge = edges[i], x0, y0, x1, y1)\n        || !clipEdge(edge, x0, y0, x1, y1)\n        || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon$3\n            || Math.abs(edge[0][1] - edge[1][1]) > epsilon$3)) {\n      delete edges[i];\n    }\n  }\n}\n\nfunction createCell(site) {\n  return cells[site.index] = {\n    site: site,\n    halfedges: []\n  };\n}\n\nfunction cellHalfedgeAngle(cell, edge) {\n  var site = cell.site,\n      va = edge.left,\n      vb = edge.right;\n  if (site === vb) vb = va, va = site;\n  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);\n  if (site === va) va = edge[1], vb = edge[0];\n  else va = edge[0], vb = edge[1];\n  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);\n}\n\nfunction cellHalfedgeStart(cell, edge) {\n  return edge[+(edge.left !== cell.site)];\n}\n\nfunction cellHalfedgeEnd(cell, edge) {\n  return edge[+(edge.left === cell.site)];\n}\n\nfunction sortCellHalfedges() {\n  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {\n    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {\n      var index = new Array(m),\n          array = new Array(m);\n      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);\n      index.sort(function(i, j) { return array[j] - array[i]; });\n      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];\n      for (j = 0; j < m; ++j) halfedges[j] = array[j];\n    }\n  }\n}\n\nfunction clipCells(x0, y0, x1, y1) {\n  var nCells = cells.length,\n      iCell,\n      cell,\n      site,\n      iHalfedge,\n      halfedges,\n      nHalfedges,\n      start,\n      startX,\n      startY,\n      end,\n      endX,\n      endY,\n      cover = true;\n\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    if (cell = cells[iCell]) {\n      site = cell.site;\n      halfedges = cell.halfedges;\n      iHalfedge = halfedges.length;\n\n      // Remove any dangling clipped edges.\n      while (iHalfedge--) {\n        if (!edges[halfedges[iHalfedge]]) {\n          halfedges.splice(iHalfedge, 1);\n        }\n      }\n\n      // Insert any border edges as necessary.\n      iHalfedge = 0, nHalfedges = halfedges.length;\n      while (iHalfedge < nHalfedges) {\n        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];\n        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];\n        if (Math.abs(endX - startX) > epsilon$3 || Math.abs(endY - startY) > epsilon$3) {\n          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,\n              Math.abs(endX - x0) < epsilon$3 && y1 - endY > epsilon$3 ? [x0, Math.abs(startX - x0) < epsilon$3 ? startY : y1]\n              : Math.abs(endY - y1) < epsilon$3 && x1 - endX > epsilon$3 ? [Math.abs(startY - y1) < epsilon$3 ? startX : x1, y1]\n              : Math.abs(endX - x1) < epsilon$3 && endY - y0 > epsilon$3 ? [x1, Math.abs(startX - x1) < epsilon$3 ? startY : y0]\n              : Math.abs(endY - y0) < epsilon$3 && endX - x0 > epsilon$3 ? [Math.abs(startY - y0) < epsilon$3 ? startX : x0, y0]\n              : null)) - 1);\n          ++nHalfedges;\n        }\n      }\n\n      if (nHalfedges) cover = false;\n    }\n  }\n\n  // If there weren’t any edges, have the closest site cover the extent.\n  // It doesn’t matter which corner of the extent we measure!\n  if (cover) {\n    var dx, dy, d2, dc = Infinity;\n\n    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {\n      if (cell = cells[iCell]) {\n        site = cell.site;\n        dx = site[0] - x0;\n        dy = site[1] - y0;\n        d2 = dx * dx + dy * dy;\n        if (d2 < dc) dc = d2, cover = cell;\n      }\n    }\n\n    if (cover) {\n      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];\n      cover.halfedges.push(\n        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,\n        edges.push(createBorderEdge(site, v01, v11)) - 1,\n        edges.push(createBorderEdge(site, v11, v10)) - 1,\n        edges.push(createBorderEdge(site, v10, v00)) - 1\n      );\n    }\n  }\n\n  // Lastly delete any cells with no edges; these were entirely clipped.\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    if (cell = cells[iCell]) {\n      if (!cell.halfedges.length) {\n        delete cells[iCell];\n      }\n    }\n  }\n}\n\nvar circlePool = [];\n\nvar firstCircle;\n\nfunction Circle() {\n  RedBlackNode(this);\n  this.x =\n  this.y =\n  this.arc =\n  this.site =\n  this.cy = null;\n}\n\nfunction attachCircle(arc) {\n  var lArc = arc.P,\n      rArc = arc.N;\n\n  if (!lArc || !rArc) return;\n\n  var lSite = lArc.site,\n      cSite = arc.site,\n      rSite = rArc.site;\n\n  if (lSite === rSite) return;\n\n  var bx = cSite[0],\n      by = cSite[1],\n      ax = lSite[0] - bx,\n      ay = lSite[1] - by,\n      cx = rSite[0] - bx,\n      cy = rSite[1] - by;\n\n  var d = 2 * (ax * cy - ay * cx);\n  if (d >= -epsilon2$1) return;\n\n  var ha = ax * ax + ay * ay,\n      hc = cx * cx + cy * cy,\n      x = (cy * ha - ay * hc) / d,\n      y = (ax * hc - cx * ha) / d;\n\n  var circle = circlePool.pop() || new Circle;\n  circle.arc = arc;\n  circle.site = cSite;\n  circle.x = x + bx;\n  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom\n\n  arc.circle = circle;\n\n  var before = null,\n      node = circles._;\n\n  while (node) {\n    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {\n      if (node.L) node = node.L;\n      else { before = node.P; break; }\n    } else {\n      if (node.R) node = node.R;\n      else { before = node; break; }\n    }\n  }\n\n  circles.insert(before, circle);\n  if (!before) firstCircle = circle;\n}\n\nfunction detachCircle(arc) {\n  var circle = arc.circle;\n  if (circle) {\n    if (!circle.P) firstCircle = circle.N;\n    circles.remove(circle);\n    circlePool.push(circle);\n    RedBlackNode(circle);\n    arc.circle = null;\n  }\n}\n\nvar beachPool = [];\n\nfunction Beach() {\n  RedBlackNode(this);\n  this.edge =\n  this.site =\n  this.circle = null;\n}\n\nfunction createBeach(site) {\n  var beach = beachPool.pop() || new Beach;\n  beach.site = site;\n  return beach;\n}\n\nfunction detachBeach(beach) {\n  detachCircle(beach);\n  beaches.remove(beach);\n  beachPool.push(beach);\n  RedBlackNode(beach);\n}\n\nfunction removeBeach(beach) {\n  var circle = beach.circle,\n      x = circle.x,\n      y = circle.cy,\n      vertex = [x, y],\n      previous = beach.P,\n      next = beach.N,\n      disappearing = [beach];\n\n  detachBeach(beach);\n\n  var lArc = previous;\n  while (lArc.circle\n      && Math.abs(x - lArc.circle.x) < epsilon$3\n      && Math.abs(y - lArc.circle.cy) < epsilon$3) {\n    previous = lArc.P;\n    disappearing.unshift(lArc);\n    detachBeach(lArc);\n    lArc = previous;\n  }\n\n  disappearing.unshift(lArc);\n  detachCircle(lArc);\n\n  var rArc = next;\n  while (rArc.circle\n      && Math.abs(x - rArc.circle.x) < epsilon$3\n      && Math.abs(y - rArc.circle.cy) < epsilon$3) {\n    next = rArc.N;\n    disappearing.push(rArc);\n    detachBeach(rArc);\n    rArc = next;\n  }\n\n  disappearing.push(rArc);\n  detachCircle(rArc);\n\n  var nArcs = disappearing.length,\n      iArc;\n  for (iArc = 1; iArc < nArcs; ++iArc) {\n    rArc = disappearing[iArc];\n    lArc = disappearing[iArc - 1];\n    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);\n  }\n\n  lArc = disappearing[0];\n  rArc = disappearing[nArcs - 1];\n  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);\n\n  attachCircle(lArc);\n  attachCircle(rArc);\n}\n\nfunction addBeach(site) {\n  var x = site[0],\n      directrix = site[1],\n      lArc,\n      rArc,\n      dxl,\n      dxr,\n      node = beaches._;\n\n  while (node) {\n    dxl = leftBreakPoint(node, directrix) - x;\n    if (dxl > epsilon$3) node = node.L; else {\n      dxr = x - rightBreakPoint(node, directrix);\n      if (dxr > epsilon$3) {\n        if (!node.R) {\n          lArc = node;\n          break;\n        }\n        node = node.R;\n      } else {\n        if (dxl > -epsilon$3) {\n          lArc = node.P;\n          rArc = node;\n        } else if (dxr > -epsilon$3) {\n          lArc = node;\n          rArc = node.N;\n        } else {\n          lArc = rArc = node;\n        }\n        break;\n      }\n    }\n  }\n\n  createCell(site);\n  var newArc = createBeach(site);\n  beaches.insert(lArc, newArc);\n\n  if (!lArc && !rArc) return;\n\n  if (lArc === rArc) {\n    detachCircle(lArc);\n    rArc = createBeach(lArc.site);\n    beaches.insert(newArc, rArc);\n    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);\n    attachCircle(lArc);\n    attachCircle(rArc);\n    return;\n  }\n\n  if (!rArc) { // && lArc\n    newArc.edge = createEdge(lArc.site, newArc.site);\n    return;\n  }\n\n  // else lArc !== rArc\n  detachCircle(lArc);\n  detachCircle(rArc);\n\n  var lSite = lArc.site,\n      ax = lSite[0],\n      ay = lSite[1],\n      bx = site[0] - ax,\n      by = site[1] - ay,\n      rSite = rArc.site,\n      cx = rSite[0] - ax,\n      cy = rSite[1] - ay,\n      d = 2 * (bx * cy - by * cx),\n      hb = bx * bx + by * by,\n      hc = cx * cx + cy * cy,\n      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];\n\n  setEdgeEnd(rArc.edge, lSite, rSite, vertex);\n  newArc.edge = createEdge(lSite, site, null, vertex);\n  rArc.edge = createEdge(site, rSite, null, vertex);\n  attachCircle(lArc);\n  attachCircle(rArc);\n}\n\nfunction leftBreakPoint(arc, directrix) {\n  var site = arc.site,\n      rfocx = site[0],\n      rfocy = site[1],\n      pby2 = rfocy - directrix;\n\n  if (!pby2) return rfocx;\n\n  var lArc = arc.P;\n  if (!lArc) return -Infinity;\n\n  site = lArc.site;\n  var lfocx = site[0],\n      lfocy = site[1],\n      plby2 = lfocy - directrix;\n\n  if (!plby2) return lfocx;\n\n  var hl = lfocx - rfocx,\n      aby2 = 1 / pby2 - 1 / plby2,\n      b = hl / plby2;\n\n  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;\n\n  return (rfocx + lfocx) / 2;\n}\n\nfunction rightBreakPoint(arc, directrix) {\n  var rArc = arc.N;\n  if (rArc) return leftBreakPoint(rArc, directrix);\n  var site = arc.site;\n  return site[1] === directrix ? site[0] : Infinity;\n}\n\nvar epsilon$3 = 1e-6;\nvar epsilon2$1 = 1e-12;\nvar beaches;\nvar cells;\nvar circles;\nvar edges;\n\nfunction triangleArea(a, b, c) {\n  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);\n}\n\nfunction lexicographic(a, b) {\n  return b[1] - a[1]\n      || b[0] - a[0];\n}\n\nfunction Diagram(sites, extent) {\n  var site = sites.sort(lexicographic).pop(),\n      x,\n      y,\n      circle;\n\n  edges = [];\n  cells = new Array(sites.length);\n  beaches = new RedBlackTree;\n  circles = new RedBlackTree;\n\n  while (true) {\n    circle = firstCircle;\n    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {\n      if (site[0] !== x || site[1] !== y) {\n        addBeach(site);\n        x = site[0], y = site[1];\n      }\n      site = sites.pop();\n    } else if (circle) {\n      removeBeach(circle.arc);\n    } else {\n      break;\n    }\n  }\n\n  sortCellHalfedges();\n\n  if (extent) {\n    var x0 = +extent[0][0],\n        y0 = +extent[0][1],\n        x1 = +extent[1][0],\n        y1 = +extent[1][1];\n    clipEdges(x0, y0, x1, y1);\n    clipCells(x0, y0, x1, y1);\n  }\n\n  this.edges = edges;\n  this.cells = cells;\n\n  beaches =\n  circles =\n  edges =\n  cells = null;\n}\n\nDiagram.prototype = {\n  constructor: Diagram,\n\n  polygons: function() {\n    var edges = this.edges;\n\n    return this.cells.map(function(cell) {\n      var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });\n      polygon.data = cell.site.data;\n      return polygon;\n    });\n  },\n\n  triangles: function() {\n    var triangles = [],\n        edges = this.edges;\n\n    this.cells.forEach(function(cell, i) {\n      var site = cell.site,\n          halfedges = cell.halfedges,\n          j = -1,\n          m = halfedges.length,\n          s0,\n          e1 = edges[halfedges[m - 1]],\n          s1 = e1.left === site ? e1.right : e1.left;\n\n      while (++j < m) {\n        s0 = s1;\n        e1 = edges[halfedges[j]];\n        s1 = e1.left === site ? e1.right : e1.left;\n        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {\n          triangles.push([site.data, s0.data, s1.data]);\n        }\n      }\n    });\n\n    return triangles;\n  },\n\n  links: function() {\n    return this.edges.filter(function(edge) {\n      return edge.right;\n    }).map(function(edge) {\n      return {\n        source: edge.left.data,\n        target: edge.right.data\n      };\n    });\n  },\n\n  find: function(x, y, radius) {\n    var that = this,\n        i0, i1 = that._found || 0,\n        cell = that.cells[i1] || that.cells[i1 = 0],\n        dx = x - cell.site[0],\n        dy = y - cell.site[1],\n        d2 = dx * dx + dy * dy;\n\n    do {\n      cell = that.cells[i0 = i1], i1 = null;\n      cell.halfedges.forEach(function(e) {\n        var edge = that.edges[e], v = edge.left;\n        if ((v === cell.site || !v) && !(v = edge.right)) return;\n        var vx = x - v[0],\n            vy = y - v[1],\n            v2 = vx * vx + vy * vy;\n        if (v2 < d2) d2 = v2, i1 = v.index;\n      });\n    } while (i1 !== null);\n\n    that._found = i0;\n\n    return radius == null || d2 <= radius * radius ? cell.site : null;\n  }\n};\n\nvar voronoi = function() {\n  var x$$1 = x$4,\n      y$$1 = y$4,\n      extent = null;\n\n  function voronoi(data) {\n    return new Diagram(data.map(function(d, i) {\n      var s = [Math.round(x$$1(d, i, data) / epsilon$3) * epsilon$3, Math.round(y$$1(d, i, data) / epsilon$3) * epsilon$3];\n      s.index = i;\n      s.data = d;\n      return s;\n    }), extent);\n  }\n\n  voronoi.polygons = function(data) {\n    return voronoi(data).polygons();\n  };\n\n  voronoi.links = function(data) {\n    return voronoi(data).links();\n  };\n\n  voronoi.triangles = function(data) {\n    return voronoi(data).triangles();\n  };\n\n  voronoi.x = function(_) {\n    return arguments.length ? (x$$1 = typeof _ === \"function\" ? _ : constant$9(+_), voronoi) : x$$1;\n  };\n\n  voronoi.y = function(_) {\n    return arguments.length ? (y$$1 = typeof _ === \"function\" ? _ : constant$9(+_), voronoi) : y$$1;\n  };\n\n  voronoi.extent = function(_) {\n    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];\n  };\n\n  voronoi.size = function(_) {\n    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];\n  };\n\n  return voronoi;\n};\n\nvar constant$10 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nfunction ZoomEvent(target, type, transform) {\n  this.target = target;\n  this.type = type;\n  this.transform = transform;\n}\n\nfunction Transform(k, x, y) {\n  this.k = k;\n  this.x = x;\n  this.y = y;\n}\n\nTransform.prototype = {\n  constructor: Transform,\n  scale: function(k) {\n    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);\n  },\n  translate: function(x, y) {\n    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);\n  },\n  apply: function(point) {\n    return [point[0] * this.k + this.x, point[1] * this.k + this.y];\n  },\n  applyX: function(x) {\n    return x * this.k + this.x;\n  },\n  applyY: function(y) {\n    return y * this.k + this.y;\n  },\n  invert: function(location) {\n    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];\n  },\n  invertX: function(x) {\n    return (x - this.x) / this.k;\n  },\n  invertY: function(y) {\n    return (y - this.y) / this.k;\n  },\n  rescaleX: function(x) {\n    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));\n  },\n  rescaleY: function(y) {\n    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));\n  },\n  toString: function() {\n    return \"translate(\" + this.x + \",\" + this.y + \") scale(\" + this.k + \")\";\n  }\n};\n\nvar identity$6 = new Transform(1, 0, 0);\n\ntransform.prototype = Transform.prototype;\n\nfunction transform(node) {\n  return node.__zoom || identity$6;\n}\n\nfunction nopropagation$1() {\n  exports.event.stopImmediatePropagation();\n}\n\nvar noevent$1 = function() {\n  exports.event.preventDefault();\n  exports.event.stopImmediatePropagation();\n};\n\n// Ignore right-click, since that should open the context menu.\nfunction defaultFilter$1() {\n  return !exports.event.button;\n}\n\nfunction defaultExtent() {\n  var e = this, w, h;\n  if (e instanceof SVGElement) {\n    e = e.ownerSVGElement || e;\n    w = e.width.baseVal.value;\n    h = e.height.baseVal.value;\n  } else {\n    w = e.clientWidth;\n    h = e.clientHeight;\n  }\n  return [[0, 0], [w, h]];\n}\n\nfunction defaultTransform() {\n  return this.__zoom || identity$6;\n}\n\nvar zoom = function() {\n  var filter = defaultFilter$1,\n      extent = defaultExtent,\n      k0 = 0,\n      k1 = Infinity,\n      x0 = -k1,\n      x1 = k1,\n      y0 = x0,\n      y1 = x1,\n      duration = 250,\n      gestures = [],\n      listeners = dispatch(\"start\", \"zoom\", \"end\"),\n      touchstarting,\n      touchending,\n      touchDelay = 500,\n      wheelDelay = 150;\n\n  function zoom(selection$$1) {\n    selection$$1\n        .on(\"wheel.zoom\", wheeled)\n        .on(\"mousedown.zoom\", mousedowned)\n        .on(\"dblclick.zoom\", dblclicked)\n        .on(\"touchstart.zoom\", touchstarted)\n        .on(\"touchmove.zoom\", touchmoved)\n        .on(\"touchend.zoom touchcancel.zoom\", touchended)\n        .style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\")\n        .property(\"__zoom\", defaultTransform);\n  }\n\n  zoom.transform = function(collection, transform) {\n    var selection$$1 = collection.selection ? collection.selection() : collection;\n    selection$$1.property(\"__zoom\", defaultTransform);\n    if (collection !== selection$$1) {\n      schedule(collection, transform);\n    } else {\n      selection$$1.interrupt().each(function() {\n        gesture(this, arguments)\n            .start()\n            .zoom(null, typeof transform === \"function\" ? transform.apply(this, arguments) : transform)\n            .end();\n      });\n    }\n  };\n\n  zoom.scaleBy = function(selection$$1, k) {\n    zoom.scaleTo(selection$$1, function() {\n      var k0 = this.__zoom.k,\n          k1 = typeof k === \"function\" ? k.apply(this, arguments) : k;\n      return k0 * k1;\n    });\n  };\n\n  zoom.scaleTo = function(selection$$1, k) {\n    zoom.transform(selection$$1, function() {\n      var e = extent.apply(this, arguments),\n          t0 = this.__zoom,\n          p0 = centroid(e),\n          p1 = t0.invert(p0),\n          k1 = typeof k === \"function\" ? k.apply(this, arguments) : k;\n      return constrain(translate(scale(t0, k1), p0, p1), e);\n    });\n  };\n\n  zoom.translateBy = function(selection$$1, x, y) {\n    zoom.transform(selection$$1, function() {\n      return constrain(this.__zoom.translate(\n        typeof x === \"function\" ? x.apply(this, arguments) : x,\n        typeof y === \"function\" ? y.apply(this, arguments) : y\n      ), extent.apply(this, arguments));\n    });\n  };\n\n  function scale(transform, k) {\n    k = Math.max(k0, Math.min(k1, k));\n    return k === transform.k ? transform : new Transform(k, transform.x, transform.y);\n  }\n\n  function translate(transform, p0, p1) {\n    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;\n    return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);\n  }\n\n  function constrain(transform, extent) {\n    var dx = Math.min(0, transform.invertX(extent[0][0]) - x0) || Math.max(0, transform.invertX(extent[1][0]) - x1),\n        dy = Math.min(0, transform.invertY(extent[0][1]) - y0) || Math.max(0, transform.invertY(extent[1][1]) - y1);\n    return dx || dy ? transform.translate(dx, dy) : transform;\n  }\n\n  function centroid(extent) {\n    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];\n  }\n\n  function schedule(transition$$1, transform, center) {\n    transition$$1\n        .on(\"start.zoom\", function() { gesture(this, arguments).start(); })\n        .on(\"interrupt.zoom end.zoom\", function() { gesture(this, arguments).end(); })\n        .tween(\"zoom\", function() {\n          var that = this,\n              args = arguments,\n              g = gesture(that, args),\n              e = extent.apply(that, args),\n              p = center || centroid(e),\n              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),\n              a = that.__zoom,\n              b = typeof transform === \"function\" ? transform.apply(that, args) : transform,\n              i = interpolateZoom(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));\n          return function(t) {\n            if (t === 1) t = b; // Avoid rounding error on end.\n            else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }\n            g.zoom(null, t);\n          };\n        });\n  }\n\n  function gesture(that, args) {\n    for (var i = 0, n = gestures.length, g; i < n; ++i) {\n      if ((g = gestures[i]).that === that) {\n        return g;\n      }\n    }\n    return new Gesture(that, args);\n  }\n\n  function Gesture(that, args) {\n    this.that = that;\n    this.args = args;\n    this.index = -1;\n    this.active = 0;\n    this.extent = extent.apply(that, args);\n  }\n\n  Gesture.prototype = {\n    start: function() {\n      if (++this.active === 1) {\n        this.index = gestures.push(this) - 1;\n        this.emit(\"start\");\n      }\n      return this;\n    },\n    zoom: function(key, transform) {\n      if (this.mouse && key !== \"mouse\") this.mouse[1] = transform.invert(this.mouse[0]);\n      if (this.touch0 && key !== \"touch\") this.touch0[1] = transform.invert(this.touch0[0]);\n      if (this.touch1 && key !== \"touch\") this.touch1[1] = transform.invert(this.touch1[0]);\n      this.that.__zoom = transform;\n      this.emit(\"zoom\");\n      return this;\n    },\n    end: function() {\n      if (--this.active === 0) {\n        gestures.splice(this.index, 1);\n        this.index = -1;\n        this.emit(\"end\");\n      }\n      return this;\n    },\n    emit: function(type) {\n      customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);\n    }\n  };\n\n  function wheeled() {\n    if (!filter.apply(this, arguments)) return;\n    var g = gesture(this, arguments),\n        t = this.__zoom,\n        k = Math.max(k0, Math.min(k1, t.k * Math.pow(2, -exports.event.deltaY * (exports.event.deltaMode ? 120 : 1) / 500))),\n        p = mouse(this);\n\n    // If the mouse is in the same location as before, reuse it.\n    // If there were recent wheel events, reset the wheel idle timeout.\n    if (g.wheel) {\n      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {\n        g.mouse[1] = t.invert(g.mouse[0] = p);\n      }\n      clearTimeout(g.wheel);\n    }\n\n    // If this wheel event won’t trigger a transform change, ignore it.\n    else if (t.k === k) return;\n\n    // Otherwise, capture the mouse point and location at the start.\n    else {\n      g.mouse = [p, t.invert(p)];\n      interrupt(this);\n      g.start();\n    }\n\n    noevent$1();\n    g.wheel = setTimeout(wheelidled, wheelDelay);\n    g.zoom(\"mouse\", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent));\n\n    function wheelidled() {\n      g.wheel = null;\n      g.end();\n    }\n  }\n\n  function mousedowned() {\n    if (touchending || !filter.apply(this, arguments)) return;\n    var g = gesture(this, arguments),\n        v = select(exports.event.view).on(\"mousemove.zoom\", mousemoved, true).on(\"mouseup.zoom\", mouseupped, true),\n        p = mouse(this);\n\n    dragDisable(exports.event.view);\n    nopropagation$1();\n    g.mouse = [p, this.__zoom.invert(p)];\n    interrupt(this);\n    g.start();\n\n    function mousemoved() {\n      noevent$1();\n      g.moved = true;\n      g.zoom(\"mouse\", constrain(translate(g.that.__zoom, g.mouse[0] = mouse(g.that), g.mouse[1]), g.extent));\n    }\n\n    function mouseupped() {\n      v.on(\"mousemove.zoom mouseup.zoom\", null);\n      yesdrag(exports.event.view, g.moved);\n      noevent$1();\n      g.end();\n    }\n  }\n\n  function dblclicked() {\n    if (!filter.apply(this, arguments)) return;\n    var t0 = this.__zoom,\n        p0 = mouse(this),\n        p1 = t0.invert(p0),\n        k1 = t0.k * (exports.event.shiftKey ? 0.5 : 2),\n        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments));\n\n    noevent$1();\n    if (duration > 0) select(this).transition().duration(duration).call(schedule, t1, p0);\n    else select(this).call(zoom.transform, t1);\n  }\n\n  function touchstarted() {\n    if (!filter.apply(this, arguments)) return;\n    var g = gesture(this, arguments),\n        touches$$1 = exports.event.changedTouches,\n        n = touches$$1.length, i, t, p;\n\n    nopropagation$1();\n    for (i = 0; i < n; ++i) {\n      t = touches$$1[i], p = touch(this, touches$$1, t.identifier);\n      p = [p, this.__zoom.invert(p), t.identifier];\n      if (!g.touch0) g.touch0 = p;\n      else if (!g.touch1) g.touch1 = p;\n    }\n    if (touchstarting) {\n      touchstarting = clearTimeout(touchstarting);\n      if (!g.touch1) return g.end(), dblclicked.apply(this, arguments);\n    }\n    if (exports.event.touches.length === n) {\n      touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);\n      interrupt(this);\n      g.start();\n    }\n  }\n\n  function touchmoved() {\n    var g = gesture(this, arguments),\n        touches$$1 = exports.event.changedTouches,\n        n = touches$$1.length, i, t, p, l;\n\n    noevent$1();\n    if (touchstarting) touchstarting = clearTimeout(touchstarting);\n    for (i = 0; i < n; ++i) {\n      t = touches$$1[i], p = touch(this, touches$$1, t.identifier);\n      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;\n      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;\n    }\n    t = g.that.__zoom;\n    if (g.touch1) {\n      var p0 = g.touch0[0], l0 = g.touch0[1],\n          p1 = g.touch1[0], l1 = g.touch1[1],\n          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,\n          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;\n      t = scale(t, Math.sqrt(dp / dl));\n      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];\n      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];\n    }\n    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];\n    else return;\n    g.zoom(\"touch\", constrain(translate(t, p, l), g.extent));\n  }\n\n  function touchended() {\n    var g = gesture(this, arguments),\n        touches$$1 = exports.event.changedTouches,\n        n = touches$$1.length, i, t;\n\n    nopropagation$1();\n    if (touchending) clearTimeout(touchending);\n    touchending = setTimeout(function() { touchending = null; }, touchDelay);\n    for (i = 0; i < n; ++i) {\n      t = touches$$1[i];\n      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;\n      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;\n    }\n    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;\n    if (!g.touch0) g.end();\n  }\n\n  zoom.filter = function(_) {\n    return arguments.length ? (filter = typeof _ === \"function\" ? _ : constant$10(!!_), zoom) : filter;\n  };\n\n  zoom.extent = function(_) {\n    return arguments.length ? (extent = typeof _ === \"function\" ? _ : constant$10([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;\n  };\n\n  zoom.scaleExtent = function(_) {\n    return arguments.length ? (k0 = +_[0], k1 = +_[1], zoom) : [k0, k1];\n  };\n\n  zoom.translateExtent = function(_) {\n    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], zoom) : [[x0, y0], [x1, y1]];\n  };\n\n  zoom.duration = function(_) {\n    return arguments.length ? (duration = +_, zoom) : duration;\n  };\n\n  zoom.on = function() {\n    var value = listeners.on.apply(listeners, arguments);\n    return value === listeners ? zoom : value;\n  };\n\n  return zoom;\n};\n\nvar constant$11 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nvar BrushEvent = function(target, type, selection) {\n  this.target = target;\n  this.type = type;\n  this.selection = selection;\n};\n\nfunction nopropagation$2() {\n  exports.event.stopImmediatePropagation();\n}\n\nvar noevent$2 = function() {\n  exports.event.preventDefault();\n  exports.event.stopImmediatePropagation();\n};\n\nvar MODE_DRAG = {name: \"drag\"};\nvar MODE_SPACE = {name: \"space\"};\nvar MODE_HANDLE = {name: \"handle\"};\nvar MODE_CENTER = {name: \"center\"};\n\nvar X = {\n  name: \"x\",\n  handles: [\"e\", \"w\"].map(type$1),\n  input: function(x, e) { return x && [[x[0], e[0][1]], [x[1], e[1][1]]]; },\n  output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }\n};\n\nvar Y = {\n  name: \"y\",\n  handles: [\"n\", \"s\"].map(type$1),\n  input: function(y, e) { return y && [[e[0][0], y[0]], [e[1][0], y[1]]]; },\n  output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }\n};\n\nvar XY = {\n  name: \"xy\",\n  handles: [\"n\", \"e\", \"s\", \"w\", \"nw\", \"ne\", \"se\", \"sw\"].map(type$1),\n  input: function(xy) { return xy; },\n  output: function(xy) { return xy; }\n};\n\nvar cursors = {\n  overlay: \"crosshair\",\n  selection: \"move\",\n  n: \"ns-resize\",\n  e: \"ew-resize\",\n  s: \"ns-resize\",\n  w: \"ew-resize\",\n  nw: \"nwse-resize\",\n  ne: \"nesw-resize\",\n  se: \"nwse-resize\",\n  sw: \"nesw-resize\"\n};\n\nvar flipX = {\n  e: \"w\",\n  w: \"e\",\n  nw: \"ne\",\n  ne: \"nw\",\n  se: \"sw\",\n  sw: \"se\"\n};\n\nvar flipY = {\n  n: \"s\",\n  s: \"n\",\n  nw: \"sw\",\n  ne: \"se\",\n  se: \"ne\",\n  sw: \"nw\"\n};\n\nvar signsX = {\n  overlay: +1,\n  selection: +1,\n  n: null,\n  e: +1,\n  s: null,\n  w: -1,\n  nw: -1,\n  ne: +1,\n  se: +1,\n  sw: -1\n};\n\nvar signsY = {\n  overlay: +1,\n  selection: +1,\n  n: -1,\n  e: null,\n  s: +1,\n  w: null,\n  nw: -1,\n  ne: -1,\n  se: +1,\n  sw: +1\n};\n\nfunction type$1(t) {\n  return {type: t};\n}\n\n// Ignore right-click, since that should open the context menu.\nfunction defaultFilter$2() {\n  return !exports.event.button;\n}\n\nfunction defaultExtent$1() {\n  var svg = this.ownerSVGElement || this;\n  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];\n}\n\n// Like d3.local, but with the name “__brush” rather than auto-generated.\nfunction local$1(node) {\n  while (!node.__brush) if (!(node = node.parentNode)) return;\n  return node.__brush;\n}\n\nfunction empty$1(extent) {\n  return extent[0][0] === extent[1][0]\n      || extent[0][1] === extent[1][1];\n}\n\nfunction brushSelection(node) {\n  var state = node.__brush;\n  return state ? state.dim.output(state.selection) : null;\n}\n\nfunction brushX() {\n  return brush$1(X);\n}\n\nfunction brushY() {\n  return brush$1(Y);\n}\n\nvar brush = function() {\n  return brush$1(XY);\n};\n\nfunction brush$1(dim) {\n  var extent = defaultExtent$1,\n      filter = defaultFilter$2,\n      listeners = dispatch(brush, \"start\", \"brush\", \"end\"),\n      handleSize = 6,\n      touchending;\n\n  function brush(group) {\n    var overlay = group\n        .property(\"__brush\", initialize)\n      .selectAll(\".overlay\")\n      .data([type$1(\"overlay\")]);\n\n    overlay.enter().append(\"rect\")\n        .attr(\"class\", \"overlay\")\n        .attr(\"pointer-events\", \"all\")\n        .attr(\"cursor\", cursors.overlay)\n      .merge(overlay)\n        .each(function() {\n          var extent = local$1(this).extent;\n          select(this)\n              .attr(\"x\", extent[0][0])\n              .attr(\"y\", extent[0][1])\n              .attr(\"width\", extent[1][0] - extent[0][0])\n              .attr(\"height\", extent[1][1] - extent[0][1]);\n        });\n\n    group.selectAll(\".selection\")\n      .data([type$1(\"selection\")])\n      .enter().append(\"rect\")\n        .attr(\"class\", \"selection\")\n        .attr(\"cursor\", cursors.selection)\n        .attr(\"fill\", \"#777\")\n        .attr(\"fill-opacity\", 0.3)\n        .attr(\"stroke\", \"#fff\")\n        .attr(\"shape-rendering\", \"crispEdges\");\n\n    var handle = group.selectAll(\".handle\")\n      .data(dim.handles, function(d) { return d.type; });\n\n    handle.exit().remove();\n\n    handle.enter().append(\"rect\")\n        .attr(\"class\", function(d) { return \"handle handle--\" + d.type; })\n        .attr(\"cursor\", function(d) { return cursors[d.type]; });\n\n    group\n        .each(redraw)\n        .attr(\"fill\", \"none\")\n        .attr(\"pointer-events\", \"all\")\n        .style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\")\n        .on(\"mousedown.brush touchstart.brush\", started);\n  }\n\n  brush.move = function(group, selection$$1) {\n    if (group.selection) {\n      group\n          .on(\"start.brush\", function() { emitter(this, arguments).beforestart().start(); })\n          .on(\"interrupt.brush end.brush\", function() { emitter(this, arguments).end(); })\n          .tween(\"brush\", function() {\n            var that = this,\n                state = that.__brush,\n                emit = emitter(that, arguments),\n                selection0 = state.selection,\n                selection1 = dim.input(typeof selection$$1 === \"function\" ? selection$$1.apply(this, arguments) : selection$$1, state.extent),\n                i = interpolate(selection0, selection1);\n\n            function tween(t) {\n              state.selection = t === 1 && empty$1(selection1) ? null : i(t);\n              redraw.call(that);\n              emit.brush();\n            }\n\n            return selection0 && selection1 ? tween : tween(1);\n          });\n    } else {\n      group\n          .each(function() {\n            var that = this,\n                args = arguments,\n                state = that.__brush,\n                selection1 = dim.input(typeof selection$$1 === \"function\" ? selection$$1.apply(that, args) : selection$$1, state.extent),\n                emit = emitter(that, args).beforestart();\n\n            interrupt(that);\n            state.selection = selection1 == null || empty$1(selection1) ? null : selection1;\n            redraw.call(that);\n            emit.start().brush().end();\n          });\n    }\n  };\n\n  function redraw() {\n    var group = select(this),\n        selection$$1 = local$1(this).selection;\n\n    if (selection$$1) {\n      group.selectAll(\".selection\")\n          .style(\"display\", null)\n          .attr(\"x\", selection$$1[0][0])\n          .attr(\"y\", selection$$1[0][1])\n          .attr(\"width\", selection$$1[1][0] - selection$$1[0][0])\n          .attr(\"height\", selection$$1[1][1] - selection$$1[0][1]);\n\n      group.selectAll(\".handle\")\n          .style(\"display\", null)\n          .attr(\"x\", function(d) { return d.type[d.type.length - 1] === \"e\" ? selection$$1[1][0] - handleSize / 2 : selection$$1[0][0] - handleSize / 2; })\n          .attr(\"y\", function(d) { return d.type[0] === \"s\" ? selection$$1[1][1] - handleSize / 2 : selection$$1[0][1] - handleSize / 2; })\n          .attr(\"width\", function(d) { return d.type === \"n\" || d.type === \"s\" ? selection$$1[1][0] - selection$$1[0][0] + handleSize : handleSize; })\n          .attr(\"height\", function(d) { return d.type === \"e\" || d.type === \"w\" ? selection$$1[1][1] - selection$$1[0][1] + handleSize : handleSize; });\n    }\n\n    else {\n      group.selectAll(\".selection,.handle\")\n          .style(\"display\", \"none\")\n          .attr(\"x\", null)\n          .attr(\"y\", null)\n          .attr(\"width\", null)\n          .attr(\"height\", null);\n    }\n  }\n\n  function emitter(that, args) {\n    return that.__brush.emitter || new Emitter(that, args);\n  }\n\n  function Emitter(that, args) {\n    this.that = that;\n    this.args = args;\n    this.state = that.__brush;\n    this.active = 0;\n  }\n\n  Emitter.prototype = {\n    beforestart: function() {\n      if (++this.active === 1) this.state.emitter = this, this.starting = true;\n      return this;\n    },\n    start: function() {\n      if (this.starting) this.starting = false, this.emit(\"start\");\n      return this;\n    },\n    brush: function() {\n      this.emit(\"brush\");\n      return this;\n    },\n    end: function() {\n      if (--this.active === 0) delete this.state.emitter, this.emit(\"end\");\n      return this;\n    },\n    emit: function(type) {\n      customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);\n    }\n  };\n\n  function started() {\n    if (exports.event.touches) { if (exports.event.changedTouches.length < exports.event.touches.length) return noevent$2(); }\n    else if (touchending) return;\n    if (!filter.apply(this, arguments)) return;\n\n    var that = this,\n        type = exports.event.target.__data__.type,\n        mode = (exports.event.metaKey ? type = \"overlay\" : type) === \"selection\" ? MODE_DRAG : (exports.event.altKey ? MODE_CENTER : MODE_HANDLE),\n        signX = dim === Y ? null : signsX[type],\n        signY = dim === X ? null : signsY[type],\n        state = local$1(that),\n        extent = state.extent,\n        selection$$1 = state.selection,\n        W = extent[0][0], w0, w1,\n        N = extent[0][1], n0, n1,\n        E = extent[1][0], e0, e1,\n        S = extent[1][1], s0, s1,\n        dx,\n        dy,\n        moving,\n        shifting = signX && signY && exports.event.shiftKey,\n        lockX,\n        lockY,\n        point0 = mouse(that),\n        point = point0,\n        emit = emitter(that, arguments).beforestart();\n\n    if (type === \"overlay\") {\n      state.selection = selection$$1 = [\n        [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],\n        [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]\n      ];\n    } else {\n      w0 = selection$$1[0][0];\n      n0 = selection$$1[0][1];\n      e0 = selection$$1[1][0];\n      s0 = selection$$1[1][1];\n    }\n\n    w1 = w0;\n    n1 = n0;\n    e1 = e0;\n    s1 = s0;\n\n    var group = select(that)\n        .attr(\"pointer-events\", \"none\");\n\n    var overlay = group.selectAll(\".overlay\")\n        .attr(\"cursor\", cursors[type]);\n\n    if (exports.event.touches) {\n      group\n          .on(\"touchmove.brush\", moved, true)\n          .on(\"touchend.brush touchcancel.brush\", ended, true);\n    } else {\n      var view = select(exports.event.view)\n          .on(\"keydown.brush\", keydowned, true)\n          .on(\"keyup.brush\", keyupped, true)\n          .on(\"mousemove.brush\", moved, true)\n          .on(\"mouseup.brush\", ended, true);\n\n      dragDisable(exports.event.view);\n    }\n\n    nopropagation$2();\n    interrupt(that);\n    redraw.call(that);\n    emit.start();\n\n    function moved() {\n      var point1 = mouse(that);\n      if (shifting && !lockX && !lockY) {\n        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;\n        else lockX = true;\n      }\n      point = point1;\n      moving = true;\n      noevent$2();\n      move();\n    }\n\n    function move() {\n      var t;\n\n      dx = point[0] - point0[0];\n      dy = point[1] - point0[1];\n\n      switch (mode) {\n        case MODE_SPACE:\n        case MODE_DRAG: {\n          if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;\n          if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;\n          break;\n        }\n        case MODE_HANDLE: {\n          if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;\n          else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;\n          if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;\n          else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;\n          break;\n        }\n        case MODE_CENTER: {\n          if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));\n          if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));\n          break;\n        }\n      }\n\n      if (e1 < w1) {\n        signX *= -1;\n        t = w0, w0 = e0, e0 = t;\n        t = w1, w1 = e1, e1 = t;\n        if (type in flipX) overlay.attr(\"cursor\", cursors[type = flipX[type]]);\n      }\n\n      if (s1 < n1) {\n        signY *= -1;\n        t = n0, n0 = s0, s0 = t;\n        t = n1, n1 = s1, s1 = t;\n        if (type in flipY) overlay.attr(\"cursor\", cursors[type = flipY[type]]);\n      }\n\n      if (state.selection) selection$$1 = state.selection; // May be set by brush.move!\n      if (lockX) w1 = selection$$1[0][0], e1 = selection$$1[1][0];\n      if (lockY) n1 = selection$$1[0][1], s1 = selection$$1[1][1];\n\n      if (selection$$1[0][0] !== w1\n          || selection$$1[0][1] !== n1\n          || selection$$1[1][0] !== e1\n          || selection$$1[1][1] !== s1) {\n        state.selection = [[w1, n1], [e1, s1]];\n        redraw.call(that);\n        emit.brush();\n      }\n    }\n\n    function ended() {\n      nopropagation$2();\n      if (exports.event.touches) {\n        if (exports.event.touches.length) return;\n        if (touchending) clearTimeout(touchending);\n        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!\n        group.on(\"touchmove.brush touchend.brush touchcancel.brush\", null);\n      } else {\n        yesdrag(exports.event.view, moving);\n        view.on(\"keydown.brush keyup.brush mousemove.brush mouseup.brush\", null);\n      }\n      group.attr(\"pointer-events\", \"all\");\n      overlay.attr(\"cursor\", cursors.overlay);\n      if (state.selection) selection$$1 = state.selection; // May be set by brush.move (on start)!\n      if (empty$1(selection$$1)) state.selection = null, redraw.call(that);\n      emit.end();\n    }\n\n    function keydowned() {\n      switch (exports.event.keyCode) {\n        case 16: { // SHIFT\n          shifting = signX && signY;\n          break;\n        }\n        case 18: { // ALT\n          if (mode === MODE_HANDLE) {\n            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;\n            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;\n            mode = MODE_CENTER;\n            move();\n          }\n          break;\n        }\n        case 32: { // SPACE; takes priority over ALT\n          if (mode === MODE_HANDLE || mode === MODE_CENTER) {\n            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;\n            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;\n            mode = MODE_SPACE;\n            overlay.attr(\"cursor\", cursors.selection);\n            move();\n          }\n          break;\n        }\n        default: return;\n      }\n      noevent$2();\n    }\n\n    function keyupped() {\n      switch (exports.event.keyCode) {\n        case 16: { // SHIFT\n          if (shifting) {\n            lockX = lockY = shifting = false;\n            move();\n          }\n          break;\n        }\n        case 18: { // ALT\n          if (mode === MODE_CENTER) {\n            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;\n            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;\n            mode = MODE_HANDLE;\n            move();\n          }\n          break;\n        }\n        case 32: { // SPACE\n          if (mode === MODE_SPACE) {\n            if (exports.event.altKey) {\n              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;\n              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;\n              mode = MODE_CENTER;\n            } else {\n              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;\n              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;\n              mode = MODE_HANDLE;\n            }\n            overlay.attr(\"cursor\", cursors[type]);\n            move();\n          }\n          break;\n        }\n        default: return;\n      }\n      noevent$2();\n    }\n  }\n\n  function initialize() {\n    var state = this.__brush || {selection: null};\n    state.extent = extent.apply(this, arguments);\n    state.dim = dim;\n    return state;\n  }\n\n  brush.extent = function(_) {\n    return arguments.length ? (extent = typeof _ === \"function\" ? _ : constant$11([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent;\n  };\n\n  brush.filter = function(_) {\n    return arguments.length ? (filter = typeof _ === \"function\" ? _ : constant$11(!!_), brush) : filter;\n  };\n\n  brush.handleSize = function(_) {\n    return arguments.length ? (handleSize = +_, brush) : handleSize;\n  };\n\n  brush.on = function() {\n    var value = listeners.on.apply(listeners, arguments);\n    return value === listeners ? brush : value;\n  };\n\n  return brush;\n}\n\nvar cos = Math.cos;\nvar sin = Math.sin;\nvar pi$3 = Math.PI;\nvar halfPi$2 = pi$3 / 2;\nvar tau$3 = pi$3 * 2;\nvar max$1 = Math.max;\n\nfunction compareValue(compare) {\n  return function(a, b) {\n    return compare(\n      a.source.value + a.target.value,\n      b.source.value + b.target.value\n    );\n  };\n}\n\nvar chord = function() {\n  var padAngle = 0,\n      sortGroups = null,\n      sortSubgroups = null,\n      sortChords = null;\n\n  function chord(matrix) {\n    var n = matrix.length,\n        groupSums = [],\n        groupIndex = range(n),\n        subgroupIndex = [],\n        chords = [],\n        groups = chords.groups = new Array(n),\n        subgroups = new Array(n * n),\n        k,\n        x,\n        x0,\n        dx,\n        i,\n        j;\n\n    // Compute the sum.\n    k = 0, i = -1; while (++i < n) {\n      x = 0, j = -1; while (++j < n) {\n        x += matrix[i][j];\n      }\n      groupSums.push(x);\n      subgroupIndex.push(range(n));\n      k += x;\n    }\n\n    // Sort groups…\n    if (sortGroups) groupIndex.sort(function(a, b) {\n      return sortGroups(groupSums[a], groupSums[b]);\n    });\n\n    // Sort subgroups…\n    if (sortSubgroups) subgroupIndex.forEach(function(d, i) {\n      d.sort(function(a, b) {\n        return sortSubgroups(matrix[i][a], matrix[i][b]);\n      });\n    });\n\n    // Convert the sum to scaling factor for [0, 2pi].\n    // TODO Allow start and end angle to be specified?\n    // TODO Allow padding to be specified as percentage?\n    k = max$1(0, tau$3 - padAngle * n) / k;\n    dx = k ? padAngle : tau$3 / n;\n\n    // Compute the start and end angle for each group and subgroup.\n    // Note: Opera has a bug reordering object literal properties!\n    x = 0, i = -1; while (++i < n) {\n      x0 = x, j = -1; while (++j < n) {\n        var di = groupIndex[i],\n            dj = subgroupIndex[di][j],\n            v = matrix[di][dj],\n            a0 = x,\n            a1 = x += v * k;\n        subgroups[dj * n + di] = {\n          index: di,\n          subindex: dj,\n          startAngle: a0,\n          endAngle: a1,\n          value: v\n        };\n      }\n      groups[di] = {\n        index: di,\n        startAngle: x0,\n        endAngle: x,\n        value: groupSums[di]\n      };\n      x += dx;\n    }\n\n    // Generate chords for each (non-empty) subgroup-subgroup link.\n    i = -1; while (++i < n) {\n      j = i - 1; while (++j < n) {\n        var source = subgroups[j * n + i],\n            target = subgroups[i * n + j];\n        if (source.value || target.value) {\n          chords.push(source.value < target.value\n              ? {source: target, target: source}\n              : {source: source, target: target});\n        }\n      }\n    }\n\n    return sortChords ? chords.sort(sortChords) : chords;\n  }\n\n  chord.padAngle = function(_) {\n    return arguments.length ? (padAngle = max$1(0, _), chord) : padAngle;\n  };\n\n  chord.sortGroups = function(_) {\n    return arguments.length ? (sortGroups = _, chord) : sortGroups;\n  };\n\n  chord.sortSubgroups = function(_) {\n    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;\n  };\n\n  chord.sortChords = function(_) {\n    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;\n  };\n\n  return chord;\n};\n\nvar slice$5 = Array.prototype.slice;\n\nvar constant$12 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nfunction defaultSource(d) {\n  return d.source;\n}\n\nfunction defaultTarget(d) {\n  return d.target;\n}\n\nfunction defaultRadius$1(d) {\n  return d.radius;\n}\n\nfunction defaultStartAngle(d) {\n  return d.startAngle;\n}\n\nfunction defaultEndAngle(d) {\n  return d.endAngle;\n}\n\nvar ribbon = function() {\n  var source = defaultSource,\n      target = defaultTarget,\n      radius = defaultRadius$1,\n      startAngle = defaultStartAngle,\n      endAngle = defaultEndAngle,\n      context = null;\n\n  function ribbon() {\n    var buffer,\n        argv = slice$5.call(arguments),\n        s = source.apply(this, argv),\n        t = target.apply(this, argv),\n        sr = +radius.apply(this, (argv[0] = s, argv)),\n        sa0 = startAngle.apply(this, argv) - halfPi$2,\n        sa1 = endAngle.apply(this, argv) - halfPi$2,\n        sx0 = sr * cos(sa0),\n        sy0 = sr * sin(sa0),\n        tr = +radius.apply(this, (argv[0] = t, argv)),\n        ta0 = startAngle.apply(this, argv) - halfPi$2,\n        ta1 = endAngle.apply(this, argv) - halfPi$2;\n\n    if (!context) context = buffer = path();\n\n    context.moveTo(sx0, sy0);\n    context.arc(0, 0, sr, sa0, sa1);\n    if (sa0 !== ta0 || sa1 !== ta1) { // TODO sr !== tr?\n      context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));\n      context.arc(0, 0, tr, ta0, ta1);\n    }\n    context.quadraticCurveTo(0, 0, sx0, sy0);\n    context.closePath();\n\n    if (buffer) return context = null, buffer + \"\" || null;\n  }\n\n  ribbon.radius = function(_) {\n    return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant$12(+_), ribbon) : radius;\n  };\n\n  ribbon.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant$12(+_), ribbon) : startAngle;\n  };\n\n  ribbon.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant$12(+_), ribbon) : endAngle;\n  };\n\n  ribbon.source = function(_) {\n    return arguments.length ? (source = _, ribbon) : source;\n  };\n\n  ribbon.target = function(_) {\n    return arguments.length ? (target = _, ribbon) : target;\n  };\n\n  ribbon.context = function(_) {\n    return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;\n  };\n\n  return ribbon;\n};\n\n// Adds floating point numbers with twice the normal precision.\n// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and\n// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)\n// 305–363 (1997).\n// Code adapted from GeographicLib by Charles F. F. Karney,\n// http://geographiclib.sourceforge.net/\n\nvar adder = function() {\n  return new Adder;\n};\n\nfunction Adder() {\n  this.reset();\n}\n\nAdder.prototype = {\n  constructor: Adder,\n  reset: function() {\n    this.s = // rounded value\n    this.t = 0; // exact error\n  },\n  add: function(y) {\n    add$1(temp, y, this.t);\n    add$1(this, temp.s, this.s);\n    if (this.s) this.t += temp.t;\n    else this.s = temp.t;\n  },\n  valueOf: function() {\n    return this.s;\n  }\n};\n\nvar temp = new Adder;\n\nfunction add$1(adder, a, b) {\n  var x = adder.s = a + b,\n      bv = x - a,\n      av = x - bv;\n  adder.t = (a - av) + (b - bv);\n}\n\nvar epsilon$4 = 1e-6;\nvar epsilon2$2 = 1e-12;\nvar pi$4 = Math.PI;\nvar halfPi$3 = pi$4 / 2;\nvar quarterPi = pi$4 / 4;\nvar tau$4 = pi$4 * 2;\n\nvar degrees$1 = 180 / pi$4;\nvar radians = pi$4 / 180;\n\nvar abs = Math.abs;\nvar atan = Math.atan;\nvar atan2 = Math.atan2;\nvar cos$1 = Math.cos;\nvar ceil = Math.ceil;\nvar exp = Math.exp;\n\nvar log$1 = Math.log;\nvar pow$1 = Math.pow;\nvar sin$1 = Math.sin;\nvar sign$1 = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };\nvar sqrt$1 = Math.sqrt;\nvar tan = Math.tan;\n\nfunction acos(x) {\n  return x > 1 ? 0 : x < -1 ? pi$4 : Math.acos(x);\n}\n\nfunction asin$1(x) {\n  return x > 1 ? halfPi$3 : x < -1 ? -halfPi$3 : Math.asin(x);\n}\n\nfunction haversin(x) {\n  return (x = sin$1(x / 2)) * x;\n}\n\nfunction noop$2() {}\n\nfunction streamGeometry(geometry, stream) {\n  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {\n    streamGeometryType[geometry.type](geometry, stream);\n  }\n}\n\nvar streamObjectType = {\n  Feature: function(feature, stream) {\n    streamGeometry(feature.geometry, stream);\n  },\n  FeatureCollection: function(object, stream) {\n    var features = object.features, i = -1, n = features.length;\n    while (++i < n) streamGeometry(features[i].geometry, stream);\n  }\n};\n\nvar streamGeometryType = {\n  Sphere: function(object, stream) {\n    stream.sphere();\n  },\n  Point: function(object, stream) {\n    object = object.coordinates;\n    stream.point(object[0], object[1], object[2]);\n  },\n  MultiPoint: function(object, stream) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);\n  },\n  LineString: function(object, stream) {\n    streamLine(object.coordinates, stream, 0);\n  },\n  MultiLineString: function(object, stream) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) streamLine(coordinates[i], stream, 0);\n  },\n  Polygon: function(object, stream) {\n    streamPolygon(object.coordinates, stream);\n  },\n  MultiPolygon: function(object, stream) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) streamPolygon(coordinates[i], stream);\n  },\n  GeometryCollection: function(object, stream) {\n    var geometries = object.geometries, i = -1, n = geometries.length;\n    while (++i < n) streamGeometry(geometries[i], stream);\n  }\n};\n\nfunction streamLine(coordinates, stream, closed) {\n  var i = -1, n = coordinates.length - closed, coordinate;\n  stream.lineStart();\n  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);\n  stream.lineEnd();\n}\n\nfunction streamPolygon(coordinates, stream) {\n  var i = -1, n = coordinates.length;\n  stream.polygonStart();\n  while (++i < n) streamLine(coordinates[i], stream, 1);\n  stream.polygonEnd();\n}\n\nvar geoStream = function(object, stream) {\n  if (object && streamObjectType.hasOwnProperty(object.type)) {\n    streamObjectType[object.type](object, stream);\n  } else {\n    streamGeometry(object, stream);\n  }\n};\n\nvar areaRingSum = adder();\n\nvar areaSum = adder();\nvar lambda00;\nvar phi00;\nvar lambda0;\nvar cosPhi0;\nvar sinPhi0;\n\nvar areaStream = {\n  point: noop$2,\n  lineStart: noop$2,\n  lineEnd: noop$2,\n  polygonStart: function() {\n    areaRingSum.reset();\n    areaStream.lineStart = areaRingStart;\n    areaStream.lineEnd = areaRingEnd;\n  },\n  polygonEnd: function() {\n    var areaRing = +areaRingSum;\n    areaSum.add(areaRing < 0 ? tau$4 + areaRing : areaRing);\n    this.lineStart = this.lineEnd = this.point = noop$2;\n  },\n  sphere: function() {\n    areaSum.add(tau$4);\n  }\n};\n\nfunction areaRingStart() {\n  areaStream.point = areaPointFirst;\n}\n\nfunction areaRingEnd() {\n  areaPoint(lambda00, phi00);\n}\n\nfunction areaPointFirst(lambda, phi) {\n  areaStream.point = areaPoint;\n  lambda00 = lambda, phi00 = phi;\n  lambda *= radians, phi *= radians;\n  lambda0 = lambda, cosPhi0 = cos$1(phi = phi / 2 + quarterPi), sinPhi0 = sin$1(phi);\n}\n\nfunction areaPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  phi = phi / 2 + quarterPi; // half the angular distance from south pole\n\n  // Spherical excess E for a spherical triangle with vertices: south pole,\n  // previous point, current point.  Uses a formula derived from Cagnoli’s\n  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n  var dLambda = lambda - lambda0,\n      sdLambda = dLambda >= 0 ? 1 : -1,\n      adLambda = sdLambda * dLambda,\n      cosPhi = cos$1(phi),\n      sinPhi = sin$1(phi),\n      k = sinPhi0 * sinPhi,\n      u = cosPhi0 * cosPhi + k * cos$1(adLambda),\n      v = k * sdLambda * sin$1(adLambda);\n  areaRingSum.add(atan2(v, u));\n\n  // Advance the previous points.\n  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;\n}\n\nvar area$2 = function(object) {\n  areaSum.reset();\n  geoStream(object, areaStream);\n  return areaSum * 2;\n};\n\nfunction spherical(cartesian) {\n  return [atan2(cartesian[1], cartesian[0]), asin$1(cartesian[2])];\n}\n\nfunction cartesian(spherical) {\n  var lambda = spherical[0], phi = spherical[1], cosPhi = cos$1(phi);\n  return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi)];\n}\n\nfunction cartesianDot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n\nfunction cartesianCross(a, b) {\n  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n}\n\n// TODO return a\nfunction cartesianAddInPlace(a, b) {\n  a[0] += b[0], a[1] += b[1], a[2] += b[2];\n}\n\nfunction cartesianScale(vector, k) {\n  return [vector[0] * k, vector[1] * k, vector[2] * k];\n}\n\n// TODO return d\nfunction cartesianNormalizeInPlace(d) {\n  var l = sqrt$1(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n  d[0] /= l, d[1] /= l, d[2] /= l;\n}\n\nvar lambda0$1;\nvar phi0;\nvar lambda1;\nvar phi1;\nvar lambda2;\nvar lambda00$1;\nvar phi00$1;\nvar p0;\nvar deltaSum = adder();\nvar ranges;\nvar range$1;\n\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: boundsLineStart,\n  lineEnd: boundsLineEnd,\n  polygonStart: function() {\n    boundsStream.point = boundsRingPoint;\n    boundsStream.lineStart = boundsRingStart;\n    boundsStream.lineEnd = boundsRingEnd;\n    deltaSum.reset();\n    areaStream.polygonStart();\n  },\n  polygonEnd: function() {\n    areaStream.polygonEnd();\n    boundsStream.point = boundsPoint;\n    boundsStream.lineStart = boundsLineStart;\n    boundsStream.lineEnd = boundsLineEnd;\n    if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n    else if (deltaSum > epsilon$4) phi1 = 90;\n    else if (deltaSum < -epsilon$4) phi0 = -90;\n    range$1[0] = lambda0$1, range$1[1] = lambda1;\n  }\n};\n\nfunction boundsPoint(lambda, phi) {\n  ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n}\n\nfunction linePoint(lambda, phi) {\n  var p = cartesian([lambda * radians, phi * radians]);\n  if (p0) {\n    var normal = cartesianCross(p0, p),\n        equatorial = [normal[1], -normal[0], 0],\n        inflection = cartesianCross(equatorial, normal);\n    cartesianNormalizeInPlace(inflection);\n    inflection = spherical(inflection);\n    var delta = lambda - lambda2,\n        sign$$1 = delta > 0 ? 1 : -1,\n        lambdai = inflection[0] * degrees$1 * sign$$1,\n        phii,\n        antimeridian = abs(delta) > 180;\n    if (antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {\n      phii = inflection[1] * degrees$1;\n      if (phii > phi1) phi1 = phii;\n    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {\n      phii = -inflection[1] * degrees$1;\n      if (phii < phi0) phi0 = phii;\n    } else {\n      if (phi < phi0) phi0 = phi;\n      if (phi > phi1) phi1 = phi;\n    }\n    if (antimeridian) {\n      if (lambda < lambda2) {\n        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;\n      } else {\n        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;\n      }\n    } else {\n      if (lambda1 >= lambda0$1) {\n        if (lambda < lambda0$1) lambda0$1 = lambda;\n        if (lambda > lambda1) lambda1 = lambda;\n      } else {\n        if (lambda > lambda2) {\n          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;\n        } else {\n          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;\n        }\n      }\n    }\n  } else {\n    boundsPoint(lambda, phi);\n  }\n  p0 = p, lambda2 = lambda;\n}\n\nfunction boundsLineStart() {\n  boundsStream.point = linePoint;\n}\n\nfunction boundsLineEnd() {\n  range$1[0] = lambda0$1, range$1[1] = lambda1;\n  boundsStream.point = boundsPoint;\n  p0 = null;\n}\n\nfunction boundsRingPoint(lambda, phi) {\n  if (p0) {\n    var delta = lambda - lambda2;\n    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n  } else {\n    lambda00$1 = lambda, phi00$1 = phi;\n  }\n  areaStream.point(lambda, phi);\n  linePoint(lambda, phi);\n}\n\nfunction boundsRingStart() {\n  areaStream.lineStart();\n}\n\nfunction boundsRingEnd() {\n  boundsRingPoint(lambda00$1, phi00$1);\n  areaStream.lineEnd();\n  if (abs(deltaSum) > epsilon$4) lambda0$1 = -(lambda1 = 180);\n  range$1[0] = lambda0$1, range$1[1] = lambda1;\n  p0 = null;\n}\n\n// Finds the left-right distance between two longitudes.\n// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want\n// the distance between ±180° to be 360°.\nfunction angle(lambda0, lambda1) {\n  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n}\n\nfunction rangeCompare(a, b) {\n  return a[0] - b[0];\n}\n\nfunction rangeContains(range, x) {\n  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n}\n\nvar bounds = function(feature) {\n  var i, n, a, b, merged, deltaMax, delta;\n\n  phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);\n  ranges = [];\n  geoStream(feature, boundsStream);\n\n  // First, sort ranges by their minimum longitudes.\n  if (n = ranges.length) {\n    ranges.sort(rangeCompare);\n\n    // Then, merge any ranges that overlap.\n    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n      b = ranges[i];\n      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n      } else {\n        merged.push(a = b);\n      }\n    }\n\n    // Finally, find the largest gap between the merged ranges.\n    // The final bounding box will be the inverse of this gap.\n    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n      b = merged[i];\n      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];\n    }\n  }\n\n  ranges = range$1 = null;\n\n  return lambda0$1 === Infinity || phi0 === Infinity\n      ? [[NaN, NaN], [NaN, NaN]]\n      : [[lambda0$1, phi0], [lambda1, phi1]];\n};\n\nvar W0;\nvar W1;\nvar X0;\nvar Y0;\nvar Z0;\nvar X1;\nvar Y1;\nvar Z1;\nvar X2;\nvar Y2;\nvar Z2;\nvar lambda00$2;\nvar phi00$2;\nvar x0;\nvar y0;\nvar z0; // previous point\n\nvar centroidStream = {\n  sphere: noop$2,\n  point: centroidPoint,\n  lineStart: centroidLineStart,\n  lineEnd: centroidLineEnd,\n  polygonStart: function() {\n    centroidStream.lineStart = centroidRingStart;\n    centroidStream.lineEnd = centroidRingEnd;\n  },\n  polygonEnd: function() {\n    centroidStream.lineStart = centroidLineStart;\n    centroidStream.lineEnd = centroidLineEnd;\n  }\n};\n\n// Arithmetic mean of Cartesian vectors.\nfunction centroidPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos$1(phi);\n  centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi));\n}\n\nfunction centroidPointCartesian(x, y, z) {\n  ++W0;\n  X0 += (x - X0) / W0;\n  Y0 += (y - Y0) / W0;\n  Z0 += (z - Z0) / W0;\n}\n\nfunction centroidLineStart() {\n  centroidStream.point = centroidLinePointFirst;\n}\n\nfunction centroidLinePointFirst(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos$1(phi);\n  x0 = cosPhi * cos$1(lambda);\n  y0 = cosPhi * sin$1(lambda);\n  z0 = sin$1(phi);\n  centroidStream.point = centroidLinePoint;\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidLinePoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos$1(phi),\n      x = cosPhi * cos$1(lambda),\n      y = cosPhi * sin$1(lambda),\n      z = sin$1(phi),\n      w = atan2(sqrt$1((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidLineEnd() {\n  centroidStream.point = centroidPoint;\n}\n\n// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,\n// J. Applied Mechanics 42, 239 (1975).\nfunction centroidRingStart() {\n  centroidStream.point = centroidRingPointFirst;\n}\n\nfunction centroidRingEnd() {\n  centroidRingPoint(lambda00$2, phi00$2);\n  centroidStream.point = centroidPoint;\n}\n\nfunction centroidRingPointFirst(lambda, phi) {\n  lambda00$2 = lambda, phi00$2 = phi;\n  lambda *= radians, phi *= radians;\n  centroidStream.point = centroidRingPoint;\n  var cosPhi = cos$1(phi);\n  x0 = cosPhi * cos$1(lambda);\n  y0 = cosPhi * sin$1(lambda);\n  z0 = sin$1(phi);\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidRingPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos$1(phi),\n      x = cosPhi * cos$1(lambda),\n      y = cosPhi * sin$1(lambda),\n      z = sin$1(phi),\n      cx = y0 * z - z0 * y,\n      cy = z0 * x - x0 * z,\n      cz = x0 * y - y0 * x,\n      m = sqrt$1(cx * cx + cy * cy + cz * cz),\n      u = x0 * x + y0 * y + z0 * z,\n      v = m && -acos(u) / m, // area weight\n      w = atan2(m, u); // line weight\n  X2 += v * cx;\n  Y2 += v * cy;\n  Z2 += v * cz;\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\n\nvar centroid$1 = function(object) {\n  W0 = W1 =\n  X0 = Y0 = Z0 =\n  X1 = Y1 = Z1 =\n  X2 = Y2 = Z2 = 0;\n  geoStream(object, centroidStream);\n\n  var x = X2,\n      y = Y2,\n      z = Z2,\n      m = x * x + y * y + z * z;\n\n  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.\n  if (m < epsilon2$2) {\n    x = X1, y = Y1, z = Z1;\n    // If the feature has zero length, fall back to arithmetic mean of point vectors.\n    if (W1 < epsilon$4) x = X0, y = Y0, z = Z0;\n    m = x * x + y * y + z * z;\n    // If the feature still has an undefined ccentroid, then return.\n    if (m < epsilon2$2) return [NaN, NaN];\n  }\n\n  return [atan2(y, x) * degrees$1, asin$1(z / sqrt$1(m)) * degrees$1];\n};\n\nvar constant$13 = function(x) {\n  return function() {\n    return x;\n  };\n};\n\nvar compose = function(a, b) {\n\n  function compose(x, y) {\n    return x = a(x, y), b(x[0], x[1]);\n  }\n\n  if (a.invert && b.invert) compose.invert = function(x, y) {\n    return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n  };\n\n  return compose;\n};\n\nfunction rotationIdentity(lambda, phi) {\n  return [lambda > pi$4 ? lambda - tau$4 : lambda < -pi$4 ? lambda + tau$4 : lambda, phi];\n}\n\nrotationIdentity.invert = rotationIdentity;\n\nfunction rotateRadians(deltaLambda, deltaPhi, deltaGamma) {\n  return (deltaLambda %= tau$4) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))\n    : rotationLambda(deltaLambda))\n    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)\n    : rotationIdentity);\n}\n\nfunction forwardRotationLambda(deltaLambda) {\n  return function(lambda, phi) {\n    return lambda += deltaLambda, [lambda > pi$4 ? lambda - tau$4 : lambda < -pi$4 ? lambda + tau$4 : lambda, phi];\n  };\n}\n\nfunction rotationLambda(deltaLambda) {\n  var rotation = forwardRotationLambda(deltaLambda);\n  rotation.invert = forwardRotationLambda(-deltaLambda);\n  return rotation;\n}\n\nfunction rotationPhiGamma(deltaPhi, deltaGamma) {\n  var cosDeltaPhi = cos$1(deltaPhi),\n      sinDeltaPhi = sin$1(deltaPhi),\n      cosDeltaGamma = cos$1(deltaGamma),\n      sinDeltaGamma = sin$1(deltaGamma);\n\n  function rotation(lambda, phi) {\n    var cosPhi = cos$1(phi),\n        x = cos$1(lambda) * cosPhi,\n        y = sin$1(lambda) * cosPhi,\n        z = sin$1(phi),\n        k = z * cosDeltaPhi + x * sinDeltaPhi;\n    return [\n      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),\n      asin$1(k * cosDeltaGamma + y * sinDeltaGamma)\n    ];\n  }\n\n  rotation.invert = function(lambda, phi) {\n    var cosPhi = cos$1(phi),\n        x = cos$1(lambda) * cosPhi,\n        y = sin$1(lambda) * cosPhi,\n        z = sin$1(phi),\n        k = z * cosDeltaGamma - y * sinDeltaGamma;\n    return [\n      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),\n      asin$1(k * cosDeltaPhi - x * sinDeltaPhi)\n    ];\n  };\n\n  return rotation;\n}\n\nvar rotation = function(rotate) {\n  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);\n\n  function forward(coordinates) {\n    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);\n    return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;\n  }\n\n  forward.invert = function(coordinates) {\n    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);\n    return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;\n  };\n\n  return forward;\n};\n\n// Generates a circle centered at [0°, 0°], with a given radius and precision.\nfunction circleStream(stream, radius, delta, direction, t0, t1) {\n  if (!delta) return;\n  var cosRadius = cos$1(radius),\n      sinRadius = sin$1(radius),\n      step = direction * delta;\n  if (t0 == null) {\n    t0 = radius + direction * tau$4;\n    t1 = radius - step / 2;\n  } else {\n    t0 = circleRadius(cosRadius, t0);\n    t1 = circleRadius(cosRadius, t1);\n    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau$4;\n  }\n  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {\n    point = spherical([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);\n    stream.point(point[0], point[1]);\n  }\n}\n\n// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].\nfunction circleRadius(cosRadius, point) {\n  point = cartesian(point), point[0] -= cosRadius;\n  cartesianNormalizeInPlace(point);\n  var radius = acos(-point[1]);\n  return ((-point[2] < 0 ? -radius : radius) + tau$4 - epsilon$4) % tau$4;\n}\n\nvar circle$1 = function() {\n  var center = constant$13([0, 0]),\n      radius = constant$13(90),\n      precision = constant$13(6),\n      ring,\n      rotate,\n      stream = {point: point};\n\n  function point(x, y) {\n    ring.push(x = rotate(x, y));\n    x[0] *= degrees$1, x[1] *= degrees$1;\n  }\n\n  function circle() {\n    var c = center.apply(this, arguments),\n        r = radius.apply(this, arguments) * radians,\n        p = precision.apply(this, arguments) * radians;\n    ring = [];\n    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;\n    circleStream(stream, r, p, 1);\n    c = {type: \"Polygon\", coordinates: [ring]};\n    ring = rotate = null;\n    return c;\n  }\n\n  circle.center = function(_) {\n    return arguments.length ? (center = typeof _ === \"function\" ? _ : constant$13([+_[0], +_[1]]), circle) : center;\n  };\n\n  circle.radius = function(_) {\n    return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant$13(+_), circle) : radius;\n  };\n\n  circle.precision = function(_) {\n    return arguments.length ? (precision = typeof _ === \"function\" ? _ : constant$13(+_), circle) : precision;\n  };\n\n  return circle;\n};\n\nvar clipBuffer = function() {\n  var lines = [],\n      line;\n  return {\n    point: function(x, y) {\n      line.push([x, y]);\n    },\n    lineStart: function() {\n      lines.push(line = []);\n    },\n    lineEnd: noop$2,\n    rejoin: function() {\n      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n    },\n    result: function() {\n      var result = lines;\n      lines = [];\n      line = null;\n      return result;\n    }\n  };\n};\n\nvar clipLine = function(a, b, x0, y0, x1, y1) {\n  var ax = a[0],\n      ay = a[1],\n      bx = b[0],\n      by = b[1],\n      t0 = 0,\n      t1 = 1,\n      dx = bx - ax,\n      dy = by - ay,\n      r;\n\n  r = x0 - ax;\n  if (!dx && r > 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dx > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = x1 - ax;\n  if (!dx && r < 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dx > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  r = y0 - ay;\n  if (!dy && r > 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dy > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = y1 - ay;\n  if (!dy && r < 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dy > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;\n  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;\n  return true;\n};\n\nvar pointEqual = function(a, b) {\n  return abs(a[0] - b[0]) < epsilon$4 && abs(a[1] - b[1]) < epsilon$4;\n};\n\nfunction Intersection(point, points, other, entry) {\n  this.x = point;\n  this.z = points;\n  this.o = other; // another intersection\n  this.e = entry; // is an entry?\n  this.v = false; // visited\n  this.n = this.p = null; // next & previous\n}\n\n// A generalized polygon clipping algorithm: given a polygon that has been cut\n// into its visible line segments, and rejoins the segments by interpolating\n// along the clip edge.\nvar clipPolygon = function(segments, compareIntersection, startInside, interpolate, stream) {\n  var subject = [],\n      clip = [],\n      i,\n      n;\n\n  segments.forEach(function(segment) {\n    if ((n = segment.length - 1) <= 0) return;\n    var n, p0 = segment[0], p1 = segment[n], x;\n\n    // If the first and last points of a segment are coincident, then treat as a\n    // closed ring. TODO if all rings are closed, then the winding order of the\n    // exterior ring should be checked.\n    if (pointEqual(p0, p1)) {\n      stream.lineStart();\n      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);\n      stream.lineEnd();\n      return;\n    }\n\n    subject.push(x = new Intersection(p0, segment, null, true));\n    clip.push(x.o = new Intersection(p0, null, x, false));\n    subject.push(x = new Intersection(p1, segment, null, false));\n    clip.push(x.o = new Intersection(p1, null, x, true));\n  });\n\n  if (!subject.length) return;\n\n  clip.sort(compareIntersection);\n  link$1(subject);\n  link$1(clip);\n\n  for (i = 0, n = clip.length; i < n; ++i) {\n    clip[i].e = startInside = !startInside;\n  }\n\n  var start = subject[0],\n      points,\n      point;\n\n  while (1) {\n    // Find first unvisited intersection.\n    var current = start,\n        isSubject = true;\n    while (current.v) if ((current = current.n) === start) return;\n    points = current.z;\n    stream.lineStart();\n    do {\n      current.v = current.o.v = true;\n      if (current.e) {\n        if (isSubject) {\n          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);\n        } else {\n          interpolate(current.x, current.n.x, 1, stream);\n        }\n        current = current.n;\n      } else {\n        if (isSubject) {\n          points = current.p.z;\n          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);\n        } else {\n          interpolate(current.x, current.p.x, -1, stream);\n        }\n        current = current.p;\n      }\n      current = current.o;\n      points = current.z;\n      isSubject = !isSubject;\n    } while (!current.v);\n    stream.lineEnd();\n  }\n};\n\nfunction link$1(array) {\n  if (!(n = array.length)) return;\n  var n,\n      i = 0,\n      a = array[0],\n      b;\n  while (++i < n) {\n    a.n = b = array[i];\n    b.p = a;\n    a = b;\n  }\n  a.n = b = array[0];\n  b.p = a;\n}\n\nvar clipMax = 1e9;\nvar clipMin = -clipMax;\n\n// TODO Use d3-polygon’s polygonContains here for the ring check?\n// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\n\nfunction clipExtent(x0, y0, x1, y1) {\n\n  function visible(x, y) {\n    return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n  }\n\n  function interpolate(from, to, direction, stream) {\n    var a = 0, a1 = 0;\n    if (from == null\n        || (a = corner(from, direction)) !== (a1 = corner(to, direction))\n        || comparePoint(from, to) < 0 ^ direction > 0) {\n      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n      while ((a = (a + direction + 4) % 4) !== a1);\n    } else {\n      stream.point(to[0], to[1]);\n    }\n  }\n\n  function corner(p, direction) {\n    return abs(p[0] - x0) < epsilon$4 ? direction > 0 ? 0 : 3\n        : abs(p[0] - x1) < epsilon$4 ? direction > 0 ? 2 : 1\n        : abs(p[1] - y0) < epsilon$4 ? direction > 0 ? 1 : 0\n        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon\n  }\n\n  function compareIntersection(a, b) {\n    return comparePoint(a.x, b.x);\n  }\n\n  function comparePoint(a, b) {\n    var ca = corner(a, 1),\n        cb = corner(b, 1);\n    return ca !== cb ? ca - cb\n        : ca === 0 ? b[1] - a[1]\n        : ca === 1 ? a[0] - b[0]\n        : ca === 2 ? a[1] - b[1]\n        : b[0] - a[0];\n  }\n\n  return function(stream) {\n    var activeStream = stream,\n        bufferStream = clipBuffer(),\n        segments,\n        polygon,\n        ring,\n        x__, y__, v__, // first point\n        x_, y_, v_, // previous point\n        first,\n        clean;\n\n    var clipStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: polygonStart,\n      polygonEnd: polygonEnd\n    };\n\n    function point(x, y) {\n      if (visible(x, y)) activeStream.point(x, y);\n    }\n\n    function polygonInside() {\n      var winding = 0;\n\n      for (var i = 0, n = polygon.length; i < n; ++i) {\n        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }\n          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }\n        }\n      }\n\n      return winding;\n    }\n\n    // Buffer geometry within a polygon and then clip it en masse.\n    function polygonStart() {\n      activeStream = bufferStream, segments = [], polygon = [], clean = true;\n    }\n\n    function polygonEnd() {\n      var startInside = polygonInside(),\n          cleanInside = clean && startInside,\n          visible = (segments = merge(segments)).length;\n      if (cleanInside || visible) {\n        stream.polygonStart();\n        if (cleanInside) {\n          stream.lineStart();\n          interpolate(null, null, 1, stream);\n          stream.lineEnd();\n        }\n        if (visible) {\n          clipPolygon(segments, compareIntersection, startInside, interpolate, stream);\n        }\n        stream.polygonEnd();\n      }\n      activeStream = stream, segments = polygon = ring = null;\n    }\n\n    function lineStart() {\n      clipStream.point = linePoint;\n      if (polygon) polygon.push(ring = []);\n      first = true;\n      v_ = false;\n      x_ = y_ = NaN;\n    }\n\n    // TODO rather than special-case polygons, simply handle them separately.\n    // Ideally, coincident intersection points should be jittered to avoid\n    // clipping issues.\n    function lineEnd() {\n      if (segments) {\n        linePoint(x__, y__);\n        if (v__ && v_) bufferStream.rejoin();\n        segments.push(bufferStream.result());\n      }\n      clipStream.point = point;\n      if (v_) activeStream.lineEnd();\n    }\n\n    function linePoint(x, y) {\n      var v = visible(x, y);\n      if (polygon) ring.push([x, y]);\n      if (first) {\n        x__ = x, y__ = y, v__ = v;\n        first = false;\n        if (v) {\n          activeStream.lineStart();\n          activeStream.point(x, y);\n        }\n      } else {\n        if (v && v_) activeStream.point(x, y);\n        else {\n          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],\n              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n          if (clipLine(a, b, x0, y0, x1, y1)) {\n            if (!v_) {\n              activeStream.lineStart();\n              activeStream.point(a[0], a[1]);\n            }\n            activeStream.point(b[0], b[1]);\n            if (!v) activeStream.lineEnd();\n            clean = false;\n          } else if (v) {\n            activeStream.lineStart();\n            activeStream.point(x, y);\n            clean = false;\n          }\n        }\n      }\n      x_ = x, y_ = y, v_ = v;\n    }\n\n    return clipStream;\n  };\n}\n\nvar extent$1 = function() {\n  var x0 = 0,\n      y0 = 0,\n      x1 = 960,\n      y1 = 500,\n      cache,\n      cacheStream,\n      clip;\n\n  return clip = {\n    stream: function(stream) {\n      return cache && cacheStream === stream ? cache : cache = clipExtent(x0, y0, x1, y1)(cacheStream = stream);\n    },\n    extent: function(_) {\n      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];\n    }\n  };\n};\n\nvar lengthSum = adder();\nvar lambda0$2;\nvar sinPhi0$1;\nvar cosPhi0$1;\n\nvar lengthStream = {\n  sphere: noop$2,\n  point: noop$2,\n  lineStart: lengthLineStart,\n  lineEnd: noop$2,\n  polygonStart: noop$2,\n  polygonEnd: noop$2\n};\n\nfunction lengthLineStart() {\n  lengthStream.point = lengthPointFirst;\n  lengthStream.lineEnd = lengthLineEnd;\n}\n\nfunction lengthLineEnd() {\n  lengthStream.point = lengthStream.lineEnd = noop$2;\n}\n\nfunction lengthPointFirst(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  lambda0$2 = lambda, sinPhi0$1 = sin$1(phi), cosPhi0$1 = cos$1(phi);\n  lengthStream.point = lengthPoint;\n}\n\nfunction lengthPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var sinPhi = sin$1(phi),\n      cosPhi = cos$1(phi),\n      delta = abs(lambda - lambda0$2),\n      cosDelta = cos$1(delta),\n      sinDelta = sin$1(delta),\n      x = cosPhi * sinDelta,\n      y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,\n      z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;\n  lengthSum.add(atan2(sqrt$1(x * x + y * y), z));\n  lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;\n}\n\nvar length$2 = function(object) {\n  lengthSum.reset();\n  geoStream(object, lengthStream);\n  return +lengthSum;\n};\n\nvar coordinates = [null, null];\nvar object$1 = {type: \"LineString\", coordinates: coordinates};\n\nvar distance = function(a, b) {\n  coordinates[0] = a;\n  coordinates[1] = b;\n  return length$2(object$1);\n};\n\nfunction graticuleX(y0, y1, dy) {\n  var y = range(y0, y1 - epsilon$4, dy).concat(y1);\n  return function(x) { return y.map(function(y) { return [x, y]; }); };\n}\n\nfunction graticuleY(x0, x1, dx) {\n  var x = range(x0, x1 - epsilon$4, dx).concat(x1);\n  return function(y) { return x.map(function(x) { return [x, y]; }); };\n}\n\nfunction graticule() {\n  var x1, x0, X1, X0,\n      y1, y0, Y1, Y0,\n      dx = 10, dy = dx, DX = 90, DY = 360,\n      x, y, X, Y,\n      precision = 2.5;\n\n  function graticule() {\n    return {type: \"MultiLineString\", coordinates: lines()};\n  }\n\n  function lines() {\n    return range(ceil(X0 / DX) * DX, X1, DX).map(X)\n        .concat(range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))\n        .concat(range(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon$4; }).map(x))\n        .concat(range(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon$4; }).map(y));\n  }\n\n  graticule.lines = function() {\n    return lines().map(function(coordinates) { return {type: \"LineString\", coordinates: coordinates}; });\n  };\n\n  graticule.outline = function() {\n    return {\n      type: \"Polygon\",\n      coordinates: [\n        X(X0).concat(\n        Y(Y1).slice(1),\n        X(X1).reverse().slice(1),\n        Y(Y0).reverse().slice(1))\n      ]\n    };\n  };\n\n  graticule.extent = function(_) {\n    if (!arguments.length) return graticule.extentMinor();\n    return graticule.extentMajor(_).extentMinor(_);\n  };\n\n  graticule.extentMajor = function(_) {\n    if (!arguments.length) return [[X0, Y0], [X1, Y1]];\n    X0 = +_[0][0], X1 = +_[1][0];\n    Y0 = +_[0][1], Y1 = +_[1][1];\n    if (X0 > X1) _ = X0, X0 = X1, X1 = _;\n    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;\n    return graticule.precision(precision);\n  };\n\n  graticule.extentMinor = function(_) {\n    if (!arguments.length) return [[x0, y0], [x1, y1]];\n    x0 = +_[0][0], x1 = +_[1][0];\n    y0 = +_[0][1], y1 = +_[1][1];\n    if (x0 > x1) _ = x0, x0 = x1, x1 = _;\n    if (y0 > y1) _ = y0, y0 = y1, y1 = _;\n    return graticule.precision(precision);\n  };\n\n  graticule.step = function(_) {\n    if (!arguments.length) return graticule.stepMinor();\n    return graticule.stepMajor(_).stepMinor(_);\n  };\n\n  graticule.stepMajor = function(_) {\n    if (!arguments.length) return [DX, DY];\n    DX = +_[0], DY = +_[1];\n    return graticule;\n  };\n\n  graticule.stepMinor = function(_) {\n    if (!arguments.length) return [dx, dy];\n    dx = +_[0], dy = +_[1];\n    return graticule;\n  };\n\n  graticule.precision = function(_) {\n    if (!arguments.length) return precision;\n    precision = +_;\n    x = graticuleX(y0, y1, 90);\n    y = graticuleY(x0, x1, precision);\n    X = graticuleX(Y0, Y1, 90);\n    Y = graticuleY(X0, X1, precision);\n    return graticule;\n  };\n\n  return graticule\n      .extentMajor([[-180, -90 + epsilon$4], [180, 90 - epsilon$4]])\n      .extentMinor([[-180, -80 - epsilon$4], [180, 80 + epsilon$4]]);\n}\n\nfunction graticule10() {\n  return graticule()();\n}\n\nvar interpolate$2 = function(a, b) {\n  var x0 = a[0] * radians,\n      y0 = a[1] * radians,\n      x1 = b[0] * radians,\n      y1 = b[1] * radians,\n      cy0 = cos$1(y0),\n      sy0 = sin$1(y0),\n      cy1 = cos$1(y1),\n      sy1 = sin$1(y1),\n      kx0 = cy0 * cos$1(x0),\n      ky0 = cy0 * sin$1(x0),\n      kx1 = cy1 * cos$1(x1),\n      ky1 = cy1 * sin$1(x1),\n      d = 2 * asin$1(sqrt$1(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),\n      k = sin$1(d);\n\n  var interpolate = d ? function(t) {\n    var B = sin$1(t *= d) / k,\n        A = sin$1(d - t) / k,\n        x = A * kx0 + B * kx1,\n        y = A * ky0 + B * ky1,\n        z = A * sy0 + B * sy1;\n    return [\n      atan2(y, x) * degrees$1,\n      atan2(z, sqrt$1(x * x + y * y)) * degrees$1\n    ];\n  } : function() {\n    return [x0 * degrees$1, y0 * degrees$1];\n  };\n\n  interpolate.distance = d;\n\n  return interpolate;\n};\n\nvar identity$7 = function(x) {\n  return x;\n};\n\nvar areaSum$1 = adder();\nvar areaRingSum$1 = adder();\nvar x00;\nvar y00;\nvar x0$1;\nvar y0$1;\n\nvar areaStream$1 = {\n  point: noop$2,\n  lineStart: noop$2,\n  lineEnd: noop$2,\n  polygonStart: function() {\n    areaStream$1.lineStart = areaRingStart$1;\n    areaStream$1.lineEnd = areaRingEnd$1;\n  },\n  polygonEnd: function() {\n    areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop$2;\n    areaSum$1.add(abs(areaRingSum$1));\n    areaRingSum$1.reset();\n  },\n  result: function() {\n    var area = areaSum$1 / 2;\n    areaSum$1.reset();\n    return area;\n  }\n};\n\nfunction areaRingStart$1() {\n  areaStream$1.point = areaPointFirst$1;\n}\n\nfunction areaPointFirst$1(x, y) {\n  areaStream$1.point = areaPoint$1;\n  x00 = x0$1 = x, y00 = y0$1 = y;\n}\n\nfunction areaPoint$1(x, y) {\n  areaRingSum$1.add(y0$1 * x - x0$1 * y);\n  x0$1 = x, y0$1 = y;\n}\n\nfunction areaRingEnd$1() {\n  areaPoint$1(x00, y00);\n}\n\nvar x0$2 = Infinity;\nvar y0$2 = x0$2;\nvar x1 = -x0$2;\nvar y1 = x1;\n\nvar boundsStream$1 = {\n  point: boundsPoint$1,\n  lineStart: noop$2,\n  lineEnd: noop$2,\n  polygonStart: noop$2,\n  polygonEnd: noop$2,\n  result: function() {\n    var bounds = [[x0$2, y0$2], [x1, y1]];\n    x1 = y1 = -(y0$2 = x0$2 = Infinity);\n    return bounds;\n  }\n};\n\nfunction boundsPoint$1(x, y) {\n  if (x < x0$2) x0$2 = x;\n  if (x > x1) x1 = x;\n  if (y < y0$2) y0$2 = y;\n  if (y > y1) y1 = y;\n}\n\n// TODO Enforce positive area for exterior, negative area for interior?\n\nvar X0$1 = 0;\nvar Y0$1 = 0;\nvar Z0$1 = 0;\nvar X1$1 = 0;\nvar Y1$1 = 0;\nvar Z1$1 = 0;\nvar X2$1 = 0;\nvar Y2$1 = 0;\nvar Z2$1 = 0;\nvar x00$1;\nvar y00$1;\nvar x0$3;\nvar y0$3;\n\nvar centroidStream$1 = {\n  point: centroidPoint$1,\n  lineStart: centroidLineStart$1,\n  lineEnd: centroidLineEnd$1,\n  polygonStart: function() {\n    centroidStream$1.lineStart = centroidRingStart$1;\n    centroidStream$1.lineEnd = centroidRingEnd$1;\n  },\n  polygonEnd: function() {\n    centroidStream$1.point = centroidPoint$1;\n    centroidStream$1.lineStart = centroidLineStart$1;\n    centroidStream$1.lineEnd = centroidLineEnd$1;\n  },\n  result: function() {\n    var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]\n        : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]\n        : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]\n        : [NaN, NaN];\n    X0$1 = Y0$1 = Z0$1 =\n    X1$1 = Y1$1 = Z1$1 =\n    X2$1 = Y2$1 = Z2$1 = 0;\n    return centroid;\n  }\n};\n\nfunction centroidPoint$1(x, y) {\n  X0$1 += x;\n  Y0$1 += y;\n  ++Z0$1;\n}\n\nfunction centroidLineStart$1() {\n  centroidStream$1.point = centroidPointFirstLine;\n}\n\nfunction centroidPointFirstLine(x, y) {\n  centroidStream$1.point = centroidPointLine;\n  centroidPoint$1(x0$3 = x, y0$3 = y);\n}\n\nfunction centroidPointLine(x, y) {\n  var dx = x - x0$3, dy = y - y0$3, z = sqrt$1(dx * dx + dy * dy);\n  X1$1 += z * (x0$3 + x) / 2;\n  Y1$1 += z * (y0$3 + y) / 2;\n  Z1$1 += z;\n  centroidPoint$1(x0$3 = x, y0$3 = y);\n}\n\nfunction centroidLineEnd$1() {\n  centroidStream$1.point = centroidPoint$1;\n}\n\nfunction centroidRingStart$1() {\n  centroidStream$1.point = centroidPointFirstRing;\n}\n\nfunction centroidRingEnd$1() {\n  centroidPointRing(x00$1, y00$1);\n}\n\nfunction centroidPointFirstRing(x, y) {\n  centroidStream$1.point = centroidPointRing;\n  centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);\n}\n\nfunction centroidPointRing(x, y) {\n  var dx = x - x0$3,\n      dy = y - y0$3,\n      z = sqrt$1(dx * dx + dy * dy);\n\n  X1$1 += z * (x0$3 + x) / 2;\n  Y1$1 += z * (y0$3 + y) / 2;\n  Z1$1 += z;\n\n  z = y0$3 * x - x0$3 * y;\n  X2$1 += z * (x0$3 + x);\n  Y2$1 += z * (y0$3 + y);\n  Z2$1 += z * 3;\n  centroidPoint$1(x0$3 = x, y0$3 = y);\n}\n\nfunction PathContext(context) {\n  this._context = context;\n}\n\nPathContext.prototype = {\n  _radius: 4.5,\n  pointRadius: function(_) {\n    return this._radius = _, this;\n  },\n  polygonStart: function() {\n    this._line = 0;\n  },\n  polygonEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line === 0) this._context.closePath();\n    this._point = NaN;\n  },\n  point: function(x, y) {\n    switch (this._point) {\n      case 0: {\n        this._context.moveTo(x, y);\n        this._point = 1;\n        break;\n      }\n      case 1: {\n        this._context.lineTo(x, y);\n        break;\n      }\n      default: {\n        this._context.moveTo(x + this._radius, y);\n        this._context.arc(x, y, this._radius, 0, tau$4);\n        break;\n      }\n    }\n  },\n  result: noop$2\n};\n\nfunction PathString() {\n  this._string = [];\n}\n\nPathString.prototype = {\n  _circle: circle$2(4.5),\n  pointRadius: function(_) {\n    return this._circle = circle$2(_), this;\n  },\n  polygonStart: function() {\n    this._line = 0;\n  },\n  polygonEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line === 0) this._string.push(\"Z\");\n    this._point = NaN;\n  },\n  point: function(x, y) {\n    switch (this._point) {\n      case 0: {\n        this._string.push(\"M\", x, \",\", y);\n        this._point = 1;\n        break;\n      }\n      case 1: {\n        this._string.push(\"L\", x, \",\", y);\n        break;\n      }\n      default: {\n        this._string.push(\"M\", x, \",\", y, this._circle);\n        break;\n      }\n    }\n  },\n  result: function() {\n    if (this._string.length) {\n      var result = this._string.join(\"\");\n      this._string = [];\n      return result;\n    }\n  }\n};\n\nfunction circle$2(radius) {\n  return \"m0,\" + radius\n      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius\n      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + 2 * radius\n      + \"z\";\n}\n\nvar index$3 = function(projection, context) {\n  var pointRadius = 4.5,\n      projectionStream,\n      contextStream;\n\n  function path(object) {\n    if (object) {\n      if (typeof pointRadius === \"function\") contextStream.pointRadius(+pointRadius.apply(this, arguments));\n      geoStream(object, projectionStream(contextStream));\n    }\n    return contextStream.result();\n  }\n\n  path.area = function(object) {\n    geoStream(object, projectionStream(areaStream$1));\n    return areaStream$1.result();\n  };\n\n  path.bounds = function(object) {\n    geoStream(object, projectionStream(boundsStream$1));\n    return boundsStream$1.result();\n  };\n\n  path.centroid = function(object) {\n    geoStream(object, projectionStream(centroidStream$1));\n    return centroidStream$1.result();\n  };\n\n  path.projection = function(_) {\n    return arguments.length ? (projectionStream = (projection = _) == null ? identity$7 : _.stream, path) : projection;\n  };\n\n  path.context = function(_) {\n    if (!arguments.length) return context;\n    contextStream = (context = _) == null ? new PathString : new PathContext(_);\n    if (typeof pointRadius !== \"function\") contextStream.pointRadius(pointRadius);\n    return path;\n  };\n\n  path.pointRadius = function(_) {\n    if (!arguments.length) return pointRadius;\n    pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n    return path;\n  };\n\n  return path.projection(projection).context(context);\n};\n\nvar sum$2 = adder();\n\nvar polygonContains = function(polygon, point) {\n  var lambda = point[0],\n      phi = point[1],\n      normal = [sin$1(lambda), -cos$1(lambda), 0],\n      angle = 0,\n      winding = 0;\n\n  sum$2.reset();\n\n  for (var i = 0, n = polygon.length; i < n; ++i) {\n    if (!(m = (ring = polygon[i]).length)) continue;\n    var ring,\n        m,\n        point0 = ring[m - 1],\n        lambda0 = point0[0],\n        phi0 = point0[1] / 2 + quarterPi,\n        sinPhi0 = sin$1(phi0),\n        cosPhi0 = cos$1(phi0);\n\n    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {\n      var point1 = ring[j],\n          lambda1 = point1[0],\n          phi1 = point1[1] / 2 + quarterPi,\n          sinPhi1 = sin$1(phi1),\n          cosPhi1 = cos$1(phi1),\n          delta = lambda1 - lambda0,\n          sign$$1 = delta >= 0 ? 1 : -1,\n          absDelta = sign$$1 * delta,\n          antimeridian = absDelta > pi$4,\n          k = sinPhi0 * sinPhi1;\n\n      sum$2.add(atan2(k * sign$$1 * sin$1(absDelta), cosPhi0 * cosPhi1 + k * cos$1(absDelta)));\n      angle += antimeridian ? delta + sign$$1 * tau$4 : delta;\n\n      // Are the longitudes either side of the point’s meridian (lambda),\n      // and are the latitudes smaller than the parallel (phi)?\n      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {\n        var arc = cartesianCross(cartesian(point0), cartesian(point1));\n        cartesianNormalizeInPlace(arc);\n        var intersection = cartesianCross(normal, arc);\n        cartesianNormalizeInPlace(intersection);\n        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin$1(intersection[2]);\n        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {\n          winding += antimeridian ^ delta >= 0 ? 1 : -1;\n        }\n      }\n    }\n  }\n\n  // First, determine whether the South pole is inside or outside:\n  //\n  // It is inside if:\n  // * the polygon winds around it in a clockwise direction.\n  // * the polygon does not (cumulatively) wind around it, but has a negative\n  //   (counter-clockwise) area.\n  //\n  // Second, count the (signed) number of times a segment crosses a lambda\n  // from the point to the South pole.  If it is zero, then the point is the\n  // same side as the South pole.\n\n  return (angle < -epsilon$4 || angle < epsilon$4 && sum$2 < -epsilon$4) ^ (winding & 1);\n};\n\nvar clip = function(pointVisible, clipLine, interpolate, start) {\n  return function(rotate, sink) {\n    var line = clipLine(sink),\n        rotatedStart = rotate.invert(start[0], start[1]),\n        ringBuffer = clipBuffer(),\n        ringSink = clipLine(ringBuffer),\n        polygonStarted = false,\n        polygon,\n        segments,\n        ring;\n\n    var clip = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        clip.point = pointRing;\n        clip.lineStart = ringStart;\n        clip.lineEnd = ringEnd;\n        segments = [];\n        polygon = [];\n      },\n      polygonEnd: function() {\n        clip.point = point;\n        clip.lineStart = lineStart;\n        clip.lineEnd = lineEnd;\n        segments = merge(segments);\n        var startInside = polygonContains(polygon, rotatedStart);\n        if (segments.length) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          clipPolygon(segments, compareIntersection, startInside, interpolate, sink);\n        } else if (startInside) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n        }\n        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n        segments = polygon = null;\n      },\n      sphere: function() {\n        sink.polygonStart();\n        sink.lineStart();\n        interpolate(null, null, 1, sink);\n        sink.lineEnd();\n        sink.polygonEnd();\n      }\n    };\n\n    function point(lambda, phi) {\n      var point = rotate(lambda, phi);\n      if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);\n    }\n\n    function pointLine(lambda, phi) {\n      var point = rotate(lambda, phi);\n      line.point(point[0], point[1]);\n    }\n\n    function lineStart() {\n      clip.point = pointLine;\n      line.lineStart();\n    }\n\n    function lineEnd() {\n      clip.point = point;\n      line.lineEnd();\n    }\n\n    function pointRing(lambda, phi) {\n      ring.push([lambda, phi]);\n      var point = rotate(lambda, phi);\n      ringSink.point(point[0], point[1]);\n    }\n\n    function ringStart() {\n      ringSink.lineStart();\n      ring = [];\n    }\n\n    function ringEnd() {\n      pointRing(ring[0][0], ring[0][1]);\n      ringSink.lineEnd();\n\n      var clean = ringSink.clean(),\n          ringSegments = ringBuffer.result(),\n          i, n = ringSegments.length, m,\n          segment,\n          point;\n\n      ring.pop();\n      polygon.push(ring);\n      ring = null;\n\n      if (!n) return;\n\n      // No intersections.\n      if (clean & 1) {\n        segment = ringSegments[0];\n        if ((m = segment.length - 1) > 0) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);\n          sink.lineEnd();\n        }\n        return;\n      }\n\n      // Rejoin connected segments.\n      // TODO reuse ringBuffer.rejoin()?\n      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n\n      segments.push(ringSegments.filter(validSegment));\n    }\n\n    return clip;\n  };\n};\n\nfunction validSegment(segment) {\n  return segment.length > 1;\n}\n\n// Intersections are sorted along the clip edge. For both antimeridian cutting\n// and circle clipping, the same comparison is used.\nfunction compareIntersection(a, b) {\n  return ((a = a.x)[0] < 0 ? a[1] - halfPi$3 - epsilon$4 : halfPi$3 - a[1])\n       - ((b = b.x)[0] < 0 ? b[1] - halfPi$3 - epsilon$4 : halfPi$3 - b[1]);\n}\n\nvar clipAntimeridian = clip(\n  function() { return true; },\n  clipAntimeridianLine,\n  clipAntimeridianInterpolate,\n  [-pi$4, -halfPi$3]\n);\n\n// Takes a line and cuts into visible segments. Return values: 0 - there were\n// intersections or the line was empty; 1 - no intersections; 2 - there were\n// intersections, and the first and last segments should be rejoined.\nfunction clipAntimeridianLine(stream) {\n  var lambda0 = NaN,\n      phi0 = NaN,\n      sign0 = NaN,\n      clean; // no intersections\n\n  return {\n    lineStart: function() {\n      stream.lineStart();\n      clean = 1;\n    },\n    point: function(lambda1, phi1) {\n      var sign1 = lambda1 > 0 ? pi$4 : -pi$4,\n          delta = abs(lambda1 - lambda0);\n      if (abs(delta - pi$4) < epsilon$4) { // line crosses a pole\n        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi$3 : -halfPi$3);\n        stream.point(sign0, phi0);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi0);\n        stream.point(lambda1, phi0);\n        clean = 0;\n      } else if (sign0 !== sign1 && delta >= pi$4) { // line crosses antimeridian\n        if (abs(lambda0 - sign0) < epsilon$4) lambda0 -= sign0 * epsilon$4; // handle degeneracies\n        if (abs(lambda1 - sign1) < epsilon$4) lambda1 -= sign1 * epsilon$4;\n        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);\n        stream.point(sign0, phi0);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi0);\n        clean = 0;\n      }\n      stream.point(lambda0 = lambda1, phi0 = phi1);\n      sign0 = sign1;\n    },\n    lineEnd: function() {\n      stream.lineEnd();\n      lambda0 = phi0 = NaN;\n    },\n    clean: function() {\n      return 2 - clean; // if intersections, rejoin first and last segments\n    }\n  };\n}\n\nfunction clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {\n  var cosPhi0,\n      cosPhi1,\n      sinLambda0Lambda1 = sin$1(lambda0 - lambda1);\n  return abs(sinLambda0Lambda1) > epsilon$4\n      ? atan((sin$1(phi0) * (cosPhi1 = cos$1(phi1)) * sin$1(lambda1)\n          - sin$1(phi1) * (cosPhi0 = cos$1(phi0)) * sin$1(lambda0))\n          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))\n      : (phi0 + phi1) / 2;\n}\n\nfunction clipAntimeridianInterpolate(from, to, direction, stream) {\n  var phi;\n  if (from == null) {\n    phi = direction * halfPi$3;\n    stream.point(-pi$4, phi);\n    stream.point(0, phi);\n    stream.point(pi$4, phi);\n    stream.point(pi$4, 0);\n    stream.point(pi$4, -phi);\n    stream.point(0, -phi);\n    stream.point(-pi$4, -phi);\n    stream.point(-pi$4, 0);\n    stream.point(-pi$4, phi);\n  } else if (abs(from[0] - to[0]) > epsilon$4) {\n    var lambda = from[0] < to[0] ? pi$4 : -pi$4;\n    phi = direction * lambda / 2;\n    stream.point(-lambda, phi);\n    stream.point(0, phi);\n    stream.point(lambda, phi);\n  } else {\n    stream.point(to[0], to[1]);\n  }\n}\n\nvar clipCircle = function(radius, delta) {\n  var cr = cos$1(radius),\n      smallRadius = cr > 0,\n      notHemisphere = abs(cr) > epsilon$4; // TODO optimise for this common case\n\n  function interpolate(from, to, direction, stream) {\n    circleStream(stream, radius, delta, direction, from, to);\n  }\n\n  function visible(lambda, phi) {\n    return cos$1(lambda) * cos$1(phi) > cr;\n  }\n\n  // Takes a line and cuts into visible segments. Return values used for polygon\n  // clipping: 0 - there were intersections or the line was empty; 1 - no\n  // intersections 2 - there were intersections, and the first and last segments\n  // should be rejoined.\n  function clipLine(stream) {\n    var point0, // previous point\n        c0, // code for previous point\n        v0, // visibility of previous point\n        v00, // visibility of first point\n        clean; // no intersections\n    return {\n      lineStart: function() {\n        v00 = v0 = false;\n        clean = 1;\n      },\n      point: function(lambda, phi) {\n        var point1 = [lambda, phi],\n            point2,\n            v = visible(lambda, phi),\n            c = smallRadius\n              ? v ? 0 : code(lambda, phi)\n              : v ? code(lambda + (lambda < 0 ? pi$4 : -pi$4), phi) : 0;\n        if (!point0 && (v00 = v0 = v)) stream.lineStart();\n        // Handle degeneracies.\n        // TODO ignore if not clipping polygons.\n        if (v !== v0) {\n          point2 = intersect(point0, point1);\n          if (pointEqual(point0, point2) || pointEqual(point1, point2)) {\n            point1[0] += epsilon$4;\n            point1[1] += epsilon$4;\n            v = visible(point1[0], point1[1]);\n          }\n        }\n        if (v !== v0) {\n          clean = 0;\n          if (v) {\n            // outside going in\n            stream.lineStart();\n            point2 = intersect(point1, point0);\n            stream.point(point2[0], point2[1]);\n          } else {\n            // inside going out\n            point2 = intersect(point0, point1);\n            stream.point(point2[0], point2[1]);\n            stream.lineEnd();\n          }\n          point0 = point2;\n        } else if (notHemisphere && point0 && smallRadius ^ v) {\n          var t;\n          // If the codes for two points are different, or are both zero,\n          // and there this segment intersects with the small circle.\n          if (!(c & c0) && (t = intersect(point1, point0, true))) {\n            clean = 0;\n            if (smallRadius) {\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n            } else {\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n            }\n          }\n        }\n        if (v && (!point0 || !pointEqual(point0, point1))) {\n          stream.point(point1[0], point1[1]);\n        }\n        point0 = point1, v0 = v, c0 = c;\n      },\n      lineEnd: function() {\n        if (v0) stream.lineEnd();\n        point0 = null;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function() {\n        return clean | ((v00 && v0) << 1);\n      }\n    };\n  }\n\n  // Intersects the great circle between a and b with the clip circle.\n  function intersect(a, b, two) {\n    var pa = cartesian(a),\n        pb = cartesian(b);\n\n    // We have two planes, n1.p = d1 and n2.p = d2.\n    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).\n    var n1 = [1, 0, 0], // normal\n        n2 = cartesianCross(pa, pb),\n        n2n2 = cartesianDot(n2, n2),\n        n1n2 = n2[0], // cartesianDot(n1, n2),\n        determinant = n2n2 - n1n2 * n1n2;\n\n    // Two polar points.\n    if (!determinant) return !two && a;\n\n    var c1 =  cr * n2n2 / determinant,\n        c2 = -cr * n1n2 / determinant,\n        n1xn2 = cartesianCross(n1, n2),\n        A = cartesianScale(n1, c1),\n        B = cartesianScale(n2, c2);\n    cartesianAddInPlace(A, B);\n\n    // Solve |p(t)|^2 = 1.\n    var u = n1xn2,\n        w = cartesianDot(A, u),\n        uu = cartesianDot(u, u),\n        t2 = w * w - uu * (cartesianDot(A, A) - 1);\n\n    if (t2 < 0) return;\n\n    var t = sqrt$1(t2),\n        q = cartesianScale(u, (-w - t) / uu);\n    cartesianAddInPlace(q, A);\n    q = spherical(q);\n\n    if (!two) return q;\n\n    // Two intersection points.\n    var lambda0 = a[0],\n        lambda1 = b[0],\n        phi0 = a[1],\n        phi1 = b[1],\n        z;\n\n    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\n\n    var delta = lambda1 - lambda0,\n        polar = abs(delta - pi$4) < epsilon$4,\n        meridian = polar || delta < epsilon$4;\n\n    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;\n\n    // Check that the first point is between a and b.\n    if (meridian\n        ? polar\n          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon$4 ? phi0 : phi1)\n          : phi0 <= q[1] && q[1] <= phi1\n        : delta > pi$4 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n      var q1 = cartesianScale(u, (-w + t) / uu);\n      cartesianAddInPlace(q1, A);\n      return [q, spherical(q1)];\n    }\n  }\n\n  // Generates a 4-bit vector representing the location of a point relative to\n  // the small circle's bounding box.\n  function code(lambda, phi) {\n    var r = smallRadius ? radius : pi$4 - radius,\n        code = 0;\n    if (lambda < -r) code |= 1; // left\n    else if (lambda > r) code |= 2; // right\n    if (phi < -r) code |= 4; // below\n    else if (phi > r) code |= 8; // above\n    return code;\n  }\n\n  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$4, radius - pi$4]);\n};\n\nvar transform$1 = function(methods) {\n  return {\n    stream: transformer(methods)\n  };\n};\n\nfunction transformer(methods) {\n  return function(stream) {\n    var s = new TransformStream;\n    for (var key in methods) s[key] = methods[key];\n    s.stream = stream;\n    return s;\n  };\n}\n\nfunction TransformStream() {}\n\nTransformStream.prototype = {\n  constructor: TransformStream,\n  point: function(x, y) { this.stream.point(x, y); },\n  sphere: function() { this.stream.sphere(); },\n  lineStart: function() { this.stream.lineStart(); },\n  lineEnd: function() { this.stream.lineEnd(); },\n  polygonStart: function() { this.stream.polygonStart(); },\n  polygonEnd: function() { this.stream.polygonEnd(); }\n};\n\nfunction fitExtent(projection, extent, object) {\n  var w = extent[1][0] - extent[0][0],\n      h = extent[1][1] - extent[0][1],\n      clip = projection.clipExtent && projection.clipExtent();\n\n  projection\n      .scale(150)\n      .translate([0, 0]);\n\n  if (clip != null) projection.clipExtent(null);\n\n  geoStream(object, projection.stream(boundsStream$1));\n\n  var b = boundsStream$1.result(),\n      k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),\n      x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,\n      y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;\n\n  if (clip != null) projection.clipExtent(clip);\n\n  return projection\n      .scale(k * 150)\n      .translate([x, y]);\n}\n\nfunction fitSize(projection, size, object) {\n  return fitExtent(projection, [[0, 0], size], object);\n}\n\nvar maxDepth = 16;\nvar cosMinDistance = cos$1(30 * radians); // cos(minimum angular distance)\n\nvar resample = function(project, delta2) {\n  return +delta2 ? resample$1(project, delta2) : resampleNone(project);\n};\n\nfunction resampleNone(project) {\n  return transformer({\n    point: function(x, y) {\n      x = project(x, y);\n      this.stream.point(x[0], x[1]);\n    }\n  });\n}\n\nfunction resample$1(project, delta2) {\n\n  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {\n    var dx = x1 - x0,\n        dy = y1 - y0,\n        d2 = dx * dx + dy * dy;\n    if (d2 > 4 * delta2 && depth--) {\n      var a = a0 + a1,\n          b = b0 + b1,\n          c = c0 + c1,\n          m = sqrt$1(a * a + b * b + c * c),\n          phi2 = asin$1(c /= m),\n          lambda2 = abs(abs(c) - 1) < epsilon$4 || abs(lambda0 - lambda1) < epsilon$4 ? (lambda0 + lambda1) / 2 : atan2(b, a),\n          p = project(lambda2, phi2),\n          x2 = p[0],\n          y2 = p[1],\n          dx2 = x2 - x0,\n          dy2 = y2 - y0,\n          dz = dy * dx2 - dx * dy2;\n      if (dz * dz / d2 > delta2 // perpendicular projected distance\n          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end\n          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance\n        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);\n        stream.point(x2, y2);\n        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);\n      }\n    }\n  }\n  return function(stream) {\n    var lambda00, x00, y00, a00, b00, c00, // first point\n        lambda0, x0, y0, a0, b0, c0; // previous point\n\n    var resampleStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },\n      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }\n    };\n\n    function point(x, y) {\n      x = project(x, y);\n      stream.point(x[0], x[1]);\n    }\n\n    function lineStart() {\n      x0 = NaN;\n      resampleStream.point = linePoint;\n      stream.lineStart();\n    }\n\n    function linePoint(lambda, phi) {\n      var c = cartesian([lambda, phi]), p = project(lambda, phi);\n      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n      stream.point(x0, y0);\n    }\n\n    function lineEnd() {\n      resampleStream.point = point;\n      stream.lineEnd();\n    }\n\n    function ringStart() {\n      lineStart();\n      resampleStream.point = ringPoint;\n      resampleStream.lineEnd = ringEnd;\n    }\n\n    function ringPoint(lambda, phi) {\n      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n      resampleStream.point = linePoint;\n    }\n\n    function ringEnd() {\n      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);\n      resampleStream.lineEnd = lineEnd;\n      lineEnd();\n    }\n\n    return resampleStream;\n  };\n}\n\nvar transformRadians = transformer({\n  point: function(x, y) {\n    this.stream.point(x * radians, y * radians);\n  }\n});\n\nfunction projection(project) {\n  return projectionMutator(function() { return project; })();\n}\n\nfunction projectionMutator(projectAt) {\n  var project,\n      k = 150, // scale\n      x = 480, y = 250, // translate\n      dx, dy, lambda = 0, phi = 0, // center\n      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, projectRotate, // rotate\n      theta = null, preclip = clipAntimeridian, // clip angle\n      x0 = null, y0, x1, y1, postclip = identity$7, // clip extent\n      delta2 = 0.5, projectResample = resample(projectTransform, delta2), // precision\n      cache,\n      cacheStream;\n\n  function projection(point) {\n    point = projectRotate(point[0] * radians, point[1] * radians);\n    return [point[0] * k + dx, dy - point[1] * k];\n  }\n\n  function invert(point) {\n    point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);\n    return point && [point[0] * degrees$1, point[1] * degrees$1];\n  }\n\n  function projectTransform(x, y) {\n    return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];\n  }\n\n  projection.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));\n  };\n\n  projection.clipAngle = function(_) {\n    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians, 6 * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees$1;\n  };\n\n  projection.clipExtent = function(_) {\n    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$7) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n  };\n\n  projection.scale = function(_) {\n    return arguments.length ? (k = +_, recenter()) : k;\n  };\n\n  projection.translate = function(_) {\n    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];\n  };\n\n  projection.center = function(_) {\n    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees$1, phi * degrees$1];\n  };\n\n  projection.rotate = function(_) {\n    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees$1, deltaPhi * degrees$1, deltaGamma * degrees$1];\n  };\n\n  projection.precision = function(_) {\n    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt$1(delta2);\n  };\n\n  projection.fitExtent = function(extent, object) {\n    return fitExtent(projection, extent, object);\n  };\n\n  projection.fitSize = function(size, object) {\n    return fitSize(projection, size, object);\n  };\n\n  function recenter() {\n    projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);\n    var center = project(lambda, phi);\n    dx = x - center[0] * k;\n    dy = y + center[1] * k;\n    return reset();\n  }\n\n  function reset() {\n    cache = cacheStream = null;\n    return projection;\n  }\n\n  return function() {\n    project = projectAt.apply(this, arguments);\n    projection.invert = project.invert && invert;\n    return recenter();\n  };\n}\n\nfunction conicProjection(projectAt) {\n  var phi0 = 0,\n      phi1 = pi$4 / 3,\n      m = projectionMutator(projectAt),\n      p = m(phi0, phi1);\n\n  p.parallels = function(_) {\n    return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees$1, phi1 * degrees$1];\n  };\n\n  return p;\n}\n\nfunction cylindricalEqualAreaRaw(phi0) {\n  var cosPhi0 = cos$1(phi0);\n\n  function forward(lambda, phi) {\n    return [lambda * cosPhi0, sin$1(phi) / cosPhi0];\n  }\n\n  forward.invert = function(x, y) {\n    return [x / cosPhi0, asin$1(y * cosPhi0)];\n  };\n\n  return forward;\n}\n\nfunction conicEqualAreaRaw(y0, y1) {\n  var sy0 = sin$1(y0), n = (sy0 + sin$1(y1)) / 2;\n\n  // Are the parallels symmetrical around the Equator?\n  if (abs(n) < epsilon$4) return cylindricalEqualAreaRaw(y0);\n\n  var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt$1(c) / n;\n\n  function project(x, y) {\n    var r = sqrt$1(c - 2 * n * sin$1(y)) / n;\n    return [r * sin$1(x *= n), r0 - r * cos$1(x)];\n  }\n\n  project.invert = function(x, y) {\n    var r0y = r0 - y;\n    return [atan2(x, abs(r0y)) / n * sign$1(r0y), asin$1((c - (x * x + r0y * r0y) * n * n) / (2 * n))];\n  };\n\n  return project;\n}\n\nvar conicEqualArea = function() {\n  return conicProjection(conicEqualAreaRaw)\n      .scale(155.424)\n      .center([0, 33.6442]);\n};\n\nvar albers = function() {\n  return conicEqualArea()\n      .parallels([29.5, 45.5])\n      .scale(1070)\n      .translate([480, 250])\n      .rotate([96, 0])\n      .center([-0.6, 38.7]);\n};\n\n// The projections must have mutually exclusive clip regions on the sphere,\n// as this will avoid emitting interleaving lines and polygons.\nfunction multiplex(streams) {\n  var n = streams.length;\n  return {\n    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },\n    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },\n    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },\n    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },\n    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },\n    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }\n  };\n}\n\n// A composite projection for the United States, configured by default for\n// 960×500. The projection also works quite well at 960×600 if you change the\n// scale to 1285 and adjust the translate accordingly. The set of standard\n// parallels for each region comes from USGS, which is published here:\n// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers\nvar albersUsa = function() {\n  var cache,\n      cacheStream,\n      lower48 = albers(), lower48Point,\n      alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338\n      hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007\n      point, pointStream = {point: function(x, y) { point = [x, y]; }};\n\n  function albersUsa(coordinates) {\n    var x = coordinates[0], y = coordinates[1];\n    return point = null,\n        (lower48Point.point(x, y), point)\n        || (alaskaPoint.point(x, y), point)\n        || (hawaiiPoint.point(x, y), point);\n  }\n\n  albersUsa.invert = function(coordinates) {\n    var k = lower48.scale(),\n        t = lower48.translate(),\n        x = (coordinates[0] - t[0]) / k,\n        y = (coordinates[1] - t[1]) / k;\n    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska\n        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii\n        : lower48).invert(coordinates);\n  };\n\n  albersUsa.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);\n  };\n\n  albersUsa.precision = function(_) {\n    if (!arguments.length) return lower48.precision();\n    lower48.precision(_), alaska.precision(_), hawaii.precision(_);\n    return reset();\n  };\n\n  albersUsa.scale = function(_) {\n    if (!arguments.length) return lower48.scale();\n    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);\n    return albersUsa.translate(lower48.translate());\n  };\n\n  albersUsa.translate = function(_) {\n    if (!arguments.length) return lower48.translate();\n    var k = lower48.scale(), x = +_[0], y = +_[1];\n\n    lower48Point = lower48\n        .translate(_)\n        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])\n        .stream(pointStream);\n\n    alaskaPoint = alaska\n        .translate([x - 0.307 * k, y + 0.201 * k])\n        .clipExtent([[x - 0.425 * k + epsilon$4, y + 0.120 * k + epsilon$4], [x - 0.214 * k - epsilon$4, y + 0.234 * k - epsilon$4]])\n        .stream(pointStream);\n\n    hawaiiPoint = hawaii\n        .translate([x - 0.205 * k, y + 0.212 * k])\n        .clipExtent([[x - 0.214 * k + epsilon$4, y + 0.166 * k + epsilon$4], [x - 0.115 * k - epsilon$4, y + 0.234 * k - epsilon$4]])\n        .stream(pointStream);\n\n    return reset();\n  };\n\n  albersUsa.fitExtent = function(extent, object) {\n    return fitExtent(albersUsa, extent, object);\n  };\n\n  albersUsa.fitSize = function(size, object) {\n    return fitSize(albersUsa, size, object);\n  };\n\n  function reset() {\n    cache = cacheStream = null;\n    return albersUsa;\n  }\n\n  return albersUsa.scale(1070);\n};\n\nfunction azimuthalRaw(scale) {\n  return function(x, y) {\n    var cx = cos$1(x),\n        cy = cos$1(y),\n        k = scale(cx * cy);\n    return [\n      k * cy * sin$1(x),\n      k * sin$1(y)\n    ];\n  }\n}\n\nfunction azimuthalInvert(angle) {\n  return function(x, y) {\n    var z = sqrt$1(x * x + y * y),\n        c = angle(z),\n        sc = sin$1(c),\n        cc = cos$1(c);\n    return [\n      atan2(x * sc, z * cc),\n      asin$1(z && y * sc / z)\n    ];\n  }\n}\n\nvar azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {\n  return sqrt$1(2 / (1 + cxcy));\n});\n\nazimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {\n  return 2 * asin$1(z / 2);\n});\n\nvar azimuthalEqualArea = function() {\n  return projection(azimuthalEqualAreaRaw)\n      .scale(124.75)\n      .clipAngle(180 - 1e-3);\n};\n\nvar azimuthalEquidistantRaw = azimuthalRaw(function(c) {\n  return (c = acos(c)) && c / sin$1(c);\n});\n\nazimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {\n  return z;\n});\n\nvar azimuthalEquidistant = function() {\n  return projection(azimuthalEquidistantRaw)\n      .scale(79.4188)\n      .clipAngle(180 - 1e-3);\n};\n\nfunction mercatorRaw(lambda, phi) {\n  return [lambda, log$1(tan((halfPi$3 + phi) / 2))];\n}\n\nmercatorRaw.invert = function(x, y) {\n  return [x, 2 * atan(exp(y)) - halfPi$3];\n};\n\nvar mercator = function() {\n  return mercatorProjection(mercatorRaw)\n      .scale(961 / tau$4);\n};\n\nfunction mercatorProjection(project) {\n  var m = projection(project),\n      scale = m.scale,\n      translate = m.translate,\n      clipExtent = m.clipExtent,\n      clipAuto;\n\n  m.scale = function(_) {\n    return arguments.length ? (scale(_), clipAuto && m.clipExtent(null), m) : scale();\n  };\n\n  m.translate = function(_) {\n    return arguments.length ? (translate(_), clipAuto && m.clipExtent(null), m) : translate();\n  };\n\n  m.clipExtent = function(_) {\n    if (!arguments.length) return clipAuto ? null : clipExtent();\n    if (clipAuto = _ == null) {\n      var k = pi$4 * scale(),\n          t = translate();\n      _ = [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]];\n    }\n    clipExtent(_);\n    return m;\n  };\n\n  return m.clipExtent(null);\n}\n\nfunction tany(y) {\n  return tan((halfPi$3 + y) / 2);\n}\n\nfunction conicConformalRaw(y0, y1) {\n  var cy0 = cos$1(y0),\n      n = y0 === y1 ? sin$1(y0) : log$1(cy0 / cos$1(y1)) / log$1(tany(y1) / tany(y0)),\n      f = cy0 * pow$1(tany(y0), n) / n;\n\n  if (!n) return mercatorRaw;\n\n  function project(x, y) {\n    if (f > 0) { if (y < -halfPi$3 + epsilon$4) y = -halfPi$3 + epsilon$4; }\n    else { if (y > halfPi$3 - epsilon$4) y = halfPi$3 - epsilon$4; }\n    var r = f / pow$1(tany(y), n);\n    return [r * sin$1(n * x), f - r * cos$1(n * x)];\n  }\n\n  project.invert = function(x, y) {\n    var fy = f - y, r = sign$1(n) * sqrt$1(x * x + fy * fy);\n    return [atan2(x, abs(fy)) / n * sign$1(fy), 2 * atan(pow$1(f / r, 1 / n)) - halfPi$3];\n  };\n\n  return project;\n}\n\nvar conicConformal = function() {\n  return conicProjection(conicConformalRaw)\n      .scale(109.5)\n      .parallels([30, 30]);\n};\n\nfunction equirectangularRaw(lambda, phi) {\n  return [lambda, phi];\n}\n\nequirectangularRaw.invert = equirectangularRaw;\n\nvar equirectangular = function() {\n  return projection(equirectangularRaw)\n      .scale(152.63);\n};\n\nfunction conicEquidistantRaw(y0, y1) {\n  var cy0 = cos$1(y0),\n      n = y0 === y1 ? sin$1(y0) : (cy0 - cos$1(y1)) / (y1 - y0),\n      g = cy0 / n + y0;\n\n  if (abs(n) < epsilon$4) return equirectangularRaw;\n\n  function project(x, y) {\n    var gy = g - y, nx = n * x;\n    return [gy * sin$1(nx), g - gy * cos$1(nx)];\n  }\n\n  project.invert = function(x, y) {\n    var gy = g - y;\n    return [atan2(x, abs(gy)) / n * sign$1(gy), g - sign$1(n) * sqrt$1(x * x + gy * gy)];\n  };\n\n  return project;\n}\n\nvar conicEquidistant = function() {\n  return conicProjection(conicEquidistantRaw)\n      .scale(131.154)\n      .center([0, 13.9389]);\n};\n\nfunction gnomonicRaw(x, y) {\n  var cy = cos$1(y), k = cos$1(x) * cy;\n  return [cy * sin$1(x) / k, sin$1(y) / k];\n}\n\ngnomonicRaw.invert = azimuthalInvert(atan);\n\nvar gnomonic = function() {\n  return projection(gnomonicRaw)\n      .scale(144.049)\n      .clipAngle(60);\n};\n\nfunction scaleTranslate(k, tx, ty) {\n  return k === 1 && tx === 0 && ty === 0 ? identity$7 : transformer({\n    point: function(x, y) {\n      this.stream.point(x * k + tx, y * k + ty);\n    }\n  });\n}\n\nvar identity$8 = function() {\n  var k = 1, tx = 0, ty = 0, transform = identity$7, // scale and translate\n      x0 = null, y0, x1, y1, clip = identity$7, // clip extent\n      cache,\n      cacheStream,\n      projection;\n\n  function reset() {\n    cache = cacheStream = null;\n    return projection;\n  }\n\n  return projection = {\n    stream: function(stream) {\n      return cache && cacheStream === stream ? cache : cache = transform(clip(cacheStream = stream));\n    },\n    clipExtent: function(_) {\n      return arguments.length ? (clip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$7) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n    },\n    scale: function(_) {\n      return arguments.length ? (transform = scaleTranslate(k = +_, tx, ty), reset()) : k;\n    },\n    translate: function(_) {\n      return arguments.length ? (transform = scaleTranslate(k, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];\n    },\n    fitExtent: function(extent, object) {\n      return fitExtent(projection, extent, object);\n    },\n    fitSize: function(size, object) {\n      return fitSize(projection, size, object);\n    }\n  };\n};\n\nfunction orthographicRaw(x, y) {\n  return [cos$1(y) * sin$1(x), sin$1(y)];\n}\n\northographicRaw.invert = azimuthalInvert(asin$1);\n\nvar orthographic = function() {\n  return projection(orthographicRaw)\n      .scale(249.5)\n      .clipAngle(90 + epsilon$4);\n};\n\nfunction stereographicRaw(x, y) {\n  var cy = cos$1(y), k = 1 + cos$1(x) * cy;\n  return [cy * sin$1(x) / k, sin$1(y) / k];\n}\n\nstereographicRaw.invert = azimuthalInvert(function(z) {\n  return 2 * atan(z);\n});\n\nvar stereographic = function() {\n  return projection(stereographicRaw)\n      .scale(250)\n      .clipAngle(142);\n};\n\nfunction transverseMercatorRaw(lambda, phi) {\n  return [log$1(tan((halfPi$3 + phi) / 2)), -lambda];\n}\n\ntransverseMercatorRaw.invert = function(x, y) {\n  return [-y, 2 * atan(exp(x)) - halfPi$3];\n};\n\nvar transverseMercator = function() {\n  var m = mercatorProjection(transverseMercatorRaw),\n      center = m.center,\n      rotate = m.rotate;\n\n  m.center = function(_) {\n    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);\n  };\n\n  m.rotate = function(_) {\n    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);\n  };\n\n  return rotate([0, 0, 90])\n      .scale(159.155);\n};\n\nexports.version = version;\nexports.bisect = bisectRight;\nexports.bisectRight = bisectRight;\nexports.bisectLeft = bisectLeft;\nexports.ascending = ascending;\nexports.bisector = bisector;\nexports.descending = descending;\nexports.deviation = deviation;\nexports.extent = extent;\nexports.histogram = histogram;\nexports.thresholdFreedmanDiaconis = freedmanDiaconis;\nexports.thresholdScott = scott;\nexports.thresholdSturges = sturges;\nexports.max = max;\nexports.mean = mean;\nexports.median = median;\nexports.merge = merge;\nexports.min = min;\nexports.pairs = pairs;\nexports.permute = permute;\nexports.quantile = threshold;\nexports.range = range;\nexports.scan = scan;\nexports.shuffle = shuffle;\nexports.sum = sum;\nexports.ticks = ticks;\nexports.tickStep = tickStep;\nexports.transpose = transpose;\nexports.variance = variance;\nexports.zip = zip;\nexports.entries = entries;\nexports.keys = keys;\nexports.values = values;\nexports.map = map$1;\nexports.set = set;\nexports.nest = nest;\nexports.randomUniform = uniform;\nexports.randomNormal = normal;\nexports.randomLogNormal = logNormal;\nexports.randomBates = bates;\nexports.randomIrwinHall = irwinHall;\nexports.randomExponential = exponential;\nexports.easeLinear = linear;\nexports.easeQuad = quadInOut;\nexports.easeQuadIn = quadIn;\nexports.easeQuadOut = quadOut;\nexports.easeQuadInOut = quadInOut;\nexports.easeCubic = cubicInOut;\nexports.easeCubicIn = cubicIn;\nexports.easeCubicOut = cubicOut;\nexports.easeCubicInOut = cubicInOut;\nexports.easePoly = polyInOut;\nexports.easePolyIn = polyIn;\nexports.easePolyOut = polyOut;\nexports.easePolyInOut = polyInOut;\nexports.easeSin = sinInOut;\nexports.easeSinIn = sinIn;\nexports.easeSinOut = sinOut;\nexports.easeSinInOut = sinInOut;\nexports.easeExp = expInOut;\nexports.easeExpIn = expIn;\nexports.easeExpOut = expOut;\nexports.easeExpInOut = expInOut;\nexports.easeCircle = circleInOut;\nexports.easeCircleIn = circleIn;\nexports.easeCircleOut = circleOut;\nexports.easeCircleInOut = circleInOut;\nexports.easeBounce = bounceOut;\nexports.easeBounceIn = bounceIn;\nexports.easeBounceOut = bounceOut;\nexports.easeBounceInOut = bounceInOut;\nexports.easeBack = backInOut;\nexports.easeBackIn = backIn;\nexports.easeBackOut = backOut;\nexports.easeBackInOut = backInOut;\nexports.easeElastic = elasticOut;\nexports.easeElasticIn = elasticIn;\nexports.easeElasticOut = elasticOut;\nexports.easeElasticInOut = elasticInOut;\nexports.polygonArea = area;\nexports.polygonCentroid = centroid;\nexports.polygonHull = hull;\nexports.polygonContains = contains;\nexports.polygonLength = length$1;\nexports.path = path;\nexports.quadtree = quadtree;\nexports.queue = queue;\nexports.arc = arc;\nexports.area = area$1;\nexports.line = line;\nexports.pie = pie;\nexports.radialArea = radialArea;\nexports.radialLine = radialLine$1;\nexports.symbol = symbol;\nexports.symbols = symbols;\nexports.symbolCircle = circle;\nexports.symbolCross = cross$1;\nexports.symbolDiamond = diamond;\nexports.symbolSquare = square;\nexports.symbolStar = star;\nexports.symbolTriangle = triangle;\nexports.symbolWye = wye;\nexports.curveBasisClosed = basisClosed;\nexports.curveBasisOpen = basisOpen;\nexports.curveBasis = basis;\nexports.curveBundle = bundle;\nexports.curveCardinalClosed = cardinalClosed;\nexports.curveCardinalOpen = cardinalOpen;\nexports.curveCardinal = cardinal;\nexports.curveCatmullRomClosed = catmullRomClosed;\nexports.curveCatmullRomOpen = catmullRomOpen;\nexports.curveCatmullRom = catmullRom;\nexports.curveLinearClosed = linearClosed;\nexports.curveLinear = curveLinear;\nexports.curveMonotoneX = monotoneX;\nexports.curveMonotoneY = monotoneY;\nexports.curveNatural = natural;\nexports.curveStep = step;\nexports.curveStepAfter = stepAfter;\nexports.curveStepBefore = stepBefore;\nexports.stack = stack;\nexports.stackOffsetExpand = expand;\nexports.stackOffsetNone = none;\nexports.stackOffsetSilhouette = silhouette;\nexports.stackOffsetWiggle = wiggle;\nexports.stackOrderAscending = ascending$1;\nexports.stackOrderDescending = descending$2;\nexports.stackOrderInsideOut = insideOut;\nexports.stackOrderNone = none$1;\nexports.stackOrderReverse = reverse;\nexports.color = color;\nexports.rgb = rgb;\nexports.hsl = hsl;\nexports.lab = lab;\nexports.hcl = hcl;\nexports.cubehelix = cubehelix;\nexports.interpolate = interpolate;\nexports.interpolateArray = array$1;\nexports.interpolateDate = date;\nexports.interpolateNumber = interpolateNumber;\nexports.interpolateObject = object;\nexports.interpolateRound = interpolateRound;\nexports.interpolateString = interpolateString;\nexports.interpolateTransformCss = interpolateTransformCss;\nexports.interpolateTransformSvg = interpolateTransformSvg;\nexports.interpolateZoom = interpolateZoom;\nexports.interpolateRgb = interpolateRgb;\nexports.interpolateRgbBasis = rgbBasis;\nexports.interpolateRgbBasisClosed = rgbBasisClosed;\nexports.interpolateHsl = hsl$2;\nexports.interpolateHslLong = hslLong;\nexports.interpolateLab = lab$1;\nexports.interpolateHcl = hcl$2;\nexports.interpolateHclLong = hclLong;\nexports.interpolateCubehelix = cubehelix$2;\nexports.interpolateCubehelixLong = cubehelixLong;\nexports.interpolateBasis = basis$2;\nexports.interpolateBasisClosed = basisClosed$1;\nexports.quantize = quantize;\nexports.dispatch = dispatch;\nexports.dsvFormat = dsv;\nexports.csvParse = csvParse;\nexports.csvParseRows = csvParseRows;\nexports.csvFormat = csvFormat;\nexports.csvFormatRows = csvFormatRows;\nexports.tsvParse = tsvParse;\nexports.tsvParseRows = tsvParseRows;\nexports.tsvFormat = tsvFormat;\nexports.tsvFormatRows = tsvFormatRows;\nexports.request = request;\nexports.html = html;\nexports.json = json;\nexports.text = text;\nexports.xml = xml;\nexports.csv = csv$1;\nexports.tsv = tsv$1;\nexports.now = now;\nexports.timer = timer;\nexports.timerFlush = timerFlush;\nexports.timeout = timeout$1;\nexports.interval = interval$1;\nexports.timeInterval = newInterval;\nexports.timeMillisecond = millisecond;\nexports.timeMilliseconds = milliseconds;\nexports.timeSecond = second;\nexports.timeSeconds = seconds;\nexports.timeMinute = minute;\nexports.timeMinutes = minutes;\nexports.timeHour = hour;\nexports.timeHours = hours;\nexports.timeDay = day;\nexports.timeDays = days;\nexports.timeWeek = sunday;\nexports.timeWeeks = sundays;\nexports.timeSunday = sunday;\nexports.timeSundays = sundays;\nexports.timeMonday = monday;\nexports.timeMondays = mondays;\nexports.timeTuesday = tuesday;\nexports.timeTuesdays = tuesdays;\nexports.timeWednesday = wednesday;\nexports.timeWednesdays = wednesdays;\nexports.timeThursday = thursday;\nexports.timeThursdays = thursdays;\nexports.timeFriday = friday;\nexports.timeFridays = fridays;\nexports.timeSaturday = saturday;\nexports.timeSaturdays = saturdays;\nexports.timeMonth = month;\nexports.timeMonths = months;\nexports.timeYear = year;\nexports.timeYears = years;\nexports.utcMillisecond = millisecond;\nexports.utcMilliseconds = milliseconds;\nexports.utcSecond = second;\nexports.utcSeconds = seconds;\nexports.utcMinute = utcMinute;\nexports.utcMinutes = utcMinutes;\nexports.utcHour = utcHour;\nexports.utcHours = utcHours;\nexports.utcDay = utcDay;\nexports.utcDays = utcDays;\nexports.utcWeek = utcSunday;\nexports.utcWeeks = utcSundays;\nexports.utcSunday = utcSunday;\nexports.utcSundays = utcSundays;\nexports.utcMonday = utcMonday;\nexports.utcMondays = utcMondays;\nexports.utcTuesday = utcTuesday;\nexports.utcTuesdays = utcTuesdays;\nexports.utcWednesday = utcWednesday;\nexports.utcWednesdays = utcWednesdays;\nexports.utcThursday = utcThursday;\nexports.utcThursdays = utcThursdays;\nexports.utcFriday = utcFriday;\nexports.utcFridays = utcFridays;\nexports.utcSaturday = utcSaturday;\nexports.utcSaturdays = utcSaturdays;\nexports.utcMonth = utcMonth;\nexports.utcMonths = utcMonths;\nexports.utcYear = utcYear;\nexports.utcYears = utcYears;\nexports.formatLocale = formatLocale;\nexports.formatDefaultLocale = defaultLocale;\nexports.formatSpecifier = formatSpecifier;\nexports.precisionFixed = precisionFixed;\nexports.precisionPrefix = precisionPrefix;\nexports.precisionRound = precisionRound;\nexports.isoFormat = formatIso;\nexports.isoParse = parseIso;\nexports.timeFormatLocale = formatLocale$1;\nexports.timeFormatDefaultLocale = defaultLocale$1;\nexports.scaleBand = band;\nexports.scalePoint = point$4;\nexports.scaleIdentity = identity$4;\nexports.scaleLinear = linear$2;\nexports.scaleLog = log;\nexports.scaleOrdinal = ordinal;\nexports.scaleImplicit = implicit;\nexports.scalePow = pow;\nexports.scaleSqrt = sqrt;\nexports.scaleQuantile = quantile$$1;\nexports.scaleQuantize = quantize$1;\nexports.scaleThreshold = threshold$1;\nexports.scaleTime = time;\nexports.scaleUtc = utcTime;\nexports.schemeCategory10 = category10;\nexports.schemeCategory20b = category20b;\nexports.schemeCategory20c = category20c;\nexports.schemeCategory20 = category20;\nexports.scaleSequential = sequential;\nexports.interpolateCubehelixDefault = cubehelix$3;\nexports.interpolateRainbow = rainbow$1;\nexports.interpolateWarm = warm;\nexports.interpolateCool = cool;\nexports.interpolateViridis = viridis;\nexports.interpolateMagma = magma;\nexports.interpolateInferno = inferno;\nexports.interpolatePlasma = plasma;\nexports.creator = creator;\nexports.customEvent = customEvent;\nexports.local = local;\nexports.matcher = matcher$1;\nexports.mouse = mouse;\nexports.namespace = namespace;\nexports.namespaces = namespaces;\nexports.select = select;\nexports.selectAll = selectAll;\nexports.selection = selection;\nexports.selector = selector;\nexports.selectorAll = selectorAll;\nexports.touch = touch;\nexports.touches = touches;\nexports.window = window;\nexports.active = active;\nexports.interrupt = interrupt;\nexports.transition = transition;\nexports.axisTop = axisTop;\nexports.axisRight = axisRight;\nexports.axisBottom = axisBottom;\nexports.axisLeft = axisLeft;\nexports.cluster = cluster;\nexports.hierarchy = hierarchy;\nexports.pack = index;\nexports.packSiblings = siblings;\nexports.packEnclose = enclose;\nexports.partition = partition;\nexports.stratify = stratify;\nexports.tree = tree;\nexports.treemap = index$1;\nexports.treemapBinary = binary;\nexports.treemapDice = treemapDice;\nexports.treemapSlice = treemapSlice;\nexports.treemapSliceDice = sliceDice;\nexports.treemapSquarify = squarify;\nexports.treemapResquarify = resquarify;\nexports.forceCenter = center$1;\nexports.forceCollide = collide;\nexports.forceLink = link;\nexports.forceManyBody = manyBody;\nexports.forceSimulation = simulation;\nexports.forceX = x$3;\nexports.forceY = y$3;\nexports.drag = drag;\nexports.dragDisable = dragDisable;\nexports.dragEnable = yesdrag;\nexports.voronoi = voronoi;\nexports.zoom = zoom;\nexports.zoomIdentity = identity$6;\nexports.zoomTransform = transform;\nexports.brush = brush;\nexports.brushX = brushX;\nexports.brushY = brushY;\nexports.brushSelection = brushSelection;\nexports.chord = chord;\nexports.ribbon = ribbon;\nexports.geoAlbers = albers;\nexports.geoAlbersUsa = albersUsa;\nexports.geoArea = area$2;\nexports.geoAzimuthalEqualArea = azimuthalEqualArea;\nexports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;\nexports.geoAzimuthalEquidistant = azimuthalEquidistant;\nexports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;\nexports.geoBounds = bounds;\nexports.geoCentroid = centroid$1;\nexports.geoCircle = circle$1;\nexports.geoClipExtent = extent$1;\nexports.geoConicConformal = conicConformal;\nexports.geoConicConformalRaw = conicConformalRaw;\nexports.geoConicEqualArea = conicEqualArea;\nexports.geoConicEqualAreaRaw = conicEqualAreaRaw;\nexports.geoConicEquidistant = conicEquidistant;\nexports.geoConicEquidistantRaw = conicEquidistantRaw;\nexports.geoDistance = distance;\nexports.geoEquirectangular = equirectangular;\nexports.geoEquirectangularRaw = equirectangularRaw;\nexports.geoGnomonic = gnomonic;\nexports.geoGnomonicRaw = gnomonicRaw;\nexports.geoGraticule = graticule;\nexports.geoGraticule10 = graticule10;\nexports.geoIdentity = identity$8;\nexports.geoInterpolate = interpolate$2;\nexports.geoLength = length$2;\nexports.geoMercator = mercator;\nexports.geoMercatorRaw = mercatorRaw;\nexports.geoOrthographic = orthographic;\nexports.geoOrthographicRaw = orthographicRaw;\nexports.geoPath = index$3;\nexports.geoProjection = projection;\nexports.geoProjectionMutator = projectionMutator;\nexports.geoRotation = rotation;\nexports.geoStereographic = stereographic;\nexports.geoStereographicRaw = stereographicRaw;\nexports.geoStream = geoStream;\nexports.geoTransform = transform$1;\nexports.geoTransverseMercator = transverseMercator;\nexports.geoTransverseMercatorRaw = transverseMercatorRaw;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/d3/build/d3.js\n// module id = 135\n// module chunks = 1","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ieee754/index.js\n// module id = 141\n// module chunks = 1","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/isarray/index.js\n// module id = 142\n// module chunks = 1","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stream-browserify/~/isarray/index.js\n// module id = 143\n// module chunks = 1","module.exports = require(\"./lib/_stream_duplex.js\")\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stream-browserify/~/readable-stream/duplex.js\n// module id = 144\n// module chunks = 1","module.exports = require(\"./lib/_stream_passthrough.js\")\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stream-browserify/~/readable-stream/passthrough.js\n// module id = 145\n// module chunks = 1","exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = require('stream');\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\nif (!process.browser && process.env.READABLE_STREAM === 'disable') {\n  module.exports = require('stream');\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stream-browserify/~/readable-stream/readable.js\n// module id = 146\n// module chunks = 1","module.exports = require(\"./lib/_stream_transform.js\")\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stream-browserify/~/readable-stream/transform.js\n// module id = 147\n// module chunks = 1","module.exports = require(\"./lib/_stream_writable.js\")\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/stream-browserify/~/readable-stream/writable.js\n// module id = 148\n// module chunks = 1","/*!\n * Vue.js v2.0.3\n * (c) 2014-2016 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Vue = factory());\n}(this, (function () { 'use strict';\n\n/*  */\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction _toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val, 10);\n  return (n || n === 0) ? n : val\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Remove an item from an array\n */\nfunction remove$1 (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return typeof value === 'string' || typeof value === 'number'\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  }\n}\n\n/**\n * Camelize a hyphen-delmited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind$1 (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nvar toString = Object.prototype.toString;\nvar OBJECT_STRING = '[object Object]';\nfunction isPlainObject (obj) {\n  return toString.call(obj) === OBJECT_STRING\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n */\nfunction noop () {}\n\n/**\n * Always return false.\n */\nvar no = function () { return false; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  /* eslint-disable eqeqeq */\n  return a == b || (\n    isObject(a) && isObject(b)\n      ? JSON.stringify(a) === JSON.stringify(b)\n      : false\n  )\n  /* eslint-enable eqeqeq */\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/*  */\n\nvar config = {\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: \"development\" !== 'production',\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: null,\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * List of asset types that a component can own.\n   */\n  _assetTypes: [\n    'component',\n    'directive',\n    'filter'\n  ],\n\n  /**\n   * List of lifecycle hooks.\n   */\n  _lifecycleHooks: [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated'\n  ],\n\n  /**\n   * Max circular updates allowed in a scheduler flush cycle.\n   */\n  _maxUpdateCount: 100,\n\n  /**\n   * Server rendering?\n   */\n  _isServer: \"client\" === 'server'\n};\n\n/*  */\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w\\.\\$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  } else {\n    var segments = path.split('.');\n    return function (obj) {\n      for (var i = 0; i < segments.length; i++) {\n        if (!obj) { return }\n        obj = obj[segments[i]];\n      }\n      return obj\n    }\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser =\n  typeof window !== 'undefined' &&\n  Object.prototype.toString.call(window) !== '[object Object]';\n\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return /native code/.test(Ctor.toString())\n}\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    timerFunc = function () {\n      p.then(nextTickHandler);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var func = ctx\n      ? function () { cb.call(ctx); }\n      : cb;\n    callbacks.push(func);\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] !== undefined\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = 1;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar hasProxy;\nvar proxyHandlers;\nvar initProxy;\n\n{\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  proxyHandlers = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warn(\n          \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n          \"referenced during render. Make sure to declare reactive data \" +\n          \"properties in the data option.\",\n          target\n        );\n      }\n      return has || !isAllowed\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      vm._renderProxy = new Proxy(vm, proxyHandlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\n\nvar uid$2 = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid$2++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove$1(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stablize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*  */\n\n\nvar queue = [];\nvar has$1 = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  queue.length = 0;\n  has$1 = {};\n  {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    var watcher = queue[index];\n    var id = watcher.id;\n    has$1[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (\"development\" !== 'production' && has$1[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > config._maxUpdateCount) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n\n  resetSchedulerState();\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has$1[id] == null) {\n    has$1[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i >= 0 && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(Math.max(i, index) + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$1 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  if ( options === void 0 ) options = {};\n\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  this.deep = !!options.deep;\n  this.user = !!options.user;\n  this.lazy = !!options.lazy;\n  this.sync = !!options.sync;\n  this.expression = expOrFn.toString();\n  this.cb = cb;\n  this.id = ++uid$1; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      \"development\" !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value = this.getter.call(this.vm, this.vm);\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  popTarget();\n  this.cleanupDeps();\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n      if (\n        value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          \"development\" !== 'production' && warn(\n            (\"Error in watcher \\\"\" + (this.expression) + \"\\\"\"),\n            this.vm\n          );\n          /* istanbul ignore else */\n          if (config.errorHandler) {\n            config.errorHandler.call(null, e, this.vm);\n          } else {\n            throw e\n          }\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subcriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed or is performing a v-for\n    // re-render (the watcher list is then filtered by v-for).\n    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {\n      remove$1(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val, seen) {\n  var i, keys;\n  if (!seen) {\n    seen = seenObjects;\n    seen.clear();\n  }\n  var isA = Array.isArray(val);\n  var isO = isObject(val);\n  if ((isA || isO) && Object.isExtensible(val)) {\n    if (val.__ob__) {\n      var depId = val.__ob__.dep.id;\n      if (seen.has(depId)) {\n        return\n      } else {\n        seen.add(depId);\n      }\n    }\n    if (isA) {\n      i = val.length;\n      while (i--) { traverse(val[i], seen); }\n    } else if (isO) {\n      keys = Object.keys(val);\n      i = keys.length;\n      while (i--) { traverse(val[keys[i]], seen); }\n    }\n  }\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var arguments$1 = arguments;\n\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments$1[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true,\n  isSettingProps: false\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n *\n * istanbul ignore next\n */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !config._isServer &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      if (newVal === value) {\n        return\n      }\n      if (\"development\" !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (obj, key, val) {\n  if (Array.isArray(obj)) {\n    obj.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(obj, key)) {\n    obj[key] = val;\n    return\n  }\n  var ob = obj.__ob__;\n  if (obj._isVue || (ob && ob.vmCount)) {\n    \"development\" !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return\n  }\n  if (!ob) {\n    obj[key] = val;\n    return\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (obj, key) {\n  var ob = obj.__ob__;\n  if (obj._isVue || (ob && ob.vmCount)) {\n    \"development\" !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(obj, key)) {\n    return\n  }\n  delete obj[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = void 0, i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\nfunction initState (vm) {\n  vm._watchers = [];\n  initProps(vm);\n  initData(vm);\n  initComputed(vm);\n  initMethods(vm);\n  initWatch(vm);\n}\n\nfunction initProps (vm) {\n  var props = vm.$options.props;\n  if (props) {\n    var propsData = vm.$options.propsData || {};\n    var keys = vm.$options._propKeys = Object.keys(props);\n    var isRoot = !vm.$parent;\n    // root instance props should be converted\n    observerState.shouldConvert = isRoot;\n    var loop = function ( i ) {\n      var key = keys[i];\n      /* istanbul ignore else */\n      {\n        defineReactive$$1(vm, key, validateProp(key, props, propsData, vm), function () {\n          if (vm.$parent && !observerState.isSettingProps) {\n            warn(\n              \"Avoid mutating a prop directly since the value will be \" +\n              \"overwritten whenever the parent component re-renders. \" +\n              \"Instead, use a data or computed property based on the prop's \" +\n              \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n              vm\n            );\n          }\n        });\n      }\n    };\n\n    for (var i = 0; i < keys.length; i++) loop( i );\n    observerState.shouldConvert = true;\n  }\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? data.call(vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    \"development\" !== 'production' && warn(\n      'data functions should return an object.',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var i = keys.length;\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      \"development\" !== 'production' && warn(\n        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else {\n      proxy(vm, keys[i]);\n    }\n  }\n  // observe data\n  observe(data);\n  data.__ob__ && data.__ob__.vmCount++;\n}\n\nvar computedSharedDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction initComputed (vm) {\n  var computed = vm.$options.computed;\n  if (computed) {\n    for (var key in computed) {\n      var userDef = computed[key];\n      if (typeof userDef === 'function') {\n        computedSharedDefinition.get = makeComputedGetter(userDef, vm);\n        computedSharedDefinition.set = noop;\n      } else {\n        computedSharedDefinition.get = userDef.get\n          ? userDef.cache !== false\n            ? makeComputedGetter(userDef.get, vm)\n            : bind$1(userDef.get, vm)\n          : noop;\n        computedSharedDefinition.set = userDef.set\n          ? bind$1(userDef.set, vm)\n          : noop;\n      }\n      Object.defineProperty(vm, key, computedSharedDefinition);\n    }\n  }\n}\n\nfunction makeComputedGetter (getter, owner) {\n  var watcher = new Watcher(owner, getter, noop, {\n    lazy: true\n  });\n  return function computedGetter () {\n    if (watcher.dirty) {\n      watcher.evaluate();\n    }\n    if (Dep.target) {\n      watcher.depend();\n    }\n    return watcher.value\n  }\n}\n\nfunction initMethods (vm) {\n  var methods = vm.$options.methods;\n  if (methods) {\n    for (var key in methods) {\n      vm[key] = methods[key] == null ? noop : bind$1(methods[key], vm);\n      if (\"development\" !== 'production' && methods[key] == null) {\n        warn(\n          \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n    }\n  }\n}\n\nfunction initWatch (vm) {\n  var watch = vm.$options.watch;\n  if (watch) {\n    for (var key in watch) {\n      var handler = watch[key];\n      if (Array.isArray(handler)) {\n        for (var i = 0; i < handler.length; i++) {\n          createWatcher(vm, key, handler[i]);\n        }\n      } else {\n        createWatcher(vm, key, handler);\n      }\n    }\n  }\n}\n\nfunction createWatcher (vm, key, handler) {\n  var options;\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  vm.$watch(key, handler, options);\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () {\n    return this._data\n  };\n  {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\nfunction proxy (vm, key) {\n  if (!isReserved(key)) {\n    Object.defineProperty(vm, key, {\n      configurable: true,\n      enumerable: true,\n      get: function proxyGetter () {\n        return vm._data[key]\n      },\n      set: function proxySetter (val) {\n        vm._data[key] = val;\n      }\n    });\n  }\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  ns,\n  context,\n  componentOptions\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = ns;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.child = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n};\n\nvar emptyVNode = function () {\n  var node = new VNode();\n  node.text = '';\n  node.isComment = true;\n  return node\n};\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.ns,\n    vnode.context,\n    vnode.componentOptions\n  );\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isCloned = true;\n  return cloned\n}\n\nfunction cloneVNodes (vnodes) {\n  var res = new Array(vnodes.length);\n  for (var i = 0; i < vnodes.length; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook, key) {\n  key = key + hookKey;\n  var injectedHash = def.__injected || (def.__injected = {});\n  if (!injectedHash[key]) {\n    injectedHash[key] = true;\n    var oldHook = def[hookKey];\n    if (oldHook) {\n      def[hookKey] = function () {\n        oldHook.apply(this, arguments);\n        hook.apply(this, arguments);\n      };\n    } else {\n      def[hookKey] = hook;\n    }\n  }\n}\n\n/*  */\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, fn, event, capture;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    if (!cur) {\n      \"development\" !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + name + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (!old) {\n      capture = name.charAt(0) === '!';\n      event = capture ? name.slice(1) : name;\n      if (Array.isArray(cur)) {\n        add(event, (cur.invoker = arrInvoker(cur)), capture);\n      } else {\n        if (!cur.invoker) {\n          fn = cur;\n          cur = on[name] = {};\n          cur.fn = fn;\n          cur.invoker = fnInvoker(cur);\n        }\n        add(event, cur.invoker, capture);\n      }\n    } else if (cur !== old) {\n      if (Array.isArray(old)) {\n        old.length = cur.length;\n        for (var i = 0; i < old.length; i++) { old[i] = cur[i]; }\n        on[name] = old;\n      } else {\n        old.fn = cur;\n        on[name] = old;\n      }\n    }\n  }\n  for (name in oldOn) {\n    if (!on[name]) {\n      event = name.charAt(0) === '!' ? name.slice(1) : name;\n      remove$$1(event, oldOn[name].invoker);\n    }\n  }\n}\n\nfunction arrInvoker (arr) {\n  return function (ev) {\n    var arguments$1 = arguments;\n\n    var single = arguments.length === 1;\n    for (var i = 0; i < arr.length; i++) {\n      single ? arr[i](ev) : arr[i].apply(null, arguments$1);\n    }\n  }\n}\n\nfunction fnInvoker (o) {\n  return function (ev) {\n    var single = arguments.length === 1;\n    single ? o.fn(ev) : o.fn.apply(null, arguments);\n  }\n}\n\n/*  */\n\nfunction normalizeChildren (\n  children,\n  ns,\n  nestedIndex\n) {\n  if (isPrimitive(children)) {\n    return [createTextVNode(children)]\n  }\n  if (Array.isArray(children)) {\n    var res = [];\n    for (var i = 0, l = children.length; i < l; i++) {\n      var c = children[i];\n      var last = res[res.length - 1];\n      //  nested\n      if (Array.isArray(c)) {\n        res.push.apply(res, normalizeChildren(c, ns, ((nestedIndex || '') + \"_\" + i)));\n      } else if (isPrimitive(c)) {\n        if (last && last.text) {\n          last.text += String(c);\n        } else if (c !== '') {\n          // convert primitive to vnode\n          res.push(createTextVNode(c));\n        }\n      } else if (c instanceof VNode) {\n        if (c.text && last && last.text) {\n          last.text += c.text;\n        } else {\n          // inherit parent namespace\n          if (ns) {\n            applyNS(c, ns);\n          }\n          // default key for nested array children (likely generated by v-for)\n          if (c.tag && c.key == null && nestedIndex != null) {\n            c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n          }\n          res.push(c);\n        }\n      }\n    }\n    return res\n  }\n}\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\nfunction applyNS (vnode, ns) {\n  if (vnode.tag && !vnode.ns) {\n    vnode.ns = ns;\n    if (vnode.children) {\n      for (var i = 0, l = vnode.children.length; i < l; i++) {\n        applyNS(vnode.children[i], ns);\n      }\n    }\n  }\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  return children && children.filter(function (c) { return c && c.componentOptions; })[0]\n}\n\n/*  */\n\nvar activeInstance = null;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._mount = function (\n    el,\n    hydrating\n  ) {\n    var vm = this;\n    vm.$el = el;\n    if (!vm.$options.render) {\n      vm.$options.render = emptyVNode;\n      {\n        /* istanbul ignore if */\n        if (vm.$options.template) {\n          warn(\n            'You are using the runtime-only build of Vue where the template ' +\n            'option is not available. Either pre-compile the templates into ' +\n            'render functions, or use the compiler-included build.',\n            vm\n          );\n        } else {\n          warn(\n            'Failed to mount component: template or render function not defined.',\n            vm\n          );\n        }\n      }\n    }\n    callHook(vm, 'beforeMount');\n    vm._watcher = new Watcher(vm, function () {\n      vm._update(vm._render(), hydrating);\n    }, noop);\n    hydrating = false;\n    // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n    if (vm.$vnode == null) {\n      vm._isMounted = true;\n      callHook(vm, 'mounted');\n    }\n    return vm\n  };\n\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    var prevVnode = vm._vnode;\n    vm._vnode = vnode;\n    if (!prevVnode) {\n      // Vue.prototype.__patch__ is injected in entry points\n      // based on the rendering backend used.\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating);\n    } else {\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    if (vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  };\n\n  Vue.prototype._updateFromParent = function (\n    propsData,\n    listeners,\n    parentVnode,\n    renderChildren\n  ) {\n    var vm = this;\n    var hasChildren = !!(vm.$options._renderChildren || renderChildren);\n    vm.$options._parentVnode = parentVnode;\n    vm.$options._renderChildren = renderChildren;\n    // update props\n    if (propsData && vm.$options.props) {\n      observerState.shouldConvert = false;\n      {\n        observerState.isSettingProps = true;\n      }\n      var propKeys = vm.$options._propKeys || [];\n      for (var i = 0; i < propKeys.length; i++) {\n        var key = propKeys[i];\n        vm[key] = validateProp(key, vm.$options.props, propsData, vm);\n      }\n      observerState.shouldConvert = true;\n      {\n        observerState.isSettingProps = false;\n      }\n    }\n    // update listeners\n    if (listeners) {\n      var oldListeners = vm.$options._parentListeners;\n      vm.$options._parentListeners = listeners;\n      vm._updateListeners(listeners, oldListeners);\n    }\n    // resolve slots + force update if has children\n    if (hasChildren) {\n      vm.$slots = resolveSlots(renderChildren, vm._renderContext);\n      vm.$forceUpdate();\n    }\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove$1(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n  };\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      handlers[i].call(vm);\n    }\n  }\n  vm.$emit('hook:' + hook);\n}\n\n/*  */\n\nvar hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy$1 };\nvar hooksToMerge = Object.keys(hooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (!Ctor) {\n    return\n  }\n\n  if (isObject(Ctor)) {\n    Ctor = Vue$3.extend(Ctor);\n  }\n\n  if (typeof Ctor !== 'function') {\n    {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  if (!Ctor.cid) {\n    if (Ctor.resolved) {\n      Ctor = Ctor.resolved;\n    } else {\n      Ctor = resolveAsyncComponent(Ctor, function () {\n        // it's ok to queue this on every render because\n        // $forceUpdate is buffered by the scheduler.\n        context.$forceUpdate();\n      });\n      if (!Ctor) {\n        // return nothing if this is indeed an async component\n        // wait for the callback to trigger parent update.\n        return\n      }\n    }\n  }\n\n  data = data || {};\n\n  // extract props\n  var propsData = extractProps(data, Ctor);\n\n  // functional component\n  if (Ctor.options.functional) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  data.on = data.nativeOn;\n\n  if (Ctor.options.abstract) {\n    // abstract components do not keep anything\n    // other than props & listeners\n    data = {};\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n  );\n  return vnode\n}\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (propOptions) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData);\n    }\n  }\n  var vnode = Ctor.options.render.call(\n    null,\n    // ensure the createElement function in functional components\n    // gets a unique context - this is necessary for correct named slot check\n    bind$1(createElement, { _self: Object.create(context) }),\n    {\n      props: props,\n      data: data,\n      parent: context,\n      children: normalizeChildren(children),\n      slots: function () { return resolveSlots(children, context); }\n    }\n  );\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent // activeInstance in lifecycle state\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (inlineTemplate) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction init (vnode, hydrating) {\n  if (!vnode.child || vnode.child._isDestroyed) {\n    var child = vnode.child = createComponentInstanceForVnode(vnode, activeInstance);\n    child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n  }\n}\n\nfunction prepatch (\n  oldVnode,\n  vnode\n) {\n  var options = vnode.componentOptions;\n  var child = vnode.child = oldVnode.child;\n  child._updateFromParent(\n    options.propsData, // updated props\n    options.listeners, // updated listeners\n    vnode, // new parent vnode\n    options.children // new children\n  );\n}\n\nfunction insert (vnode) {\n  if (!vnode.child._isMounted) {\n    vnode.child._isMounted = true;\n    callHook(vnode.child, 'mounted');\n  }\n  if (vnode.data.keepAlive) {\n    vnode.child._inactive = false;\n    callHook(vnode.child, 'activated');\n  }\n}\n\nfunction destroy$1 (vnode) {\n  if (!vnode.child._isDestroyed) {\n    if (!vnode.data.keepAlive) {\n      vnode.child.$destroy();\n    } else {\n      vnode.child._inactive = true;\n      callHook(vnode.child, 'deactivated');\n    }\n  }\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  cb\n) {\n  if (factory.requested) {\n    // pool callbacks\n    factory.pendingCallbacks.push(cb);\n  } else {\n    factory.requested = true;\n    var cbs = factory.pendingCallbacks = [cb];\n    var sync = true;\n\n    var resolve = function (res) {\n      if (isObject(res)) {\n        res = Vue$3.extend(res);\n      }\n      // cache resolved\n      factory.resolved = res;\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          cbs[i](res);\n        }\n      }\n    };\n\n    var reject = function (reason) {\n      \"development\" !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n    };\n\n    var res = factory(resolve, reject);\n\n    // handle promise\n    if (res && typeof res.then === 'function' && !factory.resolved) {\n      res.then(resolve, reject);\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.resolved\n  }\n}\n\nfunction extractProps (data, Ctor) {\n  // we are only extrating raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (!propOptions) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  var domProps = data.domProps;\n  if (attrs || props || domProps) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey) ||\n      checkProp(res, domProps, key, altKey);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (hash) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = hooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (a, b) {\n  // since all hooks have at most two args, use fixed args\n  // to avoid having to use fn.apply().\n  return function (_, __) {\n    a(_, __);\n    b(_, __);\n  }\n}\n\n/*  */\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  tag,\n  data,\n  children\n) {\n  if (data && (Array.isArray(data) || typeof data !== 'object')) {\n    children = data;\n    data = undefined;\n  }\n  // make sure to use real instance instead of proxy as context\n  return _createElement(this._self, tag, data, children)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children\n) {\n  if (data && data.__ob__) {\n    \"development\" !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return emptyVNode()\n  }\n  if (typeof tag === 'string') {\n    var Ctor;\n    var ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      return new VNode(\n        tag, data, normalizeChildren(children, ns),\n        undefined, undefined, ns, context\n      )\n    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      return createComponent(Ctor, data, context, children, tag)\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      return new VNode(\n        tag, data, normalizeChildren(children, ns),\n        undefined, undefined, ns, context\n      )\n    }\n  } else {\n    // direct component options / constructor\n    return createComponent(tag, data, context, children)\n  }\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm.$vnode = null; // the placeholder node in parent tree\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  vm._renderContext = vm.$options._parentVnode && vm.$options._parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, vm._renderContext);\n  // bind the public createElement fn to this instance\n  // so that we get proper render context inside it.\n  vm.$createElement = bind$1(createElement, vm);\n  if (vm.$options.el) {\n    vm.$mount(vm.$options.el);\n  }\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    nextTick(fn, this);\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      {\n        warn((\"Error when rendering \" + (formatComponentName(vm)) + \":\"));\n      }\n      /* istanbul ignore else */\n      if (config.errorHandler) {\n        config.errorHandler.call(null, e, vm);\n      } else {\n        if (config._isServer) {\n          throw e\n        } else {\n          setTimeout(function () { throw e }, 0);\n        }\n      }\n      // return previous vnode to prevent render error causing blank component\n      vnode = vm._vnode;\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (\"development\" !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = emptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // shorthands used in render functions\n  Vue.prototype._h = createElement;\n  // toString for mustaches\n  Vue.prototype._s = _toString;\n  // number conversion\n  Vue.prototype._n = toNumber;\n  // empty vnode\n  Vue.prototype._e = emptyVNode;\n  // loose equal\n  Vue.prototype._q = looseEqual;\n  // loose indexOf\n  Vue.prototype._i = looseIndexOf;\n\n  // render static tree by index\n  Vue.prototype._m = function renderStatic (\n    index,\n    isInFor\n  ) {\n    var tree = this._staticTrees[index];\n    // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree by doing a shallow clone.\n    if (tree && !isInFor) {\n      return Array.isArray(tree)\n        ? cloneVNodes(tree)\n        : cloneVNode(tree)\n    }\n    // otherwise, render a fresh tree.\n    tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);\n    if (Array.isArray(tree)) {\n      for (var i = 0; i < tree.length; i++) {\n        if (typeof tree[i] !== 'string') {\n          tree[i].isStatic = true;\n          tree[i].key = \"__static__\" + index + \"_\" + i;\n        }\n      }\n    } else {\n      tree.isStatic = true;\n      tree.key = \"__static__\" + index;\n    }\n    return tree\n  };\n\n  // filter resolution helper\n  var identity = function (_) { return _; };\n  Vue.prototype._f = function resolveFilter (id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity\n  };\n\n  // render v-for\n  Vue.prototype._l = function renderList (\n    val,\n    render\n  ) {\n    var ret, i, l, keys, key;\n    if (Array.isArray(val)) {\n      ret = new Array(val.length);\n      for (i = 0, l = val.length; i < l; i++) {\n        ret[i] = render(val[i], i);\n      }\n    } else if (typeof val === 'number') {\n      ret = new Array(val);\n      for (i = 0; i < val; i++) {\n        ret[i] = render(i + 1, i);\n      }\n    } else if (isObject(val)) {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n    return ret\n  };\n\n  // renderSlot\n  Vue.prototype._t = function (\n    name,\n    fallback\n  ) {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && \"development\" !== 'production') {\n      slotNodes._rendered && warn(\n        \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n        \"- this will likely cause render errors.\",\n        this\n      );\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback\n  };\n\n  // apply v-bind object\n  Vue.prototype._b = function bindProps (\n    data,\n    value,\n    asProp\n  ) {\n    if (value) {\n      if (!isObject(value)) {\n        \"development\" !== 'production' && warn(\n          'v-bind without argument expects an Object or Array value',\n          this\n        );\n      } else {\n        if (Array.isArray(value)) {\n          value = toObject(value);\n        }\n        for (var key in value) {\n          if (key === 'class' || key === 'style') {\n            data[key] = value[key];\n          } else {\n            var hash = asProp || config.mustUseProp(key)\n              ? data.domProps || (data.domProps = {})\n              : data.attrs || (data.attrs = {});\n            hash[key] = value[key];\n          }\n        }\n      }\n    }\n    return data\n  };\n\n  // expose v-on keyCodes\n  Vue.prototype._k = function getKeyCodes (key) {\n    return config.keyCodes[key]\n  };\n}\n\nfunction resolveSlots (\n  renderChildren,\n  context\n) {\n  var slots = {};\n  if (!renderChildren) {\n    return slots\n  }\n  var children = normalizeChildren(renderChildren) || [];\n  var defaultSlot = [];\n  var name, child;\n  for (var i = 0, l = children.length; i < l; i++) {\n    child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n        child.data && (name = child.data.slot)) {\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore single whitespace\n  if (defaultSlot.length && !(\n    defaultSlot.length === 1 &&\n    (defaultSlot[0].text === ' ' || defaultSlot[0].isComment)\n  )) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  var on = bind$1(vm.$on, vm);\n  var off = bind$1(vm.$off, vm);\n  vm._updateListeners = function (listeners, oldListeners) {\n    updateListeners(listeners, oldListeners || {}, on, off, vm);\n  };\n  if (listeners) {\n    vm._updateListeners(listeners);\n  }\n}\n\nfunction eventsMixin (Vue) {\n  Vue.prototype.$on = function (event, fn) {\n    var vm = this;(vm._events[event] || (vm._events[event] = [])).push(fn);\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        cbs[i].apply(vm, args);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\nvar uid = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid++;\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    {\n      initProxy(vm);\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    callHook(vm, 'beforeCreate');\n    initState(vm);\n    callHook(vm, 'created');\n    initRender(vm);\n  };\n\n  function initInternalComponent (vm, options) {\n    var opts = vm.$options = Object.create(resolveConstructorOptions(vm));\n    // doing this because it's faster than dynamic enumeration.\n    opts.parent = options.parent;\n    opts.propsData = options.propsData;\n    opts._parentVnode = options._parentVnode;\n    opts._parentListeners = options._parentListeners;\n    opts._renderChildren = options._renderChildren;\n    opts._componentTag = options._componentTag;\n    if (options.render) {\n      opts.render = options.render;\n      opts.staticRenderFns = options.staticRenderFns;\n    }\n  }\n\n  function resolveConstructorOptions (vm) {\n    var Ctor = vm.constructor;\n    var options = Ctor.options;\n    if (Ctor.super) {\n      var superOptions = Ctor.super.options;\n      var cachedSuperOptions = Ctor.superOptions;\n      if (superOptions !== cachedSuperOptions) {\n        // super option changed\n        Ctor.superOptions = superOptions;\n        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n        if (options.name) {\n          options.components[options.name] = Ctor;\n        }\n      }\n    }\n    return options\n  }\n}\n\nfunction Vue$3 (options) {\n  if (\"development\" !== 'production' &&\n    !(this instanceof Vue$3)) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\nvar warn = noop;\nvar formatComponentName;\n\n{\n  var hasConsole = typeof console !== 'undefined';\n\n  warn = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.error(\"[Vue warn]: \" + msg + \" \" + (\n        vm ? formatLocation(formatComponentName(vm)) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm) {\n    if (vm.$root === vm) {\n      return 'root instance'\n    }\n    var name = vm._isVue\n      ? vm.$options.name || vm.$options._componentTag\n      : vm.name;\n    return (\n      (name ? (\"component <\" + name + \">\") : \"anonymous component\") +\n      (vm._isVue && vm.$options.__file ? (\" at \" + (vm.$options.__file)) : '')\n    )\n  };\n\n  var formatLocation = function (str) {\n    if (str === 'anonymous component') {\n      str += \" - use the \\\"name\\\" option for better debugging messages.\";\n    }\n    return (\"\\n(found in \" + str + \")\")\n  };\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\n{\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  var key, toVal, fromVal;\n  for (key in from) {\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isObject(toVal) && isObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== 'function') {\n      \"development\" !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n};\n\n/**\n * Hooks and param attributes are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nconfig._lifecycleHooks.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  /* istanbul ignore if */\n  if (!childVal) { return parentVal }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal, childVal) {\n  if (!childVal) { return parentVal }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret\n};\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Make sure component options get converted to actual\n * constructors.\n */\nfunction normalizeComponents (options) {\n  if (options.components) {\n    var components = options.components;\n    var def;\n    for (var key in components) {\n      var lower = key.toLowerCase();\n      if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n        \"development\" !== 'production' && warn(\n          'Do not use built-in or reserved HTML elements as component ' +\n          'id: ' + key\n        );\n        continue\n      }\n      def = components[key];\n      if (isPlainObject(def)) {\n        components[key] = Vue$3.extend(def);\n      }\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  normalizeComponents(child);\n  normalizeProps(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = typeof extendsFrom === 'function'\n      ? mergeOptions(parent, extendsFrom.options, vm)\n      : mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      var mixin = child.mixins[i];\n      if (mixin.prototype instanceof Vue$3) {\n        mixin = mixin.options;\n      }\n      parent = mergeOptions(parent, mixin, vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  var res = assets[id] ||\n    // camelCase ID\n    assets[camelize(id)] ||\n    // Pascal Case ID\n    assets[capitalize(camelize(id))];\n  if (\"development\" !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isBooleanType(prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (value === '' || value === hyphenate(key)) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, name) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (isObject(def)) {\n    \"development\" !== 'production' && warn(\n      'Invalid default value for prop \"' + name + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // call factory function for non-Function types\n  return typeof def === 'function' && prop.type !== Function\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType);\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\n/**\n * Assert the type of a value\n */\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (expectedType === 'String') {\n    valid = typeof value === (expectedType = 'string');\n  } else if (expectedType === 'Number') {\n    valid = typeof value === (expectedType = 'number');\n  } else if (expectedType === 'Boolean') {\n    valid = typeof value === (expectedType = 'boolean');\n  } else if (expectedType === 'Function') {\n    valid = typeof value === (expectedType = 'function');\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match && match[1]\n}\n\nfunction isBooleanType (fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === 'Boolean'\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === 'Boolean') {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\n\n\nvar util = Object.freeze({\n\tdefineReactive: defineReactive$$1,\n\t_toString: _toString,\n\ttoNumber: toNumber,\n\tmakeMap: makeMap,\n\tisBuiltInTag: isBuiltInTag,\n\tremove: remove$1,\n\thasOwn: hasOwn,\n\tisPrimitive: isPrimitive,\n\tcached: cached,\n\tcamelize: camelize,\n\tcapitalize: capitalize,\n\thyphenate: hyphenate,\n\tbind: bind$1,\n\ttoArray: toArray,\n\textend: extend,\n\tisObject: isObject,\n\tisPlainObject: isPlainObject,\n\ttoObject: toObject,\n\tnoop: noop,\n\tno: no,\n\tgenStaticKeys: genStaticKeys,\n\tlooseEqual: looseEqual,\n\tlooseIndexOf: looseIndexOf,\n\tisReserved: isReserved,\n\tdef: def,\n\tparsePath: parsePath,\n\thasProto: hasProto,\n\tinBrowser: inBrowser,\n\tUA: UA,\n\tisIE: isIE,\n\tisIE9: isIE9,\n\tisEdge: isEdge,\n\tisAndroid: isAndroid,\n\tisIOS: isIOS,\n\tdevtools: devtools,\n\tnextTick: nextTick,\n\tget _Set () { return _Set; },\n\tmergeOptions: mergeOptions,\n\tresolveAsset: resolveAsset,\n\tget warn () { return warn; },\n\tget formatComponentName () { return formatComponentName; },\n\tvalidateProp: validateProp\n});\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    Vue.options = mergeOptions(Vue.options, mixin);\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var isFirstExtend = Super.cid === 0;\n    if (isFirstExtend && extendOptions._Ctor) {\n      return extendOptions._Ctor\n    }\n    var name = extendOptions.name || Super.options.name;\n    {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characaters and the hyphen.'\n        );\n        name = null;\n      }\n    }\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n    // allow further extension\n    Sub.extend = Super.extend;\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    config._assetTypes.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    // cache constructor\n    if (isFirstExtend) {\n      extendOptions._Ctor = Sub;\n    }\n    return Sub\n  };\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  config._assetTypes.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = Vue.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    if (vnode && vnode.componentOptions) {\n      var opts = vnode.componentOptions;\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? opts.Ctor.cid + '::' + opts.tag\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.child = this.cache[key].child;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  },\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this.cache) {\n      var vnode = this$1.cache[key];\n      callHook(vnode.child, 'deactivated');\n      vnode.child.$destroy();\n    }\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n  Vue.util = util;\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  config._assetTypes.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: function () { return config._isServer; }\n});\n\nVue$3.version = '2.0.3';\n\n/*  */\n\n// attributes that should be using props for binding\nvar mustUseProp = makeMap('value,selected,checked,muted');\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar isAttr = makeMap(\n  'accept,accept-charset,accesskey,action,align,alt,async,autocomplete,' +\n  'autofocus,autoplay,autosave,bgcolor,border,buffered,challenge,charset,' +\n  'checked,cite,class,code,codebase,color,cols,colspan,content,http-equiv,' +\n  'name,contenteditable,contextmenu,controls,coords,data,datetime,default,' +\n  'defer,dir,dirname,disabled,download,draggable,dropzone,enctype,method,for,' +\n  'form,formaction,headers,<th>,height,hidden,high,href,hreflang,http-equiv,' +\n  'icon,id,ismap,itemprop,keytype,kind,label,lang,language,list,loop,low,' +\n  'manifest,max,maxlength,media,method,GET,POST,min,multiple,email,file,' +\n  'muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,' +\n  'preload,radiogroup,readonly,rel,required,reversed,rows,rowspan,sandbox,' +\n  'scope,scoped,seamless,selected,shape,size,type,text,password,sizes,span,' +\n  'spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,' +\n  'target,title,type,usemap,value,width,wrap'\n);\n\n\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (childNode.child) {\n    childNode = childNode.child._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return genClassFromData(data)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: child.class\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction genClassFromData (data) {\n  var dynamicClass = data.class;\n  var staticClass = data.staticClass;\n  if (staticClass || dynamicClass) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  var res = '';\n  if (!value) {\n    return res\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  if (Array.isArray(value)) {\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (value[i]) {\n        if ((stringified = stringifyClass(value[i]))) {\n          res += stringified + ' ';\n        }\n      }\n    }\n    return res.slice(0, -1)\n  }\n  if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) { res += key + ' '; }\n    }\n    return res.slice(0, -1)\n  }\n  /* istanbul ignore next */\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template'\n);\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr',\n  true\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source',\n  true\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track',\n  true\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font,' +\n  'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selector = el;\n    el = document.querySelector(el);\n    if (!el) {\n      \"development\" !== 'production' && warn(\n        'Cannot find element: ' + selector\n      );\n      return document.createElement('div')\n    }\n  }\n  return el\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  if (vnode.data && vnode.data.attrs && 'multiple' in vnode.data.attrs) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction childNodes (node) {\n  return node.childNodes\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tchildNodes: childNodes,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.child || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove$1(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (Array.isArray(refs[key])) {\n        refs[key].push(ref);\n      } else {\n        refs[key] = [ref];\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks$1 = ['create', 'update', 'remove', 'destroy'];\n\nfunction isUndef (s) {\n  return s == null\n}\n\nfunction isDef (s) {\n  return s != null\n}\n\nfunction sameVnode (vnode1, vnode2) {\n  return (\n    vnode1.key === vnode2.key &&\n    vnode1.tag === vnode2.tag &&\n    vnode1.isComment === vnode2.isComment &&\n    !vnode1.data === !vnode2.data\n  )\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks$1.length; ++i) {\n    cbs[hooks$1[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeElement(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeElement (el) {\n    var parent = nodeOps.parentNode(el);\n    nodeOps.removeChild(parent, el);\n  }\n\n  function createElm (vnode, insertedVnodeQueue, nested) {\n    var i;\n    var data = vnode.data;\n    vnode.isRootInsert = !nested;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode); }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(i = vnode.child)) {\n        initComponent(vnode, insertedVnodeQueue);\n        return vnode.elm\n      }\n    }\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      {\n        if (\n          !vnode.ns &&\n          !(config.ignoredElements && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n      createChildren(vnode, children, insertedVnodeQueue);\n      if (isDef(data)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue);\n      }\n    } else if (vnode.isComment) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n    }\n    return vnode.elm\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        nodeOps.appendChild(vnode.elm, createElm(children[i], insertedVnodeQueue, true));\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.child) {\n      vnode = vnode.child._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (i.create) { i.create(emptyNode, vnode); }\n      if (i.insert) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (vnode.data.pendingInsert) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n    }\n    vnode.elm = vnode.child.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    if (isDef(i = vnode.context) && isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n    if (isDef(i = activeInstance) &&\n        i !== vnode.context &&\n        isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      nodeOps.insertBefore(parentElm, createElm(vnodes[startIdx], insertedVnodeQueue), before);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          nodeOps.removeChild(parentElm, ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (rm || isDef(vnode.data)) {\n      var listeners = cbs.remove.length + 1;\n      if (!rm) {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      } else {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.child) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeElement(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, before;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) { // New element\n          nodeOps.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (\"development\" !== 'production' && !elmToMove) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (elmToMove.tag !== newStartVnode.tag) {\n            // same key but different element. treat as new element\n            nodeOps.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      before = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (vnode.isStatic &&\n        oldVnode.isStatic &&\n        vnode.key === oldVnode.key &&\n        vnode.isCloned) {\n      vnode.elm = oldVnode.elm;\n      return\n    }\n    var i;\n    var data = vnode.data;\n    var hasData = isDef(data);\n    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm;\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (hasData && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (hasData) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (initial && vnode.parent) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.child)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        var childNodes = nodeOps.childNodes(elm);\n        // empty element, allow client to pick up and populate children\n        if (!childNodes.length) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          if (childNodes.length !== children.length) {\n            childrenMatch = false;\n          } else {\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!hydrate(childNodes[i$1], children[i$1], insertedVnodeQueue)) {\n                childrenMatch = false;\n                break\n              }\n            }\n          }\n          if (!childrenMatch) {\n            if (\"development\" !== 'production' &&\n                typeof console !== 'undefined' &&\n                !bailed) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', childNodes, children);\n            }\n            return false\n          }\n        }\n      }\n      if (isDef(data)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue);\n      }\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (vnode.tag) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag === nodeOps.tagName(node).toLowerCase()\n      )\n    } else {\n      return _toString(vnode.text) === node.data\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly) {\n    if (!vnode) {\n      if (oldVnode) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var elm, parent;\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (!oldVnode) {\n      // empty mount, create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {\n            oldVnode.removeAttribute('server-rendered');\n            hydrating = true;\n          }\n          if (hydrating) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        elm = oldVnode.elm;\n        parent = nodeOps.parentNode(elm);\n\n        createElm(vnode, insertedVnodeQueue);\n\n        // component root element replaced.\n        // update parent placeholder node element.\n        if (vnode.parent) {\n          vnode.parent.elm = vnode.elm;\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (parent !== null) {\n          nodeOps.insertBefore(parent, vnode.elm, nodeOps.nextSibling(elm));\n          removeVnodes(parent, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (\n  oldVnode,\n  vnode\n) {\n  if (!oldVnode.data.directives && !vnode.data.directives) {\n    return\n  }\n  var isCreate = oldVnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      dirsWithInsert.forEach(function (dir) {\n        callHook$1(dir, 'inserted', vnode, oldVnode);\n      });\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert, 'dir-insert');\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      dirsWithPostpatch.forEach(function (dir) {\n        callHook$1(dir, 'componentUpdated', vnode, oldVnode);\n      });\n    }, 'dir-postpatch');\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    fn(vnode.elm, dir, vnode, oldVnode);\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  if (!oldVnode.data.attrs && !vnode.data.attrs) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (attrs.__ob__) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  for (key in oldAttrs) {\n    if (attrs[key] == null) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (!data.staticClass && !data.class &&\n      (!oldData || (!oldData.staticClass && !oldData.class))) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (transitionClass) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n// skip type checking this file because we need to attach private properties\n// to elements\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (!oldVnode.data.on && !vnode.data.on) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  var add = vnode.elm._v_add || (vnode.elm._v_add = function (event, handler, capture) {\n    vnode.elm.addEventListener(event, handler, capture);\n  });\n  var remove = vnode.elm._v_remove || (vnode.elm._v_remove = function (event, handler) {\n    vnode.elm.removeEventListener(event, handler);\n  });\n  updateListeners(on, oldOn, add, remove, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (!oldVnode.data.domProps && !vnode.data.domProps) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (props.__ob__) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (props[key] == null) {\n      elm[key] = undefined;\n    }\n  }\n  for (key in props) {\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if ((key === 'textContent' || key === 'innerHTML') && vnode.children) {\n      vnode.children.length = 0;\n    }\n    cur = props[key];\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = cur == null ? '' : String(cur);\n      if (elm.value !== strCur && !elm.composing) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar prefixes = ['Webkit', 'Moz', 'ms'];\n\nvar testEl;\nvar normalize = cached(function (prop) {\n  testEl = testEl || document.createElement('div');\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in testEl.style)) {\n    return prop\n  }\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefixed = prefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return prefixed\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  if ((!oldVnode.data || !oldVnode.data.style) && !vnode.data.style) {\n    return\n  }\n  var cur, name;\n  var el = vnode.elm;\n  var oldStyle = oldVnode.data.style || {};\n  var style = vnode.data.style || {};\n\n  // handle string\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n    return\n  }\n\n  var needClone = style.__ob__;\n\n  // handle array syntax\n  if (Array.isArray(style)) {\n    style = vnode.data.style = toObject(style);\n  }\n\n  // clone the style for future updates,\n  // in case the user mutates the style object in-place.\n  if (needClone) {\n    style = vnode.data.style = extend({}, style);\n  }\n\n  for (name in oldStyle) {\n    if (style[name] == null) {\n      el.style[normalize(name)] = '';\n    }\n  }\n  for (name in style) {\n    cur = style[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      el.style[normalize(name)] = cur == null ? '' : cur;\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = ' ' + el.getAttribute('class') + ' ';\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n  } else {\n    var cur = ' ' + el.getAttribute('class') + ' ';\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    el.setAttribute('class', cur.trim());\n  }\n}\n\n/*  */\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\nvar raf = (inBrowser && window.requestAnimationFrame) || setTimeout;\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n  addClass(el, cls);\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove$1(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitioneDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitioneDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (el._leaveCb) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (el._enterCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var transitionNode = activeInstance.$vnode;\n  var context = transitionNode && transitionNode.parent\n    ? transitionNode.parent.context\n    : activeInstance;\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear ? appearClass : enterClass;\n  var activeClass = isAppear ? appearActiveClass : enterActiveClass;\n  var beforeEnterHook = isAppear ? (beforeAppear || beforeEnter) : beforeEnter;\n  var enterHook = isAppear ? (typeof appear === 'function' ? appear : enter) : enter;\n  var afterEnterHook = isAppear ? (afterAppear || afterEnter) : afterEnter;\n  var enterCancelledHook = isAppear ? (appearCancelled || enterCancelled) : enterCancelled;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl =\n    enterHook &&\n    // enterHook may be a bound method which exposes\n    // the length of original fn as _length\n    (enterHook._length || enterHook.length) > 1;\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    }, 'transition-insert');\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        whenTransitionEnds(el, type, cb);\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (el._enterCb) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (el._leaveCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl =\n    leave &&\n    // leave hook may be a bound method which exposes\n    // the length of original fn as _length\n    (leave._length || leave.length) > 1;\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          whenTransitionEnds(el, type, cb);\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    leaveClass: (name + \"-leave\"),\n    appearClass: (name + \"-enter\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveActiveClass: (name + \"-leave-active\"),\n    appearActiveClass: (name + \"-enter-active\")\n  }\n});\n\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn();\n    }\n  }\n}\n\nvar transition = inBrowser ? {\n  create: function create (_, vnode) {\n    if (!vnode.data.show) {\n      enter(vnode);\n    }\n  },\n  remove: function remove (vnode, rm) {\n    /* istanbul ignore else */\n    if (!vnode.data.show) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch$1 = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\nvar modelableTagRE = /^input|select|textarea|vue-component-[0-9]+(-[0-9a-zA-Z_\\-]*)?$/;\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model = {\n  inserted: function inserted (el, binding, vnode) {\n    {\n      if (!modelableTagRE.test(vnode.tag)) {\n        warn(\n          \"v-model is not supported on element type: <\" + (vnode.tag) + \">. \" +\n          'If you are working with contenteditable, it\\'s recommended to ' +\n          'wrap a library dedicated for that purpose inside a custom component.',\n          vnode.context\n        );\n      }\n    }\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n    } else if (\n      (vnode.tag === 'textarea' || el.type === 'text') &&\n      !binding.modifiers.lazy\n    ) {\n      if (!isAndroid) {\n        el.addEventListener('compositionstart', onCompositionStart);\n        el.addEventListener('compositionend', onCompositionEnd);\n      }\n      /* istanbul ignore if */\n      if (isIE9) {\n        el.vmodel = true;\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matchig\n      // option in the DOM.\n      var needReset = el.multiple\n        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n      if (needReset) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    \"development\" !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  for (var i = 0, l = options.length; i < l; i++) {\n    if (looseEqual(getValue(options[i]), value)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.child && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.child._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (value && transition && !isIE9) {\n      enter(vnode);\n    }\n    var originalDisplay = el.style.display === 'none' ? '' : el.style.display;\n    el.style.display = value ? originalDisplay : 'none';\n    el.__vOriginalDisplay = originalDisplay;\n  },\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (transition && !isIE9) {\n      if (value) {\n        enter(vnode);\n        el.style.display = el.__vOriginalDisplay;\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recrusively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1].fn;\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  return /\\d-keep-alive$/.test(rawChild.tag)\n    ? h('keep-alive')\n    : null\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag; });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (\"development\" !== 'production' && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (\"development\" !== 'production' &&\n        mode && mode !== 'in-out' && mode !== 'out-in') {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    var key = child.key = child.key == null || child.isStatic\n      ? (\"__v\" + (child.tag + this._uid) + \"__\")\n      : child.key;\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && oldChild.key !== key) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild.data.transition = extend({}, data);\n\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        }, key);\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave, key);\n        mergeVNodeHook(data, 'enterCancelled', performLeave, key);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n          delayedLeave = leave;\n        }, key);\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final disired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else {\n          var opts = c.componentOptions;\n          var name = opts\n            ? (opts.Ctor.options.name || opts.tag)\n            : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || (this.name + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var f = document.body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      if (this._hasMove != null) {\n        return this._hasMove\n      }\n      addTransitionClass(el, moveClass);\n      var info = getTransitionInfo(el);\n      removeTransitionClass(el, moveClass);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.isUnknownElement = isUnknownElement;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.mustUseProp = mustUseProp;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = config._isServer ? noop : patch$1;\n\n// wrap mount\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && !config._isServer ? query(el) : undefined;\n  return this._mount(el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (\n      \"development\" !== 'production' &&\n      inBrowser && /Chrome\\/\\d+/.test(window.navigator.userAgent)\n    ) {\n      console.log(\n        'Download the Vue Devtools for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n}, 0);\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nfunction shouldDecode (content, encoded) {\n  var div = document.createElement('div');\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\">\";\n  return div.innerHTML.indexOf(encoded) > 0\n}\n\n// #3663\n// IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n/*  */\n\nvar decoder = document.createElement('div');\n\nfunction decode (html) {\n  decoder.innerHTML = html;\n  return decoder.textContent\n}\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>\\/=]+)/;\nvar singleAttrAssign = /(?:=)/;\nvar singleAttrValues = [\n  // attr value double quotes\n  /\"([^\"]*)\"+/.source,\n  // attr value, single quotes\n  /'([^']*)'+/.source,\n  // attr value, no quotes\n  /([^\\s\"'=<>`]+)/.source\n];\nvar attribute = new RegExp(\n  '^\\\\s*' + singleAttrIdentifier.source +\n  '(?:\\\\s*(' + singleAttrAssign.source + ')' +\n  '\\\\s*(?:' + singleAttrValues.join('|') + '))?'\n);\n\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\nvar startTagOpen = new RegExp('^<' + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nvar doctype = /^<!DOCTYPE [^>]+>/i;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isSpecialTag = makeMap('script,style', true);\n\nvar reCache = {};\n\nvar ltRE = /&lt;/g;\nvar gtRE = /&gt;/g;\nvar nlRE = /&#10;/g;\nvar ampRE = /&amp;/g;\nvar quoteRE = /&quot;/g;\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  if (shouldDecodeNewlines) {\n    value = value.replace(nlRE, '\\n');\n  }\n  return value\n    .replace(ltRE, '<')\n    .replace(gtRE, '>')\n    .replace(ampRE, '&')\n    .replace(quoteRE, '\"')\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a script or style element\n    if (!lastTag || !isSpecialTag(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (/^<!--/.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (/^<!\\[/.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[0], endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          continue\n        }\n      }\n\n      var text = void 0;\n      if (textEnd >= 0) {\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      } else {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars) {\n        options.chars(text);\n      }\n    } else {\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var endTagLength = 0;\n      var rest = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!--([\\s\\S]*?)-->/g, '$1')\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)\\]\\]>/g, '$1');\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest.length;\n      html = rest;\n      parseEndTag('</' + stackedTag + '>', stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      throw new Error('Error parsing template:\\n\\n' + html)\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag('', lastTag);\n      }\n      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {\n        parseEndTag('', tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(\n          value,\n          options.shouldDecodeNewlines\n        )\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, attrs: attrs });\n      lastTag = tagName;\n      unarySlash = '';\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tag, tagName, start, end) {\n    var pos;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      var needle = tagName.toLowerCase();\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].tag.toLowerCase() === needle) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (tagName.toLowerCase() === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (tagName.toLowerCase() === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      // check single quote\n      if (c === 0x27 && prev !== 0x5C) { inSingle = !inSingle; }\n    } else if (inDouble) {\n      // check double quote\n      if (c === 0x22 && prev !== 0x5C) { inDouble = !inDouble; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break // \"\n        case 0x27: inSingle = true; break // '\n        case 0x28: paren++; break         // (\n        case 0x29: paren--; break         // )\n        case 0x5B: square++; break        // [\n        case 0x5D: square--; break        // ]\n        case 0x7B: curly++; break         // {\n        case 0x7D: curly--; break         // }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+')\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue parser]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important\n) {\n  // check capture modifier\n  if (modifiers && modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  var events;\n  if (modifiers && modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n  var newHandler = { value: value, modifiers: modifiers };\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return dynamicValue\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\nfunction getAndRemoveAttr (el, name) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  return val\n}\n\n/*  */\n\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /\\(([^,]*),([^,]*)(?:,([^,]*))?\\)/;\nvar bindRE = /^:|^v-bind:/;\nvar onRE = /^@|^v-on:/;\nvar argRE = /:(.*)$/;\nvar modifierRE = /\\.[^\\.]+/g;\nvar specialNewlineRE = /\\u2028|\\u2029/g;\n\nvar decodeHTMLCached = cached(decode);\n\n// configurable state\nvar warn$1;\nvar platformGetTagNamespace;\nvar platformMustUseProp;\nvar platformIsPreTag;\nvar preTransforms;\nvar transforms;\nvar postTransforms;\nvar delimiters;\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$1 = options.warn || baseWarn;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformIsPreTag = options.isPreTag || no;\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n  delimiters = options.delimiters;\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n  parseHTML(template, {\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (options.isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs, options.isIE),\n        parent: currentParent,\n        children: []\n      };\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (\"client\" !== 'server' && isForbiddenTag(element)) {\n        element.forbidden = true;\n        \"development\" !== 'production' && warn$1(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">.\"\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else {\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element);\n\n        // determine whether this is a plain element after\n        // removing structural attributes\n        element.plain = !element.key && !attrs.length;\n\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n          transforms[i$1](element, options);\n        }\n        processAttrs(element);\n      }\n\n      function checkRootConstraints (el) {\n        {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warn$1(\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n              'contain multiple nodes:\\n' + template\n            );\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warn$1(\n              'Cannot use v-for on stateful component root element because ' +\n              'it renders multiple elements:\\n' + template\n            );\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (\"development\" !== 'production' && !stack.length && !warned) {\n        // allow 2 root elements with v-if and v-else\n        if (root.if && element.else) {\n          checkRootConstraints(element);\n          root.elseBlock = element;\n        } else {\n          warned = true;\n          warn$1(\n            (\"Component template should contain exactly one root element:\\n\\n\" + template)\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.else) {\n          processElse(element, currentParent);\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      }\n      // apply post-transforms\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n        postTransforms[i$2](element, options);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ') {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      // check pre state\n      if (element.pre) {\n        inVPre = false;\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = false;\n      }\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (\"development\" !== 'production' && !warned && text === template) {\n          warned = true;\n          warn$1(\n            'Component template requires a root element, rather than just text:\\n\\n' + template\n          );\n        }\n        return\n      }\n      text = inPre || text.trim()\n        ? decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && currentParent.children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          currentParent.children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else {\n          // #3895 special character\n          text = text.replace(specialNewlineRE, '');\n          currentParent.children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (\"development\" !== 'production' && el.tag === 'template') {\n      warn$1(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      \"development\" !== 'production' && warn$1(\n        (\"Invalid v-for expression: \" + exp)\n      );\n      return\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim();\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n  }\n  if (getAndRemoveAttr(el, 'v-else') != null) {\n    el.else = true;\n  }\n}\n\nfunction processElse (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    prev.elseBlock = el;\n  } else {\n    warn$1(\n      (\"v-else used on element <\" + (el.tag) + \"> without corresponding v-if.\")\n    );\n  }\n}\n\nfunction processOnce (el) {\n  var once = getAndRemoveAttr(el, 'v-once');\n  if (once != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n  } else {\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget;\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, arg, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        if (modifiers && modifiers.prop) {\n          isProp = true;\n          name = camelize(name);\n          if (name === 'innerHtml') { name = 'innerHTML'; }\n        }\n        if (isProp || platformMustUseProp(name)) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        if (argMatch && (arg = argMatch[1])) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (\"development\" !== 'production' && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$1(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been deprecated. ' +\n            'Use v-bind or the colon shorthand instead.'\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs, isIE) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\"development\" !== 'production' && map[attrs[i].name] && !isIE) {\n      warn$1('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].tag) { return children[i] }\n  }\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizier: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || (function () { return false; });\n  // first pass: mark all non-static nodes.\n  markStatic(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.once || node.static) {\n      node.staticRoot = true;\n      node.staticInFor = isInFor;\n      return\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\]|\\[\\d+\\]|\\[[A-Za-z_$][\\w$]*\\])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: 'if($event.target !== $event.currentTarget)return;'\n};\n\nfunction genHandlers (events, native) {\n  var res = native ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(events[name])) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  } else if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(genHandler).join(',')) + \"]\")\n  } else if (!handler.modifiers) {\n    return simplePathRE.test(handler.value)\n      ? handler.value\n      : (\"function($event){\" + (handler.value) + \"}\")\n  } else {\n    var code = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        code += modifierCode[key];\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code = genKeyFilter(keys) + code;\n    }\n    var handlerCode = simplePathRE.test(handler.value)\n      ? handler.value + '($event)'\n      : handler.value;\n    return 'function($event){' + code + handlerCode + '}'\n  }\n}\n\nfunction genKeyFilter (keys) {\n  var code = keys.length === 1\n    ? normalizeKeyCode(keys[0])\n    : Array.prototype.concat.apply([], keys.map(normalizeKeyCode));\n  if (Array.isArray(code)) {\n    return (\"if(\" + (code.map(function (c) { return (\"$event.keyCode!==\" + c); }).join('&&')) + \")return;\")\n  } else {\n    return (\"if($event.keyCode!==\" + code + \")return;\")\n  }\n}\n\nfunction normalizeKeyCode (key) {\n  return (\n    parseInt(key, 10) || // number keyCode\n    keyCodes[key] || // built-in alias\n    (\"_k(\" + (JSON.stringify(key)) + \")\") // custom alias\n  )\n}\n\n/*  */\n\nfunction bind$2 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",\" + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + \")\")\n  };\n}\n\nvar baseDirectives = {\n  bind: bind$2,\n  cloak: noop\n};\n\n/*  */\n\n// configurable state\nvar warn$2;\nvar transforms$1;\nvar dataGenFns;\nvar platformDirectives$1;\nvar staticRenderFns;\nvar currentOptions;\n\nfunction generate (\n  ast,\n  options\n) {\n  // save previous staticRenderFns so generate calls can be nested\n  var prevStaticRenderFns = staticRenderFns;\n  var currentStaticRenderFns = staticRenderFns = [];\n  currentOptions = options;\n  warn$2 = options.warn || baseWarn;\n  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n  dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  platformDirectives$1 = options.directives || {};\n  var code = ast ? genElement(ast) : '_h(\"div\")';\n  staticRenderFns = prevStaticRenderFns;\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: currentStaticRenderFns\n  }\n}\n\nfunction genElement (el) {\n  if (el.staticRoot && !el.staticProcessed) {\n    // hoist static sub-trees out\n    el.staticProcessed = true;\n    staticRenderFns.push((\"with(this){return \" + (genElement(el)) + \"}\"));\n    return (\"_m(\" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el);\n    } else {\n      var data = genData(el);\n      var children = el.inlineTemplate ? null : genChildren(el);\n      code = \"_h('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < transforms$1.length; i++) {\n      code = transforms$1[i](el, code);\n    }\n    return code\n  }\n}\n\nfunction genIf (el) {\n  var exp = el.if;\n  el.ifProcessed = true; // avoid recursion\n  return (\"(\" + exp + \")?\" + (genElement(el)) + \":\" + (genElse(el)))\n}\n\nfunction genElse (el) {\n  return el.elseBlock\n    ? genElement(el.elseBlock)\n    : '_e()'\n}\n\nfunction genFor (el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genElement(el)) +\n    '})'\n}\n\nfunction genData (el) {\n  if (el.plain) {\n    return\n  }\n\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // slot target\n  if (el.slotTarget) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < dataGenFns.length; i++) {\n    data += dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true)) + \",\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var ast = el.children[0];\n    if (\"development\" !== 'production' && (\n      el.children.length > 1 || ast.type !== 1\n    )) {\n      warn$2('Inline-template components must have exactly one child element.');\n    }\n    if (ast.type === 1) {\n      var inlineRenderFns = generate(ast, currentOptions);\n      data += \"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  return data\n}\n\nfunction genDirectives (el) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, warn$2);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genChildren (el) {\n  if (el.children.length) {\n    return '[' + el.children.map(genNode).join(',') + ']'\n  }\n}\n\nfunction genNode (node) {\n  if (node.type === 1) {\n    return genElement(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : JSON.stringify(text.text)\n}\n\nfunction genSlot (el) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el);\n  return children\n    ? (\"_t(\" + slotName + \",\" + children + \")\")\n    : (\"_t(\" + slotName + \")\")\n}\n\nfunction genComponent (el) {\n  var children = el.inlineTemplate ? null : genChildren(el);\n  return (\"_h(\" + (el.component) + \",\" + (genData(el)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + (prop.name) + \"\\\":\" + (prop.value) + \",\";\n  }\n  return res.slice(0, -1)\n}\n\n/*  */\n\n/**\n * Compile a template.\n */\nfunction compile$1 (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n}\n\n/*  */\n\n// operators like typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n// check valid identifier for v-for\nvar identRE = /[A-Za-z_$][\\w$]*/;\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (ident, type, text, errors) {\n  if (typeof ident === 'string' && !identRE.test(ident)) {\n    errors.push((\"- invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text));\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"- avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + text\n      );\n    } else {\n      errors.push((\"- invalid expression: \" + text));\n    }\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (\"development\" !== 'production' && staticClass) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been deprecated. ' +\n        'Use v-bind or the colon shorthand instead.'\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData$1\n};\n\n/*  */\n\nfunction transformNode$1 (el) {\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$2 (el) {\n  return el.styleBinding\n    ? (\"style:(\" + (el.styleBinding) + \"),\")\n    : ''\n}\n\nvar style$1 = {\n  transformNode: transformNode$1,\n  genData: genData$2\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1\n];\n\n/*  */\n\nvar warn$3;\n\nfunction model$1 (\n  el,\n  dir,\n  _warn\n) {\n  warn$3 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n  {\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (tag === 'input' && dynamicType) {\n      warn$3(\n        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\n        \"v-model does not support dynamic input types. Use v-if branches instead.\"\n      );\n    }\n  }\n  if (tag === 'select') {\n    genSelect(el, value);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value);\n  } else {\n    genDefaultModel(el, value, modifiers);\n  }\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (el, value) {\n  if (\"development\" !== 'production' &&\n    el.attrsMap.checked != null) {\n    warn$3(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" checked>:\\n\" +\n      \"inline checked attributes will be ignored when using v-model. \" +\n      'Declare initial values in the component\\'s data option instead.'\n    );\n  }\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" +\n      \":_q(\" + value + \",\" + trueValueBinding + \")\"\n  );\n  addHandler(el, 'change',\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + valueBinding + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" +\n      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n    \"}else{\" + value + \"=$$c}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (el, value) {\n  if (\"development\" !== 'production' &&\n    el.attrsMap.checked != null) {\n    warn$3(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" checked>:\\n\" +\n      \"inline checked attributes will be ignored when using v-model. \" +\n      'Declare initial values in the component\\'s data option instead.'\n    );\n  }\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, 'change', (value + \"=\" + valueBinding), null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  {\n    if (el.tag === 'input' && el.attrsMap.value) {\n      warn$3(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" value=\\\"\" + (el.attrsMap.value) + \"\\\">:\\n\" +\n        'inline value attributes will be ignored when using v-model. ' +\n        'Declare initial values in the component\\'s data option instead.'\n      );\n    }\n    if (el.tag === 'textarea' && el.children.length) {\n      warn$3(\n        \"<textarea v-model=\\\"\" + value + \"\\\">:\\n\" +\n        'inline content inside <textarea> will be ignored when using v-model. ' +\n        'Declare initial values in the component\\'s data option instead.'\n      );\n    }\n  }\n\n  var type = el.attrsMap.type;\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var event = lazy || (isIE && type === 'range') ? 'change' : 'input';\n  var needCompositionGuard = !lazy && type !== 'range';\n  var isNative = el.tag === 'input' || el.tag === 'textarea';\n\n  var valueExpression = isNative\n    ? (\"$event.target.value\" + (trim ? '.trim()' : ''))\n    : \"$event\";\n  var code = number || type === 'number'\n    ? (value + \"=_n(\" + valueExpression + \")\")\n    : (value + \"=\" + valueExpression);\n  if (isNative && needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n  // inputs with type=\"file\" are read only and setting the input's\n  // value will throw an error.\n  if (\"development\" !== 'production' &&\n      type === 'file') {\n    warn$3(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n      \"File inputs are read only. Use a v-on:change listener instead.\"\n    );\n  }\n  addProp(el, 'value', isNative ? (\"_s(\" + value + \")\") : (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n}\n\nfunction genSelect (el, value) {\n  {\n    el.children.some(checkOptionWarning);\n  }\n  var code = value + \"=Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){return \\\"_value\\\" in o ? o._value : o.value})\" +\n    (el.attrsMap.multiple == null ? '[0]' : '');\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction checkOptionWarning (option) {\n  if (option.type === 1 &&\n    option.tag === 'option' &&\n    option.attrsMap.selected != null) {\n    warn$3(\n      \"<select v-model=\\\"\" + (option.parent.attrsMap['v-model']) + \"\\\">:\\n\" +\n      'inline selected attributes on <option> will be ignored when using v-model. ' +\n      'Declare initial values in the component\\'s data option instead.'\n    );\n    return true\n  }\n  return false\n}\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model$1,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar cache = Object.create(null);\n\nvar baseOptions = {\n  isIE: isIE,\n  expectHTML: true,\n  modules: modules$1,\n  staticKeys: genStaticKeys(modules$1),\n  directives: directives$1,\n  isReservedTag: isReservedTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  getTagNamespace: getTagNamespace,\n  isPreTag: isPreTag\n};\n\nfunction compile$$1 (\n  template,\n  options\n) {\n  options = options\n    ? extend(extend({}, baseOptions), options)\n    : baseOptions;\n  return compile$1(template, options)\n}\n\nfunction compileToFunctions (\n  template,\n  options,\n  vm\n) {\n  var _warn = (options && options.warn) || warn;\n  // detect possible CSP restriction\n  /* istanbul ignore if */\n  {\n    try {\n      new Function('return 1');\n    } catch (e) {\n      if (e.toString().match(/unsafe-eval|CSP/)) {\n        _warn(\n          'It seems you are using the standalone build of Vue.js in an ' +\n          'environment with Content Security Policy that prohibits unsafe-eval. ' +\n          'The template compiler cannot work in this environment. Consider ' +\n          'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n          'templates into render functions.'\n        );\n      }\n    }\n  }\n  var key = options && options.delimiters\n    ? String(options.delimiters) + template\n    : template;\n  if (cache[key]) {\n    return cache[key]\n  }\n  var res = {};\n  var compiled = compile$$1(template, options);\n  res.render = makeFunction(compiled.render);\n  var l = compiled.staticRenderFns.length;\n  res.staticRenderFns = new Array(l);\n  for (var i = 0; i < l; i++) {\n    res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i]);\n  }\n  {\n    if (res.render === noop || res.staticRenderFns.some(function (fn) { return fn === noop; })) {\n      _warn(\n        \"failed to compile template:\\n\\n\" + template + \"\\n\\n\" +\n        detectErrors(compiled.ast).join('\\n') +\n        '\\n\\n',\n        vm\n      );\n    }\n  }\n  return (cache[key] = res)\n}\n\nfunction makeFunction (code) {\n  try {\n    return new Function(code)\n  } catch (e) {\n    return noop\n  }\n}\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    \"development\" !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      var ref = compileToFunctions(template, {\n        warn: warn,\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\nreturn Vue$3;\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue/dist/vue.js\n// module id = 159\n// module chunks = 1","\nvar XML_CHARACTER_MAP = {\n    '&': '&amp;',\n    '\"': '&quot;',\n    \"'\": '&apos;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\n\nfunction escapeForXML(string) {\n    return string && string.replace\n        ? string.replace(/([&\"<>'])/g, function(str, item) {\n            return XML_CHARACTER_MAP[item];\n          })\n        : string;\n}\n\nmodule.exports = escapeForXML;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xml/lib/escapeForXML.js\n// module id = 160\n// module chunks = 1","var escapeForXML = require('./escapeForXML');\nvar Stream = require('stream').Stream;\n\nvar DEFAULT_INDENT = '    ';\n\nfunction xml(input, options) {\n\n    if (typeof options !== 'object') {\n        options = {\n            indent: options\n        };\n    }\n\n    var stream      = options.stream ? new Stream() : null,\n        output      = \"\",\n        interrupted = false,\n        indent      = !options.indent ? ''\n                        : options.indent === true ? DEFAULT_INDENT\n                            : options.indent,\n        instant     = true;\n\n\n    function delay (func) {\n        if (!instant) {\n            func();\n        } else {\n            process.nextTick(func);\n        }\n    }\n\n    function append (interrupt, out) {\n        if (out !== undefined) {\n            output += out;\n        }\n        if (interrupt && !interrupted) {\n            stream = stream || new Stream();\n            interrupted = true;\n        }\n        if (interrupt && interrupted) {\n            var data = output;\n            delay(function () { stream.emit('data', data) });\n            output = \"\";\n        }\n    }\n\n    function add (value, last) {\n        format(append, resolve(value, indent, indent ? 1 : 0), last);\n    }\n\n    function end() {\n        if (stream) {\n            var data = output;\n            delay(function () {\n              stream.emit('data', data);\n              stream.emit('end');\n              stream.readable = false;\n              stream.emit('close');\n            });\n        }\n    }\n\n    function addXmlDeclaration(declaration) {\n        var encoding = declaration.encoding || 'UTF-8',\n            attr =  { version: '1.0', encoding: encoding };\n\n        if (declaration.standalone) {\n            attr.standalone = declaration.standalone\n        }\n\n        add({'?xml': { _attr: attr } });\n        output = output.replace('/>', '?>');\n    }\n\n    // disable delay delayed\n    delay(function () { instant = false });\n\n    if (options.declaration) {\n        addXmlDeclaration(options.declaration);\n    }\n\n    if (input && input.forEach) {\n        input.forEach(function (value, i) {\n            var last;\n            if (i + 1 === input.length)\n                last = end;\n            add(value, last);\n        });\n    } else {\n        add(input, end);\n    }\n\n    if (stream) {\n        stream.readable = true;\n        return stream;\n    }\n    return output;\n}\n\nfunction element (/*input, …*/) {\n    var input = Array.prototype.slice.call(arguments),\n        self = {\n            _elem:  resolve(input)\n        };\n\n    self.push = function (input) {\n        if (!this.append) {\n            throw new Error(\"not assigned to a parent!\");\n        }\n        var that = this;\n        var indent = this._elem.indent;\n        format(this.append, resolve(\n            input, indent, this._elem.icount + (indent ? 1 : 0)),\n            function () { that.append(true) });\n    };\n\n    self.close = function (input) {\n        if (input !== undefined) {\n            this.push(input);\n        }\n        if (this.end) {\n            this.end();\n        }\n    };\n\n    return self;\n}\n\nfunction create_indent(character, count) {\n    return (new Array(count || 0).join(character || ''))\n}\n\nfunction resolve(data, indent, indent_count) {\n    indent_count = indent_count || 0;\n    var indent_spaces = create_indent(indent, indent_count);\n    var name;\n    var values = data;\n    var interrupt = false;\n\n    if (typeof data === 'object') {\n        var keys = Object.keys(data);\n        name = keys[0];\n        values = data[name];\n\n        if (values && values._elem) {\n            values._elem.name = name;\n            values._elem.icount = indent_count;\n            values._elem.indent = indent;\n            values._elem.indents = indent_spaces;\n            values._elem.interrupt = values;\n            return values._elem;\n        }\n    }\n\n    var attributes = [],\n        content = [];\n\n    var isStringContent;\n\n    function get_attributes(obj){\n        var keys = Object.keys(obj);\n        keys.forEach(function(key){\n            attributes.push(attribute(key, obj[key]));\n        });\n    }\n\n    switch(typeof values) {\n        case 'object':\n            if (values === null) break;\n\n            if (values._attr) {\n                get_attributes(values._attr);\n            }\n\n            if (values._cdata) {\n                content.push(\n                    ('<![CDATA[' + values._cdata).replace(/\\]\\]>/g, ']]]]><![CDATA[>') + ']]>'\n                );\n            }\n\n            if (values.forEach) {\n                isStringContent = false;\n                content.push('');\n                values.forEach(function(value) {\n                    if (typeof value == 'object') {\n                        var _name = Object.keys(value)[0];\n\n                        if (_name == '_attr') {\n                            get_attributes(value._attr);\n                        } else {\n                            content.push(resolve(\n                                value, indent, indent_count + 1));\n                        }\n                    } else {\n                        //string\n                        content.pop();\n                        isStringContent=true;\n                        content.push(escapeForXML(value));\n                    }\n\n                });\n                if (!isStringContent) {\n                    content.push('');\n                }\n            }\n        break;\n\n        default:\n            //string\n            content.push(escapeForXML(values));\n\n    }\n\n    return {\n        name:       name,\n        interrupt:  interrupt,\n        attributes: attributes,\n        content:    content,\n        icount:     indent_count,\n        indents:    indent_spaces,\n        indent:     indent\n    };\n}\n\nfunction format(append, elem, end) {\n\n    if (typeof elem != 'object') {\n        return append(false, elem);\n    }\n\n    var len = elem.interrupt ? 1 : elem.content.length;\n\n    function proceed () {\n        while (elem.content.length) {\n            var value = elem.content.shift();\n\n            if (value === undefined) continue;\n            if (interrupt(value)) return;\n\n            format(append, value);\n        }\n\n        append(false, (len > 1 ? elem.indents : '')\n            + (elem.name ? '</' + elem.name + '>' : '')\n            + (elem.indent && !end ? '\\n' : ''));\n\n        if (end) {\n            end();\n        }\n    }\n\n    function interrupt(value) {\n       if (value.interrupt) {\n           value.interrupt.append = append;\n           value.interrupt.end = proceed;\n           value.interrupt = false;\n           append(true);\n           return true;\n       }\n       return false;\n    }\n\n    append(false, elem.indents\n        + (elem.name ? '<' + elem.name : '')\n        + (elem.attributes.length ? ' ' + elem.attributes.join(' ') : '')\n        + (len ? (elem.name ? '>' : '') : (elem.name ? '/>' : ''))\n        + (elem.indent && len > 1 ? '\\n' : ''));\n\n    if (!len) {\n        return append(false, elem.indent ? '\\n' : '');\n    }\n\n    if (!interrupt(elem)) {\n        proceed();\n    }\n}\n\nfunction attribute(key, value) {\n    return key + '=' + '\"' + escapeForXML(value) + '\"';\n}\n\nmodule.exports = xml;\nmodule.exports.element = module.exports.Element = element;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xml/lib/xml.js\n// module id = 161\n// module chunks = 1","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 163\n// module chunks = 1","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [];\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\tstyleElement.type = \"text/css\";\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\tvar sourceMap = obj.sourceMap;\n\n\tif (media) {\n\t\tstyleElement.setAttribute(\"media\", media);\n\t}\n\n\tif (sourceMap) {\n\t\t// https://developer.chrome.com/devtools/docs/javascript-debugging\n\t\t// this makes source maps inside style tags work properly in Chrome\n\t\tcss += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */';\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-style-loader/addStyles.js\n// module id = 164\n// module chunks = 1"],"sourceRoot":""}